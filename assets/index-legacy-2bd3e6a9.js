;
(function () {
  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
  System.register([], function (exports, module) {
    'use strict';

    return {
      execute: function execute() {
        false && function polyfill() {
          var relList = document.createElement('link').relList;
          if (relList && relList.supports && relList.supports('modulepreload')) {
            return;
          }
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(mutations => {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== 'childList') {
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var node = _step3.value;
                    if (node.tagName === 'LINK' && node.rel === 'modulepreload') processPreload(node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            var fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === 'use-credentials') fetchOpts.credentials = 'include';else if (link.crossOrigin === 'anonymous') fetchOpts.credentials = 'omit';else fetchOpts.credentials = 'same-origin';
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep)
              // ep marker = processed
              return;
            link.ep = true;
            // prepopulate the load record
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var settings = {};
        var subscribers = {};
        var initSettings = (appSettings, platformSettings) => {
          settings['app'] = appSettings;
          settings['platform'] = platformSettings;
          settings['user'] = {};
        };
        var publish = (key, value) => {
          subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value));
        };
        var dotGrab = function dotGrab() {
          var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var key = arguments.length > 1 ? arguments[1] : undefined;
          if (obj === null) return undefined;
          var keys = key.split('.');
          for (var i = 0; i < keys.length; i++) {
            obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
          }
          return typeof obj === 'object' && obj !== null ? Object.keys(obj).length ? obj : undefined : obj;
        };
        var Settings$1 = {
          get(type, key) {
            var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var val = dotGrab(settings[type], key);
            return val !== undefined ? val : fallback;
          },
          has(type, key) {
            return !!this.get(type, key);
          },
          set(key, value) {
            settings['user'][key] = value;
            publish(key, value);
          },
          subscribe(key, callback) {
            subscribers[key] = subscribers[key] || [];
            subscribers[key].push(callback);
          },
          unsubscribe(key, callback) {
            if (callback) {
              var index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback);
              index > -1 && subscribers[key].splice(index, 1);
            } else {
              if (key in subscribers) {
                subscribers[key] = [];
              }
            }
          },
          clearSubscribers() {
            var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertyNames(subscribers)),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var key = _step4.value;
                delete subscribers[key];
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var prepLog = (type, args) => {
          var colors = {
            Info: 'green',
            Debug: 'gray',
            Warn: 'orange',
            Error: 'red'
          };
          args = Array.from(args);
          return ['%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type), 'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px', args];
        };
        var Log$1 = {
          info() {
            Settings$1.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments));
          },
          debug() {
            Settings$1.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments));
          },
          error() {
            Settings$1.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments));
          },
          warn() {
            Settings$1.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments));
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class StageUtils {
          static mergeNumbers(v1, v2, p) {
            return v1 * p + v2 * (1 - p);
          }
          static rgb(r, g, b) {
            return (r << 16) + (g << 8) + b + 255 * 16777216;
          }
          static rgba(r, g, b, a) {
            return (r << 16) + (g << 8) + b + (a * 255 | 0) * 16777216;
          }
          static getRgbString(color) {
            var r = (color / 65536 | 0) % 256;
            var g = (color / 256 | 0) % 256;
            var b = color % 256;
            return 'rgb(' + r + ',' + g + ',' + b + ')';
          }
          static getRgbaString(color) {
            var r = (color / 65536 | 0) % 256;
            var g = (color / 256 | 0) % 256;
            var b = color % 256;
            var a = (color / 16777216 | 0) / 255;
            return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
          }
          static getRgbaStringFromArray(color) {
            var r = Math.floor(color[0] * 255);
            var g = Math.floor(color[1] * 255);
            var b = Math.floor(color[2] * 255);
            var a = Math.floor(color[3] * 255) / 255;
            return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
          }
          static getRgbaComponentsNormalized(argb) {
            var r = (argb / 65536 | 0) % 256;
            var g = (argb / 256 | 0) % 256;
            var b = argb % 256;
            var a = argb / 16777216 | 0;
            return [r / 255, g / 255, b / 255, a / 255];
          }
          static getRgbComponentsNormalized(argb) {
            var r = (argb / 65536 | 0) % 256;
            var g = (argb / 256 | 0) % 256;
            var b = argb % 256;
            return [r / 255, g / 255, b / 255];
          }
          static getRgbaComponents(argb) {
            var r = (argb / 65536 | 0) % 256;
            var g = (argb / 256 | 0) % 256;
            var b = argb % 256;
            var a = argb / 16777216 | 0;
            return [r, g, b, a];
          }
          static getArgbNumber(rgba) {
            rgba[0] = Math.max(0, Math.min(255, rgba[0]));
            rgba[1] = Math.max(0, Math.min(255, rgba[1]));
            rgba[2] = Math.max(0, Math.min(255, rgba[2]));
            rgba[3] = Math.max(0, Math.min(255, rgba[3]));
            var v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
            if (v < 0) {
              v = 0xFFFFFFFF + v + 1;
            }
            return v;
          }
          static mergeColors(c1, c2, p) {
            var r1 = (c1 / 65536 | 0) % 256;
            var g1 = (c1 / 256 | 0) % 256;
            var b1 = c1 % 256;
            var a1 = c1 / 16777216 | 0;
            var r2 = (c2 / 65536 | 0) % 256;
            var g2 = (c2 / 256 | 0) % 256;
            var b2 = c2 % 256;
            var a2 = c2 / 16777216 | 0;
            var r = r1 * p + r2 * (1 - p);
            var g = g1 * p + g2 * (1 - p);
            var b = b1 * p + b2 * (1 - p);
            var a = a1 * p + a2 * (1 - p);
            return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
          }
          static mergeMultiColors(c, p) {
            var r = 0,
              g = 0,
              b = 0,
              a = 0,
              t = 0;
            var n = c.length;
            for (var i = 0; i < n; i++) {
              var r1 = (c[i] / 65536 | 0) % 256;
              var g1 = (c[i] / 256 | 0) % 256;
              var b1 = c[i] % 256;
              var a1 = c[i] / 16777216 | 0;
              r += r1 * p[i];
              g += g1 * p[i];
              b += b1 * p[i];
              a += a1 * p[i];
              t += p[i];
            }
            t = 1 / t;
            return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
          }
          static mergeMultiColorsEqual(c) {
            var r = 0,
              g = 0,
              b = 0,
              a = 0,
              t = 0;
            var n = c.length;
            for (var i = 0; i < n; i++) {
              var r1 = (c[i] / 65536 | 0) % 256;
              var g1 = (c[i] / 256 | 0) % 256;
              var b1 = c[i] % 256;
              var a1 = c[i] / 16777216 | 0;
              r += r1;
              g += g1;
              b += b1;
              a += a1;
              t += 1.0;
            }
            t = 1 / t;
            return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
          }
          static mergeColorAlpha(c, alpha) {
            var a = (c / 16777216 | 0) * alpha | 0;
            return ((c >> 16 & 0xff) * a / 255 & 0xff) + ((c & 0xff00) * a / 255 & 0xff00) + (((c & 0xff) << 16) * a / 255 & 0xff0000) + (a << 24);
          }
          static rad(deg) {
            return deg * (Math.PI / 180);
          }
          static getTimingBezier(a, b, c, d) {
            var xc = 3.0 * a;
            var xb = 3.0 * (c - a) - xc;
            var xa = 1.0 - xc - xb;
            var yc = 3.0 * b;
            var yb = 3.0 * (d - b) - yc;
            var ya = 1.0 - yc - yb;
            return function (time) {
              if (time >= 1.0) {
                return 1;
              }
              if (time <= 0) {
                return 0;
              }
              var t = 0.5,
                cbx,
                cbxd,
                dx;
              for (var it = 0; it < 20; it++) {
                cbx = t * (t * (t * xa + xb) + xc);
                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                  return t * (t * (t * ya + yb) + yc);
                }

                // Cubic bezier derivative.
                cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
                if (cbxd > 1e-10 && cbxd < 1e-10) {
                  // Problematic. Fall back to binary search method.
                  break;
                }
                t += dx / cbxd;
              }

              // Fallback: binary search method. This is more reliable when there are near-0 slopes.
              var minT = 0;
              var maxT = 1;
              for (var _it = 0; _it < 20; _it++) {
                t = 0.5 * (minT + maxT);
                cbx = t * (t * (t * xa + xb) + xc);
                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                  // Solution found!
                  return t * (t * (t * ya + yb) + yc);
                }
                if (dx < 0) {
                  maxT = t;
                } else {
                  minT = t;
                }
              }
            };
          }
          static getTimingFunction(str) {
            switch (str) {
              case "linear":
                return function (time) {
                  return time;
                };
              case "ease":
                return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1.0);
              case "ease-in":
                return StageUtils.getTimingBezier(0.42, 0, 1.0, 1.0);
              case "ease-out":
                return StageUtils.getTimingBezier(0, 0, 0.58, 1.0);
              case "ease-in-out":
                return StageUtils.getTimingBezier(0.42, 0, 0.58, 1.0);
              case "step-start":
                return function () {
                  return 1;
                };
              case "step-end":
                return function (time) {
                  return time === 1 ? 1 : 0;
                };
              default:
                var s = "cubic-bezier(";
                if (str && str.indexOf(s) === 0) {
                  var parts = str.substr(s.length, str.length - s.length - 1).split(",");
                  if (parts.length !== 4) {
                    console.warn("[Lightning] Unknown timing function: " + str);

                    // Fallback: use linear.
                    return function (time) {
                      return time;
                    };
                  }
                  var a = parseFloat(parts[0]);
                  var b = parseFloat(parts[1]);
                  var c = parseFloat(parts[2]);
                  var d = parseFloat(parts[3]);
                  if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
                    console.warn("[Lightning] Unknown timing function: " + str);
                    // Fallback: use linear.
                    return function (time) {
                      return time;
                    };
                  }
                  return StageUtils.getTimingBezier(a, b, c, d);
                } else {
                  console.warn("[Lightning] Unknown timing function: " + str);
                  // Fallback: use linear.
                  return function (time) {
                    return time;
                  };
                }
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Utils$2 = class Utils {
          static isFunction(value) {
            return typeof value === 'function';
          }
          static isNumber(value) {
            return typeof value === 'number';
          }
          static isInteger(value) {
            return typeof value === 'number' && value % 1 === 0;
          }
          static isBoolean(value) {
            return value === true || value === false;
          }
          static isString(value) {
            return typeof value === 'string';
          }
          static clone(v) {
            if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
              return Utils.getDeepClone(v);
            } else {
              // Copy by value.
              return v;
            }
          }
          static cloneObjShallow(obj) {
            var keys = Object.keys(obj);
            var clone = {};
            for (var i = 0; i < keys.length; i++) {
              clone[keys[i]] = obj[keys[i]];
            }
            return clone;
          }
          static merge(obj1, obj2) {
            var keys = Object.keys(obj2);
            for (var i = 0; i < keys.length; i++) {
              obj1[keys[i]] = obj2[keys[i]];
            }
            return obj1;
          }
          static isObject(value) {
            var type = typeof value;
            return !!value && (type === 'object' || type === 'function');
          }
          static isPlainObject(value) {
            var type = typeof value;
            return !!value && type === 'object';
          }
          static isObjectLiteral(value) {
            return typeof value === 'object' && value && value.constructor === Object;
          }
          static getArrayIndex(index, arr) {
            return Utils.getModuloIndex(index, arr.length);
          }
          static getModuloIndex(index, len) {
            if (len === 0) return index;
            while (index < 0) {
              index += Math.ceil(-index / len) * len;
            }
            index = index % len;
            return index;
          }
          static getDeepClone(obj) {
            var i, c;
            if (Utils.isFunction(obj)) {
              // Copy functions by reference.
              return obj;
            }
            if (Array.isArray(obj)) {
              c = [];
              var keys = Object.keys(obj);
              for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
              }
              return c;
            } else if (Utils.isObject(obj)) {
              c = {};
              var _keys = Object.keys(obj);
              for (i = 0; i < _keys.length; i++) {
                c[_keys[i]] = Utils.getDeepClone(obj[_keys[i]]);
              }
              return c;
            } else {
              return obj;
            }
          }
          static equalValues(v1, v2) {
            if (typeof v1 !== typeof v2) return false;
            if (Utils.isObjectLiteral(v1)) {
              return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
            } else if (Array.isArray(v1)) {
              return Array.isArray(v2) && Utils.equalArrays(v1, v2);
            } else {
              return v1 === v2;
            }
          }
          static equalObjectLiterals(obj1, obj2) {
            var keys1 = Object.keys(obj1);
            var keys2 = Object.keys(obj2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            for (var i = 0, n = keys1.length; i < n; i++) {
              var k1 = keys1[i];
              var k2 = keys2[i];
              if (k1 !== k2) {
                return false;
              }
              var v1 = obj1[k1];
              var v2 = obj2[k2];
              if (!Utils.equalValues(v1, v2)) {
                return false;
              }
            }
            return true;
          }
          static equalArrays(v1, v2) {
            if (v1.length !== v2.length) {
              return false;
            }
            for (var i = 0, n = v1.length; i < n; i++) {
              if (!this.equalValues(v1[i], v2[i])) {
                return false;
              }
            }
            return true;
          }
          static setToArray(s) {
            var result = [];
            s.forEach(function (value) {
              result.push(value);
            });
            return result;
          }
          static iteratorToArray(iterator) {
            var result = [];
            var iteratorResult = iterator.next();
            while (!iteratorResult.done) {
              result.push(iteratorResult.value);
              iteratorResult = iterator.next();
            }
            return result;
          }
          static isUcChar(charcode) {
            return charcode >= 65 && charcode <= 90;
          }
        };
        Utils$2.isWeb = typeof window !== "undefined" && typeof sparkscene === "undefined";
        Utils$2.isWPE = Utils$2.isWeb && navigator.userAgent.indexOf("WPE") !== -1;
        Utils$2.isSpark = typeof sparkscene !== "undefined";
        Utils$2.isNode = typeof window === "undefined" || Utils$2.isSpark;
        Utils$2.isPS4 = Utils$2.isWeb && navigator.userAgent.indexOf("PlayStation 4") !== -1;
        Utils$2.isZiggo = Utils$2.isWeb && (navigator.userAgent.indexOf("EOSSTB") !== -1 || navigator.userAgent.indexOf("HZNSTB") !== -1);

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Base {
          static defaultSetter(obj, name, value) {
            obj[name] = value;
          }
          static patchObject(obj, settings) {
            if (!Utils$2.isObjectLiteral(settings)) {
              console.error("[Lightning] Settings must be object literal");
            } else {
              var names = Object.keys(settings);
              for (var i = 0, n = names.length; i < n; i++) {
                var _name = names[i];
                this.patchObjectProperty(obj, _name, settings[_name]);
              }
            }
          }
          static patchObjectProperty(obj, name, value) {
            var setter = obj.setSetting || Base.defaultSetter;
            if (name.charAt(0) === "_") {
              // Disallow patching private variables.
              if (name !== "__create") {
                console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
              }
            } else if (name !== "type") {
              // Type is a reserved keyword to specify the class type on creation.
              if (Utils$2.isFunction(value) && value.__local) {
                // Local function (Base.local(s => s.something))
                value = value.__local(obj);
              }
              setter(obj, name, value);
            }
          }
          static local(func) {
            // This function can be used as an object setting, which is called with the target object.
            func.__local = true;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SpacingCalculator {
          static getSpacing(mode, numberOfItems, remainingSpace) {
            var itemGaps = numberOfItems - 1;
            var spacePerGap;
            var spacingBefore, spacingBetween;
            switch (mode) {
              case "flex-start":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
              case "flex-end":
                spacingBefore = remainingSpace;
                spacingBetween = 0;
                break;
              case "center":
                spacingBefore = remainingSpace / 2;
                spacingBetween = 0;
                break;
              case "space-between":
                spacingBefore = 0;
                spacingBetween = Math.max(0, remainingSpace) / itemGaps;
                break;
              case "space-around":
                if (remainingSpace < 0) {
                  return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                  spacePerGap = remainingSpace / (itemGaps + 1);
                  spacingBefore = 0.5 * spacePerGap;
                  spacingBetween = spacePerGap;
                }
                break;
              case "space-evenly":
                if (remainingSpace < 0) {
                  return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                  spacePerGap = remainingSpace / (itemGaps + 2);
                  spacingBefore = spacePerGap;
                  spacingBetween = spacePerGap;
                }
                break;
              case "stretch":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
              default:
                throw new Error("Unknown mode: " + mode);
            }
            return {
              spacingBefore,
              spacingBetween
            };
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ContentAligner {
          constructor(layout) {
            this._layout = layout;
            this._totalCrossAxisSize = 0;
          }
          get _lines() {
            return this._layout._lines;
          }
          init() {
            this._totalCrossAxisSize = this._getTotalCrossAxisSize();
          }
          align() {
            var crossAxisSize = this._layout.crossAxisSize;
            var remainingSpace = crossAxisSize - this._totalCrossAxisSize;
            var _this$_getSpacing = this._getSpacing(remainingSpace),
              spacingBefore = _this$_getSpacing.spacingBefore,
              spacingBetween = _this$_getSpacing.spacingBetween;
            var lines = this._lines;
            var mode = this._layout._flexContainer.alignContent;
            var growSize = 0;
            if (mode === "stretch" && lines.length && remainingSpace > 0) {
              growSize = remainingSpace / lines.length;
            }
            var currentPos = spacingBefore;
            for (var i = 0, n = lines.length; i < n; i++) {
              var crossAxisLayoutOffset = currentPos;
              var aligner = lines[i].createItemAligner();
              var finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;
              aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
              aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);
              aligner.align();
              if (aligner.recursiveResizeOccured) {
                lines[i].setItemPositions();
              }
              currentPos += finalCrossAxisLayoutSize;
              currentPos += spacingBetween;
            }
          }
          get totalCrossAxisSize() {
            return this._totalCrossAxisSize;
          }
          _getTotalCrossAxisSize() {
            var lines = this._lines;
            var total = 0;
            for (var i = 0, n = lines.length; i < n; i++) {
              var line = lines[i];
              total += line.crossAxisLayoutSize;
            }
            return total;
          }
          _getSpacing(remainingSpace) {
            var mode = this._layout._flexContainer.alignContent;
            var numberOfItems = this._lines.length;
            return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class FlexUtils {
          static getParentAxisSizeWithPadding(item, horizontal) {
            var target = item.target;
            var parent = target.getParent();
            if (!parent) {
              return 0;
            } else {
              var flexParent = item.flexParent;
              if (flexParent) {
                // Use pending layout size.
                return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
              } else {
                // Use 'absolute' size.
                return horizontal ? parent.w : parent.h;
              }
            }
          }
          static getRelAxisSize(item, horizontal) {
            if (horizontal) {
              if (item.funcW) {
                if (this._allowRelAxisSizeFunction(item, true)) {
                  return item.funcW(this.getParentAxisSizeWithPadding(item, true));
                } else {
                  return 0;
                }
              } else {
                return item.originalWidth;
              }
            } else {
              if (item.funcH) {
                if (this._allowRelAxisSizeFunction(item, false)) {
                  return item.funcH(this.getParentAxisSizeWithPadding(item, false));
                } else {
                  return 0;
                }
              } else {
                return item.originalHeight;
              }
            }
          }
          static _allowRelAxisSizeFunction(item, horizontal) {
            var flexParent = item.flexParent;
            if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
              // We don't allow relative width on fit-to-contents because it leads to conflicts.
              return false;
            }
            return true;
          }
          static isZeroAxisSize(item, horizontal) {
            if (horizontal) {
              return !item.originalWidth && !item.funcW;
            } else {
              return !item.originalHeight && !item.funcH;
            }
          }
          static getAxisLayoutPos(item, horizontal) {
            return horizontal ? item.x : item.y;
          }
          static getAxisLayoutSize(item, horizontal) {
            return horizontal ? item.w : item.h;
          }
          static setAxisLayoutPos(item, horizontal, pos) {
            if (horizontal) {
              item.x = pos;
            } else {
              item.y = pos;
            }
          }
          static setAxisLayoutSize(item, horizontal, size) {
            if (horizontal) {
              item.w = size;
            } else {
              item.h = size;
            }
          }
          static getAxisMinSize(item, horizontal) {
            var minSize = this.getPlainAxisMinSize(item, horizontal);
            var flexItemMinSize = 0;
            if (item.isFlexItemEnabled()) {
              flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
            }
            var hasLimitedMinSize = flexItemMinSize > 0;
            if (hasLimitedMinSize) {
              minSize = Math.max(minSize, flexItemMinSize);
            }
            return minSize;
          }
          static getPlainAxisMinSize(item, horizontal) {
            if (item.isFlexEnabled()) {
              return item._flex._layout.getAxisMinSize(horizontal);
            } else {
              var isShrinkable = item.flexItem.shrink !== 0;
              if (isShrinkable) {
                return 0;
              } else {
                return this.getRelAxisSize(item, horizontal);
              }
            }
          }
          static resizeAxis(item, horizontal, size) {
            if (item.isFlexEnabled()) {
              var isMainAxis = item._flex._horizontal === horizontal;
              if (isMainAxis) {
                item._flex._layout.resizeMainAxis(size);
              } else {
                item._flex._layout.resizeCrossAxis(size);
              }
            } else {
              this.setAxisLayoutSize(item, horizontal, size);
            }
          }
          static getPaddingOffset(item, horizontal) {
            if (item.isFlexEnabled()) {
              var flex = item._flex;
              if (horizontal) {
                return flex.paddingLeft;
              } else {
                return flex.paddingTop;
              }
            } else {
              return 0;
            }
          }
          static getTotalPadding(item, horizontal) {
            if (item.isFlexEnabled()) {
              var flex = item._flex;
              if (horizontal) {
                return flex.paddingRight + flex.paddingLeft;
              } else {
                return flex.paddingTop + flex.paddingBottom;
              }
            } else {
              return 0;
            }
          }
          static getMarginOffset(item, horizontal) {
            var flexItem = item.flexItem;
            if (flexItem) {
              if (horizontal) {
                return flexItem.marginLeft;
              } else {
                return flexItem.marginTop;
              }
            } else {
              return 0;
            }
          }
          static getTotalMargin(item, horizontal) {
            var flexItem = item.flexItem;
            if (flexItem) {
              if (horizontal) {
                return flexItem.marginRight + flexItem.marginLeft;
              } else {
                return flexItem.marginTop + flexItem.marginBottom;
              }
            } else {
              return 0;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SizeShrinker {
          constructor(line) {
            this._line = line;
            this._amountRemaining = 0;
            this._shrunkSize = 0;
          }
          shrink(amount) {
            this._shrunkSize = 0;
            this._amountRemaining = amount;
            var totalShrinkAmount = this._getTotalShrinkAmount();
            if (totalShrinkAmount) {
              var items = this._line.items;
              do {
                var amountPerShrink = this._amountRemaining / totalShrinkAmount;
                for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  var item = items[i];
                  var flexItem = item.flexItem;
                  var shrinkAmount = flexItem.shrink;
                  var isShrinkableItem = shrinkAmount > 0;
                  if (isShrinkableItem) {
                    var shrink = shrinkAmount * amountPerShrink;
                    var minSize = flexItem._getMainAxisMinSize();
                    var size = flexItem._getMainAxisLayoutSize();
                    if (size > minSize) {
                      var maxShrink = size - minSize;
                      var isFullyShrunk = shrink >= maxShrink;
                      if (isFullyShrunk) {
                        shrink = maxShrink;

                        // Destribute remaining amount over the other flex items.
                        totalShrinkAmount -= shrinkAmount;
                      }
                      var finalSize = size - shrink;
                      flexItem._resizeMainAxis(finalSize);
                      this._shrunkSize += shrink;
                      this._amountRemaining -= shrink;
                      if (Math.abs(this._amountRemaining) < 10e-6) {
                        return;
                      }
                    }
                  }
                }
              } while (totalShrinkAmount && Math.abs(this._amountRemaining) > 10e-6);
            }
          }
          _getTotalShrinkAmount() {
            var total = 0;
            var items = this._line.items;
            for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
              var item = items[i];
              var flexItem = item.flexItem;
              if (flexItem.shrink) {
                var minSize = flexItem._getMainAxisMinSize();
                var size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully shrunk.
                if (size > minSize) {
                  total += flexItem.shrink;
                }
              }
            }
            return total;
          }
          getShrunkSize() {
            return this._shrunkSize;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SizeGrower {
          constructor(line) {
            this._line = line;
            this._amountRemaining = 0;
            this._grownSize = 0;
          }
          grow(amount) {
            this._grownSize = 0;
            this._amountRemaining = amount;
            var totalGrowAmount = this._getTotalGrowAmount();
            if (totalGrowAmount) {
              var items = this._line.items;
              do {
                var amountPerGrow = this._amountRemaining / totalGrowAmount;
                for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  var item = items[i];
                  var flexItem = item.flexItem;
                  var growAmount = flexItem.grow;
                  var isGrowableItem = growAmount > 0;
                  if (isGrowableItem) {
                    var grow = growAmount * amountPerGrow;
                    var maxSize = flexItem._getMainAxisMaxSizeSetting();
                    var size = flexItem._getMainAxisLayoutSize();
                    if (maxSize > 0) {
                      if (size >= maxSize) {
                        // Already fully grown.
                        grow = 0;
                      } else {
                        var maxGrow = maxSize - size;
                        var isFullyGrown = grow >= maxGrow;
                        if (isFullyGrown) {
                          grow = maxGrow;

                          // Destribute remaining amount over the other flex items.
                          totalGrowAmount -= growAmount;
                        }
                      }
                    }
                    if (grow > 0) {
                      var finalSize = size + grow;
                      flexItem._resizeMainAxis(finalSize);
                      this._grownSize += grow;
                      this._amountRemaining -= grow;
                      if (Math.abs(this._amountRemaining) < 10e-6) {
                        return;
                      }
                    }
                  }
                }
              } while (totalGrowAmount && Math.abs(this._amountRemaining) > 10e-6);
            }
          }
          _getTotalGrowAmount() {
            var total = 0;
            var items = this._line.items;
            for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
              var item = items[i];
              var flexItem = item.flexItem;
              if (flexItem.grow) {
                var maxSize = flexItem._getMainAxisMaxSizeSetting();
                var size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully grown.
                if (maxSize === 0 || size < maxSize) {
                  total += flexItem.grow;
                }
              }
            }
            return total;
          }
          getGrownSize() {
            return this._grownSize;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ItemPositioner {
          constructor(lineLayout) {
            this._line = lineLayout;
          }
          get _layout() {
            return this._line._layout;
          }
          position() {
            var _this$_getSpacing2 = this._getSpacing(),
              spacingBefore = _this$_getSpacing2.spacingBefore,
              spacingBetween = _this$_getSpacing2.spacingBetween;
            var currentPos = spacingBefore;
            var items = this._line.items;
            for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
              var item = items[i];
              item.flexItem._setMainAxisLayoutPos(currentPos);
              currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
              currentPos += spacingBetween;
            }
          }
          _getSpacing() {
            var remainingSpace = this._line._availableSpace;
            var mode = this._layout._flexContainer.justifyContent;
            var numberOfItems = this._line.numberOfItems;
            return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ItemAligner {
          constructor(line) {
            this._line = line;
            this._crossAxisLayoutSize = 0;
            this._crossAxisLayoutOffset = 0;
            this._alignItemsSetting = null;
            this._recursiveResizeOccured = false;
            this._isCrossAxisFitToContents = false;
          }
          get _layout() {
            return this._line._layout;
          }
          get _flexContainer() {
            return this._layout._flexContainer;
          }
          setCrossAxisLayoutSize(size) {
            this._crossAxisLayoutSize = size;
          }
          setCrossAxisLayoutOffset(offset) {
            this._crossAxisLayoutOffset = offset;
          }
          align() {
            this._alignItemsSetting = this._flexContainer.alignItems;
            this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);
            this._recursiveResizeOccured = false;
            var items = this._line.items;
            for (var i = this._line.startIndex; i <= this._line.endIndex; i++) {
              var item = items[i];
              this._alignItem(item);
            }
          }
          get recursiveResizeOccured() {
            return this._recursiveResizeOccured;
          }
          _alignItem(item) {
            var flexItem = item.flexItem;
            var align = flexItem.alignSelf || this._alignItemsSetting;
            if (align === "stretch" && this._preventStretch(flexItem)) {
              align = "flex-start";
            }
            if (align !== "stretch" && !this._isCrossAxisFitToContents) {
              if (flexItem._hasRelCrossAxisSize()) {
                // As cross axis size might have changed, we need to recalc the relative flex item's size.
                flexItem._resetCrossAxisLayoutSize();
              }
            }
            switch (align) {
              case "flex-start":
                this._alignItemFlexStart(flexItem);
                break;
              case "flex-end":
                this._alignItemFlexEnd(flexItem);
                break;
              case "center":
                this._alignItemFlexCenter(flexItem);
                break;
              case "stretch":
                this._alignItemStretch(flexItem);
                break;
            }
          }
          _alignItemFlexStart(flexItem) {
            flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
          }
          _alignItemFlexEnd(flexItem) {
            var itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
            flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
          }
          _alignItemFlexCenter(flexItem) {
            var itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
            var center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
            flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
          }
          _alignItemStretch(flexItem) {
            flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
            var mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
            var size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();
            var crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
            if (crossAxisMinSizeSetting > 0) {
              size = Math.max(size, crossAxisMinSizeSetting);
            }
            var crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
            var crossAxisMaxSizeSettingEnabled = crossAxisMaxSizeSetting > 0;
            if (crossAxisMaxSizeSettingEnabled) {
              size = Math.min(size, crossAxisMaxSizeSetting);
            }
            flexItem._resizeCrossAxis(size);
            var mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();
            var recursiveResize = mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize;
            if (recursiveResize) {
              // Recursive resize can happen when this flex item has the opposite direction than the container
              // and is wrapping and auto-sizing. Due to item/content stretching the main axis size of the flex
              // item may decrease. If it does so, we must re-justify-content the complete line.
              // Notice that we don't account for changes to the (if autosized) main axis size caused by recursive
              // resize, which may cause the container's main axis to not shrink to the contents properly.
              // This is by design, because if we had re-run the main axis layout, we could run into issues such
              // as slow layout or endless loops.
              this._recursiveResizeOccured = true;
            }
          }
          _preventStretch(flexItem) {
            var hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
            var forceStretch = flexItem.alignSelf === "stretch";
            return hasFixedCrossAxisSize && !forceStretch;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class LineLayout {
          constructor(layout, startIndex, endIndex, availableSpace) {
            this._layout = layout;
            this.items = layout.items;
            this.startIndex = startIndex;
            this.endIndex = endIndex;
            this._availableSpace = availableSpace;
          }
          performLayout() {
            this._setItemSizes();
            this.setItemPositions();
            this._calcLayoutInfo();
          }
          _setItemSizes() {
            if (this._availableSpace > 0) {
              this._growItemSizes(this._availableSpace);
            } else if (this._availableSpace < 0) {
              this._shrinkItemSizes(-this._availableSpace);
            }
          }
          _growItemSizes(amount) {
            var grower = new SizeGrower(this);
            grower.grow(amount);
            this._availableSpace -= grower.getGrownSize();
          }
          _shrinkItemSizes(amount) {
            var shrinker = new SizeShrinker(this);
            shrinker.shrink(amount);
            this._availableSpace += shrinker.getShrunkSize();
          }
          setItemPositions() {
            var positioner = new ItemPositioner(this);
            positioner.position();
          }
          createItemAligner() {
            return new ItemAligner(this);
          }
          _calcLayoutInfo() {
            this._calcCrossAxisMaxLayoutSize();
          }
          getMainAxisMinSize() {
            var mainAxisMinSize = 0;
            for (var i = this.startIndex; i <= this.endIndex; i++) {
              var item = this.items[i];
              mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
            }
            return mainAxisMinSize;
          }
          get numberOfItems() {
            return this.endIndex - this.startIndex + 1;
          }
          get crossAxisLayoutSize() {
            var noSpecifiedCrossAxisSize = this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis;
            var shouldFitToContents = this._layout.isWrapping() || noSpecifiedCrossAxisSize;
            if (shouldFitToContents) {
              return this._crossAxisMaxLayoutSize;
            } else {
              return this._layout.crossAxisSize;
            }
          }
          _calcCrossAxisMaxLayoutSize() {
            this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
          }
          _getCrossAxisMaxLayoutSize() {
            var crossAxisMaxSize = 0;
            for (var i = this.startIndex; i <= this.endIndex; i++) {
              var item = this.items[i];
              crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
            }
            return crossAxisMaxSize;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Distributes items over layout lines.
         */
        class LineLayouter {
          constructor(layout) {
            this._layout = layout;
            this._mainAxisMinSize = -1;
            this._crossAxisMinSize = -1;
            this._mainAxisContentSize = 0;
          }
          get lines() {
            return this._lines;
          }
          get mainAxisMinSize() {
            if (this._mainAxisMinSize === -1) {
              this._mainAxisMinSize = this._getMainAxisMinSize();
            }
            return this._mainAxisMinSize;
          }
          get crossAxisMinSize() {
            if (this._crossAxisMinSize === -1) {
              this._crossAxisMinSize = this._getCrossAxisMinSize();
            }
            return this._crossAxisMinSize;
          }
          get mainAxisContentSize() {
            return this._mainAxisContentSize;
          }
          layoutLines() {
            this._setup();
            var items = this._layout.items;
            var wrap = this._layout.isWrapping();
            var startIndex = 0;
            var i;
            var n = items.length;
            for (i = 0; i < n; i++) {
              var item = items[i];
              this._layoutFlexItem(item);

              // Get predicted main axis size.
              var itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
              if (wrap && i > startIndex) {
                var isOverflowing = this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize;
                if (isOverflowing) {
                  this._layoutLine(startIndex, i - 1);
                  this._curMainAxisPos = 0;
                  startIndex = i;
                }
              }
              this._addToMainAxisPos(itemMainAxisSize);
            }
            if (startIndex < i) {
              this._layoutLine(startIndex, i - 1);
            }
          }
          _layoutFlexItem(item) {
            if (item.isFlexEnabled()) {
              item.flexLayout.updateTreeLayout();
            } else {
              item.flexItem._resetLayoutSize();
            }
          }
          _setup() {
            this._mainAxisSize = this._layout.mainAxisSize;
            this._curMainAxisPos = 0;
            this._maxMainAxisPos = 0;
            this._lines = [];
            this._mainAxisMinSize = -1;
            this._crossAxisMinSize = -1;
            this._mainAxisContentSize = 0;
          }
          _addToMainAxisPos(itemMainAxisSize) {
            this._curMainAxisPos += itemMainAxisSize;
            if (this._curMainAxisPos > this._maxMainAxisPos) {
              this._maxMainAxisPos = this._curMainAxisPos;
            }
          }
          _layoutLine(startIndex, endIndex) {
            var availableSpace = this._getAvailableMainAxisLayoutSpace();
            var line = new LineLayout(this._layout, startIndex, endIndex, availableSpace);
            line.performLayout();
            this._lines.push(line);
            if (this._mainAxisContentSize === 0 || this._curMainAxisPos > this._mainAxisContentSize) {
              this._mainAxisContentSize = this._curMainAxisPos;
            }
          }
          _getAvailableMainAxisLayoutSpace() {
            if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
              return 0;
            } else {
              return this._mainAxisSize - this._curMainAxisPos;
            }
          }
          _getCrossAxisMinSize() {
            var crossAxisMinSize = 0;
            var items = this._layout.items;
            for (var i = 0, n = items.length; i < n; i++) {
              var item = items[i];
              var itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
              crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
            }
            return crossAxisMinSize;
          }
          _getMainAxisMinSize() {
            if (this._lines.length === 1) {
              return this._lines[0].getMainAxisMinSize();
            } else {
              // Wrapping lines: specified width is used as min width (in accordance to W3C flexbox).
              return this._layout.mainAxisSize;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ItemCoordinatesUpdater {
          constructor(layout) {
            this._layout = layout;
            this._isReverse = this._flexContainer._reverse;
            this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
            this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
          }
          get _flexContainer() {
            return this._layout._flexContainer;
          }
          finalize() {
            var parentFlex = this._layout.getParentFlexContainer();
            if (parentFlex) {
              // We must update it from the parent to set padding offsets and reverse position.
              var updater = new ItemCoordinatesUpdater(parentFlex._layout);
              updater._finalizeItemAndChildren(this._flexContainer.item);
            } else {
              this._finalizeRoot();
              this._finalizeItems();
            }
          }
          _finalizeRoot() {
            var item = this._flexContainer.item;
            var x = FlexUtils.getAxisLayoutPos(item, true);
            var y = FlexUtils.getAxisLayoutPos(item, false);
            var w = FlexUtils.getAxisLayoutSize(item, true);
            var h = FlexUtils.getAxisLayoutSize(item, false);
            w += this._layout._getHorizontalPadding();
            h += this._layout._getVerticalPadding();
            item.clearRecalcFlag();
            item.setLayout(x, y, w, h);
          }
          _finalizeItems() {
            var items = this._layout.items;
            for (var i = 0, n = items.length; i < n; i++) {
              var item = items[i];
              var validCache = this._validateItemCache(item);

              // Notice that we must also finalize a cached items, as it's coordinates may have changed.
              this._finalizeItem(item);
              if (!validCache) {
                this._finalizeItemChildren(item);
              }
            }
          }
          _validateItemCache(item) {
            if (item.recalc === 0) {
              if (item.isFlexEnabled()) {
                var layout = item._flex._layout;
                var dimensionsMatchPreviousResult = item.w === item.target.w && item.h === item.target.h;
                if (dimensionsMatchPreviousResult) {
                  // Cache is valid.
                  return true;
                } else {
                  var crossAxisSize = layout.crossAxisSize;
                  layout.performResizeMainAxis(layout.mainAxisSize);
                  layout.performResizeCrossAxis(crossAxisSize);
                }
              }
            }
            return false;
          }
          _finalizeItemAndChildren(item) {
            this._finalizeItem(item);
            this._finalizeItemChildren(item);
          }
          _finalizeItem(item) {
            if (this._isReverse) {
              this._reverseMainAxisLayoutPos(item);
            }
            var x = FlexUtils.getAxisLayoutPos(item, true);
            var y = FlexUtils.getAxisLayoutPos(item, false);
            var w = FlexUtils.getAxisLayoutSize(item, true);
            var h = FlexUtils.getAxisLayoutSize(item, false);
            x += this._horizontalPaddingOffset;
            y += this._verticalPaddingOffset;
            var flex = item.flex;
            if (flex) {
              w += item._flex._layout._getHorizontalPadding();
              h += item._flex._layout._getVerticalPadding();
            }
            var flexItem = item.flexItem;
            if (flexItem) {
              x += flexItem._getHorizontalMarginOffset();
              y += flexItem._getVerticalMarginOffset();
            }
            item.clearRecalcFlag();
            item.setLayout(x, y, w, h);
          }
          _finalizeItemChildren(item) {
            var flex = item._flex;
            if (flex) {
              var updater = new ItemCoordinatesUpdater(flex._layout);
              updater._finalizeItems();
            }
          }
          _reverseMainAxisLayoutPos(item) {
            var endPos = item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
            var reversedPos = this._layout.mainAxisSize - endPos;
            item.flexItem._setMainAxisLayoutPos(reversedPos);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Layouts a flex container (and descendants).
         */
        class FlexLayout {
          constructor(flexContainer) {
            this._flexContainer = flexContainer;
            this._lineLayouter = new LineLayouter(this);
            this._resizingMainAxis = false;
            this._resizingCrossAxis = false;
            this._cachedMainAxisSizeAfterLayout = 0;
            this._cachedCrossAxisSizeAfterLayout = 0;
            this._shrunk = false;
          }
          get shrunk() {
            return this._shrunk;
          }
          get recalc() {
            return this.item.recalc;
          }
          layoutTree() {
            var isSubTree = this.item.flexParent !== null;
            if (isSubTree) {
              // Use the dimensions set by the parent flex tree.
              this._updateSubTreeLayout();
            } else {
              this.updateTreeLayout();
            }
            this.updateItemCoords();
          }
          updateTreeLayout() {
            if (this.recalc) {
              this._performUpdateLayoutTree();
            } else {
              this._performUpdateLayoutTreeFromCache();
            }
          }
          _performUpdateLayoutTree() {
            this._setInitialAxisSizes();
            this._layoutAxes();
            this._refreshLayoutCache();
          }
          _refreshLayoutCache() {
            this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
            this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
          }
          _performUpdateLayoutTreeFromCache() {
            var sizeMightHaveChanged = this.item.funcW || this.item.funcH;
            if (sizeMightHaveChanged) {
              // Update after all.
              this.item.enableLocalRecalcFlag();
              this._performUpdateLayoutTree();
            } else {
              this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
              this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
            }
          }
          updateItemCoords() {
            var updater = new ItemCoordinatesUpdater(this);
            updater.finalize();
          }
          _updateSubTreeLayout() {
            // The dimensions of this container are guaranteed not to have changed.
            // That's why we can safely 'reuse' those and re-layout the contents.
            var crossAxisSize = this.crossAxisSize;
            this._layoutMainAxis();
            this.performResizeCrossAxis(crossAxisSize);
          }
          _setInitialAxisSizes() {
            if (this.item.isFlexItemEnabled()) {
              this.item.flexItem._resetLayoutSize();
            } else {
              this.mainAxisSize = this._getMainAxisBasis();
              this.crossAxisSize = this._getCrossAxisBasis();
            }
            this._resizingMainAxis = false;
            this._resizingCrossAxis = false;
            this._shrunk = false;
          }
          _layoutAxes() {
            this._layoutMainAxis();
            this._layoutCrossAxis();
          }

          /**
           * @pre mainAxisSize should exclude padding.
           */
          _layoutMainAxis() {
            this._layoutLines();
            this._fitMainAxisSizeToContents();
          }
          _layoutLines() {
            this._lineLayouter.layoutLines();
          }
          get _lines() {
            return this._lineLayouter.lines;
          }
          _fitMainAxisSizeToContents() {
            if (!this._resizingMainAxis) {
              if (this.isMainAxisFitToContents()) {
                this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
              }
            }
          }

          /**
           * @pre crossAxisSize should exclude padding.
           */
          _layoutCrossAxis() {
            var aligner = new ContentAligner(this);
            aligner.init();
            this._totalCrossAxisSize = aligner.totalCrossAxisSize;
            this._fitCrossAxisSizeToContents();
            aligner.align();
          }
          _fitCrossAxisSizeToContents() {
            if (!this._resizingCrossAxis) {
              if (this.isCrossAxisFitToContents()) {
                this.crossAxisSize = this._totalCrossAxisSize;
              }
            }
          }
          isWrapping() {
            return this._flexContainer.wrap;
          }
          isAxisFitToContents(horizontal) {
            if (this._horizontal === horizontal) {
              return this.isMainAxisFitToContents();
            } else {
              return this.isCrossAxisFitToContents();
            }
          }
          isMainAxisFitToContents() {
            return !this.isWrapping() && !this._hasFixedMainAxisBasis();
          }
          isCrossAxisFitToContents() {
            return !this._hasFixedCrossAxisBasis();
          }
          _hasFixedMainAxisBasis() {
            return !FlexUtils.isZeroAxisSize(this.item, this._horizontal);
          }
          _hasFixedCrossAxisBasis() {
            return !FlexUtils.isZeroAxisSize(this.item, !this._horizontal);
          }
          getAxisMinSize(horizontal) {
            if (this._horizontal === horizontal) {
              return this._getMainAxisMinSize();
            } else {
              return this._getCrossAxisMinSize();
            }
          }
          _getMainAxisMinSize() {
            return this._lineLayouter.mainAxisMinSize;
          }
          _getCrossAxisMinSize() {
            return this._lineLayouter.crossAxisMinSize;
          }
          resizeMainAxis(size) {
            if (this.mainAxisSize !== size) {
              if (this.recalc > 0) {
                this.performResizeMainAxis(size);
              } else {
                if (this._checkValidCacheMainAxisResize()) {
                  this.mainAxisSize = size;
                  this._fitCrossAxisSizeToContents();
                } else {
                  // Cache miss.
                  this.item.enableLocalRecalcFlag();
                  this.performResizeMainAxis(size);
                }
              }
            }
          }
          _checkValidCacheMainAxisResize(size) {
            var isFinalMainAxisSize = size === this.targetMainAxisSize;
            if (isFinalMainAxisSize) {
              return true;
            }
            var canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
            if (canIgnoreCacheMiss) {
              // Allow other main axis resizes and check if final resize matches the target main axis size
              //  (ItemCoordinatesUpdater).
              return true;
            }
            return false;
          }
          performResizeMainAxis(size) {
            var isShrinking = size < this.mainAxisSize;
            this._shrunk = isShrinking;
            this.mainAxisSize = size;
            this._resizingMainAxis = true;
            this._layoutAxes();
            this._resizingMainAxis = false;
          }
          resizeCrossAxis(size) {
            if (this.crossAxisSize !== size) {
              if (this.recalc > 0) {
                this.performResizeCrossAxis(size);
              } else {
                this.crossAxisSize = size;
              }
            }
          }
          performResizeCrossAxis(size) {
            this.crossAxisSize = size;
            this._resizingCrossAxis = true;
            this._layoutCrossAxis();
            this._resizingCrossAxis = false;
          }
          get targetMainAxisSize() {
            return this._horizontal ? this.item.target.w : this.item.target.h;
          }
          get targetCrossAxisSize() {
            return this._horizontal ? this.item.target.h : this.item.target.w;
          }
          getParentFlexContainer() {
            return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
          }
          _getHorizontalPadding() {
            return FlexUtils.getTotalPadding(this.item, true);
          }
          _getVerticalPadding() {
            return FlexUtils.getTotalPadding(this.item, false);
          }
          _getHorizontalPaddingOffset() {
            return FlexUtils.getPaddingOffset(this.item, true);
          }
          _getVerticalPaddingOffset() {
            return FlexUtils.getPaddingOffset(this.item, false);
          }
          _getMainAxisBasis() {
            return FlexUtils.getRelAxisSize(this.item, this._horizontal);
          }
          _getCrossAxisBasis() {
            return FlexUtils.getRelAxisSize(this.item, !this._horizontal);
          }
          get _horizontal() {
            return this._flexContainer._horizontal;
          }
          get _reverse() {
            return this._flexContainer._reverse;
          }
          get item() {
            return this._flexContainer.item;
          }
          get items() {
            return this.item.items;
          }
          get resizingMainAxis() {
            return this._resizingMainAxis;
          }
          get resizingCrossAxis() {
            return this._resizingCrossAxis;
          }
          get numberOfItems() {
            return this.items.length;
          }
          get mainAxisSize() {
            return FlexUtils.getAxisLayoutSize(this.item, this._horizontal);
          }
          get crossAxisSize() {
            return FlexUtils.getAxisLayoutSize(this.item, !this._horizontal);
          }
          set mainAxisSize(v) {
            FlexUtils.setAxisLayoutSize(this.item, this._horizontal, v);
          }
          set crossAxisSize(v) {
            FlexUtils.setAxisLayoutSize(this.item, !this._horizontal, v);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class FlexContainer {
          constructor(item) {
            this._item = item;
            this._layout = new FlexLayout(this);
            this._horizontal = true;
            this._reverse = false;
            this._wrap = false;
            this._alignItems = 'stretch';
            this._justifyContent = 'flex-start';
            this._alignContent = 'flex-start';
            this._paddingLeft = 0;
            this._paddingTop = 0;
            this._paddingRight = 0;
            this._paddingBottom = 0;
          }
          get item() {
            return this._item;
          }
          _changedDimensions() {
            this._item.changedDimensions();
          }
          _changedContents() {
            this._item.changedContents();
          }
          get direction() {
            return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
          }
          set direction(f) {
            if (this.direction === f) return;
            this._horizontal = f === 'row' || f === 'row-reverse';
            this._reverse = f === 'row-reverse' || f === 'column-reverse';
            this._changedContents();
          }
          set wrap(v) {
            this._wrap = v;
            this._changedContents();
          }
          get wrap() {
            return this._wrap;
          }
          get alignItems() {
            return this._alignItems;
          }
          set alignItems(v) {
            if (this._alignItems === v) return;
            if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
              throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
            }
            this._alignItems = v;
            this._changedContents();
          }
          get alignContent() {
            return this._alignContent;
          }
          set alignContent(v) {
            if (this._alignContent === v) return;
            if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
              throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
            }
            this._alignContent = v;
            this._changedContents();
          }
          get justifyContent() {
            return this._justifyContent;
          }
          set justifyContent(v) {
            if (this._justifyContent === v) return;
            if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
              throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
            }
            this._justifyContent = v;
            this._changedContents();
          }
          set padding(v) {
            this.paddingLeft = v;
            this.paddingTop = v;
            this.paddingRight = v;
            this.paddingBottom = v;
          }
          get padding() {
            return this.paddingLeft;
          }
          set paddingLeft(v) {
            this._paddingLeft = v;
            this._changedDimensions();
          }
          get paddingLeft() {
            return this._paddingLeft;
          }
          set paddingTop(v) {
            this._paddingTop = v;
            this._changedDimensions();
          }
          get paddingTop() {
            return this._paddingTop;
          }
          set paddingRight(v) {
            this._paddingRight = v;
            this._changedDimensions();
          }
          get paddingRight() {
            return this._paddingRight;
          }
          set paddingBottom(v) {
            this._paddingBottom = v;
            this._changedDimensions();
          }
          get paddingBottom() {
            return this._paddingBottom;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
        }
        FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
        FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
        FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class FlexItem {
          constructor(item) {
            this._ctr = null;
            this._item = item;
            this._grow = 0;
            this._shrink = FlexItem.SHRINK_AUTO;
            this._alignSelf = undefined;
            this._minWidth = 0;
            this._minHeight = 0;
            this._maxWidth = 0;
            this._maxHeight = 0;
            this._marginLeft = 0;
            this._marginTop = 0;
            this._marginRight = 0;
            this._marginBottom = 0;
          }
          get item() {
            return this._item;
          }
          get grow() {
            return this._grow;
          }
          set grow(v) {
            if (this._grow === v) return;
            this._grow = parseInt(v) || 0;
            this._changed();
          }
          get shrink() {
            if (this._shrink === FlexItem.SHRINK_AUTO) {
              return this._getDefaultShrink();
            }
            return this._shrink;
          }
          _getDefaultShrink() {
            if (this.item.isFlexEnabled()) {
              return 1;
            } else {
              // All non-flex containers are absolutely positioned items with fixed dimensions, and by default not shrinkable.
              return 0;
            }
          }
          set shrink(v) {
            if (this._shrink === v) return;
            this._shrink = parseInt(v) || 0;
            this._changed();
          }
          get alignSelf() {
            return this._alignSelf;
          }
          set alignSelf(v) {
            if (this._alignSelf === v) return;
            if (v === undefined) {
              this._alignSelf = undefined;
            } else {
              if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
                throw new Error("Unknown alignSelf, options: " + FlexContainer.ALIGN_ITEMS.join(","));
              }
              this._alignSelf = v;
            }
            this._changed();
          }
          get minWidth() {
            return this._minWidth;
          }
          set minWidth(v) {
            this._minWidth = Math.max(0, v);
            this._item.changedDimensions(true, false);
          }
          get minHeight() {
            return this._minHeight;
          }
          set minHeight(v) {
            this._minHeight = Math.max(0, v);
            this._item.changedDimensions(false, true);
          }
          get maxWidth() {
            return this._maxWidth;
          }
          set maxWidth(v) {
            this._maxWidth = Math.max(0, v);
            this._item.changedDimensions(true, false);
          }
          get maxHeight() {
            return this._maxHeight;
          }
          set maxHeight(v) {
            this._maxHeight = Math.max(0, v);
            this._item.changedDimensions(false, true);
          }

          /**
           * @note margins behave slightly different than in HTML with regard to shrinking.
           * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
           */
          set margin(v) {
            this.marginLeft = v;
            this.marginTop = v;
            this.marginRight = v;
            this.marginBottom = v;
          }
          get margin() {
            return this.marginLeft;
          }
          set marginLeft(v) {
            this._marginLeft = v;
            this._changed();
          }
          get marginLeft() {
            return this._marginLeft;
          }
          set marginTop(v) {
            this._marginTop = v;
            this._changed();
          }
          get marginTop() {
            return this._marginTop;
          }
          set marginRight(v) {
            this._marginRight = v;
            this._changed();
          }
          get marginRight() {
            return this._marginRight;
          }
          set marginBottom(v) {
            this._marginBottom = v;
            this._changed();
          }
          get marginBottom() {
            return this._marginBottom;
          }
          _changed() {
            if (this.ctr) this.ctr._changedContents();
          }
          set ctr(v) {
            this._ctr = v;
          }
          get ctr() {
            return this._ctr;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
          _resetLayoutSize() {
            this._resetHorizontalAxisLayoutSize();
            this._resetVerticalAxisLayoutSize();
          }
          _resetCrossAxisLayoutSize() {
            if (this.ctr._horizontal) {
              this._resetVerticalAxisLayoutSize();
            } else {
              this._resetHorizontalAxisLayoutSize();
            }
          }
          _resetHorizontalAxisLayoutSize() {
            var w = FlexUtils.getRelAxisSize(this.item, true);
            if (this._minWidth) {
              w = Math.max(this._minWidth, w);
            }
            if (this._maxWidth) {
              w = Math.min(this._maxWidth, w);
            }
            FlexUtils.setAxisLayoutSize(this.item, true, w);
          }
          _resetVerticalAxisLayoutSize() {
            var h = FlexUtils.getRelAxisSize(this.item, false);
            if (this._minHeight) {
              h = Math.max(this._minHeight, h);
            }
            if (this._maxHeight) {
              h = Math.min(this._maxHeight, h);
            }
            FlexUtils.setAxisLayoutSize(this.item, false, h);
          }
          _getCrossAxisMinSizeSetting() {
            return this._getMinSizeSetting(!this.ctr._horizontal);
          }
          _getCrossAxisMaxSizeSetting() {
            return this._getMaxSizeSetting(!this.ctr._horizontal);
          }
          _getMainAxisMaxSizeSetting() {
            return this._getMaxSizeSetting(this.ctr._horizontal);
          }
          _getMinSizeSetting(horizontal) {
            if (horizontal) {
              return this._minWidth;
            } else {
              return this._minHeight;
            }
          }
          _getMaxSizeSetting(horizontal) {
            if (horizontal) {
              return this._maxWidth;
            } else {
              return this._maxHeight;
            }
          }
          _getMainAxisMinSize() {
            return FlexUtils.getAxisMinSize(this.item, this.ctr._horizontal);
          }
          _getCrossAxisMinSize() {
            return FlexUtils.getAxisMinSize(this.item, !this.ctr._horizontal);
          }
          _getMainAxisLayoutSize() {
            return FlexUtils.getAxisLayoutSize(this.item, this.ctr._horizontal);
          }
          _getMainAxisLayoutPos() {
            return FlexUtils.getAxisLayoutPos(this.item, this.ctr._horizontal);
          }
          _setMainAxisLayoutPos(pos) {
            return FlexUtils.setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
          }
          _setCrossAxisLayoutPos(pos) {
            return FlexUtils.setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
          }
          _getCrossAxisLayoutSize() {
            return FlexUtils.getAxisLayoutSize(this.item, !this.ctr._horizontal);
          }
          _resizeCrossAxis(size) {
            return FlexUtils.resizeAxis(this.item, !this.ctr._horizontal, size);
          }
          _resizeMainAxis(size) {
            return FlexUtils.resizeAxis(this.item, this.ctr._horizontal, size);
          }
          _getMainAxisPadding() {
            return FlexUtils.getTotalPadding(this.item, this.ctr._horizontal);
          }
          _getCrossAxisPadding() {
            return FlexUtils.getTotalPadding(this.item, !this.ctr._horizontal);
          }
          _getMainAxisMargin() {
            return FlexUtils.getTotalMargin(this.item, this.ctr._horizontal);
          }
          _getCrossAxisMargin() {
            return FlexUtils.getTotalMargin(this.item, !this.ctr._horizontal);
          }
          _getHorizontalMarginOffset() {
            return FlexUtils.getMarginOffset(this.item, true);
          }
          _getVerticalMarginOffset() {
            return FlexUtils.getMarginOffset(this.item, false);
          }
          _getMainAxisMinSizeWithPaddingAndMargin() {
            return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
          }
          _getCrossAxisMinSizeWithPaddingAndMargin() {
            return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
          }
          _getMainAxisLayoutSizeWithPaddingAndMargin() {
            return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
          }
          _getCrossAxisLayoutSizeWithPaddingAndMargin() {
            return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
          }
          _hasFixedCrossAxisSize() {
            return !FlexUtils.isZeroAxisSize(this.item, !this.ctr._horizontal);
          }
          _hasRelCrossAxisSize() {
            return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
          }
        }
        FlexItem.SHRINK_AUTO = -1;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * This is the connection between the render tree with the layout tree of this flex container/item.
         */
        class FlexTarget {
          constructor(target) {
            this._target = target;

            /**
             * Possible values (only in case of container):
             * bit 0: has changed or contains items with changes
             * bit 1: width changed
             * bit 2: height changed
             */
            this._recalc = 0;
            this._enabled = false;
            this.x = 0;
            this.y = 0;
            this.w = 0;
            this.h = 0;
            this._originalX = 0;
            this._originalY = 0;
            this._originalWidth = 0;
            this._originalHeight = 0;
            this._flex = null;
            this._flexItem = null;
            this._flexItemDisabled = false;
            this._items = null;
          }
          get flexLayout() {
            return this.flex ? this.flex._layout : null;
          }
          layoutFlexTree() {
            if (this.isFlexEnabled() && this.isChanged()) {
              this.flexLayout.layoutTree();
            }
          }
          get target() {
            return this._target;
          }
          get flex() {
            return this._flex;
          }
          set flex(v) {
            if (!v) {
              if (this.isFlexEnabled()) {
                this._disableFlex();
              }
            } else {
              if (!this.isFlexEnabled()) {
                this._enableFlex();
              }
              this._flex.patch(v);
            }
          }
          get flexItem() {
            if (this._flexItemDisabled) {
              return false;
            }
            this._ensureFlexItem();
            return this._flexItem;
          }
          set flexItem(v) {
            if (v === false) {
              if (!this._flexItemDisabled) {
                var parent = this.flexParent;
                this._flexItemDisabled = true;
                this._checkEnabled();
                if (parent) {
                  parent._clearFlexItemsCache();
                  parent.changedContents();
                }
              }
            } else {
              this._ensureFlexItem();
              this._flexItem.patch(v);
              if (this._flexItemDisabled) {
                this._flexItemDisabled = false;
                this._checkEnabled();
                var _parent = this.flexParent;
                if (_parent) {
                  _parent._clearFlexItemsCache();
                  _parent.changedContents();
                }
              }
            }
          }
          _enableFlex() {
            this._flex = new FlexContainer(this);
            this._checkEnabled();
            this.changedDimensions();
            this._enableChildrenAsFlexItems();
          }
          _disableFlex() {
            this.changedDimensions();
            this._flex = null;
            this._checkEnabled();
            this._disableChildrenAsFlexItems();
          }
          _enableChildrenAsFlexItems() {
            var children = this._target._children;
            if (children) {
              for (var i = 0, n = children.length; i < n; i++) {
                var child = children[i];
                child.layout._enableFlexItem();
              }
            }
          }
          _disableChildrenAsFlexItems() {
            var children = this._target._children;
            if (children) {
              for (var i = 0, n = children.length; i < n; i++) {
                var child = children[i];
                child.layout._disableFlexItem();
              }
            }
          }
          _enableFlexItem() {
            this._ensureFlexItem();
            var flexParent = this._target._parent._layout;
            this._flexItem.ctr = flexParent._flex;
            flexParent.changedContents();
            this._checkEnabled();
          }
          _disableFlexItem() {
            if (this._flexItem) {
              this._flexItem.ctr = null;
            }

            // We keep the flexItem object because it may contain custom settings.
            this._checkEnabled();

            // Offsets have been changed. We can't recover them, so we'll just clear them instead.
            this._resetOffsets();
          }
          _resetOffsets() {
            this.x = 0;
            this.y = 0;
          }
          _ensureFlexItem() {
            if (!this._flexItem) {
              this._flexItem = new FlexItem(this);
            }
          }
          _checkEnabled() {
            var enabled = this.isEnabled();
            if (this._enabled !== enabled) {
              if (enabled) {
                this._enable();
              } else {
                this._disable();
              }
              this._enabled = enabled;
            }
          }
          _enable() {
            this._setupTargetForFlex();
            this._target.enableFlexLayout();
          }
          _disable() {
            this._restoreTargetToNonFlex();
            this._target.disableFlexLayout();
          }
          isEnabled() {
            return this.isFlexEnabled() || this.isFlexItemEnabled();
          }
          isFlexEnabled() {
            return this._flex !== null;
          }
          isFlexItemEnabled() {
            return this.flexParent !== null;
          }
          _restoreTargetToNonFlex() {
            var target = this._target;
            target.x = this._originalX;
            target.y = this._originalY;
            target.setDimensions(this._originalWidth, this._originalHeight);
          }
          _setupTargetForFlex() {
            var target = this._target;
            this._originalX = target._x;
            this._originalY = target._y;
            this._originalWidth = target._w;
            this._originalHeight = target._h;
          }
          setParent(from, to) {
            if (from && from.isFlexContainer()) {
              from._layout._changedChildren();
            }
            if (to && to.isFlexContainer()) {
              this._enableFlexItem();
              to._layout._changedChildren();
            }
            this._checkEnabled();
          }
          get flexParent() {
            if (this._flexItemDisabled) {
              return null;
            }
            var parent = this._target._parent;
            if (parent && parent.isFlexContainer()) {
              return parent._layout;
            }
            return null;
          }
          setVisible(v) {
            var parent = this.flexParent;
            if (parent) {
              parent._changedChildren();
            }
          }
          get items() {
            if (!this._items) {
              this._items = this._getFlexItems();
            }
            return this._items;
          }
          _getFlexItems() {
            var items = [];
            var children = this._target._children;
            if (children) {
              for (var i = 0, n = children.length; i < n; i++) {
                var item = children[i];
                if (item.visible) {
                  if (item.isFlexItem()) {
                    items.push(item.layout);
                  }
                }
              }
            }
            return items;
          }
          _changedChildren() {
            this._clearFlexItemsCache();
            this.changedContents();
          }
          _clearFlexItemsCache() {
            this._items = null;
          }
          setLayout(x, y, w, h) {
            var originalX = this._originalX;
            var originalY = this._originalY;
            if (this.funcX) {
              originalX = this.funcX(FlexUtils.getParentAxisSizeWithPadding(this, true));
            }
            if (this.funcY) {
              originalY = this.funcY(FlexUtils.getParentAxisSizeWithPadding(this, false));
            }
            if (this.isFlexItemEnabled()) {
              this.target.setLayout(x + originalX, y + originalY, w, h);
            } else {
              // Reuse the x,y 'settings'.
              this.target.setLayout(originalX, originalY, w, h);
            }
          }
          changedDimensions() {
            var changeWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var changeHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            this._updateRecalc(changeWidth, changeHeight);
          }
          changedContents() {
            this._updateRecalc();
          }
          forceLayout() {
            this._updateRecalc();
          }
          isChanged() {
            return this._recalc > 0;
          }
          _updateRecalc() {
            var changeExternalWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var changeExternalHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (this.isFlexEnabled()) {
              var layout = this._flex._layout;

              // When something internal changes, it can have effect on the external dimensions.
              changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
              changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
            }
            var recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
            var newRecalcFlags = this.getNewRecalcFlags(recalc);
            this._recalc |= recalc;
            if (newRecalcFlags > 1) {
              if (this.flexParent) {
                this.flexParent._updateRecalcBottomUp(recalc);
              } else {
                this._target.triggerLayout();
              }
            } else {
              this._target.triggerLayout();
            }
          }
          getNewRecalcFlags(flags) {
            return 7 - this._recalc & flags;
          }
          _updateRecalcBottomUp(childRecalc) {
            var newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
            var newRecalcFlags = this.getNewRecalcFlags(newRecalc);
            this._recalc |= newRecalc;
            if (newRecalcFlags > 1) {
              var flexParent = this.flexParent;
              if (flexParent) {
                flexParent._updateRecalcBottomUp(newRecalc);
              } else {
                this._target.triggerLayout();
              }
            } else {
              this._target.triggerLayout();
            }
          }
          _getRecalcFromChangedChildRecalc(childRecalc) {
            var layout = this._flex._layout;
            var mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
            var crossAxisRecalcFlag = layout._horizontal ? 2 : 1;
            var crossAxisDimensionsChangedInChild = childRecalc & crossAxisRecalcFlag;
            if (!crossAxisDimensionsChangedInChild) {
              var mainAxisDimensionsChangedInChild = childRecalc & mainAxisRecalcFlag;
              if (mainAxisDimensionsChangedInChild) {
                var mainAxisIsWrapping = layout.isWrapping();
                if (mainAxisIsWrapping) {
                  var crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                  if (crossAxisIsFitToContents) {
                    // Special case: due to wrapping, the cross axis size may be changed.
                    childRecalc += crossAxisRecalcFlag;
                  }
                }
              }
            }
            var isWidthDynamic = layout.isAxisFitToContents(true);
            var isHeightDynamic = layout.isAxisFitToContents(false);
            if (layout.shrunk) {
              // If during previous layout this container was 'shrunk', any changes may change the 'min axis size' of the
              // contents, leading to a different axis size on this container even when it was not 'fit to contents'.
              if (layout._horizontal) {
                isWidthDynamic = true;
              } else {
                isHeightDynamic = true;
              }
            }
            var localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);
            var combinedRecalc = childRecalc & localRecalc;
            return combinedRecalc;
          }
          get recalc() {
            return this._recalc;
          }
          clearRecalcFlag() {
            this._recalc = 0;
          }
          enableLocalRecalcFlag() {
            this._recalc = 1;
          }
          get originalX() {
            return this._originalX;
          }
          setOriginalXWithoutUpdatingLayout(v) {
            this._originalX = v;
          }
          get originalY() {
            return this._originalY;
          }
          setOriginalYWithoutUpdatingLayout(v) {
            this._originalY = v;
          }
          get originalWidth() {
            return this._originalWidth;
          }
          set originalWidth(v) {
            if (this._originalWidth !== v) {
              this._originalWidth = v;
              this.changedDimensions(true, false);
            }
          }
          get originalHeight() {
            return this._originalHeight;
          }
          set originalHeight(v) {
            if (this._originalHeight !== v) {
              this._originalHeight = v;
              this.changedDimensions(false, true);
            }
          }
          get funcX() {
            return this._target.funcX;
          }
          get funcY() {
            return this._target.funcY;
          }
          get funcW() {
            return this._target.funcW;
          }
          get funcH() {
            return this._target.funcH;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TextureSource {
          constructor(manager) {
            var loader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            this.id = TextureSource.id++;
            this.manager = manager;
            this.stage = manager.stage;

            /**
             * All enabled textures (textures that are used by visible elements).
             * @type {Set<Texture>}
             */
            this.textures = new Set();

            /**
             * The number of active textures (textures that have at least one active element).
             * @type {number}
             * @private
             */
            this._activeTextureCount = 0;

            /**
             * The factory for the source of this texture.
             * @type {Function}
             */
            this.loader = loader;

            /**
             * Identifier for reuse.
             * @type {String}
             */
            this.lookupId = null;

            /**
             * If set, this.is called when the texture source is no longer displayed (this.components.size becomes 0).
             * @type {Function}
             */
            this._cancelCb = null;

            /**
             * Loading since timestamp in millis.
             * @type {number}
             */
            this.loadingSince = 0;
            this.w = 0;
            this.h = 0;
            this._nativeTexture = null;

            /**
             * If true, then this.texture source is never freed from memory during garbage collection.
             * @type {boolean}
             */
            this.permanent = false;

            /**
             * Sub-object with texture-specific rendering information.
             * For images, contains the src property, for texts, contains handy rendering information.
             * @type {Object}
             */
            this.renderInfo = null;

            /**
             * Generated for 'renderToTexture'.
             * @type {boolean}
             * @private
             */
            this._isResultTexture = !this.loader;

            /**
             * Contains the load error, if the texture source could previously not be loaded.
             * @type {object}
             * @private
             */
            this._loadError = null;

            /**
             *  Hold a reference to the javascript variable which contains the texture, this is not required for WebGL in WebBrowsers but is required for Spark runtime.
             * @type {object}
             * @private
             */
            this._imageRef = null;

            /**
             * Track whether or not there is an alpha channel in this source
             * @type {boolean}
             * @private
             */
            this._hasAlpha = false;
          }
          get hasAlpha() {
            return this._hasAlpha;
          }
          get loadError() {
            return this._loadError;
          }
          addTexture(v) {
            if (!this.textures.has(v)) {
              this.textures.add(v);
            }
          }
          removeTexture(v) {
            this.textures.delete(v);
          }
          incActiveTextureCount() {
            this._activeTextureCount++;
            if (this._activeTextureCount === 1) {
              this.becomesUsed();
            }
          }
          decActiveTextureCount() {
            this._activeTextureCount--;
            if (this._activeTextureCount === 0) {
              this.becomesUnused();
            }
          }
          get isResultTexture() {
            return this._isResultTexture;
          }
          set isResultTexture(v) {
            this._isResultTexture = v;
          }
          forEachEnabledElement(cb) {
            this.textures.forEach(texture => {
              texture.elements.forEach(cb);
            });
          }
          hasEnabledElements() {
            return this.textures.size > 0;
          }
          forEachActiveElement(cb) {
            this.textures.forEach(texture => {
              texture.elements.forEach(element => {
                if (element.active) {
                  cb(element);
                }
              });
            });
          }
          getRenderWidth() {
            return this.w;
          }
          getRenderHeight() {
            return this.h;
          }
          allowCleanup() {
            return !this.permanent && !this.isUsed();
          }
          becomesUsed() {
            // Even while the texture is being loaded, make sure it is on the lookup map so that others can reuse it.
            this.load();
          }
          becomesUnused() {
            this.cancel();
          }
          cancel() {
            if (this.isLoading()) {
              if (this._cancelCb) {
                this._cancelCb(this);

                // Clear callback to avoid memory leaks.
                this._cancelCb = null;
              }
              this.loadingSince = 0;
            }
          }
          isLoaded() {
            return !!this._nativeTexture;
          }
          isLoading() {
            return this.loadingSince > 0;
          }
          isError() {
            return !!this._loadError;
          }
          reload() {
            this.free();
            if (this.isUsed()) {
              this.load();
            }
          }
          load() {
            var forceSync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            // From the moment of loading (when a texture source becomes used by active elements)
            if (this.isResultTexture) {
              // Element result texture source, for which the loading is managed by the core.
              return;
            }
            if (!this._nativeTexture && !this.isLoading()) {
              this.loadingSince = new Date().getTime();
              this._cancelCb = this.loader((err, options) => {
                // Ignore loads that come in after a cancel.
                if (this.isLoading()) {
                  // Clear callback to avoid memory leaks.
                  this._cancelCb = null;
                  if (this.manager.stage.destroyed) {
                    // Ignore async load when stage is destroyed.
                    return;
                  }
                  if (err) {
                    // Emit txError.
                    this.onError(err);
                  } else if (options && options.source) {
                    if (!this.stage.isUpdatingFrame() && !forceSync && options.throttle !== false) {
                      var textureThrottler = this.stage.textureThrottler;
                      this._cancelCb = textureThrottler.genericCancelCb;
                      textureThrottler.add(this, options);
                    } else {
                      this.processLoadedSource(options);
                    }
                  }
                }
              }, this);
            }
          }
          processLoadedSource(options) {
            this.loadingSince = 0;
            this.setSource(options);
          }
          setSource(options) {
            var source = options.source;
            this._hasAlpha = options ? options.hasAlpha || false : false;
            this.w = source.width || options && options.w || 0;
            this.h = source.height || options && options.h || 0;
            if (options && options.renderInfo) {
              // Assign to id in cache so that it can be reused.
              this.renderInfo = options.renderInfo;
            }
            this.permanent = !!options.permanent;
            if (options && options.imageRef) this._imageRef = options.imageRef;
            if (options && options.flipTextureY) {
              this._flipTextureY = options.flipTextureY;
            } else {
              this._flipTextureY = false;
            }
            if (this._isNativeTexture(source)) {
              // Texture managed by caller.
              this._nativeTexture = source;
              this.w = this.w || source.w;
              this.h = this.h || source.h;

              // WebGLTexture objects are by default;
              this.permanent = options.hasOwnProperty('permanent') ? options.permanent : true;
            } else {
              this.manager.uploadTextureSource(this, options);
            }

            // Must be cleared when reload is succesful.
            this._loadError = null;
            this.onLoad();
          }
          isUsed() {
            return this._activeTextureCount > 0;
          }
          onLoad() {
            if (this.isUsed()) {
              this.textures.forEach(texture => {
                texture.onLoad();
              });
            }
          }
          forceRenderUpdate() {
            // Userland should call this method after changing the nativeTexture manually outside of the framework
            //  (using tex[Sub]Image2d for example).

            if (this._nativeTexture) {
              // Change 'update' flag. This is currently not used by the framework but is handy in userland.
              this._nativeTexture.update = this.stage.frameCounter;
            }
            this.forEachActiveElement(function (element) {
              element.forceRenderUpdate();
            });
          }
          forceUpdateRenderCoords() {
            this.forEachActiveElement(function (element) {
              element._updateTextureCoords();
            });
          }
          get nativeTexture() {
            return this._nativeTexture;
          }
          clearNativeTexture() {
            this._nativeTexture = null;
            //also clear the reference to the texture variable.
            this._imageRef = null;
          }

          /**
           * Used for result textures.
           */
          replaceNativeTexture(newNativeTexture, w, h) {
            var prevNativeTexture = this._nativeTexture;
            // Loaded by core.
            this._nativeTexture = newNativeTexture;
            this.w = w;
            this.h = h;
            if (!prevNativeTexture && this._nativeTexture) {
              this.forEachActiveElement(element => element.onTextureSourceLoaded());
            }
            if (!this._nativeTexture) {
              this.forEachActiveElement(element => element._setDisplayedTexture(null));
            }

            // Dimensions must be updated also on enabled elements, as it may force it to go within bounds.
            this.forEachEnabledElement(element => element._updateDimensions());

            // Notice that the sprite map must never contain render textures.
          }

          onError(e) {
            this._loadError = e;
            this.loadingSince = 0;
            console.error('[Lightning] texture load error', e, this.lookupId);
            this.forEachActiveElement(element => element.onTextureSourceLoadError(e));
          }
          free() {
            if (this.isLoaded()) {
              this.manager.freeTextureSource(this);
            }
          }
          _isNativeTexture(source) {
            if (Utils$2.isNode) {
              return source.constructor.name === "WebGLTexture";
            }
            if ('WebGLTexture' in window) {
              return source instanceof WebGLTexture;
            }
            return false;
          }
        }
        TextureSource.prototype.isTextureSource = true;
        TextureSource.id = 1;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ElementTexturizer {
          constructor(elementCore) {
            this._element = elementCore.element;
            this._core = elementCore;
            this.ctx = this._core.ctx;
            this._enabled = false;
            this.lazy = false;
            this._colorize = false;
            this._renderTexture = null;
            this._renderTextureReused = false;
            this._resultTextureSource = null;
            this._renderOffscreen = false;
            this.empty = false;
          }
          get enabled() {
            return this._enabled;
          }
          set enabled(v) {
            this._enabled = v;
            this._core.updateRenderToTextureEnabled();
          }
          get renderOffscreen() {
            return this._renderOffscreen;
          }
          set renderOffscreen(v) {
            this._renderOffscreen = v;
            this._core.setHasRenderUpdates(1);

            // This enforces rechecking the 'within bounds'.
            this._core._setRecalc(6);
          }
          get colorize() {
            return this._colorize;
          }
          set colorize(v) {
            if (this._colorize !== v) {
              this._colorize = v;

              // Only affects the finally drawn quad.
              this._core.setHasRenderUpdates(1);
            }
          }
          _getTextureSource() {
            if (!this._resultTextureSource) {
              this._resultTextureSource = new TextureSource(this._element.stage.textureManager);
              this.updateResultTexture();
            }
            return this._resultTextureSource;
          }
          hasResultTexture() {
            return !!this._resultTextureSource;
          }
          resultTextureInUse() {
            return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
          }
          updateResultTexture() {
            var resultTexture = this.getResultTexture();
            if (this._resultTextureSource) {
              if (this._resultTextureSource.nativeTexture !== resultTexture) {
                var w = resultTexture ? resultTexture.w : 0;
                var h = resultTexture ? resultTexture.h : 0;
                this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
              }

              // Texture will be updated: all elements using the source need to be updated as well.
              this._resultTextureSource.forEachEnabledElement(element => {
                element._updateDimensions();
                element.core.setHasRenderUpdates(3);
              });
            }
          }
          mustRenderToTexture() {
            // Check if we must really render as texture.
            if (this._enabled && !this.lazy) {
              return true;
            } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
              // Static-only: if renderToTexture did not need to update during last drawn frame, generate it as a cache.
              return true;
            }
            return false;
          }
          deactivate() {
            this.release();
          }
          get renderTextureReused() {
            return this._renderTextureReused;
          }
          release() {
            this.releaseRenderTexture();
          }
          releaseRenderTexture() {
            if (this._renderTexture) {
              if (!this._renderTextureReused) {
                this.ctx.releaseRenderTexture(this._renderTexture);
              }
              this._renderTexture = null;
              this._renderTextureReused = false;
              this.updateResultTexture();
            }
          }

          // Reuses the specified texture as the render texture (in ancestor).
          reuseTextureAsRenderTexture(nativeTexture) {
            if (this._renderTexture !== nativeTexture) {
              this.releaseRenderTexture();
              this._renderTexture = nativeTexture;
              this._renderTextureReused = true;
            }
          }
          hasRenderTexture() {
            return !!this._renderTexture;
          }
          getRenderTexture() {
            if (!this._renderTexture) {
              this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
              this._renderTextureReused = false;
            }
            return this._renderTexture;
          }
          getResultTexture() {
            return this._renderTexture;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ElementCore {
          constructor(element) {
            this._element = element;
            this.ctx = element.stage.ctx;

            // The memory layout of the internal variables is affected by their position in the constructor.
            // It boosts performance to order them by usage of cpu-heavy functions (renderSimple and update).

            this._recalc = 0;
            this._parent = null;
            this._onUpdate = null;
            this._pRecalc = 0;
            this._worldContext = new ElementCoreContext();
            this._hasUpdates = false;
            this._localAlpha = 1;
            this._onAfterCalcs = null;
            this._onAfterUpdate = null;

            // All local translation/transform updates: directly propagated from x/y/w/h/scale/whatever.
            this._localPx = 0;
            this._localPy = 0;
            this._localTa = 1;
            this._localTb = 0;
            this._localTc = 0;
            this._localTd = 1;
            this._isComplex = false;
            this._dimsUnknown = false;
            this._clipping = false;

            // Used by both update and render.
            this._zSort = false;
            this._outOfBounds = 0;

            /**
             * The texture source to be displayed.
             * @type {TextureSource}
             */
            this._displayedTextureSource = null;
            this._zContextUsage = 0;
            this._children = null;
            this._hasRenderUpdates = 0;
            this._zIndexedChildren = null;
            this._renderContext = this._worldContext;
            this.renderState = this.ctx.renderState;
            this._scissor = null;

            // The ancestor ElementCore that owns the inherited shader. Null if none is active (default shader).
            this._shaderOwner = null;
            this._updateTreeOrder = 0;
            this._colorUl = this._colorUr = this._colorBl = this._colorBr = 0xFFFFFFFF;
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;
            this._optFlags = 0;
            this._funcX = null;
            this._funcY = null;
            this._funcW = null;
            this._funcH = null;
            this._scaleX = 1;
            this._scaleY = 1;
            this._pivotX = 0.5;
            this._pivotY = 0.5;
            this._mountX = 0;
            this._mountY = 0;
            this._rotation = 0;
            this._alpha = 1;
            this._visible = true;
            this._ulx = 0;
            this._uly = 0;
            this._brx = 1;
            this._bry = 1;
            this._zIndex = 0;
            this._forceZIndexContext = false;
            this._zParent = null;
            this._isRoot = false;

            /**
             * Iff true, during zSort, this element should be 're-sorted' because either:
             * - zIndex did chang
             * - zParent did change
             * - element was moved in the render tree
             * @type {boolean}
             */
            this._zIndexResort = false;
            this._shader = null;

            // Element is rendered on another texture.
            this._renderToTextureEnabled = false;
            this._texturizer = null;
            this._useRenderToTexture = false;
            this._boundsMargin = null;
            this._recBoundsMargin = null;
            this._withinBoundsMargin = false;
            this._viewport = null;
            this._clipbox = true;
            this.render = this._renderSimple;
            this._layout = null;
          }
          get offsetX() {
            if (this._funcX) {
              return this._funcX;
            } else {
              if (this.hasFlexLayout()) {
                return this._layout.originalX;
              } else {
                return this._x;
              }
            }
          }
          set offsetX(v) {
            if (Utils$2.isFunction(v)) {
              this.funcX = v;
            } else {
              this._disableFuncX();
              if (this.hasFlexLayout()) {
                this.x += v - this._layout.originalX;
                this._layout.setOriginalXWithoutUpdatingLayout(v);
              } else {
                this.x = v;
              }
            }
          }
          get x() {
            return this._x;
          }
          set x(v) {
            if (v !== this._x) {
              this._updateLocalTranslateDelta(v - this._x, 0);
              this._x = v;
            }
          }
          get funcX() {
            return this._optFlags & 1 ? this._funcX : null;
          }
          set funcX(v) {
            if (this._funcX !== v) {
              this._optFlags |= 1;
              this._funcX = v;
              if (this.hasFlexLayout()) {
                this._layout.setOriginalXWithoutUpdatingLayout(0);
                this.layout.forceLayout();
              } else {
                this._x = 0;
                this._triggerRecalcTranslate();
              }
            }
          }
          _disableFuncX() {
            this._optFlags = this._optFlags & 0xFFFF - 1;
            this._funcX = null;
          }
          get offsetY() {
            if (this._funcY) {
              return this._funcY;
            } else {
              if (this.hasFlexLayout()) {
                return this._layout.originalY;
              } else {
                return this._y;
              }
            }
          }
          set offsetY(v) {
            if (Utils$2.isFunction(v)) {
              this.funcY = v;
            } else {
              this._disableFuncY();
              if (this.hasFlexLayout()) {
                this.y += v - this._layout.originalY;
                this._layout.setOriginalYWithoutUpdatingLayout(v);
              } else {
                this.y = v;
              }
            }
          }
          get y() {
            return this._y;
          }
          set y(v) {
            if (v !== this._y) {
              this._updateLocalTranslateDelta(0, v - this._y);
              this._y = v;
            }
          }
          get funcY() {
            return this._optFlags & 2 ? this._funcY : null;
          }
          set funcY(v) {
            if (this._funcY !== v) {
              this._optFlags |= 2;
              this._funcY = v;
              if (this.hasFlexLayout()) {
                this._layout.setOriginalYWithoutUpdatingLayout(0);
                this.layout.forceLayout();
              } else {
                this._y = 0;
                this._triggerRecalcTranslate();
              }
            }
          }
          _disableFuncY() {
            this._optFlags = this._optFlags & 0xFFFF - 2;
            this._funcY = null;
          }
          get funcW() {
            return this._optFlags & 4 ? this._funcW : null;
          }
          set funcW(v) {
            if (this._funcW !== v) {
              this._optFlags |= 4;
              this._funcW = v;
              if (this.hasFlexLayout()) {
                this._layout._originalWidth = 0;
                this.layout.changedDimensions(true, false);
              } else {
                this._w = 0;
                this._triggerRecalcTranslate();
              }
            }
          }
          disableFuncW() {
            this._optFlags = this._optFlags & 0xFFFF - 4;
            this._funcW = null;
          }
          get funcH() {
            return this._optFlags & 8 ? this._funcH : null;
          }
          set funcH(v) {
            if (this._funcH !== v) {
              this._optFlags |= 8;
              this._funcH = v;
              if (this.hasFlexLayout()) {
                this._layout._originalHeight = 0;
                this.layout.changedDimensions(false, true);
              } else {
                this._h = 0;
                this._triggerRecalcTranslate();
              }
            }
          }
          disableFuncH() {
            this._optFlags = this._optFlags & 0xFFFF - 8;
            this._funcH = null;
          }
          get w() {
            return this._w;
          }
          getRenderWidth() {
            if (this.hasFlexLayout()) {
              return this._layout.originalWidth;
            } else {
              return this._w;
            }
          }
          get h() {
            return this._h;
          }
          getRenderHeight() {
            if (this.hasFlexLayout()) {
              return this._layout.originalHeight;
            } else {
              return this._h;
            }
          }
          get scaleX() {
            return this._scaleX;
          }
          set scaleX(v) {
            if (this._scaleX !== v) {
              this._scaleX = v;
              this._updateLocalTransform();
            }
          }
          get scaleY() {
            return this._scaleY;
          }
          set scaleY(v) {
            if (this._scaleY !== v) {
              this._scaleY = v;
              this._updateLocalTransform();
            }
          }
          get scale() {
            return this.scaleX;
          }
          set scale(v) {
            if (this._scaleX !== v || this._scaleY !== v) {
              this._scaleX = v;
              this._scaleY = v;
              this._updateLocalTransform();
            }
          }
          get pivotX() {
            return this._pivotX;
          }
          set pivotX(v) {
            if (this._pivotX !== v) {
              this._pivotX = v;
              this._updateLocalTranslate();
            }
          }
          get pivotY() {
            return this._pivotY;
          }
          set pivotY(v) {
            if (this._pivotY !== v) {
              this._pivotY = v;
              this._updateLocalTranslate();
            }
          }
          get pivot() {
            return this._pivotX;
          }
          set pivot(v) {
            if (this._pivotX !== v || this._pivotY !== v) {
              this._pivotX = v;
              this._pivotY = v;
              this._updateLocalTranslate();
            }
          }
          get mountX() {
            return this._mountX;
          }
          set mountX(v) {
            if (this._mountX !== v) {
              this._mountX = v;
              this._updateLocalTranslate();
            }
          }
          get mountY() {
            return this._mountY;
          }
          set mountY(v) {
            if (this._mountY !== v) {
              this._mountY = v;
              this._updateLocalTranslate();
            }
          }
          get mount() {
            return this._mountX;
          }
          set mount(v) {
            if (this._mountX !== v || this._mountY !== v) {
              this._mountX = v;
              this._mountY = v;
              this._updateLocalTranslate();
            }
          }
          get rotation() {
            return this._rotation;
          }
          set rotation(v) {
            if (this._rotation !== v) {
              this._rotation = v;
              this._updateLocalTransform();
            }
          }
          get alpha() {
            return this._alpha;
          }
          set alpha(v) {
            // Account for rounding errors.
            v = v > 1 ? 1 : v < 1e-14 ? 0 : v;
            if (this._alpha !== v) {
              var prev = this._alpha;
              this._alpha = v;
              this._updateLocalAlpha();
              if (prev === 0 !== (v === 0)) {
                this._element._updateEnabledFlag();
              }
            }
          }
          get visible() {
            return this._visible;
          }
          set visible(v) {
            if (this._visible !== v) {
              this._visible = v;
              this._updateLocalAlpha();
              this._element._updateEnabledFlag();
              if (this.hasFlexLayout()) {
                this.layout.setVisible(v);
              }
            }
          }
          _updateLocalTransform() {
            if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
              // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
              var _sr = Math.sin(this._rotation);
              var _cr = Math.cos(this._rotation);
              this._setLocalTransform(_cr * this._scaleX, -_sr * this._scaleY, _sr * this._scaleX, _cr * this._scaleY);
            } else {
              this._setLocalTransform(this._scaleX, 0, 0, this._scaleY);
            }
            this._updateLocalTranslate();
          }
          _updateLocalTranslate() {
            this._recalcLocalTranslate();
            this._triggerRecalcTranslate();
          }
          _recalcLocalTranslate() {
            var pivotXMul = this._pivotX * this._w;
            var pivotYMul = this._pivotY * this._h;
            var px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
            var py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
            px -= this._mountX * this._w;
            py -= this._mountY * this._h;
            this._localPx = px;
            this._localPy = py;
          }
          _updateLocalTranslateDelta(dx, dy) {
            this._addLocalTranslate(dx, dy);
          }
          _updateLocalAlpha() {
            this._setLocalAlpha(this._visible ? this._alpha : 0);
          }
          /**
           * @param {number} type
           * 0: no updates
           * 1: re-invoke shader
           * 3: re-create render texture and re-invoke shader
           */
          setHasRenderUpdates(type) {
            if (this._worldContext.alpha) {
              // Ignore if 'world invisible'. Render updates will be reset to 3 for every element that becomes visible.
              var p = this;
              p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
              while ((p = p._parent) && p._hasRenderUpdates !== 3) {
                p._hasRenderUpdates = 3;
              }
            }
          }

          /**
           * @param {Number} type
           *   1: alpha
           *   2: translate
           *   4: transform
           * 128: becomes visible
           * 256: flex layout updated
           */
          _setRecalc(type) {
            this._recalc |= type;
            this._setHasUpdates();

            // Any changes in descendants should trigger texture updates.
            if (this._parent) {
              this._parent.setHasRenderUpdates(3);
            }
          }
          _setHasUpdates() {
            var p = this;
            while (p && !p._hasUpdates) {
              p._hasUpdates = true;
              p = p._parent;
            }
          }
          getParent() {
            return this._parent;
          }
          setParent(parent) {
            if (parent !== this._parent) {
              var prevIsZContext = this.isZContext();
              var prevParent = this._parent;
              this._parent = parent;

              // Notify flex layout engine.
              if (this._layout || parent && parent.isFlexContainer()) {
                this.layout.setParent(prevParent, parent);
              }
              if (prevParent) {
                // When elements are deleted, the render texture must be re-rendered.
                prevParent.setHasRenderUpdates(3);
              }
              this._setRecalc(1 + 2 + 4);
              if (this._parent) {
                // Force parent to propagate hasUpdates flag.
                this._parent._setHasUpdates();
              }
              if (this._zIndex === 0) {
                this.setZParent(parent);
              } else {
                this.setZParent(parent ? parent.findZContext() : null);
              }
              if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                  this.disableZContext();
                } else {
                  this.enableZContext(prevParent.findZContext());
                }
              }

              // Tree order did change: even if zParent stays the same, we must resort.
              this._zIndexResort = true;
              if (this._zParent) {
                this._zParent.enableZSort();
              }
              if (!this._shader) {
                var newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
                if (newShaderOwner !== this._shaderOwner) {
                  this.setHasRenderUpdates(1);
                  this._setShaderOwnerRecursive(newShaderOwner);
                }
              }
            }
          }
          enableZSort() {
            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (!this._zSort && this._zContextUsage > 0) {
              this._zSort = true;
              if (force) {
                // ZSort must be done, even if this element is invisible.
                // This is done to prevent memory leaks when removing element from inactive render branches.
                this.ctx.forceZSort(this);
              }
            }
          }
          addChildAt(index, child) {
            if (!this._children) this._children = [];
            this._children.splice(index, 0, child);
            child.setParent(this);
          }
          setChildAt(index, child) {
            if (!this._children) this._children = [];
            this._children[index].setParent(null);
            this._children[index] = child;
            child.setParent(this);
          }
          removeChildAt(index) {
            var child = this._children[index];
            this._children.splice(index, 1);
            child.setParent(null);
          }
          removeChildren() {
            if (this._children) {
              for (var i = 0, n = this._children.length; i < n; i++) {
                this._children[i].setParent(null);
              }
              this._children.splice(0);
              if (this._zIndexedChildren) {
                this._zIndexedChildren.splice(0);
              }
            }
          }
          syncChildren(removed, added, order) {
            this._children = order;
            for (var i = 0, n = removed.length; i < n; i++) {
              removed[i].setParent(null);
            }
            for (var _i = 0, _n = added.length; _i < _n; _i++) {
              added[_i].setParent(this);
            }
          }
          moveChild(fromIndex, toIndex) {
            var c = this._children[fromIndex];
            this._children.splice(fromIndex, 1);
            this._children.splice(toIndex, 0, c);

            // Tree order changed: must resort!;
            this._zIndexResort = true;
            if (this._zParent) {
              this._zParent.enableZSort();
            }
          }
          _setLocalTransform(a, b, c, d) {
            this._setRecalc(4);
            this._localTa = a;
            this._localTb = b;
            this._localTc = c;
            this._localTd = d;

            // We also regard negative scaling as a complex case, so that we can optimize the non-complex case better.
            this._isComplex = b !== 0 || c !== 0 || a < 0 || d < 0;
          }
          _addLocalTranslate(dx, dy) {
            this._localPx += dx;
            this._localPy += dy;
            this._triggerRecalcTranslate();
          }
          _setLocalAlpha(a) {
            if (!this._worldContext.alpha && this._parent && this._parent._worldContext.alpha && a) {
              // Element is becoming visible. We need to force update.
              this._setRecalc(1 + 128);
            } else {
              this._setRecalc(1);
            }
            if (a < 1e-14) {
              // Tiny rounding errors may cause failing visibility tests.
              a = 0;
            }
            this._localAlpha = a;
          }
          setDimensions(w, h) {
            var isEstimate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._dimsUnknown;
            // In case of an estimation, the update loop should perform different bound checks.
            this._dimsUnknown = isEstimate;
            if (this.hasFlexLayout()) {
              this._layout.originalWidth = w;
              this._layout.originalHeight = h;
            } else {
              if (this._w !== w || this._h !== h) {
                this._updateDimensions(w, h);
                return true;
              }
            }
            return false;
          }
          _updateDimensions(w, h) {
            if (this._w !== w || this._h !== h) {
              this._w = w;
              this._h = h;
              this._triggerRecalcTranslate();
              if (this._texturizer) {
                this._texturizer.releaseRenderTexture();
                this._texturizer.updateResultTexture();
              }
              // Due to width/height change: update the translation vector.
              this._updateLocalTranslate();
            }
          }
          setTextureCoords(ulx, uly, brx, bry) {
            this.setHasRenderUpdates(3);
            this._ulx = ulx;
            this._uly = uly;
            this._brx = brx;
            this._bry = bry;
          }
          get displayedTextureSource() {
            return this._displayedTextureSource;
          }
          setDisplayedTextureSource(textureSource) {
            this.setHasRenderUpdates(3);
            this._displayedTextureSource = textureSource;
          }
          get isRoot() {
            return this._isRoot;
          }
          setAsRoot() {
            // Use parent dummy.
            this._parent = new ElementCore(this._element);

            // After setting root, make sure it's updated.
            this._parent._hasRenderUpdates = 3;
            this._parent._hasUpdates = true;

            // Root is, and will always be, the primary zContext.
            this._isRoot = true;
            this.ctx.root = this;

            // Set scissor area of 'fake parent' to stage's viewport.
            this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
            this._parent._scissor = this._parent._viewport;

            // When recBoundsMargin is null, the defaults are used (100 for all sides).
            this._parent._recBoundsMargin = null;
            this._setRecalc(1 + 2 + 4);
          }
          isAncestorOf(c) {
            var p = c;
            while (p = p._parent) {
              if (this === p) {
                return true;
              }
            }
            return false;
          }
          isZContext() {
            return this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent;
          }
          findZContext() {
            if (this.isZContext()) {
              return this;
            } else {
              return this._parent.findZContext();
            }
          }
          setZParent(newZParent) {
            if (this._zParent !== newZParent) {
              if (this._zParent !== null) {
                if (this._zIndex !== 0) {
                  this._zParent.decZContextUsage();
                }

                // We must filter out this item upon the next resort.
                this._zParent.enableZSort();
              }
              if (newZParent !== null) {
                var hadZContextUsage = newZParent._zContextUsage > 0;

                // @pre: new parent's children array has already been modified.
                if (this._zIndex !== 0) {
                  newZParent.incZContextUsage();
                }
                if (newZParent._zContextUsage > 0) {
                  if (!hadZContextUsage && this._parent === newZParent) ;else {
                    // Add new child to array.
                    newZParent._zIndexedChildren.push(this);
                  }

                  // Order should be checked.
                  newZParent.enableZSort();
                }
              }
              this._zParent = newZParent;

              // Newly added element must be marked for resort.
              this._zIndexResort = true;
            }
          }
          incZContextUsage() {
            this._zContextUsage++;
            if (this._zContextUsage === 1) {
              if (!this._zIndexedChildren) {
                this._zIndexedChildren = [];
              }
              if (this._children) {
                // Copy.
                for (var i = 0, n = this._children.length; i < n; i++) {
                  this._zIndexedChildren.push(this._children[i]);
                }
                // Initially, children are already sorted properly (tree order).
                this._zSort = false;
              }
            }
          }
          decZContextUsage() {
            this._zContextUsage--;
            if (this._zContextUsage === 0) {
              this._zSort = false;
              this._zIndexedChildren.splice(0);
            }
          }
          get zIndex() {
            return this._zIndex;
          }
          set zIndex(zIndex) {
            if (this._zIndex !== zIndex) {
              this.setHasRenderUpdates(1);
              var newZParent = this._zParent;
              var prevIsZContext = this.isZContext();
              if (zIndex === 0 && this._zIndex !== 0) {
                if (this._parent === this._zParent) {
                  if (this._zParent) {
                    this._zParent.decZContextUsage();
                  }
                } else {
                  newZParent = this._parent;
                }
              } else if (zIndex !== 0 && this._zIndex === 0) {
                newZParent = this._parent ? this._parent.findZContext() : null;
                if (newZParent === this._zParent) {
                  if (this._zParent) {
                    this._zParent.incZContextUsage();
                    this._zParent.enableZSort();
                  }
                }
              } else if (zIndex !== this._zIndex) {
                if (this._zParent && this._zParent._zContextUsage) {
                  this._zParent.enableZSort();
                }
              }
              if (newZParent !== this._zParent) {
                this.setZParent(null);
              }
              this._zIndex = zIndex;
              if (newZParent !== this._zParent) {
                this.setZParent(newZParent);
              }
              if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                  this.disableZContext();
                } else {
                  this.enableZContext(this._parent.findZContext());
                }
              }

              // Make sure that resort is done.
              this._zIndexResort = true;
              if (this._zParent) {
                this._zParent.enableZSort();
              }
            }
          }
          get forceZIndexContext() {
            return this._forceZIndexContext;
          }
          set forceZIndexContext(v) {
            this.setHasRenderUpdates(1);
            var prevIsZContext = this.isZContext();
            this._forceZIndexContext = v;
            if (prevIsZContext !== this.isZContext()) {
              if (!this.isZContext()) {
                this.disableZContext();
              } else {
                this.enableZContext(this._parent.findZContext());
              }
            }
          }
          enableZContext(prevZContext) {
            if (prevZContext && prevZContext._zContextUsage > 0) {
              // Transfer from upper z context to this z context.
              var results = this._getZIndexedDescs();
              results.forEach(c => {
                if (this.isAncestorOf(c) && c._zIndex !== 0) {
                  c.setZParent(this);
                }
              });
            }
          }
          _getZIndexedDescs() {
            var results = [];
            if (this._children) {
              for (var i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
              }
            }
            return results;
          }
          _getZIndexedDescsRec(results) {
            if (this._zIndex) {
              results.push(this);
            } else if (this._children && !this.isZContext()) {
              for (var i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
              }
            }
          }
          disableZContext() {
            // Transfer from this z context to upper z context.
            if (this._zContextUsage > 0) {
              var newZParent = this._parent.findZContext();

              // Make sure that z-indexed children are up to date (old ones removed).
              if (this._zSort) {
                this.sortZIndexedChildren();
              }
              this._zIndexedChildren.slice().forEach(function (c) {
                if (c._zIndex !== 0) {
                  c.setZParent(newZParent);
                }
              });
            }
          }
          get colorUl() {
            return this._colorUl;
          }
          set colorUl(color) {
            if (this._colorUl !== color) {
              this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
              this._colorUl = color;
            }
          }
          get colorUr() {
            return this._colorUr;
          }
          set colorUr(color) {
            if (this._colorUr !== color) {
              this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
              this._colorUr = color;
            }
          }
          get colorBl() {
            return this._colorBl;
          }
          set colorBl(color) {
            if (this._colorBl !== color) {
              this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
              this._colorBl = color;
            }
          }
          get colorBr() {
            return this._colorBr;
          }
          set colorBr(color) {
            if (this._colorBr !== color) {
              this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
              this._colorBr = color;
            }
          }
          set onUpdate(f) {
            this._onUpdate = f;
            this._setRecalc(7);
          }
          set onAfterUpdate(f) {
            this._onAfterUpdate = f;
            this._setRecalc(7);
          }
          set onAfterCalcs(f) {
            this._onAfterCalcs = f;
            this._setRecalc(7);
          }
          get shader() {
            return this._shader;
          }
          set shader(v) {
            this.setHasRenderUpdates(1);
            var prevShader = this._shader;
            this._shader = v;
            if (!v && prevShader) {
              // Disabled shader.
              var newShaderOwner = this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null;
              this._setShaderOwnerRecursive(newShaderOwner);
            } else if (v) {
              // Enabled shader.
              this._setShaderOwnerRecursive(this);
            }
          }
          get activeShader() {
            return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
          }
          get activeShaderOwner() {
            return this._shaderOwner;
          }
          get clipping() {
            return this._clipping;
          }
          set clipping(v) {
            if (this._clipping !== v) {
              this._clipping = v;

              // Force update of scissor by updating translate.
              // Alpha must also be updated because the scissor area may have been empty.
              this._setRecalc(1 + 2);
            }
          }
          get clipbox() {
            return this._clipbox;
          }
          set clipbox(v) {
            // In case of out-of-bounds element, all children will also be ignored.
            // It will save us from executing the update/render loops for those.
            // The optimization will be used immediately during the next frame.
            this._clipbox = v;
          }
          _setShaderOwnerRecursive(elementCore) {
            this._shaderOwner = elementCore;
            if (this._children && !this._renderToTextureEnabled) {
              for (var i = 0, n = this._children.length; i < n; i++) {
                var c = this._children[i];
                if (!c._shader) {
                  c._setShaderOwnerRecursive(elementCore);
                  c._hasRenderUpdates = 3;
                }
              }
            }
          }
          _setShaderOwnerChildrenRecursive(elementCore) {
            if (this._children) {
              for (var i = 0, n = this._children.length; i < n; i++) {
                var c = this._children[i];
                if (!c._shader) {
                  c._setShaderOwnerRecursive(elementCore);
                  c._hasRenderUpdates = 3;
                }
              }
            }
          }
          _hasRenderContext() {
            return this._renderContext !== this._worldContext;
          }
          get renderContext() {
            return this._renderContext;
          }
          updateRenderToTextureEnabled() {
            // Enforce texturizer initialisation.
            var v = this.texturizer._enabled;
            if (v) {
              this._enableRenderToTexture();
            } else {
              this._disableRenderToTexture();
              this._texturizer.releaseRenderTexture();
            }
          }
          _enableRenderToTexture() {
            if (!this._renderToTextureEnabled) {
              var prevIsZContext = this.isZContext();
              this._renderToTextureEnabled = true;
              this._renderContext = new ElementCoreContext();

              // If render to texture is active, a new shader context is started.
              this._setShaderOwnerChildrenRecursive(null);
              if (!prevIsZContext) {
                // Render context forces z context.
                this.enableZContext(this._parent ? this._parent.findZContext() : null);
              }
              this.setHasRenderUpdates(3);

              // Make sure that the render coordinates get updated.
              this._setRecalc(7);
              this.render = this._renderAdvanced;
            }
          }
          _disableRenderToTexture() {
            if (this._renderToTextureEnabled) {
              this._renderToTextureEnabled = false;
              this._setShaderOwnerChildrenRecursive(this._shaderOwner);
              this._renderContext = this._worldContext;
              if (!this.isZContext()) {
                this.disableZContext();
              }

              // Make sure that the render coordinates get updated.
              this._setRecalc(7);
              this.setHasRenderUpdates(3);
              this.render = this._renderSimple;
            }
          }
          isWhite() {
            return this._colorUl === 0xFFFFFFFF && this._colorUr === 0xFFFFFFFF && this._colorBl === 0xFFFFFFFF && this._colorBr === 0xFFFFFFFF;
          }
          hasSimpleTexCoords() {
            return this._ulx === 0 && this._uly === 0 && this._brx === 1 && this._bry === 1;
          }
          _stashTexCoords() {
            this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
            this._ulx = 0;
            this._uly = 0;
            this._brx = 1;
            this._bry = 1;
          }
          _unstashTexCoords() {
            this._ulx = this._stashedTexCoords[0];
            this._uly = this._stashedTexCoords[1];
            this._brx = this._stashedTexCoords[2];
            this._bry = this._stashedTexCoords[3];
            this._stashedTexCoords = null;
          }
          _stashColors() {
            this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
            this._colorUl = 0xFFFFFFFF;
            this._colorUr = 0xFFFFFFFF;
            this._colorBr = 0xFFFFFFFF;
            this._colorBl = 0xFFFFFFFF;
          }
          _unstashColors() {
            this._colorUl = this._stashedColors[0];
            this._colorUr = this._stashedColors[1];
            this._colorBr = this._stashedColors[2];
            this._colorBl = this._stashedColors[3];
            this._stashedColors = null;
          }
          isVisible() {
            return this._localAlpha > 1e-14;
          }
          get outOfBounds() {
            return this._outOfBounds;
          }
          set boundsMargin(v) {
            /**
             *  null: inherit from parent.
             *  number[4]: specific margins: left, top, right, bottom.
             */
            this._boundsMargin = v ? v.slice() : null;

            // We force recalc in order to set all boundsMargin recursively during the next update.
            this._triggerRecalcTranslate();
          }
          get boundsMargin() {
            return this._boundsMargin;
          }
          update() {
            this._recalc |= this._parent._pRecalc;
            if (this._layout && this._layout.isEnabled()) {
              if (this._recalc & 256) {
                this._layout.layoutFlexTree();
              }
            } else if (this._recalc & 2 && this._optFlags) {
              this._applyRelativeDimFuncs();
            }
            if (this._onUpdate) {
              // Block all 'upwards' updates when changing things in this branch.
              this._hasUpdates = true;
              this._onUpdate(this.element, this);
            }
            var pw = this._parent._worldContext;
            var w = this._worldContext;
            var visible = pw.alpha && this._localAlpha;

            /**
             * We must update if:
             * - branch contains updates (even when invisible because it may contain z-indexed descendants)
             * - there are (inherited) updates and this branch is visible
             * - this branch becomes invisible (descs may be z-indexed so we must update all alpha values)
             */
            if (this._hasUpdates || this._recalc && visible || w.alpha && !visible) {
              var recalc = this._recalc;

              // Update world coords/alpha.
              if (recalc & 1) {
                if (!w.alpha && visible) {
                  // Becomes visible.
                  this._hasRenderUpdates = 3;
                }
                w.alpha = pw.alpha * this._localAlpha;
                if (w.alpha < 1e-14) {
                  // Tiny rounding errors may cause failing visibility tests.
                  w.alpha = 0;
                }
              }
              if (recalc & 6) {
                w.px = pw.px + this._localPx * pw.ta;
                w.py = pw.py + this._localPy * pw.td;
                if (pw.tb !== 0) w.px += this._localPy * pw.tb;
                if (pw.tc !== 0) w.py += this._localPx * pw.tc;
              }
              if (recalc & 4) {
                w.ta = this._localTa * pw.ta;
                w.tb = this._localTd * pw.tb;
                w.tc = this._localTa * pw.tc;
                w.td = this._localTd * pw.td;
                if (this._isComplex) {
                  w.ta += this._localTc * pw.tb;
                  w.tb += this._localTb * pw.ta;
                  w.tc += this._localTc * pw.td;
                  w.td += this._localTb * pw.tc;
                }
              }

              // Update render coords/alpha.
              var pr = this._parent._renderContext;
              if (this._parent._hasRenderContext()) {
                var _init = this._renderContext === this._worldContext;
                if (_init) {
                  // First render context build: make sure that it is fully initialized correctly.
                  // Otherwise, if we get into bounds later, the render context would not be initialized correctly.
                  this._renderContext = new ElementCoreContext();
                }
                var _r = this._renderContext;

                // Update world coords/alpha.
                if (_init || recalc & 1) {
                  _r.alpha = pr.alpha * this._localAlpha;
                  if (_r.alpha < 1e-14) {
                    _r.alpha = 0;
                  }
                }
                if (_init || recalc & 6) {
                  _r.px = pr.px + this._localPx * pr.ta;
                  _r.py = pr.py + this._localPy * pr.td;
                  if (pr.tb !== 0) _r.px += this._localPy * pr.tb;
                  if (pr.tc !== 0) _r.py += this._localPx * pr.tc;
                }
                if (_init) {
                  // We set the recalc toggle, because we must make sure that the scissor is updated.
                  recalc |= 2;
                }
                if (_init || recalc & 4) {
                  _r.ta = this._localTa * pr.ta;
                  _r.tb = this._localTd * pr.tb;
                  _r.tc = this._localTa * pr.tc;
                  _r.td = this._localTd * pr.td;
                  if (this._isComplex) {
                    _r.ta += this._localTc * pr.tb;
                    _r.tb += this._localTb * pr.ta;
                    _r.tc += this._localTc * pr.td;
                    _r.td += this._localTb * pr.tc;
                  }
                }
              } else {
                this._renderContext = this._worldContext;
              }
              if (this.ctx.updateTreeOrder === -1) {
                this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
              } else {
                this._updateTreeOrder = this.ctx.updateTreeOrder++;
              }

              // Determine whether we must use a 'renderTexture'.
              var useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
              if (this._useRenderToTexture !== useRenderToTexture) {
                // Coords must be changed.
                this._recalc |= 2 + 4;

                // Scissor may change: force update.
                recalc |= 2;
                if (!this._useRenderToTexture) {
                  // We must release the texture.
                  this._texturizer.release();
                }
              }
              this._useRenderToTexture = useRenderToTexture;
              var r = this._renderContext;
              var bboxW = this._dimsUnknown ? 2048 : this._w;
              var bboxH = this._dimsUnknown ? 2048 : this._h;

              // Calculate a bbox for this element.
              var sx, sy, ex, ey;
              var rComplex = r.tb !== 0 || r.tc !== 0 || r.ta < 0 || r.td < 0;
              if (rComplex) {
                sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
              } else {
                sx = r.px;
                ex = r.px + r.ta * bboxW;
                sy = r.py;
                ey = r.py + r.td * bboxH;
              }
              if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                // If we are dealing with a non-identity matrix, we must extend the bbox so that withinBounds and
                //  scissors will include the complete range of (positive) dimensions up to ,lh.
                var nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                var ny = this._x * pr.tc + this._y * pr.td + pr.py;
                if (nx < sx) sx = nx;
                if (ny < sy) sy = ny;
                if (nx > ex) ex = nx;
                if (ny > ey) ey = ny;
              }
              if (recalc & 6 || !this._scissor /* initial */) {
                // Determine whether we must 'clip'.
                if (this._clipping && r.isSquare()) {
                  // If the parent renders to a texture, it's scissor should be ignored;
                  var area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                  if (area) {
                    // Merge scissor areas.
                    var lx = Math.max(area[0], sx);
                    var ly = Math.max(area[1], sy);
                    this._scissor = [lx, ly, Math.min(area[2] + area[0], ex) - lx, Math.min(area[3] + area[1], ey) - ly];
                  } else {
                    this._scissor = [sx, sy, ex - sx, ey - sy];
                  }
                } else {
                  // No clipping: reuse parent scissor.
                  this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                }
              }

              // Calculate the outOfBounds margin.
              if (this._boundsMargin) {
                this._recBoundsMargin = this._boundsMargin;
              } else {
                this._recBoundsMargin = this._parent._recBoundsMargin;
              }
              if (this._onAfterCalcs) {
                // After calcs may change render coords, scissor and/or recBoundsMargin.
                if (this._onAfterCalcs(this.element)) {
                  // Recalculate bbox.
                  if (rComplex) {
                    sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                    ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                    sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                    ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                  } else {
                    sx = r.px;
                    ex = r.px + r.ta * bboxW;
                    sy = r.py;
                    ey = r.py + r.td * bboxH;
                  }
                  if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                    var _nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                    var _ny = this._x * pr.tc + this._y * pr.td + pr.py;
                    if (_nx < sx) sx = _nx;
                    if (_ny < sy) sy = _ny;
                    if (_nx > ex) ex = _nx;
                    if (_ny > ey) ey = _ny;
                  }
                }
              }
              if (this._parent._outOfBounds === 2) {
                // Inherit parent out of boundsness.
                this._outOfBounds = 2;
                if (this._withinBoundsMargin) {
                  this._withinBoundsMargin = false;
                  this.element._disableWithinBoundsMargin();
                }
              } else {
                if (recalc & 6) {
                  // Recheck if element is out-of-bounds (all settings that affect this should enable recalc bit 2 or 4).
                  this._outOfBounds = 0;
                  var withinMargin = true;

                  // Offscreens are always rendered as long as the parent is within bounds.
                  if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                    if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                      // Empty scissor area.
                      this._outOfBounds = 2;
                    } else {
                      // Use bbox to check out-of-boundness.
                      if (this._scissor[0] > ex || this._scissor[1] > ey || sx > this._scissor[0] + this._scissor[2] || sy > this._scissor[1] + this._scissor[3]) {
                        this._outOfBounds = 1;
                      }
                      if (this._outOfBounds) {
                        if (this._clipping || this._useRenderToTexture || this._clipbox && bboxW && bboxH) {
                          this._outOfBounds = 2;
                        }
                      }
                    }
                    withinMargin = this._outOfBounds === 0;
                    if (!withinMargin) {
                      // Re-test, now with margins.
                      if (this._recBoundsMargin) {
                        withinMargin = !(ex < this._scissor[0] - this._recBoundsMargin[2] || ey < this._scissor[1] - this._recBoundsMargin[3] || sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0] || sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]);
                      } else {
                        withinMargin = !(ex < this._scissor[0] - 100 || ey < this._scissor[1] - 100 || sx > this._scissor[0] + this._scissor[2] + 100 || sy > this._scissor[1] + this._scissor[3] + 100);
                      }
                      if (withinMargin && this._outOfBounds === 2) {
                        // Children must be visited because they may contain elements that are within margin, so must be visible.
                        this._outOfBounds = 1;
                      }
                    }
                  }
                  if (this._withinBoundsMargin !== withinMargin) {
                    this._withinBoundsMargin = withinMargin;
                    if (this._withinBoundsMargin) {
                      // This may update things (txLoaded events) in the element itself, but also in descendants and ancestors.

                      // Changes in ancestors should be executed during the next call of the stage update. But we must
                      // take care that the _recalc and _hasUpdates flags are properly registered. That's why we clear
                      // both before entering the children, and use _pRecalc to transfer inherited updates instead of
                      // _recalc directly.

                      // Changes in descendants are automatically executed within the current update loop, though we must
                      // take care to not update the hasUpdates flag unnecessarily in ancestors. We achieve this by making
                      // sure that the hasUpdates flag of this element is turned on, which blocks it for ancestors.
                      this._hasUpdates = true;
                      var _recalc = this._recalc;
                      this._recalc = 0;
                      this.element._enableWithinBoundsMargin();
                      if (this._recalc) {
                        // This element needs to be re-updated now, because we want the dimensions (and other changes) to be updated.
                        return this.update();
                      }
                      this._recalc = _recalc;
                    } else {
                      this.element._disableWithinBoundsMargin();
                    }
                  }
                }
              }
              if (this._useRenderToTexture) {
                // Set viewport necessary for children scissor calculation.
                if (this._viewport) {
                  this._viewport[2] = bboxW;
                  this._viewport[3] = bboxH;
                } else {
                  this._viewport = [0, 0, bboxW, bboxH];
                }
              }

              // Filter out bits that should not be copied to the children (currently all are).
              this._pRecalc = this._recalc & 135;

              // Clear flags so that future updates are properly detected.
              this._recalc = 0;
              this._hasUpdates = false;
              if (this._outOfBounds < 2) {
                if (this._useRenderToTexture) {
                  if (this._worldContext.isIdentity()) {
                    // Optimization.
                    // The world context is already identity: use the world context as render context to prevents the
                    // ancestors from having to update the render context.
                    this._renderContext = this._worldContext;
                  } else {
                    // Temporarily replace the render coord attribs by the identity matrix.
                    // This allows the children to calculate the render context.
                    this._renderContext = ElementCoreContext.IDENTITY;
                  }
                }
                if (this._children) {
                  for (var i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].update();
                  }
                }
                if (this._useRenderToTexture) {
                  this._renderContext = r;
                }
              } else {
                if (this._children) {
                  for (var _i2 = 0, _n2 = this._children.length; _i2 < _n2; _i2++) {
                    if (this._children[_i2]._hasUpdates) {
                      this._children[_i2].update();
                    } else {
                      // Make sure we don't lose the 'inherited' updates.
                      this._children[_i2]._recalc |= this._pRecalc;
                      this._children[_i2].updateOutOfBounds();
                    }
                  }
                }
              }
              if (this._onAfterUpdate) {
                this._onAfterUpdate(this.element);
              }
            } else {
              if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
                // If new tree order does not interfere with the current (gaps allowed) there's no need to traverse the branch.
                this.ctx.updateTreeOrder = -1;
              } else {
                this.updateTreeOrder();
              }
            }
          }
          _applyRelativeDimFuncs() {
            if (this._optFlags & 1) {
              var x = this._funcX(this._parent.w);
              if (x !== this._x) {
                this._localPx += x - this._x;
                this._x = x;
              }
            }
            if (this._optFlags & 2) {
              var y = this._funcY(this._parent.h);
              if (y !== this._y) {
                this._localPy += y - this._y;
                this._y = y;
              }
            }
            var changedDims = false;
            if (this._optFlags & 4) {
              var w = this._funcW(this._parent.w);
              if (w !== this._w) {
                this._w = w;
                changedDims = true;
              }
            }
            if (this._optFlags & 8) {
              var h = this._funcH(this._parent.h);
              if (h !== this._h) {
                this._h = h;
                changedDims = true;
              }
            }
            if (changedDims) {
              // Recalc mount, scale position.
              this._recalcLocalTranslate();
              this.element.onDimensionsChanged(this._w, this._h);
            }
          }
          updateOutOfBounds() {
            // Propagate outOfBounds flag to descendants (necessary because of z-indexing).
            // Invisible elements are not drawn anyway. When alpha is updated, so will _outOfBounds.
            if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {
              // Inherit parent out of boundsness.
              this._outOfBounds = 2;
              if (this._withinBoundsMargin) {
                this._withinBoundsMargin = false;
                this.element._disableWithinBoundsMargin();
              }
              if (this._children) {
                for (var i = 0, n = this._children.length; i < n; i++) {
                  this._children[i].updateOutOfBounds();
                }
              }
            }
          }
          updateTreeOrder() {
            if (this._localAlpha && this._outOfBounds !== 2) {
              this._updateTreeOrder = this.ctx.updateTreeOrder++;
              if (this._children) {
                for (var i = 0, n = this._children.length; i < n; i++) {
                  this._children[i].updateTreeOrder();
                }
              }
            }
          }
          _renderSimple() {
            this._hasRenderUpdates = 0;
            if (this._zSort) {
              this.sortZIndexedChildren();
            }
            if (this._outOfBounds < 2 && this._renderContext.alpha) {
              var renderState = this.renderState;
              if (this._outOfBounds === 0 && this._displayedTextureSource) {
                renderState.setShader(this.activeShader, this._shaderOwner);
                renderState.setScissor(this._scissor);
                this.renderState.addQuad(this);
              }

              // Also add children to the VBO.
              if (this._children) {
                if (this._zContextUsage) {
                  for (var i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                    this._zIndexedChildren[i].render();
                  }
                } else {
                  for (var _i3 = 0, _n3 = this._children.length; _i3 < _n3; _i3++) {
                    if (this._children[_i3]._zIndex === 0) {
                      // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                      this._children[_i3].render();
                    }
                  }
                }
              }
            }
          }
          _renderAdvanced() {
            var hasRenderUpdates = this._hasRenderUpdates;

            // We must clear the hasRenderUpdates flag before rendering, because updating result textures in combination
            // with z-indexing may trigger render updates on a render branch that is 'half done'.
            // We need to ensure that the full render branch is marked for render updates, not only half (leading to freeze).
            this._hasRenderUpdates = 0;
            if (this._zSort) {
              this.sortZIndexedChildren();
            }
            if (this._outOfBounds < 2 && this._renderContext.alpha) {
              var renderState = this.renderState;
              var mustRenderChildren = true;
              var renderTextureInfo;
              var prevRenderTextureInfo;
              if (this._useRenderToTexture) {
                if (this._w === 0 || this._h === 0) {
                  // Ignore this branch and don't draw anything.
                  return;
                } else if (!this._texturizer.hasRenderTexture() || hasRenderUpdates >= 3) {
                  // Tell the renderer we're rendering a renderToTexture element in this frame
                  this.ctx.renderToTextureCount++;
                  // Switch to default shader for building up the render texture.
                  renderState.setShader(renderState.defaultShader, this);
                  prevRenderTextureInfo = renderState.renderTextureInfo;
                  renderTextureInfo = {
                    nativeTexture: null,
                    offset: 0,
                    // Set by CoreRenderState.
                    w: this._w,
                    h: this._h,
                    empty: true,
                    cleared: false,
                    ignore: false,
                    cache: false
                  };
                  if (this._texturizer.hasResultTexture() || !renderState.isCachingTexturizer && hasRenderUpdates < 3) {
                    /**
                     * We don't always cache render textures.
                     *
                     * The rule is, that caching for a specific render texture is only enabled if:
                     * - There is a result texture to be updated.
                     * - There were no render updates -within the contents- since last frame (ElementCore.hasRenderUpdates < 3)
                     * - AND there are no ancestors that are being cached during this frame (CoreRenderState.isCachingTexturizer)
                     *   If an ancestor is cached anyway, it's probably not necessary to keep deeper caches. If the top level is to
                     *   change while a lower one is not, that lower level will be cached instead.
                     *
                     * In case of the fast blur element, this prevents having to cache all blur levels and stages, saving a huge amount
                     * of GPU memory!
                     *
                     * Especially when using multiple stacked layers of the same dimensions that are RTT this will have a very
                     * noticable effect on performance as less render textures need to be allocated.
                     */
                    renderTextureInfo.cache = true;
                    renderState.isCachingTexturizer = true;
                  }
                  if (!this._texturizer.hasResultTexture()) {
                    // We can already release the current texture to the pool, as it will be rebuild anyway.
                    // In case of multiple layers of 'filtering', this may save us from having to create one
                    //  render-to-texture layer.
                    // Notice that we don't do this when there is a result texture, as any other element may rely on
                    //  that result texture being filled.
                    this._texturizer.releaseRenderTexture();
                  }
                  renderState.setRenderTextureInfo(renderTextureInfo);
                  renderState.setScissor(null);
                  if (this._displayedTextureSource) {
                    var r = this._renderContext;

                    // Use an identity context for drawing the displayed texture to the render texture.
                    this._renderContext = ElementCoreContext.IDENTITY;

                    // Add displayed texture source in local coordinates.
                    this.renderState.addQuad(this);
                    this._renderContext = r;
                  }
                } else {
                  mustRenderChildren = false;
                }
              } else {
                if (this._outOfBounds === 0 && this._displayedTextureSource) {
                  renderState.setShader(this.activeShader, this._shaderOwner);
                  renderState.setScissor(this._scissor);
                  this.renderState.addQuad(this);
                }
              }

              // Also add children to the VBO.
              if (mustRenderChildren && this._children) {
                if (this._zContextUsage) {
                  for (var i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                    this._zIndexedChildren[i].render();
                  }
                } else {
                  for (var _i4 = 0, _n4 = this._children.length; _i4 < _n4; _i4++) {
                    if (this._children[_i4]._zIndex === 0) {
                      // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                      this._children[_i4].render();
                    }
                  }
                }
              }
              if (this._useRenderToTexture) {
                var updateResultTexture = false;
                if (mustRenderChildren) {
                  // Finished refreshing renderTexture.
                  renderState.finishedRenderTexture();

                  // If nothing was rendered, we store a flag in the texturizer and prevent unnecessary
                  //  render-to-texture and filtering.
                  this._texturizer.empty = renderTextureInfo.empty;
                  if (renderTextureInfo.empty) {
                    // We ignore empty render textures and do not draw the final quad.

                    // The following cleans up memory and enforces that the result texture is also cleared.
                    this._texturizer.releaseRenderTexture();
                  } else if (renderTextureInfo.nativeTexture) {
                    // If nativeTexture is set, we can reuse that directly instead of creating a new render texture.
                    this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);
                    renderTextureInfo.ignore = true;
                  } else {
                    if (this._texturizer.renderTextureReused) {
                      // Quad operations must be written to a render texture actually owned.
                      this._texturizer.releaseRenderTexture();
                    }
                    // Just create the render texture.
                    renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
                  }

                  // Restore the parent's render texture.
                  renderState.setRenderTextureInfo(prevRenderTextureInfo);
                  updateResultTexture = true;
                }
                if (!this._texturizer.empty) {
                  var resultTexture = this._texturizer.getResultTexture();
                  if (updateResultTexture) {
                    if (resultTexture) {
                      // Logging the update frame can be handy for userland.
                      resultTexture.update = renderState.stage.frameCounter;
                    }
                    this._texturizer.updateResultTexture();
                  }
                  if (!this._texturizer.renderOffscreen) {
                    // Render result texture to the actual render target.
                    renderState.setShader(this.activeShader, this._shaderOwner);
                    renderState.setScissor(this._scissor);

                    // If no render texture info is set, the cache can be reused.
                    var cache = !renderTextureInfo || renderTextureInfo.cache;
                    renderState.setTexturizer(this._texturizer, cache);
                    this._stashTexCoords();
                    if (!this._texturizer.colorize) this._stashColors();
                    this.renderState.addQuad(this, true);
                    if (!this._texturizer.colorize) this._unstashColors();
                    this._unstashTexCoords();
                    renderState.setTexturizer(null);
                  }
                }
              }
              if (renderTextureInfo && renderTextureInfo.cache) {
                // Allow siblings to cache.
                renderState.isCachingTexturizer = false;
              }
            }
          }
          get zSort() {
            return this._zSort;
          }
          sortZIndexedChildren() {
            /**
             * We want to avoid resorting everything. Instead, we do a single pass of the full array:
             * - filtering out elements with a different zParent than this (were removed)
             * - filtering out, but also gathering (in a temporary array) the elements that have zIndexResort flag
             * - then, finally, we merge-sort both the new array and the 'old' one
             * - element may have been added 'double', so when merge-sorting also check for doubles.
             * - if the old one is larger (in size) than it should be, splice off the end of the array.
             */

            var n = this._zIndexedChildren.length;
            var ptr = 0;
            var a = this._zIndexedChildren;

            // Notice that items may occur multiple times due to z-index changing.
            var b = [];
            for (var i = 0; i < n; i++) {
              if (a[i]._zParent === this) {
                if (a[i]._zIndexResort) {
                  b.push(a[i]);
                } else {
                  if (ptr !== i) {
                    a[ptr] = a[i];
                  }
                  ptr++;
                }
              }
            }
            var m = b.length;
            if (m) {
              for (var j = 0; j < m; j++) {
                b[j]._zIndexResort = false;
              }
              b.sort(ElementCore.sortZIndexedChildren);
              var _n5 = ptr;
              if (!_n5) {
                ptr = 0;
                var _j = 0;
                do {
                  a[ptr++] = b[_j++];
                } while (_j < m);
                if (a.length > ptr) {
                  // Slice old (unnecessary) part off array.
                  a.splice(ptr);
                }
              } else {
                // Merge-sort arrays;
                ptr = 0;
                var _i5 = 0;
                var _j2 = 0;
                var mergeResult = [];
                do {
                  var v = a[_i5]._zIndex === b[_j2]._zIndex ? a[_i5]._updateTreeOrder - b[_j2]._updateTreeOrder : a[_i5]._zIndex - b[_j2]._zIndex;
                  var add = v > 0 ? b[_j2++] : a[_i5++];
                  if (ptr === 0 || mergeResult[ptr - 1] !== add) {
                    mergeResult[ptr++] = add;
                  }
                  if (_i5 >= _n5) {
                    do {
                      var _add = b[_j2++];
                      if (ptr === 0 || mergeResult[ptr - 1] !== _add) {
                        mergeResult[ptr++] = _add;
                      }
                    } while (_j2 < m);
                    break;
                  } else if (_j2 >= m) {
                    do {
                      var _add2 = a[_i5++];
                      if (ptr === 0 || mergeResult[ptr - 1] !== _add2) {
                        mergeResult[ptr++] = _add2;
                      }
                    } while (_i5 < _n5);
                    break;
                  }
                } while (true);
                this._zIndexedChildren = mergeResult;
              }
            } else {
              if (a.length > ptr) {
                // Slice old (unnecessary) part off array.
                a.splice(ptr);
              }
            }
            this._zSort = false;
          }
          get localTa() {
            return this._localTa;
          }
          get localTb() {
            return this._localTb;
          }
          get localTc() {
            return this._localTc;
          }
          get localTd() {
            return this._localTd;
          }
          get element() {
            return this._element;
          }
          get renderUpdates() {
            return this._hasRenderUpdates;
          }
          get texturizer() {
            if (!this._texturizer) {
              this._texturizer = new ElementTexturizer(this);
            }
            return this._texturizer;
          }
          getCornerPoints() {
            var w = this._worldContext;
            return [w.px, w.py, w.px + this._w * w.ta, w.py + this._w * w.tc, w.px + this._w * w.ta + this._h * w.tb, w.py + this._w * w.tc + this._h * w.td, w.px + this._h * w.tb, w.py + this._h * w.td];
          }
          getRenderTextureCoords(relX, relY) {
            var r = this._renderContext;
            return [r.px + r.ta * relX + r.tb * relY, r.py + r.tc * relX + r.td * relY];
          }
          getAbsoluteCoords(relX, relY) {
            var w = this._renderContext;
            return [w.px + w.ta * relX + w.tb * relY, w.py + w.tc * relX + w.td * relY];
          }
          collectAtCoord(x, y, children) {
            // return when branch is hidden
            if (this._renderContext.alpha === 0) {
              return;
            }
            if (this.inBound(x, y)) {
              if (this._scissor) {
                if (this.inScissor()) {
                  children.push(this);
                }
              } else {
                children.push(this);
              }
            }
            if (this._children) {
              var j = this._children.length;
              for (var i = 0; i < j; i++) {
                this._children[i].collectAtCoord(x, y, children);
              }
            }
            return children.sort(ElementCore.sortZIndexedChildren);
          }
          inBound(tx, ty) {
            var c = this.getCornerPoints();
            return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
          }
          inScissor() {
            var sc = this._scissor;
            var c = this.getCornerPoints();
            return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
          }
          get layout() {
            this._ensureLayout();
            return this._layout;
          }
          get flex() {
            return this._layout ? this._layout.flex : null;
          }
          set flex(v) {
            this.layout.flex = v;
          }
          get flexItem() {
            return this._layout ? this._layout.flexItem : null;
          }
          set flexItem(v) {
            this.layout.flexItem = v;
          }
          isFlexItem() {
            return !!this._layout && this._layout.isFlexItemEnabled();
          }
          isFlexContainer() {
            return !!this._layout && this._layout.isFlexEnabled();
          }
          enableFlexLayout() {
            this._ensureLayout();
          }
          _ensureLayout() {
            if (!this._layout) {
              this._layout = new FlexTarget(this);
            }
          }
          disableFlexLayout() {
            this._triggerRecalcTranslate();
          }
          hasFlexLayout() {
            return this._layout && this._layout.isEnabled();
          }
          setLayout(x, y, w, h) {
            this.x = x;
            this.y = y;
            this._updateDimensions(w, h);
          }
          triggerLayout() {
            this._setRecalc(256);
          }
          _triggerRecalcTranslate() {
            this._setRecalc(2);
          }
        }
        class ElementCoreContext {
          constructor() {
            this.alpha = 1;
            this.px = 0;
            this.py = 0;
            this.ta = 1;
            this.tb = 0;
            this.tc = 0;
            this.td = 1;
          }
          isIdentity() {
            return this.alpha === 1 && this.px === 0 && this.py === 0 && this.ta === 1 && this.tb === 0 && this.tc === 0 && this.td === 1;
          }
          isSquare() {
            return this.tb === 0 && this.tc === 0;
          }
        }
        ElementCoreContext.IDENTITY = new ElementCoreContext();
        ElementCore.sortZIndexedChildren = function (a, b) {
          return a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * This is a partial (and more efficient) implementation of the event emitter.
         * It attempts to maintain a one-to-one mapping between events and listeners, skipping an array lookup.
         * Only if there are multiple listeners, they are combined in an array.
         */
        class EventEmitter {
          constructor() {
            // This is set (and kept) to true when events are used at all.
            this._hasEventListeners = false;
          }
          on(name, listener) {
            if (!this._hasEventListeners) {
              this._eventFunction = {};
              this._eventListeners = {};
              this._hasEventListeners = true;
            }
            var current = this._eventFunction[name];
            if (!current) {
              this._eventFunction[name] = listener;
            } else {
              if (this._eventFunction[name] !== EventEmitter.combiner) {
                this._eventListeners[name] = [this._eventFunction[name], listener];
                this._eventFunction[name] = EventEmitter.combiner;
              } else {
                this._eventListeners[name].push(listener);
              }
            }
          }
          once(name, listener) {
            var wrapper = (arg1, arg2, arg3) => {
              listener(arg1, arg2, arg3);
              this.off(name, wrapper);
            };
            wrapper.__originalFunc = listener;
            this.on(name, wrapper);
          }
          has(name, listener) {
            if (this._hasEventListeners) {
              var current = this._eventFunction[name];
              if (current) {
                if (current === EventEmitter.combiner) {
                  var listeners = this._eventListeners[name];
                  var _iterator5 = _createForOfIteratorHelper(listeners),
                    _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var l = _step5.value;
                      if (l === listener || l.__originalFunc == listener) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                  return true;
                }
              }
            }
            return false;
          }
          off(name, listener) {
            if (this._hasEventListeners) {
              var current = this._eventFunction[name];
              if (current) {
                if (current === EventEmitter.combiner) {
                  var listeners = this._eventListeners[name];
                  var index = listeners.indexOf(listener);
                  if (index >= 0) {
                    listeners.splice(index, 1);
                  }
                  index = listeners.map(l => l.__originalFunc).indexOf(listener);
                  if (index >= 0) {
                    listeners.splice(index, 1);
                  }
                  if (listeners.length === 1) {
                    this._eventFunction[name] = listeners[0];
                    this._eventListeners[name] = undefined;
                  }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                  this._eventFunction[name] = undefined;
                }
              }
            }
          }
          removeListener(name, listener) {
            this.off(name, listener);
          }
          emit(name, arg1, arg2, arg3) {
            if (this._hasEventListeners) {
              var func = this._eventFunction[name];
              if (func) {
                if (func === EventEmitter.combiner) {
                  func(this, name, arg1, arg2, arg3);
                } else {
                  func(arg1, arg2, arg3);
                }
              }
            }
          }
          listenerCount(name) {
            if (this._hasEventListeners) {
              var func = this._eventFunction[name];
              if (func) {
                if (func === EventEmitter.combiner) {
                  return this._eventListeners[name].length;
                } else {
                  return 1;
                }
              }
            }
            return 0;
          }
          removeAllListeners(name) {
            if (this._hasEventListeners) {
              delete this._eventFunction[name];
              delete this._eventListeners[name];
            }
          }
        }
        EventEmitter.combiner = function (object, name, arg1, arg2, arg3) {
          var listeners = object._eventListeners[name];
          if (listeners) {
            /* Because listener may detach itself while being invoked and therefore invalidate the iterator,
               we need to create a copy to loop over it */
            for (var _i6 = 0, _arr = [...listeners]; _i6 < _arr.length; _i6++) {
              var listener = _arr[_i6];
              listener(arg1, arg2, arg3);
            }
          }
        };
        EventEmitter.addAsMixin = function (cls) {
          cls.prototype.on = EventEmitter.prototype.on;
          cls.prototype.once = EventEmitter.prototype.once;
          cls.prototype.has = EventEmitter.prototype.has;
          cls.prototype.off = EventEmitter.prototype.off;
          cls.prototype.removeListener = EventEmitter.prototype.removeListener;
          cls.prototype.emit = EventEmitter.prototype.emit;
          cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
          cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Shader {
          constructor(coreContext) {
            this._initialized = false;
            this.ctx = coreContext;

            /**
             * The (enabled) elements that use this shader.
             * @type {Set<ElementCore>}
             */
            this._elements = new Set();
          }
          static create(stage, v) {
            var shader;
            if (Utils$2.isObjectLiteral(v)) {
              if (v.type) {
                shader = stage.renderer.createShader(stage.ctx, v);
              } else {
                shader = this.shader;
              }
              if (shader) {
                Base.patchObject(shader, v);
              }
            } else if (v === null) {
              shader = stage.ctx.renderState.defaultShader;
            } else if (v === undefined) {
              shader = null;
            } else {
              if (v.isShader) {
                if (!stage.renderer.isValidShaderType(v.constructor)) {
                  console.error("[Lightning] Invalid shader type");
                  v = null;
                }
                shader = v;
              } else {
                console.error("[Lightning] Please specify a shader type.");
                return;
              }
            }
            return shader;
          }
          static getWebGL() {
            return undefined;
          }
          static getC2d() {
            return undefined;
          }
          addElement(elementCore) {
            this._elements.add(elementCore);
          }
          removeElement(elementCore) {
            this._elements.delete(elementCore);
            if (!this._elements) {
              this.cleanup();
            }
          }
          redraw() {
            this._elements.forEach(elementCore => {
              elementCore.setHasRenderUpdates(2);
            });
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
          useDefault() {
            // Should return true if this shader is configured (using it's properties) to not have any effect.
            // This may allow the render engine to avoid unnecessary shader program switches or even texture copies.
            return false;
          }
          addEmpty() {
            // Draws this shader even if there are no quads to be added.
            // This is handy for custom shaders.
            return false;
          }
          cleanup() {
            // Called when no more enabled elements have this shader.
          }
          get isShader() {
            return true;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Texture {
          /**
           * @param {Stage} stage
           */
          constructor(stage) {
            this.stage = stage;
            this.manager = this.stage.textureManager;
            this.id = Texture.id++;

            /**
             * All enabled elements that use this texture object (either as texture or displayedTexture).
             * @type {Set<Element>}
             */
            this.elements = new Set();

            /**
             * The number of enabled elements that are active.
             * @type {number}
             */
            this._activeCount = 0;

            /**
             * The associated texture source.
             * Should not be changed.
             * @type {TextureSource}
             */
            this._source = null;

            /**
             * A resize mode can be set to cover or contain a certain area.
             * It will reset the texture clipping settings.
             * When manual texture clipping is performed, the resizeMode is reset.
             * @type {{type: string, width: number, height: number}}
             * @private
             */
            this._resizeMode = null;

            /**
             * The texture clipping x-offset.
             * @type {number}
             */
            this._x = 0;

            /**
             * The texture clipping y-offset.
             * @type {number}
             */
            this._y = 0;

            /**
             * The texture clipping width. If 0 then full width.
             * @type {number}
             */
            this._w = 0;

            /**
             * The texture clipping height. If 0 then full height.
             * @type {number}
             */
            this._h = 0;

            /**
             * Render precision (0.5 = fuzzy, 1 = normal, 2 = sharp even when scaled twice, etc.).
             * @type {number}
             * @private
             */
            this._precision = 1;

            /**
             * The (maximum) expected texture source width. Used for within bounds determination while texture is not yet loaded.
             * If not set, 2048 is used by ElementCore.update.
             * @type {number}
             */
            this.mw = 0;

            /**
             * The (maximum) expected texture source height. Used for within bounds determination while texture is not yet loaded.
             * If not set, 2048 is used by ElementCore.update.
             * @type {number}
             */
            this.mh = 0;

            /**
             * Indicates if Texture.prototype.texture uses clipping.
             * @type {boolean}
             */
            this.clipping = false;

            /**
             * Indicates whether this texture must update (when it becomes used again).
             * @type {boolean}
             * @private
             */
            this._mustUpdate = true;
          }
          get source() {
            if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
              this._performUpdateSource(true);
              this.stage.removeUpdateSourceTexture(this);
            }
            return this._source;
          }
          addElement(v) {
            if (!this.elements.has(v)) {
              this.elements.add(v);
              if (this.elements.size === 1) {
                if (this._source) {
                  this._source.addTexture(this);
                }
              }
              if (v.active) {
                this.incActiveCount();
              }
            }
          }
          removeElement(v) {
            if (this.elements.delete(v)) {
              if (this.elements.size === 0) {
                if (this._source) {
                  this._source.removeTexture(this);
                }
              }
              if (v.active) {
                this.decActiveCount();
              }
            }
          }
          incActiveCount() {
            // Ensure that texture source's activeCount has transferred ownership.
            var source = this.source;
            if (source) {
              this._checkForNewerReusableTextureSource();
            }
            this._activeCount++;
            if (this._activeCount === 1) {
              this.becomesUsed();
            }
          }
          decActiveCount() {
            this.source; // Force updating the source.
            this._activeCount--;
            if (!this._activeCount) {
              this.becomesUnused();
            }
          }
          becomesUsed() {
            if (this.source) {
              this.source.incActiveTextureCount();
            }
          }
          onLoad() {
            if (this._resizeMode) {
              this._applyResizeMode();
            }
            this.elements.forEach(element => {
              if (element.active) {
                element.onTextureSourceLoaded();
              }
            });
          }
          _checkForNewerReusableTextureSource() {
            // When this source became unused and cleaned up, it may have disappeared from the reusable texture map.
            // In the meantime another texture may have been generated loaded with the same lookup id.
            // If this is the case, use that one instead to make sure only one active texture source per lookup id exists.
            var source = this.source;
            if (!source.isLoaded()) {
              var reusable = this._getReusableTextureSource();
              if (reusable && reusable.isLoaded() && reusable !== source) {
                this._replaceTextureSource(reusable);
              }
            } else {
              if (this._resizeMode) {
                this._applyResizeMode();
              }
            }
          }
          becomesUnused() {
            if (this.source) {
              this.source.decActiveTextureCount();
            }
          }
          isUsed() {
            return this._activeCount > 0;
          }

          /**
           * Returns the lookup id for the current texture settings, to be able to reuse it.
           * @returns {string|null}
           */
          _getLookupId() {
            // Default: do not reuse texture.
            return null;
          }

          /**
           * Generates a loader function that is able to generate the texture for the current settings of this texture.
           * It should return a function that receives a single callback argument.
           * That callback should be called with the following arguments:
           *   - err
           *   - options: object
           *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
           *     - w: Number
           *     - h: Number
           *     - permanent: Boolean
           *     - hasAlpha: boolean
           *     - permultiplyAlpha: boolean
           *     - flipBlueRed: boolean
           *     - renderInfo: object
           * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
           * to stop fetching an image when it is no longer in element, for example.
           */
          _getSourceLoader() {
            throw new Error("Texture.generate must be implemented.");
          }
          get isValid() {
            return this._getIsValid();
          }

          /**
           * If texture is not 'valid', no source can be created for it.
           * @returns {boolean}
           */
          _getIsValid() {
            return true;
          }

          /**
           * This must be called when the texture source must be re-generated.
           */
          _changed() {
            // If no element is actively using this texture, ignore it altogether.
            if (this.isUsed()) {
              this._updateSource();
            } else {
              this._mustUpdate = true;
            }
          }
          _updateSource() {
            // We delay all updateSource calls to the next drawFrame, so that we can bundle them.
            // Otherwise we may reload a texture more often than necessary, when, for example, patching multiple text
            // properties.
            this.stage.addUpdateSourceTexture(this);
          }
          _performUpdateSource() {
            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            // If, in the meantime, the texture was no longer used, just remember that it must update until it becomes used
            // again.
            if (force || this.isUsed()) {
              this._mustUpdate = false;
              var source = this._getTextureSource();
              this._replaceTextureSource(source);
            }
          }
          _getTextureSource() {
            var source = null;
            if (this._getIsValid()) {
              var lookupId = this._getLookupId();
              source = this._getReusableTextureSource(lookupId);
              if (!source) {
                source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
              }
            }
            return source;
          }
          _getReusableTextureSource() {
            var lookupId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._getLookupId();
            if (this._getIsValid()) {
              if (lookupId) {
                return this.manager.getReusableTextureSource(lookupId);
              }
            }
            return null;
          }
          _replaceTextureSource() {
            var newSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var oldSource = this._source;
            this._source = newSource;
            if (this.elements.size) {
              if (oldSource) {
                if (this._activeCount) {
                  oldSource.decActiveTextureCount();
                }
                oldSource.removeTexture(this);

                // free up unused TextTextures immediately as they are not reused anyway
                if (this['text'] && !oldSource.isUsed()) {
                  this.manager.freeTextureSource(oldSource);
                }
              }
              if (newSource) {
                // Must happen before setDisplayedTexture to ensure sprite map texcoords are used.
                newSource.addTexture(this);
                if (this._activeCount) {
                  newSource.incActiveTextureCount();
                }
              }
            }
            if (this.isUsed()) {
              if (newSource) {
                if (newSource.isLoaded()) {
                  // Apply resizeMode
                  if (this._resizeMode) {
                    this._applyResizeMode();
                  }
                  this.elements.forEach(element => {
                    if (element.active) {
                      element._setDisplayedTexture(this);
                    }
                  });
                } else {
                  var loadError = newSource.loadError;
                  if (loadError) {
                    this.elements.forEach(element => {
                      if (element.active) {
                        element.onTextureSourceLoadError(loadError);
                      }
                    });
                  }
                }
              } else {
                this.elements.forEach(element => {
                  if (element.active) {
                    element._setDisplayedTexture(null);
                  }
                });
              }
            }
          }
          load() {
            // Make sure that source is up to date.
            if (this.source) {
              if (!this.isLoaded()) {
                this.source.load(true);
              }
            }
          }
          isLoaded() {
            return this._source && this._source.isLoaded();
          }
          get loadError() {
            return this._source && this._source.loadError;
          }
          free() {
            if (this._source) {
              this._source.free();
            }
          }
          set resizeMode(_ref) {
            var _ref$type = _ref.type,
              type = _ref$type === void 0 ? "cover" : _ref$type,
              _ref$w = _ref.w,
              w = _ref$w === void 0 ? 0 : _ref$w,
              _ref$h = _ref.h,
              h = _ref$h === void 0 ? 0 : _ref$h,
              _ref$clipX = _ref.clipX,
              clipX = _ref$clipX === void 0 ? 0.5 : _ref$clipX,
              _ref$clipY = _ref.clipY,
              clipY = _ref$clipY === void 0 ? 0.5 : _ref$clipY;
            this._resizeMode = {
              type,
              w,
              h,
              clipX,
              clipY
            };
            if (this.isLoaded()) {
              this._applyResizeMode();
            }
          }
          get resizeMode() {
            return this._resizeMode;
          }
          _clearResizeMode() {
            this._resizeMode = null;
          }
          _applyResizeMode() {
            if (this._resizeMode.type === "cover") {
              this._applyResizeCover();
            } else if (this._resizeMode.type === "contain") {
              this._applyResizeContain();
            }
            this._updatePrecision();
            this._updateClipping();
          }
          _applyResizeCover() {
            var scaleX = this._resizeMode.w / this._source.w;
            var scaleY = this._resizeMode.h / this._source.h;
            var scale = Math.max(scaleX, scaleY);
            if (!scale) return;
            this._precision = 1 / scale;
            if (scaleX && scaleX < scale) {
              var desiredSize = this._precision * this._resizeMode.w;
              var choppedOffPixels = this._source.w - desiredSize;
              this._x = choppedOffPixels * this._resizeMode.clipX;
              this._w = this._source.w - choppedOffPixels;
            }
            if (scaleY && scaleY < scale) {
              var _desiredSize = this._precision * this._resizeMode.h;
              var _choppedOffPixels = this._source.h - _desiredSize;
              this._y = _choppedOffPixels * this._resizeMode.clipY;
              this._h = this._source.h - _choppedOffPixels;
            }
          }
          _applyResizeContain() {
            var scaleX = this._resizeMode.w / this._source.w;
            var scaleY = this._resizeMode.h / this._source.h;
            var scale = scaleX;
            if (!scale || scaleY < scale) {
              scale = scaleY;
            }
            if (!scale) return;
            this._precision = 1 / scale;
          }
          enableClipping(x, y, w, h) {
            this._clearResizeMode();
            x *= this._precision;
            y *= this._precision;
            w *= this._precision;
            h *= this._precision;
            if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
              this._x = x;
              this._y = y;
              this._w = w;
              this._h = h;
              this._updateClipping(true);
            }
          }
          disableClipping() {
            this._clearResizeMode();
            if (this._x || this._y || this._w || this._h) {
              this._x = 0;
              this._y = 0;
              this._w = 0;
              this._h = 0;
              this._updateClipping();
            }
          }
          _updateClipping() {
            this.clipping = !!(this._x || this._y || this._w || this._h);
            var self = this;
            this.elements.forEach(function (element) {
              // Ignore if not the currently displayed texture.
              if (element.displayedTexture === self) {
                element.onDisplayedTextureClippingChanged();
              }
            });
          }
          _updatePrecision() {
            var self = this;
            this.elements.forEach(function (element) {
              // Ignore if not the currently displayed texture.
              if (element.displayedTexture === self) {
                element.onPrecisionChanged();
              }
            });
          }
          getNonDefaults() {
            var nonDefaults = {};
            nonDefaults['type'] = this.constructor.name;
            if (this.x !== 0) nonDefaults['x'] = this.x;
            if (this.y !== 0) nonDefaults['y'] = this.y;
            if (this.w !== 0) nonDefaults['w'] = this.w;
            if (this.h !== 0) nonDefaults['h'] = this.h;
            if (this.precision !== 1) nonDefaults['precision'] = this.precision;
            return nonDefaults;
          }
          get px() {
            return this._x;
          }
          get py() {
            return this._y;
          }
          get pw() {
            return this._w;
          }
          get ph() {
            return this._h;
          }
          get x() {
            return this._x / this._precision;
          }
          set x(v) {
            this._clearResizeMode();
            v = v * this._precision;
            if (this._x !== v) {
              this._x = v;
              this._updateClipping();
            }
          }
          get y() {
            return this._y / this._precision;
          }
          set y(v) {
            this._clearResizeMode();
            v = v * this._precision;
            if (this._y !== v) {
              this._y = v;
              this._updateClipping();
            }
          }
          get w() {
            return this._w / this._precision;
          }
          set w(v) {
            this._clearResizeMode();
            v = v * this._precision;
            if (this._w !== v) {
              this._w = v;
              this._updateClipping();
            }
          }
          get h() {
            return this._h / this._precision;
          }
          set h(v) {
            this._clearResizeMode();
            v = v * this._precision;
            if (this._h !== v) {
              this._h = v;
              this._updateClipping();
            }
          }
          get precision() {
            return this._precision;
          }
          set precision(v) {
            this._clearResizeMode();
            if (this._precision !== v) {
              this._precision = v;
              this._updatePrecision();
            }
          }
          isAutosizeTexture() {
            return true;
          }
          getRenderWidth() {
            if (!this.isAutosizeTexture()) {
              // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
              return 0;
            }

            // If dimensions are unknown (texture not yet loaded), use maximum width as a fallback as render width to allow proper bounds checking.
            return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
          }
          getRenderHeight() {
            if (!this.isAutosizeTexture()) {
              // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
              return 0;
            }
            return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
        }
        Texture.prototype.isTexture = true;
        Texture.id = 0;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ImageTexture extends Texture {
          constructor(stage) {
            super(stage);
            this._src = undefined;
            this._hasAlpha = false;
          }
          get src() {
            return this._src;
          }
          set src(v) {
            if (this._src !== v) {
              this._src = v;
              this._changed();
            }
          }
          get hasAlpha() {
            return this._hasAlpha;
          }
          set hasAlpha(v) {
            if (this._hasAlpha !== v) {
              this._hasAlpha = v;
              this._changed();
            }
          }
          _getIsValid() {
            return !!this._src;
          }
          _getLookupId() {
            return this._src;
          }
          _getSourceLoader() {
            var src = this._src;
            var hasAlpha = this._hasAlpha;
            if (this.stage.getOption('srcBasePath')) {
              var fc = src.charCodeAt(0);
              if (src.indexOf("//") === -1 && (fc >= 65 && fc <= 90 || fc >= 97 && fc <= 122 || fc == 46)) {
                // Alphabetical or dot: prepend base path.
                src = this.stage.getOption('srcBasePath') + src;
              }
            }
            return cb => {
              return this.stage.platform.loadSrcTexture({
                src: src,
                hasAlpha: hasAlpha
              }, cb);
            };
          }
          getNonDefaults() {
            var obj = super.getNonDefaults();
            if (this._src) {
              obj.src = this._src;
            }
            return obj;
          }
        }

        /**
         * Returns CSS font setting string for use in canvas context.
         *
         * @private
         * @param {string | string[]} fontFace
         * @param {string} fontStyle
         * @param {number} fontSize
         * @param {number} precision
         * @param {string} defaultFontFace
         * @returns {string}
         */
        function getFontSetting(fontFace, fontStyle, fontSize, precision, defaultFontFace) {
          var ff = fontFace;
          if (!Array.isArray(ff)) {
            ff = [ff];
          }
          var ffs = [];
          for (var i = 0, n = ff.length; i < n; i++) {
            var curFf = ff[i];
            // Replace the default font face `null` with the actual default font face set
            // on the stage.
            if (curFf === null) {
              curFf = defaultFontFace;
            }
            if (curFf === "serif" || curFf === "sans-serif") {
              ffs.push(curFf);
            } else {
              ffs.push(`"${curFf}"`);
            }
          }
          return `${fontStyle} ${fontSize * precision}px ${ffs.join(",")}`;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TextTextureRenderer {
          constructor(stage, canvas, settings) {
            this._stage = stage;
            this._canvas = canvas;
            this._context = this._canvas.getContext('2d');
            this._settings = settings;
          }
          getPrecision() {
            return this._settings.precision;
          }
          setFontProperties() {
            this._context.font = getFontSetting(this._settings.fontFace, this._settings.fontStyle, this._settings.fontSize, this.getPrecision(), this._stage.getOption('defaultFontFace'));
            this._context.textBaseline = this._settings.textBaseline;
          }
          _load() {
            if (Utils$2.isWeb && document.fonts) {
              var fontSetting = getFontSetting(this._settings.fontFace, this._settings.fontStyle, this._settings.fontSize, this.getPrecision(), this._stage.getOption('defaultFontFace'));
              try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                  // Use a promise that waits for loading.
                  return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                    // Just load the fallback font.
                    console.warn('[Lightning] Font load error', err, fontSetting);
                  }).then(() => {
                    if (!document.fonts.check(fontSetting, this._settings.text)) {
                      console.warn('[Lightning] Font not found', fontSetting);
                    }
                  });
                }
              } catch (e) {
                console.warn("[Lightning] Can't check font loading for " + fontSetting);
              }
            }
          }
          draw() {
            // We do not use a promise so that loading is performed syncronous when possible.
            var loadPromise = this._load();
            if (!loadPromise) {
              return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
            } else {
              return loadPromise.then(() => {
                return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
              });
            }
          }
          _calculateRenderInfo() {
            var renderInfo = {};
            var precision = this.getPrecision();
            var paddingLeft = this._settings.paddingLeft * precision;
            var paddingRight = this._settings.paddingRight * precision;
            var fontSize = this._settings.fontSize * precision;
            var offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision;
            var lineHeight = this._settings.lineHeight * precision;
            var w = this._settings.w * precision;
            var h = this._settings.h * precision;
            var wordWrapWidth = this._settings.wordWrapWidth * precision;
            var cutSx = this._settings.cutSx * precision;
            var cutEx = this._settings.cutEx * precision;
            var cutSy = this._settings.cutSy * precision;
            var cutEy = this._settings.cutEy * precision;
            var letterSpacing = (this._settings.letterSpacing || 0) * precision;
            var textIndent = this._settings.textIndent * precision;

            // Set font properties.
            this.setFontProperties();

            // Total width.
            var width = w || 2048 / this.getPrecision();

            // Inner width.
            var innerWidth = width - paddingLeft;
            if (innerWidth < 10) {
              width += 10 - innerWidth;
              innerWidth = 10;
            }
            if (!wordWrapWidth) {
              wordWrapWidth = innerWidth;
            }

            // Text overflow
            if (this._settings.textOverflow && !this._settings.wordWrap) {
              var suffix;
              switch (this._settings.textOverflow) {
                case 'clip':
                  suffix = '';
                  break;
                case 'ellipsis':
                  suffix = this._settings.maxLinesSuffix;
                  break;
                default:
                  suffix = this._settings.textOverflow;
              }
              this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
            }

            // word wrap
            // preserve original text
            var linesInfo;
            if (this._settings.wordWrap) {
              linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
            } else {
              linesInfo = {
                l: this._settings.text.split(/(?:\r\n|\r|\n)/),
                n: []
              };
              var n = linesInfo.l.length;
              for (var i = 0; i < n - 1; i++) {
                linesInfo.n.push(i);
              }
            }
            var lines = linesInfo.l;
            if (this._settings.maxLines && lines.length > this._settings.maxLines) {
              var usedLines = lines.slice(0, this._settings.maxLines);
              var otherLines = null;
              if (this._settings.maxLinesSuffix) {
                // Wrap again with max lines suffix enabled.
                var _w2 = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
                var al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - _w2, letterSpacing, textIndent);
                usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
                otherLines = [al.l.length > 1 ? al.l[1] : ''];
              } else {
                otherLines = [''];
              }

              // Re-assemble the remaining text.
              var _i7,
                _n6 = lines.length;
              var j = 0;
              var m = linesInfo.n.length;
              for (_i7 = this._settings.maxLines; _i7 < _n6; _i7++) {
                otherLines[j] += (otherLines[j] ? " " : "") + lines[_i7];
                if (_i7 + 1 < m && linesInfo.n[_i7 + 1]) {
                  j++;
                }
              }
              renderInfo.remainingText = otherLines.join("\n");
              renderInfo.moreTextLines = true;
              lines = usedLines;
            } else {
              renderInfo.moreTextLines = false;
              renderInfo.remainingText = "";
            }

            // calculate text width
            var maxLineWidth = 0;
            var lineWidths = [];
            for (var _i8 = 0; _i8 < lines.length; _i8++) {
              var lineWidth = this.measureText(lines[_i8], letterSpacing) + (_i8 === 0 ? textIndent : 0);
              lineWidths.push(lineWidth);
              maxLineWidth = Math.max(maxLineWidth, lineWidth);
            }
            renderInfo.lineWidths = lineWidths;
            if (!w) {
              // Auto-set width to max text length.
              width = maxLineWidth + paddingLeft + paddingRight;
              innerWidth = maxLineWidth;
            }

            // calculate text height
            lineHeight = lineHeight || fontSize;
            var height;
            if (h) {
              height = h;
            } else {
              var baselineOffset = this._settings.textBaseline != 'bottom' ? 0.5 * fontSize : 0;
              height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
            }
            if (offsetY === null) {
              offsetY = fontSize;
            }
            renderInfo.w = width;
            renderInfo.h = height;
            renderInfo.lines = lines;
            renderInfo.precision = precision;
            if (!width) {
              // To prevent canvas errors.
              width = 1;
            }
            if (!height) {
              // To prevent canvas errors.
              height = 1;
            }
            if (cutSx || cutEx) {
              width = Math.min(width, cutEx - cutSx);
            }
            if (cutSy || cutEy) {
              height = Math.min(height, cutEy - cutSy);
            }
            renderInfo.width = width;
            renderInfo.innerWidth = innerWidth;
            renderInfo.height = height;
            renderInfo.fontSize = fontSize;
            renderInfo.cutSx = cutSx;
            renderInfo.cutSy = cutSy;
            renderInfo.cutEx = cutEx;
            renderInfo.cutEy = cutEy;
            renderInfo.lineHeight = lineHeight;
            renderInfo.lineWidths = lineWidths;
            renderInfo.offsetY = offsetY;
            renderInfo.paddingLeft = paddingLeft;
            renderInfo.paddingRight = paddingRight;
            renderInfo.letterSpacing = letterSpacing;
            renderInfo.textIndent = textIndent;
            return renderInfo;
          }
          _draw() {
            var renderInfo = this._calculateRenderInfo();
            var precision = this.getPrecision();

            // Add extra margin to prevent issue with clipped text when scaling.
            this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption('textRenderIssueMargin'));
            this._canvas.height = Math.ceil(renderInfo.height);

            // Canvas context has been reset.
            this.setFontProperties();
            if (renderInfo.fontSize >= 128) {
              // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
              this._context.globalAlpha = 0.01;
              this._context.fillRect(0, 0, 0.01, 0.01);
              this._context.globalAlpha = 1.0;
            }
            if (renderInfo.cutSx || renderInfo.cutSy) {
              this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
            }
            var linePositionX;
            var linePositionY;
            var drawLines = [];

            // Draw lines line by line.
            for (var i = 0, n = renderInfo.lines.length; i < n; i++) {
              linePositionX = i === 0 ? renderInfo.textIndent : 0;

              // By default, text is aligned to top
              linePositionY = i * renderInfo.lineHeight + renderInfo.offsetY;
              if (this._settings.verticalAlign == 'middle') {
                linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
              } else if (this._settings.verticalAlign == 'bottom') {
                linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
              }
              if (this._settings.textAlign === 'right') {
                linePositionX += renderInfo.innerWidth - renderInfo.lineWidths[i];
              } else if (this._settings.textAlign === 'center') {
                linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2;
              }
              linePositionX += renderInfo.paddingLeft;
              drawLines.push({
                text: renderInfo.lines[i],
                x: linePositionX,
                y: linePositionY,
                w: renderInfo.lineWidths[i]
              });
            }

            // Highlight.
            if (this._settings.highlight) {
              var color = this._settings.highlightColor || 0x00000000;
              var hlHeight = this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5;
              var offset = this._settings.highlightOffset * precision;
              var hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft;
              var hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight;
              this._context.fillStyle = StageUtils.getRgbaString(color);
              for (var _i9 = 0; _i9 < drawLines.length; _i9++) {
                var drawLine = drawLines[_i9];
                this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
              }
            }

            // Text shadow.
            var prevShadowSettings = null;
            if (this._settings.shadow) {
              prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
              this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
              this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
              this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
              this._context.shadowBlur = this._settings.shadowBlur * precision;
            }
            this._context.fillStyle = StageUtils.getRgbaString(this._settings.textColor);
            for (var _i10 = 0, _n7 = drawLines.length; _i10 < _n7; _i10++) {
              var _drawLine = drawLines[_i10];
              if (renderInfo.letterSpacing === 0) {
                this._context.fillText(_drawLine.text, _drawLine.x, _drawLine.y);
              } else {
                var textSplit = _drawLine.text.split('');
                var x = _drawLine.x;
                for (var _i11 = 0, j = textSplit.length; _i11 < j; _i11++) {
                  this._context.fillText(textSplit[_i11], x, _drawLine.y);
                  x += this.measureText(textSplit[_i11], renderInfo.letterSpacing);
                }
              }
            }
            if (prevShadowSettings) {
              this._context.shadowColor = prevShadowSettings[0];
              this._context.shadowOffsetX = prevShadowSettings[1];
              this._context.shadowOffsetY = prevShadowSettings[2];
              this._context.shadowBlur = prevShadowSettings[3];
            }
            if (renderInfo.cutSx || renderInfo.cutSy) {
              this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
            }
            this.renderInfo = renderInfo;
          }
          wrapWord(word, wordWrapWidth, suffix) {
            var suffixWidth = this._context.measureText(suffix).width;
            var wordLen = word.length;
            var wordWidth = this._context.measureText(word).width;

            /* If word fits wrapWidth, do nothing */
            if (wordWidth <= wordWrapWidth) {
              return word;
            }

            /* Make initial guess for text cuttoff */
            var cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
            var truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

            /* In case guess was overestimated, shrink it letter by letter. */
            if (truncWordWidth > wordWrapWidth) {
              while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                  cutoffIndex -= 1;
                } else {
                  break;
                }
              }

              /* In case guess was underestimated, extend it letter by letter. */
            } else {
              while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                  cutoffIndex += 1;
                } else {
                  // Finally, when bound is crossed, retract last letter.
                  cutoffIndex -= 1;
                  break;
                }
              }
            }

            /* If wrapWidth is too short to even contain suffix alone, return empty string */
            return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
          }

          /**
           * Applies newlines to a string to have it optimally fit into the horizontal
           * bounds set by the Text object's wordWrapWidth property.
           */
          wrapText(text, wordWrapWidth, letterSpacing) {
            var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            // Greedy wrapping algorithm that will wrap words as the line grows longer.
            // than its horizontal bounds.
            var lines = text.split(/\r?\n/g);
            var allLines = [];
            var realNewlines = [];
            for (var i = 0; i < lines.length; i++) {
              var resultLines = [];
              var result = '';
              var spaceLeft = wordWrapWidth - indent;
              var words = lines[i].split(' ');
              for (var j = 0; j < words.length; j++) {
                var wordWidth = this.measureText(words[j], letterSpacing);
                var wordWidthWithSpace = wordWidth + this.measureText(' ', letterSpacing);
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                  // Skip printing the newline if it's the first word of the line that is.
                  // greater than the word wrap width.
                  if (j > 0) {
                    resultLines.push(result);
                    result = '';
                  }
                  result += words[j];
                  spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                } else {
                  spaceLeft -= wordWidthWithSpace;
                  result += ' ' + words[j];
                }
              }
              resultLines.push(result);
              result = '';
              allLines = allLines.concat(resultLines);
              if (i < lines.length - 1) {
                realNewlines.push(allLines.length);
              }
            }
            return {
              l: allLines,
              n: realNewlines
            };
          }
          measureText(word) {
            var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (!space) {
              return this._context.measureText(word).width;
            }
            return word.split('').reduce((acc, char) => {
              return acc + this._context.measureText(char).width + space;
            }, 0);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TextTextureRendererAdvanced {
          constructor(stage, canvas, settings) {
            this._stage = stage;
            this._canvas = canvas;
            this._context = this._canvas.getContext('2d');
            this._settings = settings;
          }
          getPrecision() {
            return this._settings.precision;
          }
          setFontProperties() {
            var font = getFontSetting(this._settings.fontFace, this._settings.fontStyle, this._settings.fontSize, this.getPrecision(), this._stage.getOption('defaultFontFace'));
            this._context.font = font;
            this._context.textBaseline = this._settings.textBaseline;
            return font;
          }
          _load() {
            if (Utils$2.isWeb && document.fonts) {
              var fontSetting = getFontSetting(this._settings.fontFace, this._settings.fontStyle, this._settings.fontSize, this.getPrecision(), this._stage.getOption('defaultFontFace'));
              try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                  // Use a promise that waits for loading.
                  return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                    // Just load the fallback font.
                    console.warn('Font load error', err, fontSetting);
                  }).then(() => {
                    if (!document.fonts.check(fontSetting, this._settings.text)) {
                      console.warn('Font not found', fontSetting);
                    }
                  });
                }
              } catch (e) {
                console.warn("Can't check font loading for " + fontSetting);
              }
            }
          }
          draw() {
            // We do not use a promise so that loading is performed syncronous when possible.
            var loadPromise = this._load();
            if (!loadPromise) {
              return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
            } else {
              return loadPromise.then(() => {
                return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
              });
            }
          }
          _calculateRenderInfo() {
            var renderInfo = {};
            var precision = this.getPrecision();
            var paddingLeft = this._settings.paddingLeft * precision;
            var paddingRight = this._settings.paddingRight * precision;
            var fontSize = this._settings.fontSize * precision;
            // const offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
            var lineHeight = this._settings.lineHeight * precision || fontSize;
            var w = this._settings.w != 0 ? this._settings.w * precision : 2048 / precision;
            // const h = this._settings.h * precision;
            var wordWrapWidth = this._settings.wordWrapWidth * precision;
            var cutSx = this._settings.cutSx * precision;
            var cutEx = this._settings.cutEx * precision;
            var cutSy = this._settings.cutSy * precision;
            var cutEy = this._settings.cutEy * precision;
            var letterSpacing = this._settings.letterSpacing || 0;

            // Set font properties.
            renderInfo.baseFont = this.setFontProperties();
            renderInfo.w = w;
            renderInfo.width = w;
            renderInfo.text = this._settings.text;
            renderInfo.precision = precision;
            renderInfo.fontSize = fontSize;
            renderInfo.fontBaselineRatio = this._settings.fontBaselineRatio;
            renderInfo.lineHeight = lineHeight;
            renderInfo.letterSpacing = letterSpacing;
            renderInfo.textAlign = this._settings.textAlign;
            renderInfo.textColor = this._settings.textColor;
            renderInfo.verticalAlign = this._settings.verticalAlign;
            renderInfo.highlight = this._settings.highlight;
            renderInfo.highlightColor = this._settings.highlightColor;
            renderInfo.highlightHeight = this._settings.highlightHeight;
            renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
            renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
            renderInfo.highlightOffset = this._settings.highlightOffset;
            renderInfo.paddingLeft = this._settings.paddingLeft;
            renderInfo.paddingRight = this._settings.paddingRight;
            renderInfo.maxLines = this._settings.maxLines;
            renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
            renderInfo.textOverflow = this._settings.textOverflow;
            renderInfo.wordWrap = this._settings.wordWrap;
            renderInfo.wordWrapWidth = wordWrapWidth;
            renderInfo.shadow = this._settings.shadow;
            renderInfo.shadowColor = this._settings.shadowColor;
            renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
            renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
            renderInfo.shadowBlur = this._settings.shadowBlur;
            renderInfo.cutSx = cutSx;
            renderInfo.cutEx = cutEx;
            renderInfo.cutSy = cutSy;
            renderInfo.cutEy = cutEy;
            renderInfo.textIndent = this._settings.textIndent * precision;
            renderInfo.wordBreak = this._settings.wordBreak;
            var text = renderInfo.text;
            var wrapWidth = renderInfo.wordWrap ? renderInfo.wordWrapWidth || renderInfo.width : renderInfo.width;

            // Text overflow
            if (renderInfo.textOverflow && !renderInfo.wordWrap) {
              var suffix;
              switch (this._settings.textOverflow) {
                case 'clip':
                  suffix = '';
                  break;
                case 'ellipsis':
                  suffix = this._settings.maxLinesSuffix;
                  break;
                default:
                  suffix = this._settings.textOverflow;
              }
              text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
            }
            text = this.tokenize(text);
            text = this.parse(text);
            text = this.measure(text, letterSpacing, renderInfo.baseFont);
            if (renderInfo.textIndent) {
              text = this.indent(text, renderInfo.textIndent);
            }
            if (renderInfo.wordBreak) {
              text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), []);
              this.resetFontStyle();
            }

            // Calculate detailed drawing information
            var x = paddingLeft;
            var lineNo = 0;
            var _iterator6 = _createForOfIteratorHelper(text),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var t = _step6.value;
                // Wrap text
                if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == '\n') {
                  x = paddingLeft;
                  lineNo += 1;
                }
                t.lineNo = lineNo;
                if (t.text == '\n') {
                  continue;
                }
                t.x = x;
                x += t.width;
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
            renderInfo.lineNum = lineNo + 1;
            if (this._settings.h) {
              renderInfo.h = this._settings.h;
            } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
              renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
            } else {
              renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
            }

            // This calculates the baseline offset in pixels from the font size.
            // To retrieve this ratio, you would do this calculation:
            //     (FontUnitsPerEm  hhea.Ascender  hhea.Descender) / (2  FontUnitsPerEm)
            //
            // This give you the ratio for the baseline, which is then used to figure out
            // where the baseline is relative to the bottom of the text bounding box.
            var baselineOffsetInPx = renderInfo.fontBaselineRatio * renderInfo.fontSize;

            // Vertical align
            var vaOffset = 0;
            if (renderInfo.verticalAlign == 'top' && this._context.textBaseline == 'alphabetic') {
              vaOffset = -baselineOffsetInPx;
            } else if (renderInfo.verticalAlign == 'middle') {
              vaOffset = (renderInfo.lineHeight - renderInfo.fontSize - baselineOffsetInPx) / 2;
            } else if (this._settings.verticalAlign == 'bottom') {
              vaOffset = renderInfo.lineHeight - renderInfo.fontSize;
            }

            // Calculate lines information
            renderInfo.lines = [];
            for (var i = 0; i < renderInfo.lineNum; i++) {
              renderInfo.lines[i] = {
                width: 0,
                x: 0,
                y: renderInfo.lineHeight * i + vaOffset,
                text: []
              };
            }
            var _iterator7 = _createForOfIteratorHelper(text),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _t = _step7.value;
                renderInfo.lines[_t.lineNo].text.push(_t);
              }

              // Filter out white spaces at beginning and end of each line
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            var _iterator8 = _createForOfIteratorHelper(renderInfo.lines),
              _step8;
            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var _l2 = _step8.value;
                if (_l2.text.length == 0) {
                  continue;
                }
                var firstWord = _l2.text[0].text;
                var lastWord = _l2.text[_l2.text.length - 1].text;
                if (firstWord == '\n') {
                  _l2.text.shift();
                }
                if (lastWord == ' ' || lastWord == '\n') {
                  _l2.text.pop();
                }
              }

              // Calculate line width
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
            var _iterator9 = _createForOfIteratorHelper(renderInfo.lines),
              _step9;
            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                var _l3 = _step9.value;
                _l3.width = _l3.text.reduce((acc, t) => acc + t.width, 0);
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }
            renderInfo.width = this._settings.w != 0 ? this._settings.w * precision : Math.max(...renderInfo.lines.map(l => l.width)) + paddingRight;
            renderInfo.w = renderInfo.width;

            // Apply maxLinesSuffix
            if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
              var index = renderInfo.maxLines - 1;
              var lastLineText = text.filter(t => t.lineNo == index);
              var _suffix = renderInfo.maxLinesSuffix;
              _suffix = this.tokenize(_suffix);
              _suffix = this.parse(_suffix);
              _suffix = this.measure(_suffix, renderInfo.letterSpacing, renderInfo.baseFont);
              var _iterator10 = _createForOfIteratorHelper(_suffix),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var s = _step10.value;
                  s.lineNo = index;
                  s.x = 0;
                  lastLineText.push(s);
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
              var spl = _suffix.length + 1;
              var _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
              while (_w > renderInfo.width || lastLineText[lastLineText.length - spl].text == ' ') {
                lastLineText.splice(lastLineText.length - spl, 1);
                _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
                if (lastLineText.length < spl) {
                  break;
                }
              }
              this.alignLine(lastLineText, lastLineText[0].x);
              renderInfo.lines[index].text = lastLineText;
              renderInfo.lines[index].width = _w;
            }

            // Horizontal alignment offset
            if (renderInfo.textAlign == 'center') {
              var _iterator11 = _createForOfIteratorHelper(renderInfo.lines),
                _step11;
              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  var l = _step11.value;
                  l.x = (renderInfo.width - l.width - paddingLeft) / 2;
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }
            } else if (renderInfo.textAlign == 'right') {
              var _iterator12 = _createForOfIteratorHelper(renderInfo.lines),
                _step12;
              try {
                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                  var _l = _step12.value;
                  _l.x = renderInfo.width - _l.width - paddingLeft;
                }
              } catch (err) {
                _iterator12.e(err);
              } finally {
                _iterator12.f();
              }
            }
            return renderInfo;
          }
          _draw() {
            var renderInfo = this._calculateRenderInfo();
            var precision = this.getPrecision();
            var paddingLeft = renderInfo.paddingLeft * precision;

            // Set canvas dimensions
            var canvasWidth = renderInfo.w || renderInfo.width;
            if (renderInfo.cutSx || renderInfo.cutEx) {
              canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
            }
            var canvasHeight = renderInfo.h;
            if (renderInfo.cutSy || renderInfo.cutEy) {
              canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
            }
            this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption('textRenderIssueMargin'));
            this._canvas.height = Math.ceil(canvasHeight);

            // Canvas context has been reset.
            this.setFontProperties();
            if (renderInfo.fontSize >= 128) {
              // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
              this._context.globalAlpha = 0.01;
              this._context.fillRect(0, 0, 0.01, 0.01);
              this._context.globalAlpha = 1.0;
            }

            // Cut
            if (renderInfo.cutSx || renderInfo.cutSy) {
              this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
            }

            // Highlight
            if (renderInfo.highlight) {
              var hlColor = renderInfo.highlightColor || 0x00000000;
              var hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision : renderInfo.fontSize * 1.5;
              var hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision : 0;
              var hlPaddingLeft = renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision : renderInfo.paddingLeft;
              var hlPaddingRight = renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision : renderInfo.paddingRight;
              this._context.fillStyle = StageUtils.getRgbaString(hlColor);
              var lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum;
              for (var i = 0; i < lineNum; i++) {
                var l = renderInfo.lines[i];
                this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
              }
            }

            // Text shadow.
            var prevShadowSettings = null;
            if (this._settings.shadow) {
              prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
              this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
              this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
              this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
              this._context.shadowBlur = this._settings.shadowBlur * precision;
            }

            // Draw text
            var defaultColor = StageUtils.getRgbaString(this._settings.textColor);
            var currentColor = defaultColor;
            this._context.fillStyle = defaultColor;
            var _iterator13 = _createForOfIteratorHelper(renderInfo.lines),
              _step13;
            try {
              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                var line = _step13.value;
                var _iterator14 = _createForOfIteratorHelper(line.text),
                  _step14;
                try {
                  for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                    var t = _step14.value;
                    var lx = 0;
                    if (t.text == '\n') {
                      continue;
                    }
                    if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
                      continue;
                    }
                    if (t.color != currentColor) {
                      currentColor = t.color;
                      this._context.fillStyle = currentColor;
                    }
                    this._context.font = t.fontStyle;

                    // Draw with letter spacing
                    if (t.letters) {
                      var _iterator15 = _createForOfIteratorHelper(t.letters),
                        _step15;
                      try {
                        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                          var _l4 = _step15.value;
                          var _x = renderInfo.lines[t.lineNo].x + t.x + lx;
                          this._context.fillText(_l4.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                          lx += _l4.width;
                        }
                        // Standard drawing
                      } catch (err) {
                        _iterator15.e(err);
                      } finally {
                        _iterator15.f();
                      }
                    } else {
                      var _x2 = renderInfo.lines[t.lineNo].x + t.x;
                      this._context.fillText(t.text, _x2, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                    }
                  }
                } catch (err) {
                  _iterator14.e(err);
                } finally {
                  _iterator14.f();
                }
              }

              // Reset text shadow
            } catch (err) {
              _iterator13.e(err);
            } finally {
              _iterator13.f();
            }
            if (prevShadowSettings) {
              this._context.shadowColor = prevShadowSettings[0];
              this._context.shadowOffsetX = prevShadowSettings[1];
              this._context.shadowOffsetY = prevShadowSettings[2];
              this._context.shadowBlur = prevShadowSettings[3];
            }

            // Reset cut translation
            if (renderInfo.cutSx || renderInfo.cutSy) {
              this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
            }

            // Postprocess renderInfo.lines to be compatible with standard version
            renderInfo.lines = renderInfo.lines.map(l => l.text.reduce((acc, v) => acc + v.text, ''));
            if (renderInfo.maxLines) {
              renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
            }
            this.renderInfo = renderInfo;
          }
          measureText(word) {
            var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (!space) {
              return this._context.measureText(word).width;
            }
            return word.split('').reduce((acc, char) => {
              return acc + this._context.measureText(char).width + space;
            }, 0);
          }
          tokenize(text) {
            var re = / |\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g;
            var delimeters = text.match(re) || [];
            var words = text.split(re) || [];
            var final = [];
            for (var i = 0; i < words.length; i++) {
              final.push(words[i], delimeters[i]);
            }
            final.pop();
            return final.filter(word => word != '');
          }
          parse(tokens) {
            var italic = 0;
            var bold = 0;
            var colorStack = [StageUtils.getRgbaString(this._settings.textColor)];
            var color = 0;
            var colorRegexp = /<color=(0[xX][0-9a-fA-F]{8})>/;
            return tokens.map(t => {
              if (t == '<i>') {
                italic += 1;
                t = '';
              } else if (t == '</i>' && italic > 0) {
                italic -= 1;
                t = '';
              } else if (t == '<b>') {
                bold += 1;
                t = '';
              } else if (t == '</b>' && bold > 0) {
                bold -= 1;
                t = '';
              } else if (t == '</color>') {
                if (colorStack.length > 1) {
                  color -= 1;
                  colorStack.pop();
                }
                t = '';
              } else if (colorRegexp.test(t)) {
                var matched = colorRegexp.exec(t);
                colorStack.push(StageUtils.getRgbaString(parseInt(matched[1])));
                color += 1;
                t = '';
              }
              return {
                text: t,
                italic: italic,
                bold: bold,
                color: colorStack[color]
              };
            }).filter(o => o.text != '');
          }
          applyFontStyle(word, baseFont) {
            var font = baseFont;
            if (word.bold) {
              font = 'bold ' + font;
            }
            if (word.italic) {
              font = 'italic ' + font;
            }
            this._context.font = font;
            word.fontStyle = font;
          }
          resetFontStyle(baseFont) {
            this._context.font = baseFont;
          }
          measure(parsed) {
            var letterSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var baseFont = arguments.length > 2 ? arguments[2] : undefined;
            var _iterator16 = _createForOfIteratorHelper(parsed),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var p = _step16.value;
                this.applyFontStyle(p, baseFont);
                p.width = this.measureText(p.text, letterSpacing);

                // Letter by letter detail for letter spacing
                if (letterSpacing > 0) {
                  p.letters = p.text.split('').map(l => {
                    return {
                      text: l
                    };
                  });
                  var _iterator17 = _createForOfIteratorHelper(p.letters),
                    _step17;
                  try {
                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                      var l = _step17.value;
                      l.width = this.measureText(l.text, letterSpacing);
                    }
                  } catch (err) {
                    _iterator17.e(err);
                  } finally {
                    _iterator17.f();
                  }
                }
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            this.resetFontStyle(baseFont);
            return parsed;
          }
          indent(parsed, textIndent) {
            parsed.splice(0, 0, {
              text: "",
              width: textIndent
            });
            return parsed;
          }
          wrapWord(word, wordWrapWidth, suffix) {
            var suffixWidth = this._context.measureText(suffix).width;
            var wordLen = word.length;
            var wordWidth = this._context.measureText(word).width;

            /* If word fits wrapWidth, do nothing */
            if (wordWidth <= wordWrapWidth) {
              return word;
            }

            /* Make initial guess for text cuttoff */
            var cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
            var truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

            /* In case guess was overestimated, shrink it letter by letter. */
            if (truncWordWidth > wordWrapWidth) {
              while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                  cutoffIndex -= 1;
                } else {
                  break;
                }
              }

              /* In case guess was underestimated, extend it letter by letter. */
            } else {
              while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                  cutoffIndex += 1;
                } else {
                  // Finally, when bound is crossed, retract last letter.
                  cutoffIndex -= 1;
                  break;
                }
              }
            }

            /* If wrapWidth is too short to even contain suffix alone, return empty string */
            return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
          }
          _getBreakIndex(word, width) {
            var wordLen = word.length;
            var wordWidth = this.measureText(word);
            if (wordWidth <= width) {
              return {
                breakIndex: word.length,
                truncWordWidth: wordWidth
              };
            }
            var breakIndex = Math.floor(width * wordLen / wordWidth);
            var truncWordWidth = this.measureText(word.substring(0, breakIndex));

            /* In case guess was overestimated, shrink it letter by letter. */
            if (truncWordWidth > width) {
              while (breakIndex > 0) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth > width) {
                  breakIndex -= 1;
                } else {
                  break;
                }
              }

              /* In case guess was underestimated, extend it letter by letter. */
            } else {
              while (breakIndex < wordLen) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth < width) {
                  breakIndex += 1;
                } else {
                  // Finally, when bound is crossed, retract last letter.
                  breakIndex -= 1;
                  truncWordWidth = this.measureText(word.substring(0, breakIndex));
                  break;
                }
              }
            }
            return {
              breakIndex,
              truncWordWidth
            };
          }
          wordBreak(word, width, baseFont) {
            if (!word.text) {
              return word;
            }
            this.applyFontStyle(word, baseFont);
            var parts = [];
            var text = word.text;
            if (!word.letters) {
              while (true) {
                var _this$_getBreakIndex = this._getBreakIndex(text, width),
                  breakIndex = _this$_getBreakIndex.breakIndex,
                  truncWordWidth = _this$_getBreakIndex.truncWordWidth;
                parts.push(_objectSpread({}, word));
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = truncWordWidth;
                if (breakIndex === text.length) {
                  break;
                }
                text = text.slice(breakIndex);
              }
            } else {
              var totalWidth = 0;
              var letters = [];
              var _breakIndex = 0;
              var _iterator18 = _createForOfIteratorHelper(word.letters),
                _step18;
              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var l = _step18.value;
                  if (totalWidth + l.width >= width) {
                    parts.push(_objectSpread({}, word));
                    parts[parts.length - 1].text = text.slice(0, _breakIndex);
                    parts[parts.length - 1].width = totalWidth;
                    parts[parts.length - 1].letters = letters;
                    text = text.slice(_breakIndex);
                    totalWidth = 0;
                    letters = [];
                    _breakIndex = 0;
                  } else {
                    _breakIndex += 1;
                    letters.push(l);
                    totalWidth += l.width;
                  }
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
              if (totalWidth > 0) {
                parts.push(_objectSpread({}, word));
                parts[parts.length - 1].text = text.slice(0, _breakIndex);
                parts[parts.length - 1].width = totalWidth;
                parts[parts.length - 1].letters = letters;
              }
            }
            return parts;
          }
          alignLine(parsed) {
            var initialX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var prevWidth = 0;
            var prevX = initialX;
            var _iterator19 = _createForOfIteratorHelper(parsed),
              _step19;
            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var word = _step19.value;
                if (word.text == '\n') {
                  continue;
                }
                word.x = prevX + prevWidth;
                prevX = word.x;
                prevWidth = word.width;
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TextTexture extends Texture {
          constructor(stage) {
            super(stage);

            // We use the stage precision as the default precision in case of a text texture.
            this._precision = this.stage.getOption('precision');
          }
          static renderer(stage, canvas, settings) {
            if (this.advancedRenderer) {
              return new TextTextureRendererAdvanced(stage, canvas, settings);
            } else {
              return new TextTextureRenderer(stage, canvas, settings);
            }
          }
          get text() {
            return this._text;
          }
          set text(v) {
            if (this._text !== v) {
              this._text = "" + v;
              this._changed();
            }
          }
          get w() {
            return this._w;
          }
          set w(v) {
            if (this._w !== v) {
              this._w = v;
              this._changed();
            }
          }
          get h() {
            return this._h;
          }
          set h(v) {
            if (this._h !== v) {
              this._h = v;
              this._changed();
            }
          }
          get fontStyle() {
            return this._fontStyle;
          }
          set fontStyle(v) {
            if (this._fontStyle !== v) {
              this._fontStyle = v;
              this._changed();
            }
          }
          get fontBaselineRatio() {
            return this._fontBaselineRatio;
          }
          set fontBaselineRatio(v) {
            if (this._fontBaselineRatio !== v) {
              this._fontBaselineRatio = v;
              this._changed();
            }
          }
          get fontSize() {
            return this._fontSize;
          }
          set fontSize(v) {
            if (this._fontSize !== v) {
              this._fontSize = v;
              this._changed();
            }
          }
          get fontFace() {
            return this._fontFace;
          }
          set fontFace(v) {
            if (this._fontFace !== v) {
              this._fontFace = v;
              this._changed();
            }
          }
          get wordWrap() {
            return this._wordWrap;
          }
          set wordWrap(v) {
            if (this._wordWrap !== v) {
              this._wordWrap = v;
              this._changed();
            }
          }
          get wordWrapWidth() {
            return this._wordWrapWidth;
          }
          set wordWrapWidth(v) {
            if (this._wordWrapWidth !== v) {
              this._wordWrapWidth = v;
              this._changed();
            }
          }
          get wordBreak() {
            return this._wordBreak;
          }
          set wordBreak(v) {
            if (this._wordBreak !== v) {
              this._wordBreak = v;
              this._changed();
            }
          }
          get textOverflow() {
            return this._textOverflow;
          }
          set textOverflow(v) {
            if (v != this._textOverflow) {
              this._textOverflow = v;
              this._changed();
            }
          }
          get lineHeight() {
            return this._lineHeight;
          }
          set lineHeight(v) {
            if (this._lineHeight !== v) {
              this._lineHeight = v;
              this._changed();
            }
          }
          get textBaseline() {
            return this._textBaseline;
          }
          set textBaseline(v) {
            if (this._textBaseline !== v) {
              this._textBaseline = v;
              this._changed();
            }
          }
          get textAlign() {
            return this._textAlign;
          }
          set textAlign(v) {
            if (this._textAlign !== v) {
              this._textAlign = v;
              this._changed();
            }
          }
          get verticalAlign() {
            return this._verticalAlign;
          }
          set verticalAlign(v) {
            if (this._verticalAlign !== v) {
              this._verticalAlign = v;
              this._changed();
            }
          }
          get offsetY() {
            return this._offsetY;
          }
          set offsetY(v) {
            if (this._offsetY !== v) {
              this._offsetY = v;
              this._changed();
            }
          }
          get maxLines() {
            return this._maxLines;
          }
          set maxLines(v) {
            if (this._maxLines !== v) {
              this._maxLines = v;
              this._changed();
            }
          }
          get maxLinesSuffix() {
            return this._maxLinesSuffix;
          }
          set maxLinesSuffix(v) {
            if (this._maxLinesSuffix !== v) {
              this._maxLinesSuffix = v;
              this._changed();
            }
          }
          get textColor() {
            return this._textColor;
          }
          set textColor(v) {
            if (this._textColor !== v) {
              this._textColor = v;
              this._changed();
            }
          }
          get paddingLeft() {
            return this._paddingLeft;
          }
          set paddingLeft(v) {
            if (this._paddingLeft !== v) {
              this._paddingLeft = v;
              this._changed();
            }
          }
          get paddingRight() {
            return this._paddingRight;
          }
          set paddingRight(v) {
            if (this._paddingRight !== v) {
              this._paddingRight = v;
              this._changed();
            }
          }
          get shadow() {
            return this._shadow;
          }
          set shadow(v) {
            if (this._shadow !== v) {
              this._shadow = v;
              this._changed();
            }
          }
          get shadowColor() {
            return this._shadowColor;
          }
          set shadowColor(v) {
            if (this._shadowColor !== v) {
              this._shadowColor = v;
              this._changed();
            }
          }
          get shadowOffsetX() {
            return this._shadowOffsetX;
          }
          set shadowOffsetX(v) {
            if (this._shadowOffsetX !== v) {
              this._shadowOffsetX = v;
              this._changed();
            }
          }
          get shadowOffsetY() {
            return this._shadowOffsetY;
          }
          set shadowOffsetY(v) {
            if (this._shadowOffsetY !== v) {
              this._shadowOffsetY = v;
              this._changed();
            }
          }
          get shadowBlur() {
            return this._shadowBlur;
          }
          set shadowBlur(v) {
            if (this._shadowBlur !== v) {
              this._shadowBlur = v;
              this._changed();
            }
          }
          get highlight() {
            return this._highlight;
          }
          set highlight(v) {
            if (this._highlight !== v) {
              this._highlight = v;
              this._changed();
            }
          }
          get highlightHeight() {
            return this._highlightHeight;
          }
          set highlightHeight(v) {
            if (this._highlightHeight !== v) {
              this._highlightHeight = v;
              this._changed();
            }
          }
          get highlightColor() {
            return this._highlightColor;
          }
          set highlightColor(v) {
            if (this._highlightColor !== v) {
              this._highlightColor = v;
              this._changed();
            }
          }
          get highlightOffset() {
            return this._highlightOffset;
          }
          set highlightOffset(v) {
            if (this._highlightOffset !== v) {
              this._highlightOffset = v;
              this._changed();
            }
          }
          get highlightPaddingLeft() {
            return this._highlightPaddingLeft;
          }
          set highlightPaddingLeft(v) {
            if (this._highlightPaddingLeft !== v) {
              this._highlightPaddingLeft = v;
              this._changed();
            }
          }
          get highlightPaddingRight() {
            return this._highlightPaddingRight;
          }
          set highlightPaddingRight(v) {
            if (this._highlightPaddingRight !== v) {
              this._highlightPaddingRight = v;
              this._changed();
            }
          }
          get cutSx() {
            return this._cutSx;
          }
          set cutSx(v) {
            if (this._cutSx !== v) {
              this._cutSx = v;
              this._changed();
            }
          }
          get cutEx() {
            return this._cutEx;
          }
          set cutEx(v) {
            if (this._cutEx !== v) {
              this._cutEx = v;
              this._changed();
            }
          }
          get cutSy() {
            return this._cutSy;
          }
          set cutSy(v) {
            if (this._cutSy !== v) {
              this._cutSy = v;
              this._changed();
            }
          }
          get cutEy() {
            return this._cutEy;
          }
          set cutEy(v) {
            if (this._cutEy !== v) {
              this._cutEy = v;
              this._changed();
            }
          }
          get advancedRenderer() {
            return this._advancedRenderer;
          }
          set advancedRenderer(v) {
            if (this._advancedRenderer !== v) {
              this._advancedRenderer = v;
              this._changed();
            }
          }
          set letterSpacing(v) {
            if (this._letterSpacing !== v) {
              this._letterSpacing = v;
              this._changed();
            }
          }
          get letterSpacing() {
            return this._letterSpacing;
          }
          set textIndent(v) {
            if (this._textIndent !== v) {
              this._textIndent = v;
              this._changed();
            }
          }
          get textIndent() {
            return this._textIndent;
          }
          get precision() {
            return super.precision;
          }
          set precision(v) {
            // We actually draw differently when the precision changes.
            if (this.precision !== v) {
              super.precision = v;
              this._changed();
            }
          }
          _getIsValid() {
            return !!this.text;
          }
          _getLookupId() {
            var parts = [];
            if (this.w !== 0) parts.push("w " + this.w);
            if (this.h !== 0) parts.push("h " + this.h);
            if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
            if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
            if (this.fontBaselineRatio !== 0) parts.push('fb' + this.fontBaselineRatio);
            if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
            if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
            if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
            if (this.wordBreak !== false) parts.push("wb" + this.wordBreak ? 1 : 0);
            if (this.textOverflow != "") parts.push("to" + this.textOverflow);
            if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
            if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
            if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
            if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
            if (this.offsetY !== null) parts.push("oy" + this.offsetY);
            if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
            if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
            parts.push("pc" + this.precision);
            if (this.textColor !== 0xffffffff) parts.push("co" + this.textColor.toString(16));
            if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
            if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
            if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
            if (this.shadowColor !== 0xff000000) parts.push("sc" + this.shadowColor.toString(16));
            if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
            if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
            if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
            if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
            if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
            if (this.highlightColor !== 0xff000000) parts.push("hc" + this.highlightColor.toString(16));
            if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
            if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
            if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
            if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
            if (this.textIndent !== null) parts.push("ti" + this.textIndent);
            if (this.cutSx) parts.push("csx" + this.cutSx);
            if (this.cutEx) parts.push("cex" + this.cutEx);
            if (this.cutSy) parts.push("csy" + this.cutSy);
            if (this.cutEy) parts.push("cey" + this.cutEy);
            if (this.advancedRenderer) parts.push("aR" + this.advancedRenderer ? 1 : 0);
            var id = "TX$" + parts.join("|") + ":" + this.text;
            return id;
          }
          _getSourceLoader() {
            var args = this.cloneArgs();
            var gl = this.stage.gl;
            return function (cb) {
              var canvas = this.stage.platform.getDrawingCanvas();
              var renderer = args.advancedRenderer ? new TextTextureRendererAdvanced(this.stage, canvas, args) : new TextTextureRenderer(this.stage, canvas, args);
              var p = renderer.draw();
              var texParams = {};
              var sharpCfg = this.stage.getOption('fontSharp');
              var sharpen = false;

              // Prevent text blur when text texture is downscaled
              if (Utils$2.isBoolean(sharpCfg)) {
                sharpen = sharpCfg;
              } else if (Utils$2.isObject(sharpCfg)) {
                var _precision = this.stage.getRenderPrecision();
                sharpen = _precision <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
              }
              if (gl && sharpen) {
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
              }
              if (p) {
                p.then(() => {
                  /* FIXME: on some platforms (e.g. RPI), throttling text textures cause artifacts */
                  cb(null, Object.assign({
                    renderInfo: renderer.renderInfo,
                    throttle: false,
                    texParams: texParams
                  }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                }).catch(err => {
                  cb(err);
                });
              } else {
                cb(null, Object.assign({
                  renderInfo: renderer.renderInfo,
                  throttle: false,
                  texParams: texParams
                }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
              }
            };
          }
          getNonDefaults() {
            var nonDefaults = super.getNonDefaults();
            if (this.text !== "") nonDefaults['text'] = this.text;
            if (this.w !== 0) nonDefaults['w'] = this.w;
            if (this.h !== 0) nonDefaults['h'] = this.h;
            if (this.fontStyle !== "normal") nonDefaults['fontStyle'] = this.fontStyle;
            if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
            if (this.fontBaselineRatio !== 0) nonDefaults['fontBaselineRatio'] = this.fontBaselineRatio;
            if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
            if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
            if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
            if (this.wordBreak !== false) nonDefaults["wordBreak"] = this.wordBreak;
            if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
            if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
            if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
            if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
            if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
            if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
            if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
            if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
            if (this.precision !== this.stage.getOption('precision')) nonDefaults["precision"] = this.precision;
            if (this.textColor !== 0xffffffff) nonDefaults["textColor"] = this.textColor;
            if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
            if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
            if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
            if (this.shadowColor !== 0xff000000) nonDefaults["shadowColor"] = this.shadowColor;
            if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
            if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
            if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
            if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
            if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
            if (this.highlightColor !== 0xff000000) nonDefaults["highlightColor"] = this.highlightColor;
            if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
            if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
            if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
            if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
            if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;
            if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
            if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
            if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
            if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;
            if (this.advancedRenderer) nonDefaults["renderer"] = this.advancedRenderer;
            return nonDefaults;
          }
          cloneArgs() {
            var obj = {};
            obj.text = this._text;
            obj.w = this._w;
            obj.h = this._h;
            obj.fontStyle = this._fontStyle;
            obj.fontSize = this._fontSize;
            obj.fontBaselineRatio = this._fontBaselineRatio;
            obj.fontFace = this._fontFace;
            obj.wordWrap = this._wordWrap;
            obj.wordWrapWidth = this._wordWrapWidth;
            obj.wordBreak = this._wordBreak;
            obj.textOverflow = this._textOverflow;
            obj.lineHeight = this._lineHeight;
            obj.textBaseline = this._textBaseline;
            obj.textAlign = this._textAlign;
            obj.verticalAlign = this._verticalAlign;
            obj.offsetY = this._offsetY;
            obj.maxLines = this._maxLines;
            obj.maxLinesSuffix = this._maxLinesSuffix;
            obj.precision = this._precision;
            obj.textColor = this._textColor;
            obj.paddingLeft = this._paddingLeft;
            obj.paddingRight = this._paddingRight;
            obj.shadow = this._shadow;
            obj.shadowColor = this._shadowColor;
            obj.shadowOffsetX = this._shadowOffsetX;
            obj.shadowOffsetY = this._shadowOffsetY;
            obj.shadowBlur = this._shadowBlur;
            obj.highlight = this._highlight;
            obj.highlightHeight = this._highlightHeight;
            obj.highlightColor = this._highlightColor;
            obj.highlightOffset = this._highlightOffset;
            obj.highlightPaddingLeft = this._highlightPaddingLeft;
            obj.highlightPaddingRight = this._highlightPaddingRight;
            obj.letterSpacing = this._letterSpacing;
            obj.textIndent = this._textIndent;
            obj.cutSx = this._cutSx;
            obj.cutEx = this._cutEx;
            obj.cutSy = this._cutSy;
            obj.cutEy = this._cutEy;
            obj.advancedRenderer = this._advancedRenderer;
            return obj;
          }
        }

        // Because there are so many properties, we prefer to use the prototype for default values.
        // This causes a decrease in performance, but also a decrease in memory usage.
        var proto = TextTexture.prototype;
        proto._text = "";
        proto._w = 0;
        proto._h = 0;
        proto._fontStyle = "normal";
        proto._fontSize = 40;
        proto._fontFace = null;
        proto._wordWrap = true;
        proto._wordWrapWidth = 0;
        proto._wordBreak = false;
        proto._textOverflow = "";
        proto._lineHeight = null;
        proto._textBaseline = "alphabetic";
        proto._textAlign = "left";
        proto._verticalAlign = "top";
        proto._offsetY = null;
        proto._maxLines = 0;
        proto._maxLinesSuffix = "..";
        proto._textColor = 0xFFFFFFFF;
        proto._paddingLeft = 0;
        proto._paddingRight = 0;
        proto._shadow = false;
        proto._shadowColor = 0xFF000000;
        proto._shadowOffsetX = 0;
        proto._shadowOffsetY = 0;
        proto._shadowBlur = 5;
        proto._highlight = false;
        proto._highlightHeight = 0;
        proto._highlightColor = 0xFF000000;
        proto._highlightOffset = 0;
        proto._highlightPaddingLeft = 0;
        proto._highlightPaddingRight = 0;
        proto._letterSpacing = 0;
        proto._textIndent = 0;
        proto._cutSx = 0;
        proto._cutEx = 0;
        proto._cutSy = 0;
        proto._cutEy = 0;
        proto._advancedRenderer = false;
        proto._fontBaselineRatio = 0;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SourceTexture extends Texture {
          constructor(stage) {
            super(stage);
            this._textureSource = undefined;
          }
          get textureSource() {
            return this._textureSource;
          }
          set textureSource(v) {
            if (v !== this._textureSource) {
              if (v.isResultTexture) {
                // In case of a result texture, automatically inherit the precision.
                this._precision = this.stage.getRenderPrecision();
              }
              this._textureSource = v;
              this._changed();
            }
          }
          _getTextureSource() {
            return this._textureSource;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Transition extends EventEmitter {
          constructor(manager, settings, element, property) {
            super();
            this.manager = manager;
            this._settings = settings;
            this._element = element;
            this._getter = element.constructor.getGetter(property);
            this._setter = element.constructor.getSetter(property);
            this._merger = settings.merger;
            if (!this._merger) {
              this._merger = element.constructor.getMerger(property);
            }
            this._startValue = this._getter(this._element);
            this._targetValue = this._startValue;
            this._p = 1;
            this._delayLeft = 0;
          }
          start(targetValue) {
            this._startValue = this._getter(this._element);
            if (!this.isAttached()) {
              // We don't support transitions on non-attached elements. Just set value without invoking listeners.
              this._targetValue = targetValue;
              this._p = 1;
              this._updateDrawValue();
            } else {
              if (targetValue === this._startValue) {
                this.reset(targetValue, 1);
              } else {
                this._targetValue = targetValue;
                this._p = 0;
                this._delayLeft = this._settings.delay;
                this.emit('start');
                this.add();
              }
            }
          }
          finish() {
            if (this._p < 1) {
              // Value setting and will must be invoked (async) upon next transition cycle.
              this._p = 1;
            }
          }
          stop() {
            // Just stop where the transition is at.
            this.emit('stop');
            this.manager.removeActive(this);
          }
          pause() {
            this.stop();
          }
          play() {
            this.manager.addActive(this);
          }
          reset(targetValue, p) {
            if (!this.isAttached()) {
              // We don't support transitions on non-attached elements. Just set value without invoking listeners.
              this._startValue = this._getter(this._element);
              this._targetValue = targetValue;
              this._p = 1;
              this._updateDrawValue();
            } else {
              this._startValue = this._getter(this._element);
              this._targetValue = targetValue;
              this._p = p;
              this.add();
            }
          }
          _updateDrawValue() {
            this._setter(this._element, this.getDrawValue());
          }
          add() {
            this.manager.addActive(this);
          }
          isAttached() {
            return this._element.attached;
          }
          isRunning() {
            return this._p < 1.0;
          }
          progress(dt) {
            if (!this.isAttached()) {
              // Skip to end of transition so that it is removed.
              this._p = 1;
            }
            if (this.p < 1) {
              if (this.delayLeft > 0) {
                this._delayLeft -= dt;
                if (this.delayLeft < 0) {
                  dt = -this.delayLeft;
                  this._delayLeft = 0;
                  this.emit('delayEnd');
                } else {
                  return;
                }
              }
              if (this._settings.duration == 0) {
                this._p = 1;
              } else {
                this._p += dt / this._settings.duration;
              }
              if (this._p >= 1) {
                // Finished!;
                this._p = 1;
              }
            }
            this._updateDrawValue();
            this.invokeListeners();
          }
          invokeListeners() {
            this.emit('progress', this.p);
            if (this.p === 1) {
              this.emit('finish');
            }
          }
          updateTargetValue(targetValue) {
            var t = this._settings.timingFunctionImpl(this.p);
            if (t === 1) {
              this._targetValue = targetValue;
            } else if (t === 0) {
              this._startValue = this._targetValue;
              this._targetValue = targetValue;
            } else {
              this._startValue = targetValue - (targetValue - this._targetValue) / (1 - t);
              this._targetValue = targetValue;
            }
          }
          getDrawValue() {
            if (this.p >= 1) {
              return this.targetValue;
            } else {
              var v = this._settings._timingFunctionImpl(this.p);
              return this._merger(this.targetValue, this.startValue, v);
            }
          }
          skipDelay() {
            this._delayLeft = 0;
          }
          get startValue() {
            return this._startValue;
          }
          get targetValue() {
            return this._targetValue;
          }
          get p() {
            return this._p;
          }
          get delayLeft() {
            return this._delayLeft;
          }
          get element() {
            return this._element;
          }
          get settings() {
            return this._settings;
          }
          set settings(v) {
            this._settings = v;
          }
        }
        Transition.prototype.isTransition = true;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Manages a list of objects.
         * Objects may be patched. Then, they can be referenced using the 'ref' (string) property.
         */
        class ObjectList {
          constructor() {
            this._items = [];
            this._refs = {};
          }
          get() {
            return this._items;
          }
          get first() {
            return this._items[0];
          }
          get last() {
            return this._items.length ? this._items[this._items.length - 1] : undefined;
          }
          add(item) {
            this.addAt(item, this._items.length);
          }
          addAt(item, index) {
            if (index >= 0 && index <= this._items.length) {
              var currentIndex = this._items.indexOf(item);
              if (currentIndex === index) {
                return item;
              }
              if (Utils$2.isObjectLiteral(item)) {
                var o = item;
                item = this.createItem(o);
                item.patch(o);
              }
              if (currentIndex != -1) {
                this.setAt(item, index);
              } else {
                if (item.ref) {
                  this._refs[item.ref] = item;
                }
                this._items.splice(index, 0, item);
                this.onAdd(item, index);
              }
            } else {
              throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
            }
          }
          replaceByRef(item) {
            if (item.ref) {
              var existingItem = this.getByRef(item.ref);
              if (!existingItem) {
                throw new Error('replaceByRef: no item found with reference: ' + item.ref);
              }
              this.replace(item, existingItem);
            } else {
              throw new Error('replaceByRef: no ref specified in item');
            }
            this.addAt(item, this._items.length);
          }
          replace(item, prevItem) {
            var index = this.getIndex(prevItem);
            if (index === -1) {
              throw new Error('replace: The previous item does not exist');
            }
            this.setAt(item, index);
          }
          setAt(item, index) {
            if (index >= 0 && index < this._items.length) {
              if (Utils$2.isObjectLiteral(item)) {
                var o = item;
                item = this.createItem(o);
                item.patch(o);
              }
              var currentIndex = this._items.indexOf(item);
              if (currentIndex != -1) {
                if (currentIndex !== index) {
                  var fromIndex = currentIndex;
                  if (fromIndex !== index) {
                    this._items.splice(fromIndex, 1);
                    this._items.splice(index, 0, item);
                    this.onMove(item, fromIndex, index);
                  }
                }
              } else {
                if (index < this._items.length) {
                  if (this._items[index].ref) {
                    this._refs[this._items[index].ref] = undefined;
                  }
                }
                var prevItem = this._items[index];

                // Doesn't exist yet: overwrite current.
                this._items[index] = item;
                if (item.ref) {
                  this._refs[item.ref] = item;
                }
                this.onSet(item, index, prevItem);
              }
            } else {
              throw new Error('setAt: The index ' + index + ' is out of bounds ' + this._items.length);
            }
          }
          getAt(index) {
            return this._items[index];
          }
          getIndex(item) {
            return this._items.indexOf(item);
          }
          remove(item) {
            var index = this._items.indexOf(item);
            if (index !== -1) {
              this.removeAt(index);
            }
          }
          removeAt(index) {
            if (index >= 0 && index < this._items.length) {
              var item = this._items[index];
              if (item.ref) {
                this._refs[item.ref] = undefined;
              }
              this._items.splice(index, 1);
              this.onRemove(item, index);
              return item;
            } else {
              throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
            }
          }
          clear() {
            var n = this._items.length;
            if (n) {
              var prev = this._items;
              this._items = [];
              this._refs = {};
              this.onSync(prev, [], []);
            }
          }
          a(o) {
            if (Utils$2.isObjectLiteral(o)) {
              var c = this.createItem(o);
              c.patch(o);
              this.add(c);
              return c;
            } else if (Array.isArray(o)) {
              for (var i = 0, n = o.length; i < n; i++) {
                this.a(o[i]);
              }
              return null;
            } else if (this.isItem(o)) {
              this.add(o);
              return o;
            }
          }
          get length() {
            return this._items.length;
          }
          _getRefs() {
            return this._refs;
          }
          getByRef(ref) {
            return this._refs[ref];
          }
          clearRef(ref) {
            delete this._refs[ref];
          }
          setRef(ref, child) {
            this._refs[ref] = child;
          }
          patch(settings) {
            if (Utils$2.isObjectLiteral(settings)) {
              this._setByObject(settings);
            } else if (Array.isArray(settings)) {
              this._setByArray(settings);
            }
          }
          _setByObject(settings) {
            // Overrule settings of known referenced items.
            var refs = this._getRefs();
            var crefs = Object.keys(settings);
            for (var i = 0, n = crefs.length; i < n; i++) {
              var cref = crefs[i];
              var s = settings[cref];
              var c = refs[cref];
              if (!c) {
                if (this.isItem(s)) {
                  // Replace previous item;
                  s.ref = cref;
                  this.add(s);
                } else {
                  // Create new item.
                  c = this.createItem(s);
                  c.ref = cref;
                  c.patch(s);
                  this.add(c);
                }
              } else {
                if (this.isItem(s)) {
                  if (c !== s) {
                    // Replace previous item;
                    var idx = this.getIndex(c);
                    s.ref = cref;
                    this.setAt(s, idx);
                  }
                } else {
                  c.patch(s);
                }
              }
            }
          }
          _equalsArray(array) {
            var same = true;
            if (array.length === this._items.length) {
              for (var i = 0, n = this._items.length; i < n && same; i++) {
                same = same && this._items[i] === array[i];
              }
            } else {
              same = false;
            }
            return same;
          }
          _setByArray(array) {
            // For performance reasons, first check if the arrays match exactly and bail out if they do.
            if (this._equalsArray(array)) {
              return;
            }
            for (var i = 0, n = this._items.length; i < n; i++) {
              this._items[i].marker = true;
            }
            var refs;
            var newItems = [];
            for (var _i12 = 0, _n8 = array.length; _i12 < _n8; _i12++) {
              var s = array[_i12];
              if (this.isItem(s)) {
                s.marker = false;
                newItems.push(s);
              } else {
                var cref = s.ref;
                var c = void 0;
                if (cref) {
                  if (!refs) refs = this._getRefs();
                  c = refs[cref];
                }
                if (!c) {
                  // Create new item.
                  c = this.createItem(s);
                } else {
                  c.marker = false;
                }
                if (Utils$2.isObjectLiteral(s)) {
                  c.patch(s);
                }
                newItems.push(c);
              }
            }
            this._setItems(newItems);
          }
          _setItems(newItems) {
            var prevItems = this._items;
            this._items = newItems;

            // Remove the items.
            var removed = prevItems.filter(item => {
              var m = item.marker;
              delete item.marker;
              return m;
            });
            var added = newItems.filter(item => prevItems.indexOf(item) === -1);
            if (removed.length || added.length) {
              // Recalculate refs.
              this._refs = {};
              for (var i = 0, n = this._items.length; i < n; i++) {
                var ref = this._items[i].ref;
                if (ref) {
                  this._refs[ref] = this._items[i];
                }
              }
            }
            this.onSync(removed, added, newItems);
          }
          sort(f) {
            var items = this._items.slice();
            items.sort(f);
            this._setByArray(items);
          }
          onAdd(item, index) {}
          onRemove(item, index) {}
          onSync(removed, added, order) {}
          onSet(item, index, prevItem) {}
          onMove(item, fromIndex, toIndex) {}
          createItem(object) {
            throw new Error("ObjectList.createItem must create and return a new object");
          }
          isItem(object) {
            return false;
          }
          forEach(f) {
            this.get().forEach(f);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ElementChildList extends ObjectList {
          constructor(element) {
            super();
            this._element = element;
          }
          _connectParent(item) {
            var prevParent = item.parent;
            if (prevParent && prevParent !== this._element) {
              // Cleanup in previous child list, without
              var prevChildList = item.parent.childList;
              var index = prevChildList.getIndex(item);
              if (item.ref) {
                prevChildList._refs[item.ref] = undefined;
              }
              prevChildList._items.splice(index, 1);

              // Also clean up element core.
              prevParent.core.removeChildAt(index);
            }
            item._setParent(this._element);

            // We are expecting the caller to sync it to the core.
          }

          onAdd(item, index) {
            this._connectParent(item);
            this._element.core.addChildAt(index, item.core);
          }
          onRemove(item, index) {
            item._setParent(null);
            this._element.core.removeChildAt(index);
          }
          onSync(removed, added, order) {
            for (var i = 0, n = removed.length; i < n; i++) {
              removed[i]._setParent(null);
            }
            for (var _i13 = 0, _n9 = added.length; _i13 < _n9; _i13++) {
              this._connectParent(added[_i13]);
            }
            var gc = i => i.core;
            this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
          }
          onSet(item, index, prevItem) {
            prevItem._setParent(null);
            this._connectParent(item);
            this._element.core.setChildAt(index, item.core);
          }
          onMove(item, fromIndex, toIndex) {
            this._element.core.moveChild(fromIndex, toIndex);
          }
          createItem(object) {
            if (object.type) {
              return new object.type(this._element.stage);
            } else {
              return this._element.stage.createElement();
            }
          }
          isItem(object) {
            return object.isElement;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Element$1 = class Element {
          constructor(stage) {
            this.stage = stage;
            this.__id = Element.id++;
            this.__start();

            // EventEmitter constructor.
            this._hasEventListeners = false;
            this.__core = new ElementCore(this);

            /**
             * A reference that can be used while merging trees.
             * @type {string}
             */
            this.__ref = null;

            /**
             * An element is attached if it is a descendant of the stage root.
             * @type {boolean}
             */
            this.__attached = false;

            /**
             * An element is enabled when it is attached and it is visible (worldAlpha > 0).
             * @type {boolean}
             */
            this.__enabled = false;

            /**
             * An element is active when it is enabled and it is within bounds.
             * @type {boolean}
             */
            this.__active = false;

            /**
             * @type {Element}
             */
            this.__parent = null;

            /**
             * The texture that is currently set.
             * @type {Texture}
             */
            this.__texture = null;

            /**
             * The currently displayed texture. While this.texture is loading, this one may be different.
             * @type {Texture}
             */
            this.__displayedTexture = null;

            /**
             * Tags that can be used to identify/search for a specific element.
             * @type {String[]}
             */
            this.__tags = null;

            /**
             * The tree's tags mapping.
             * This contains all elements for all known tags, at all times.
             * @type {Map}
             */
            this.__treeTags = null;

            /**
             * Creates a tag context: tagged elements in this branch will not be reachable from ancestors of this elements.
             * @type {boolean}
             */
            this.__tagRoot = false;

            /**
             * (Lazy-initialised) list of children owned by this elements.
             * @type {ElementChildList}
             */
            this.__childList = null;
            this._w = 0;
            this._h = 0;
          }
          __start() {}
          get id() {
            return this.__id;
          }
          set ref(ref) {
            if (this.__ref !== ref) {
              var charcode = ref.charCodeAt(0);
              if (!Utils$2.isUcChar(charcode)) {
                this._throwError("Ref must start with an upper case character: " + ref);
              }
              if (this.__ref !== null) {
                this.removeTag(this.__ref);
                if (this.__parent) {
                  this.__parent.__childList.clearRef(this.__ref);
                }
              }
              this.__ref = ref;
              if (this.__ref) {
                this._addTag(this.__ref);
                if (this.__parent) {
                  this.__parent.__childList.setRef(this.__ref, this);
                }
              }
            }
          }
          get ref() {
            return this.__ref;
          }
          get core() {
            return this.__core;
          }
          setAsRoot() {
            this.__core.setAsRoot();
            this._updateAttachedFlag();
            this._updateEnabledFlag();
          }
          get isRoot() {
            return this.__core.isRoot;
          }
          _setParent(parent) {
            if (this.__parent === parent) return;
            if (this.__parent) {
              this._unsetTagsParent();
            }
            this.__parent = parent;
            if (parent) {
              this._setTagsParent();
            }
            this._updateAttachedFlag();
            this._updateEnabledFlag();
            this._updateCollision();
            if (this.isRoot && parent) {
              this._throwError("Root should not be added as a child! Results are unspecified!");
            }
          }
          getDepth() {
            var depth = 0;
            var p = this.__parent;
            while (p) {
              depth++;
              p = p.__parent;
            }
            return depth;
          }
          getAncestor(l) {
            var p = this;
            while (l > 0 && p.__parent) {
              p = p.__parent;
              l--;
            }
            return p;
          }
          getAncestors() {
            var a = [];
            var p = this;
            while (p) {
              a.push(p);
              p = p.__parent;
            }
            return a;
          }
          getAncestorAtDepth(depth) {
            var levels = this.getDepth() - depth;
            if (levels < 0) {
              return null;
            }
            return this.getAncestor(levels);
          }
          isAncestorOf(c) {
            var p = c;
            while (p = p.parent) {
              if (this === p) {
                return true;
              }
            }
            return false;
          }
          getSharedAncestor(c) {
            var o1 = this;
            var o2 = c;
            var l1 = o1.getDepth();
            var l2 = o2.getDepth();
            if (l1 > l2) {
              o1 = o1.getAncestor(l1 - l2);
            } else if (l2 > l1) {
              o2 = o2.getAncestor(l2 - l1);
            }
            do {
              if (o1 === o2) {
                return o1;
              }
              o1 = o1.__parent;
              o2 = o2.__parent;
            } while (o1 && o2);
            return null;
          }
          get attached() {
            return this.__attached;
          }
          get enabled() {
            return this.__enabled;
          }
          get active() {
            return this.__active;
          }
          _isAttached() {
            return this.__parent ? this.__parent.__attached : this.stage.root === this;
          }
          _isEnabled() {
            return this.__core.visible && this.__core.alpha > 0 && (this.__parent ? this.__parent.__enabled : this.stage.root === this);
          }
          _isActive() {
            return this._isEnabled() && this.withinBoundsMargin;
          }
          /**
           * Updates the 'attached' flag for this branch.
           */
          _updateAttachedFlag() {
            var newAttached = this._isAttached();
            if (this.__attached !== newAttached) {
              this.__attached = newAttached;
              if (newAttached) {
                this._onSetup();
              }
              var children = this._children.get();
              if (children) {
                var m = children.length;
                if (m > 0) {
                  for (var i = 0; i < m; i++) {
                    children[i]._updateAttachedFlag();
                  }
                }
              }
              if (newAttached) {
                this._onAttach();
              } else {
                this._onDetach();
              }
            }
          }
          /**
           * Updates the 'enabled' flag for this branch.
           */
          _updateEnabledFlag() {
            var newEnabled = this._isEnabled();
            if (this.__enabled !== newEnabled) {
              if (newEnabled) {
                this._onEnabled();
                this._setEnabledFlag();
              } else {
                this._onDisabled();
                this._unsetEnabledFlag();
              }
              var children = this._children.get();
              if (children) {
                var m = children.length;
                if (m > 0) {
                  for (var i = 0; i < m; i++) {
                    children[i]._updateEnabledFlag();
                  }
                }
              }
            }
          }
          _setEnabledFlag() {
            this.__enabled = true;

            // Force re-check of texture because dimensions might have changed (cutting).
            this._updateDimensions();
            this._updateTextureCoords();
            if (this.__texture) {
              this.__texture.addElement(this);
            }
            if (this.withinBoundsMargin) {
              this._setActiveFlag();
            }
            if (this.__core.shader) {
              this.__core.shader.addElement(this.__core);
            }
          }
          _unsetEnabledFlag() {
            if (this.__active) {
              this._unsetActiveFlag();
            }
            if (this.__texture) {
              this.__texture.removeElement(this);
            }
            if (this.__core.shader) {
              this.__core.shader.removeElement(this.__core);
            }
            if (this._texturizer) {
              this.texturizer.filters.forEach(filter => filter.removeElement(this.__core));
            }
            this.__enabled = false;
          }
          _setActiveFlag() {
            this.__active = true;

            // This must happen before enabling the texture, because it may already be loaded or load directly.
            if (this.__texture) {
              this.__texture.incActiveCount();
            }
            if (this.__texture) {
              this._enableTexture();
            }
            this._onActive();
          }
          _unsetActiveFlag() {
            if (this.__texture) {
              this.__texture.decActiveCount();
            }
            this.__active = false;
            if (this.__texture) {
              this._disableTexture();
            }
            if (this._hasTexturizer()) {
              this.texturizer.deactivate();
            }
            this._onInactive();
          }
          _onSetup() {}
          _onAttach() {}
          _onDetach() {}
          _onEnabled() {}
          _onDisabled() {}
          _onActive() {}
          _onInactive() {}
          _onResize() {}
          _getRenderWidth() {
            if (this._w) {
              return this._w;
            } else if (this.__displayedTexture) {
              return this.__displayedTexture.getRenderWidth();
            } else if (this.__texture) {
              // Texture already loaded, but not yet updated (probably because this element is not active).
              return this.__texture.getRenderWidth();
            } else {
              return 0;
            }
          }
          _getRenderHeight() {
            if (this._h) {
              return this._h;
            } else if (this.__displayedTexture) {
              return this.__displayedTexture.getRenderHeight();
            } else if (this.__texture) {
              // Texture already loaded, but not yet updated (probably because this element is not active).
              return this.__texture.getRenderHeight();
            } else {
              return 0;
            }
          }
          get renderWidth() {
            if (this.__enabled) {
              // Render width is only maintained if this element is enabled.
              return this.__core.getRenderWidth();
            } else {
              return this._getRenderWidth();
            }
          }
          get renderHeight() {
            if (this.__enabled) {
              return this.__core.getRenderHeight();
            } else {
              return this._getRenderHeight();
            }
          }
          get finalX() {
            return this.__core.x;
          }
          get finalY() {
            return this.__core.y;
          }
          get finalW() {
            return this.__core.w;
          }
          get finalH() {
            return this.__core.h;
          }
          textureIsLoaded() {
            return this.__texture && this.__texture.isLoaded();
          }
          loadTexture() {
            if (this.__texture) {
              this.__texture.load();
              if (!this.__texture.isUsed() || !this._isEnabled()) {
                // Loading the texture will have no effect on the dimensions of this element.
                // Manually update them, so that calcs can be performed immediately in userland.
                this._updateDimensions();
              }
            }
          }
          _enableTextureError() {
            // txError event should automatically be re-triggered when a element becomes active.
            var loadError = this.__texture.loadError;
            if (loadError) {
              this.emit('txError', loadError, this.__texture._source);
            }
          }
          _enableTexture() {
            if (this.__texture.isLoaded()) {
              this._setDisplayedTexture(this.__texture);
            } else {
              // We don't want to retain the old 'ghost' image as it wasn't visible anyway.
              this._setDisplayedTexture(null);
              this._enableTextureError();
            }
          }
          _disableTexture() {
            // We disable the displayed texture because, when the texture changes while invisible, we should use that w, h,
            // mw, mh for checking within bounds.
            this._setDisplayedTexture(null);
          }
          get texture() {
            return this.__texture;
          }
          set texture(v) {
            var texture;
            if (Utils$2.isObjectLiteral(v)) {
              if (v.type) {
                texture = new v.type(this.stage);
              } else {
                texture = this.texture;
              }
              if (texture) {
                Base.patchObject(texture, v);
              }
            } else if (!v) {
              texture = null;
            } else {
              if (v.isTexture) {
                texture = v;
              } else if (v.isTextureSource) {
                texture = new SourceTexture(this.stage);
                texture.textureSource = v;
              } else {
                console.error("[Lightning] Please specify a texture type.");
                return;
              }
            }
            var prevTexture = this.__texture;
            if (texture !== prevTexture) {
              this.__texture = texture;
              if (this.__texture) {
                if (this.__enabled) {
                  this.__texture.addElement(this);
                  if (this.withinBoundsMargin) {
                    if (this.__texture.isLoaded()) {
                      this._setDisplayedTexture(this.__texture);
                    } else {
                      this._enableTextureError();
                    }
                  }
                }
              } else {
                // Make sure that current texture is cleared when the texture is explicitly set to null.
                this._setDisplayedTexture(null);
              }
              if (prevTexture && prevTexture !== this.__displayedTexture) {
                prevTexture.removeElement(this);
              }
              this._updateDimensions();
            }
          }
          get displayedTexture() {
            return this.__displayedTexture;
          }
          _setDisplayedTexture(v) {
            var prevTexture = this.__displayedTexture;
            if (prevTexture && v !== prevTexture) {
              if (this.__texture !== prevTexture) {
                // The old displayed texture is deprecated.
                prevTexture.removeElement(this);
              }
            }
            var prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
            var sourceChanged = (v ? v._source : null) !== prevSource;
            this.__displayedTexture = v;
            this._updateDimensions();
            if (this.__displayedTexture) {
              if (sourceChanged) {
                // We don't need to reference the displayed texture because it was already referenced (this.texture === this.displayedTexture).
                this._updateTextureCoords();
                this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
              }
            } else {
              this.__core.setDisplayedTextureSource(null);
            }
            if (sourceChanged) {
              if (this.__displayedTexture) {
                this.emit('txLoaded', this.__displayedTexture);
              } else {
                this.emit('txUnloaded', this.__displayedTexture);
              }
            }
          }
          onTextureSourceLoaded() {
            // This function is called when element is enabled, but we only want to set displayed texture for active elements.
            if (this.active) {
              // We may be dealing with a texture reloading, so we must force update.
              this._setDisplayedTexture(this.__texture);
            }
          }
          onTextureSourceLoadError(e) {
            this.emit('txError', e, this.__texture._source);
          }
          forceRenderUpdate() {
            this.__core.setHasRenderUpdates(3);
          }
          onDisplayedTextureClippingChanged() {
            this._updateDimensions();
            this._updateTextureCoords();
          }
          onPrecisionChanged() {
            this._updateDimensions();
          }
          onDimensionsChanged(w, h) {
            if (this.texture instanceof TextTexture) {
              this.texture.w = w;
              this.texture.h = h;
              this.w = w;
              this.h = h;
            }
          }
          _updateDimensions() {
            var w = this._getRenderWidth();
            var h = this._getRenderHeight();
            var unknownSize = false;
            if (!w || !h) {
              if (!this.__displayedTexture && this.__texture) {
                // We use a 'max width' replacement instead in the ElementCore calcs.
                // This makes sure that it is able to determine withinBounds.
                w = w || this.__texture.mw;
                h = h || this.__texture.mh;
                if ((!w || !h) && this.__texture.isAutosizeTexture()) {
                  unknownSize = true;
                }
              }
            }
            if (this.__core.setDimensions(w, h, unknownSize)) {
              this._onResize();
            }
          }
          _updateTextureCoords() {
            if (this.displayedTexture && this.displayedTexture._source) {
              var displayedTexture = this.displayedTexture;
              var displayedTextureSource = this.displayedTexture._source;
              var tx1 = 0,
                ty1 = 0,
                tx2 = 1.0,
                ty2 = 1.0;
              if (displayedTexture.clipping) {
                // Apply texture clipping.
                var w = displayedTextureSource.getRenderWidth();
                var h = displayedTextureSource.getRenderHeight();
                var iw, ih, rw, rh;
                iw = 1 / w;
                ih = 1 / h;
                if (displayedTexture.pw) {
                  rw = displayedTexture.pw * iw;
                } else {
                  rw = (w - displayedTexture.px) * iw;
                }
                if (displayedTexture.ph) {
                  rh = displayedTexture.ph * ih;
                } else {
                  rh = (h - displayedTexture.py) * ih;
                }
                iw *= displayedTexture.px;
                ih *= displayedTexture.py;
                tx1 = iw;
                ty1 = ih;
                tx2 = tx2 * rw + iw;
                ty2 = ty2 * rh + ih;
                tx1 = Math.max(0, tx1);
                ty1 = Math.max(0, ty1);
                tx2 = Math.min(1, tx2);
                ty2 = Math.min(1, ty2);
              }
              if (displayedTextureSource._flipTextureY) {
                var tempty = ty2;
                ty2 = ty1;
                ty1 = tempty;
              }
              this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
            }
          }
          getCornerPoints() {
            return this.__core.getCornerPoints();
          }
          _unsetTagsParent() {
            if (this.__tags) {
              this.__tags.forEach(tag => {
                // Remove from treeTags.
                var p = this;
                while (p = p.__parent) {
                  var parentTreeTags = p.__treeTags.get(tag);
                  parentTreeTags.delete(this);
                  if (p.__tagRoot) {
                    break;
                  }
                }
              });
            }
            var tags = null;
            var n = 0;
            if (this.__treeTags) {
              if (!this.__tagRoot) {
                tags = Utils$2.iteratorToArray(this.__treeTags.keys());
                n = tags.length;
                if (n > 0) {
                  for (var i = 0; i < n; i++) {
                    var tagSet = this.__treeTags.get(tags[i]);

                    // Remove from treeTags.
                    var p = this;
                    var _loop = function _loop() {
                      var parentTreeTags = p.__treeTags.get(tags[i]);
                      tagSet.forEach(function (comp) {
                        parentTreeTags.delete(comp);
                      });
                      if (p.__tagRoot) {
                        return "break";
                      }
                    };
                    while (p = p.__parent) {
                      var _ret = _loop();
                      if (_ret === "break") break;
                    }
                  }
                }
              }
            }
          }
          _setTagsParent() {
            // Just copy over the 'local' tags.
            if (this.__tags) {
              this.__tags.forEach(tag => {
                var p = this;
                while (p = p.__parent) {
                  if (!p.__treeTags) {
                    p.__treeTags = new Map();
                  }
                  var s = p.__treeTags.get(tag);
                  if (!s) {
                    s = new Set();
                    p.__treeTags.set(tag, s);
                  }
                  s.add(this);
                  if (p.__tagRoot) {
                    break;
                  }
                }
              });
            }
            if (this.__treeTags && this.__treeTags.size) {
              if (!this.__tagRoot) {
                this.__treeTags.forEach((tagSet, tag) => {
                  var p = this;
                  var _loop2 = function _loop2() {
                    if (p.__tagRoot) ;
                    if (!p.__treeTags) {
                      p.__treeTags = new Map();
                    }
                    var s = p.__treeTags.get(tag);
                    if (!s) {
                      s = new Set();
                      p.__treeTags.set(tag, s);
                    }
                    tagSet.forEach(function (comp) {
                      s.add(comp);
                    });
                  };
                  while (!p.__tagRoot && (p = p.__parent)) {
                    _loop2();
                  }
                });
              }
            }
          }
          _getByTag(tag) {
            if (!this.__treeTags) {
              return [];
            }
            var t = this.__treeTags.get(tag);
            return t ? Utils$2.setToArray(t) : [];
          }
          getTags() {
            return this.__tags ? this.__tags : [];
          }
          setTags(tags) {
            tags = tags.reduce((acc, tag) => {
              return acc.concat(tag.split(' '));
            }, []);
            if (this.__ref) {
              tags.push(this.__ref);
            }
            var i,
              n = tags.length;
            var removes = [];
            var adds = [];
            for (i = 0; i < n; i++) {
              if (!this.hasTag(tags[i])) {
                adds.push(tags[i]);
              }
            }
            var currentTags = this.tags || [];
            n = currentTags.length;
            for (i = 0; i < n; i++) {
              if (tags.indexOf(currentTags[i]) == -1) {
                removes.push(currentTags[i]);
              }
            }
            for (i = 0; i < removes.length; i++) {
              this.removeTag(removes[i]);
            }
            for (i = 0; i < adds.length; i++) {
              this.addTag(adds[i]);
            }
          }
          addTag(tag) {
            if (tag.indexOf(' ') === -1) {
              if (Utils$2.isUcChar(tag.charCodeAt(0))) {
                this._throwError("Tag may not start with an upper case character.");
              }
              this._addTag(tag);
            } else {
              var tags = tag.split(' ');
              for (var i = 0, m = tags.length; i < m; i++) {
                var _tag = tags[i];
                if (Utils$2.isUcChar(_tag.charCodeAt(0))) {
                  this._throwError("Tag may not start with an upper case character.");
                }
                this._addTag(_tag);
              }
            }
          }
          _addTag(tag) {
            if (!this.__tags) {
              this.__tags = [];
            }
            if (this.__tags.indexOf(tag) === -1) {
              this.__tags.push(tag);

              // Add to treeTags hierarchy.
              var p = this.__parent;
              if (p) {
                do {
                  if (!p.__treeTags) {
                    p.__treeTags = new Map();
                  }
                  var s = p.__treeTags.get(tag);
                  if (!s) {
                    s = new Set();
                    p.__treeTags.set(tag, s);
                  }
                  s.add(this);
                } while (!p.__tagRoot && (p = p.__parent));
              }
            }
          }
          removeTag(tag) {
            var i = this.__tags.indexOf(tag);
            if (i !== -1) {
              this.__tags.splice(i, 1);

              // Remove from treeTags hierarchy.
              var p = this.__parent;
              if (p) {
                do {
                  var list = p.__treeTags.get(tag);
                  if (list) {
                    list.delete(this);
                  }
                } while (!p.__tagRoot && (p = p.__parent));
              }
            }
          }
          hasTag(tag) {
            return this.__tags && this.__tags.indexOf(tag) !== -1;
          }

          /**
           * Returns one of the elements from the subtree that have this tag.
           * @param {string} tag
           * @returns {Element}
           */
          _tag(tag) {
            if (tag.indexOf(".") !== -1) {
              return this.mtag(tag)[0];
            } else {
              if (this.__treeTags) {
                var t = this.__treeTags.get(tag);
                if (t) {
                  var item = t.values().next();
                  return item ? item.value : undefined;
                }
              }
            }
          }
          get tag() {
            return this._tag;
          }
          set tag(t) {
            this.tags = t;
          }

          /**
           * Returns all elements from the subtree that have this tag.
           * @param {string} tag
           * @returns {Element[]}
           */
          mtag(tag) {
            var idx = tag.indexOf(".");
            if (idx >= 0) {
              var parts = tag.split('.');
              var res = this._getByTag(parts[0]);
              var level = 1;
              var c = parts.length;
              while (res.length && level < c) {
                var resn = [];
                for (var j = 0, n = res.length; j < n; j++) {
                  resn = resn.concat(res[j]._getByTag(parts[level]));
                }
                res = resn;
                level++;
              }
              return res;
            } else {
              return this._getByTag(tag);
            }
          }
          stag(tag, settings) {
            var t = this.mtag(tag);
            var n = t.length;
            for (var i = 0; i < n; i++) {
              Base.patchObject(t[i], settings);
            }
          }
          get tagRoot() {
            return this.__tagRoot;
          }
          set tagRoot(v) {
            if (this.__tagRoot !== v) {
              if (!v) {
                this._setTagsParent();
              } else {
                this._unsetTagsParent();
              }
              this.__tagRoot = v;
            }
          }
          sel(path) {
            var results = this.select(path);
            if (results.length) {
              return results[0];
            } else {
              return undefined;
            }
          }
          select(path) {
            if (path.indexOf(",") !== -1) {
              var selectors = path.split(',');
              var res = [];
              for (var i = 0; i < selectors.length; i++) {
                res = res.concat(this._select(selectors[i]));
              }
              return res;
            } else {
              return this._select(path);
            }
          }
          _select(path) {
            if (path === "") return [this];
            var pointIdx = path.indexOf(".");
            var arrowIdx = path.indexOf(">");
            if (pointIdx === -1 && arrowIdx === -1) {
              // Quick case.
              return this.mtag(path);
            }

            // Detect by first char.
            var isRef;
            if (arrowIdx === 0) {
              isRef = true;
              path = path.substr(1);
            } else if (pointIdx === 0) {
              isRef = false;
              path = path.substr(1);
            } else {
              isRef = false;
            }
            return this._selectChilds(path, isRef);
          }
          _selectChilds(path, isRef) {
            var pointIdx = path.indexOf(".");
            var arrowIdx = path.indexOf(">");
            if (pointIdx === -1 && arrowIdx === -1) {
              if (isRef) {
                var ref = this.getByRef(path);
                return ref ? [ref] : [];
              } else {
                return this.mtag(path);
              }
            }
            if (arrowIdx === -1 || pointIdx !== -1 && pointIdx < arrowIdx) {
              var next;
              var str = path.substr(0, pointIdx);
              if (isRef) {
                var _ref2 = this.getByRef(str);
                next = _ref2 ? [_ref2] : [];
              } else {
                next = this.mtag(str);
              }
              var total = [];
              var subPath = path.substr(pointIdx + 1);
              for (var i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, false));
              }
              return total;
            } else {
              var _next;
              var _str = path.substr(0, arrowIdx);
              if (isRef) {
                var _ref3 = this.getByRef(_str);
                _next = _ref3 ? [_ref3] : [];
              } else {
                _next = this.mtag(_str);
              }
              var _total = [];
              var _subPath = path.substr(arrowIdx + 1);
              for (var _i14 = 0, _n10 = _next.length; _i14 < _n10; _i14++) {
                _total = _total.concat(_next[_i14]._selectChilds(_subPath, true));
              }
              return _total;
            }
          }
          getByRef(ref) {
            return this.childList.getByRef(ref);
          }
          getLocationString() {
            var i;
            i = this.__parent ? this.__parent._children.getIndex(this) : "R";
            var localTags = this.getTags();
            var str = this.__parent ? this.__parent.getLocationString() : "";
            if (this.ref) {
              str += ":[" + i + "]" + this.ref;
            } else if (localTags.length) {
              str += ":[" + i + "]" + localTags.join(",");
            } else {
              str += ":[" + i + "]#" + this.id;
            }
            return str;
          }
          toString() {
            var obj = this.getSettings();
            return Element.getPrettyString(obj, "");
          }
          static getPrettyString(obj, indent) {
            var children = obj.children;
            delete obj.children;

            // Convert singular json settings object.
            var colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
            var str = JSON.stringify(obj, function (k, v) {
              if (colorKeys.indexOf(k) !== -1) {
                return "COLOR[" + v.toString(16) + "]";
              }
              return v;
            });
            str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");
            if (children) {
              var childStr = "";
              if (Utils$2.isObjectLiteral(children)) {
                var refs = Object.keys(children);
                childStr = "";
                for (var i = 0, n = refs.length; i < n; i++) {
                  childStr += `\n${indent}  "${refs[i]}":`;
                  delete children[refs[i]].ref;
                  childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                }
                var isEmpty = str === "{}";
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
              } else {
                var _n11 = children.length;
                childStr = "[";
                for (var _i15 = 0; _i15 < _n11; _i15++) {
                  childStr += Element.getPrettyString(children[_i15], indent + "  ") + (_i15 < _n11 - 1 ? "," : "") + "\n";
                }
                childStr += indent + "]}";
                var _isEmpty = str === "{}";
                str = str.substr(0, str.length - 1) + (_isEmpty ? "" : ",") + "\"children\":\n" + indent + childStr + "}";
              }
            }
            return str;
          }
          getSettings() {
            var settings = this.getNonDefaults();
            var children = this._children.get();
            if (children) {
              var n = children.length;
              if (n) {
                var childArray = [];
                var missing = false;
                for (var i = 0; i < n; i++) {
                  childArray.push(children[i].getSettings());
                  missing = missing || !children[i].ref;
                }
                if (!missing) {
                  settings.children = {};
                  childArray.forEach(child => {
                    settings.children[child.ref] = child;
                  });
                } else {
                  settings.children = childArray;
                }
              }
            }
            settings.id = this.id;
            return settings;
          }
          getNonDefaults() {
            var settings = {};
            if (this.constructor !== Element) {
              settings.type = this.constructor.name;
            }
            if (this.__ref) {
              settings.ref = this.__ref;
            }
            if (this.__tags && this.__tags.length) {
              settings.tags = this.__tags;
            }
            if (this.x !== 0) settings.x = this.x;
            if (this.y !== 0) settings.y = this.y;
            if (this.w !== 0) settings.w = this.w;
            if (this.h !== 0) settings.h = this.h;
            if (this.scaleX === this.scaleY) {
              if (this.scaleX !== 1) settings.scale = this.scaleX;
            } else {
              if (this.scaleX !== 1) settings.scaleX = this.scaleX;
              if (this.scaleY !== 1) settings.scaleY = this.scaleY;
            }
            if (this.pivotX === this.pivotY) {
              if (this.pivotX !== 0.5) settings.pivot = this.pivotX;
            } else {
              if (this.pivotX !== 0.5) settings.pivotX = this.pivotX;
              if (this.pivotY !== 0.5) settings.pivotY = this.pivotY;
            }
            if (this.mountX === this.mountY) {
              if (this.mountX !== 0) settings.mount = this.mountX;
            } else {
              if (this.mountX !== 0) settings.mountX = this.mountX;
              if (this.mountY !== 0) settings.mountY = this.mountY;
            }
            if (this.alpha !== 1) settings.alpha = this.alpha;
            if (!this.visible) settings.visible = false;
            if (this.rotation !== 0) settings.rotation = this.rotation;
            if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
              if (this.colorUl !== 0xFFFFFFFF) settings.color = this.colorUl.toString(16);
            } else {
              if (this.colorUl !== 0xFFFFFFFF) settings.colorUl = this.colorUl.toString(16);
              if (this.colorUr !== 0xFFFFFFFF) settings.colorUr = this.colorUr.toString(16);
              if (this.colorBl !== 0xFFFFFFFF) settings.colorBl = this.colorBl.toString(16);
              if (this.colorBr !== 0xFFFFFFFF) settings.colorBr = this.colorBr.toString(16);
            }
            if (this.zIndex) settings.zIndex = this.zIndex;
            if (this.forceZIndexContext) settings.forceZIndexContext = true;
            if (this.clipping) settings.clipping = this.clipping;
            if (!this.clipbox) settings.clipbox = this.clipbox;
            if (this.__texture) {
              var tnd = this.__texture.getNonDefaults();
              if (Object.keys(tnd).length) {
                settings.texture = tnd;
              }
            }
            if (this.shader && Utils$2.isFunction(this.shader.getNonDefaults)) {
              var _tnd = this.shader.getNonDefaults();
              if (Object.keys(_tnd).length) {
                settings.shader = _tnd;
              }
            }
            if (this._hasTexturizer()) {
              if (this.texturizer.enabled) {
                settings.renderToTexture = this.texturizer.enabled;
              }
              if (this.texturizer.lazy) {
                settings.renderToTextureLazy = this.texturizer.lazy;
              }
              if (this.texturizer.colorize) {
                settings.colorizeResultTexture = this.texturizer.colorize;
              }
              if (this.texturizer.renderOffscreen) {
                settings.renderOffscreen = this.texturizer.renderOffscreen;
              }
            }
            return settings;
          }
          static getGetter(propertyPath) {
            var getter = Element.PROP_GETTERS.get(propertyPath);
            if (!getter) {
              getter = new Function('obj', 'return obj.' + propertyPath);
              Element.PROP_GETTERS.set(propertyPath, getter);
            }
            return getter;
          }
          static getSetter(propertyPath) {
            var setter = Element.PROP_SETTERS.get(propertyPath);
            if (!setter) {
              setter = new Function('obj', 'v', 'obj.' + propertyPath + ' = v');
              Element.PROP_SETTERS.set(propertyPath, setter);
            }
            return setter;
          }
          get withinBoundsMargin() {
            return this.__core._withinBoundsMargin;
          }
          _enableWithinBoundsMargin() {
            // Iff enabled, this toggles the active flag.
            if (this.__enabled) {
              this._setActiveFlag();
            }
          }
          _disableWithinBoundsMargin() {
            // Iff active, this toggles the active flag.
            if (this.__active) {
              this._unsetActiveFlag();
            }
          }
          set boundsMargin(v) {
            if (!Array.isArray(v) && v !== null) {
              throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
            }
            this.__core.boundsMargin = v;
          }
          get boundsMargin() {
            return this.__core.boundsMargin;
          }
          get x() {
            return this.__core.offsetX;
          }
          set x(v) {
            this.__core.offsetX = v;
          }
          get y() {
            return this.__core.offsetY;
          }
          set y(v) {
            this.__core.offsetY = v;
          }
          get w() {
            return this._w;
          }
          set w(v) {
            if (Utils$2.isFunction(v)) {
              this._w = 0;
              this.__core.funcW = v;
            } else {
              v = Math.max(v, 0);
              if (this._w !== v) {
                this.__core.disableFuncW();
                this._w = v;
                this._updateDimensions();
              }
            }
          }
          get h() {
            return this._h;
          }
          set h(v) {
            if (Utils$2.isFunction(v)) {
              this._h = 0;
              this.__core.funcH = v;
            } else {
              v = Math.max(v, 0);
              if (this._h !== v) {
                this.__core.disableFuncH();
                this._h = v;
                this._updateDimensions();
              }
            }
          }
          get collision() {
            return this._collision;
          }
          set collision(v) {
            this._collision = v;
          }
          _updateCollision() {
            if (this.collision && this.__parent && this.__parent.collision === undefined) {
              /**
               * Mark collision as 2 to indicate atleast one descendant has collision enabled.
               * This narrows down the search for elements with active collision.
              */
              this.__parent.collision = 2;
            }
          }
          get scaleX() {
            return this.__core.scaleX;
          }
          set scaleX(v) {
            this.__core.scaleX = v;
          }
          get scaleY() {
            return this.__core.scaleY;
          }
          set scaleY(v) {
            this.__core.scaleY = v;
          }
          get scale() {
            return this.__core.scale;
          }
          set scale(v) {
            this.__core.scale = v;
          }
          get pivotX() {
            return this.__core.pivotX;
          }
          set pivotX(v) {
            this.__core.pivotX = v;
          }
          get pivotY() {
            return this.__core.pivotY;
          }
          set pivotY(v) {
            this.__core.pivotY = v;
          }
          get pivot() {
            return this.__core.pivot;
          }
          set pivot(v) {
            this.__core.pivot = v;
          }
          get mountX() {
            return this.__core.mountX;
          }
          set mountX(v) {
            this.__core.mountX = v;
          }
          get mountY() {
            return this.__core.mountY;
          }
          set mountY(v) {
            this.__core.mountY = v;
          }
          get mount() {
            return this.__core.mount;
          }
          set mount(v) {
            this.__core.mount = v;
          }
          get rotation() {
            return this.__core.rotation;
          }
          set rotation(v) {
            this.__core.rotation = v;
          }
          get alpha() {
            return this.__core.alpha;
          }
          set alpha(v) {
            this.__core.alpha = v;
          }
          get visible() {
            return this.__core.visible;
          }
          set visible(v) {
            this.__core.visible = v;
          }
          get colorUl() {
            return this.__core.colorUl;
          }
          set colorUl(v) {
            this.__core.colorUl = v;
          }
          get colorUr() {
            return this.__core.colorUr;
          }
          set colorUr(v) {
            this.__core.colorUr = v;
          }
          get colorBl() {
            return this.__core.colorBl;
          }
          set colorBl(v) {
            this.__core.colorBl = v;
          }
          get colorBr() {
            return this.__core.colorBr;
          }
          set colorBr(v) {
            this.__core.colorBr = v;
          }
          get color() {
            return this.__core.colorUl;
          }
          set color(v) {
            if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
              this.colorUl = v;
              this.colorUr = v;
              this.colorBl = v;
              this.colorBr = v;
            }
          }
          get colorTop() {
            return this.colorUl;
          }
          set colorTop(v) {
            if (this.colorUl !== v || this.colorUr !== v) {
              this.colorUl = v;
              this.colorUr = v;
            }
          }
          get colorBottom() {
            return this.colorBl;
          }
          set colorBottom(v) {
            if (this.colorBl !== v || this.colorBr !== v) {
              this.colorBl = v;
              this.colorBr = v;
            }
          }
          get colorLeft() {
            return this.colorUl;
          }
          set colorLeft(v) {
            if (this.colorUl !== v || this.colorBl !== v) {
              this.colorUl = v;
              this.colorBl = v;
            }
          }
          get colorRight() {
            return this.colorUr;
          }
          set colorRight(v) {
            if (this.colorUr !== v || this.colorBr !== v) {
              this.colorUr = v;
              this.colorBr = v;
            }
          }
          get zIndex() {
            return this.__core.zIndex;
          }
          set zIndex(v) {
            this.__core.zIndex = v;
          }
          get forceZIndexContext() {
            return this.__core.forceZIndexContext;
          }
          set forceZIndexContext(v) {
            this.__core.forceZIndexContext = v;
          }
          get clipping() {
            return this.__core.clipping;
          }
          set clipping(v) {
            this.__core.clipping = v;
          }
          get clipbox() {
            return this.__core.clipbox;
          }
          set clipbox(v) {
            this.__core.clipbox = v;
          }
          get tags() {
            return this.getTags();
          }
          set tags(v) {
            if (!Array.isArray(v)) v = [v];
            this.setTags(v);
          }
          set t(v) {
            this.tags = v;
          }
          get _children() {
            if (!this.__childList) {
              this.__childList = new ElementChildList(this, false);
            }
            return this.__childList;
          }
          get childList() {
            if (!this._allowChildrenAccess()) {
              this._throwError("Direct access to children is not allowed in " + this.getLocationString());
            }
            return this._children;
          }
          hasChildren() {
            return this._allowChildrenAccess() && this.__childList && this.__childList.length > 0;
          }
          _allowChildrenAccess() {
            return true;
          }
          get children() {
            return this.childList.get();
          }
          set children(children) {
            this.childList.patch(children);
          }
          add(o) {
            return this.childList.a(o);
          }
          get p() {
            return this.__parent;
          }
          get parent() {
            return this.__parent;
          }
          get src() {
            if (this.texture && this.texture instanceof ImageTexture) {
              return this.texture._src;
            } else {
              return undefined;
            }
          }
          set src(v) {
            var texture = new ImageTexture(this.stage);
            texture.src = v;
            this.texture = texture;
          }
          set mw(v) {
            if (this.texture) {
              this.texture.mw = v;
              this._updateDimensions();
            } else {
              this._throwError('Please set mw after setting a texture.');
            }
          }
          set mh(v) {
            if (this.texture) {
              this.texture.mh = v;
              this._updateDimensions();
            } else {
              this._throwError('Please set mh after setting a texture.');
            }
          }
          get rect() {
            return this.texture === this.stage.rectangleTexture;
          }
          set rect(v) {
            if (v) {
              this.texture = this.stage.rectangleTexture;
            } else {
              this.texture = null;
            }
          }
          enableTextTexture() {
            if (!this.texture || !(this.texture instanceof TextTexture)) {
              this.texture = new TextTexture(this.stage);
              if (!this.texture.w && !this.texture.h) {
                // Inherit dimensions from element.
                // This allows userland to set dimensions of the Element and then later specify the text.
                this.texture.w = this.w;
                this.texture.h = this.h;
              }
            }
            return this.texture;
          }
          get text() {
            if (this.texture && this.texture instanceof TextTexture) {
              return this.texture;
            } else {
              return null;
            }
          }
          set text(v) {
            if (!this.texture || !(this.texture instanceof TextTexture)) {
              this.enableTextTexture();
            }
            if (Utils$2.isString(v)) {
              this.texture.text = v;
            } else {
              this.texture.patch(v);
            }
          }
          set onUpdate(f) {
            this.__core.onUpdate = f;
          }
          set onAfterCalcs(f) {
            this.__core.onAfterCalcs = f;
          }
          set onAfterUpdate(f) {
            this.__core.onAfterUpdate = f;
          }
          forceUpdate() {
            // Make sure that the update loop is run.
            this.__core._setHasUpdates();
          }
          get shader() {
            return this.__core.shader;
          }
          set shader(v) {
            if (Utils$2.isObjectLiteral(v) && !v.type) {
              // Setting properties on an existing shader.
              if (this.shader) {
                this.shader.patch(v);
              }
            } else {
              var shader = Shader.create(this.stage, v);
              if (this.__enabled && this.__core.shader) {
                this.__core.shader.removeElement(this.__core);
              }
              this.__core.shader = shader;
              if (this.__enabled && this.__core.shader) {
                this.__core.shader.addElement(this.__core);
              }
            }
          }
          _hasTexturizer() {
            return !!this.__core._texturizer;
          }
          get renderToTexture() {
            return this.rtt;
          }
          set renderToTexture(v) {
            this.rtt = v;
          }
          get rtt() {
            return this._hasTexturizer() && this.texturizer.enabled;
          }
          set rtt(v) {
            this.texturizer.enabled = v;
          }
          get rttLazy() {
            return this._hasTexturizer() && this.texturizer.lazy;
          }
          set rttLazy(v) {
            this.texturizer.lazy = v;
          }
          get renderOffscreen() {
            return this._hasTexturizer() && this.texturizer.renderOffscreen;
          }
          set renderOffscreen(v) {
            this.texturizer.renderOffscreen = v;
          }
          get colorizeResultTexture() {
            return this._hasTexturizer() && this.texturizer.colorize;
          }
          set colorizeResultTexture(v) {
            this.texturizer.colorize = v;
          }
          getTexture() {
            return this.texturizer._getTextureSource();
          }
          get texturizer() {
            return this.__core.texturizer;
          }
          patch(settings) {
            var paths = Object.keys(settings);
            for (var i = 0, n = paths.length; i < n; i++) {
              var path = paths[i];
              var v = settings[path];
              var firstCharCode = path.charCodeAt(0);
              if (Utils$2.isUcChar(firstCharCode)) {
                // Ref.
                var child = this.getByRef(path);
                if (!child) {
                  if (v !== undefined) {
                    // Add to list immediately.
                    var c = void 0;
                    if (Utils$2.isObjectLiteral(v)) {
                      // Catch this case to capture createMode flag.
                      c = this.childList.createItem(v);
                      c.patch(v);
                    } else if (Utils$2.isObject(v)) {
                      c = v;
                    }
                    if (c.isElement) {
                      c.ref = path;
                    }
                    this.childList.a(c);
                  }
                } else {
                  if (v === undefined) {
                    if (child.parent) {
                      child.parent.childList.remove(child);
                    }
                  } else if (Utils$2.isObjectLiteral(v)) {
                    child.patch(v);
                  } else if (v.isElement) {
                    // Replace element by new element.
                    v.ref = path;
                    this.childList.replace(v, child);
                  } else {
                    this._throwError("Unexpected value for path: " + path);
                  }
                }
              } else {
                // Property.
                Base.patchObjectProperty(this, path, v);
              }
            }
          }
          _throwError(message) {
            throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
          }
          animation(settings) {
            return this.stage.animations.createAnimation(this, settings);
          }
          transition(property) {
            var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            if (settings === null) {
              return this._getTransition(property);
            } else {
              this._setTransition(property, settings);
              // We do not create/return the transition, because it would undo the 'lazy transition creation' optimization.
              return null;
            }
          }
          set transitions(object) {
            var keys = Object.keys(object);
            keys.forEach(property => {
              this.transition(property, object[property]);
            });
          }
          set smooth(object) {
            var keys = Object.keys(object);
            keys.forEach(property => {
              var value = object[property];
              if (Array.isArray(value)) {
                this.setSmooth(property, value[0], value[1]);
              } else {
                this.setSmooth(property, value);
              }
            });
          }
          fastForward(property) {
            if (this._transitions) {
              var t = this._transitions[property];
              if (t && t.isTransition) {
                t.finish();
              }
            }
          }
          _getTransition(property) {
            if (!this._transitions) {
              this._transitions = {};
            }
            var t = this._transitions[property];
            if (!t) {
              // Create default transition.
              t = new Transition(this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
            } else if (t.isTransitionSettings) {
              // Upgrade to 'real' transition.
              t = new Transition(this.stage.transitions, t, this, property);
            }
            this._transitions[property] = t;
            return t;
          }
          _setTransition(property, settings) {
            if (!settings) {
              this._removeTransition(property);
            } else {
              if (Utils$2.isObjectLiteral(settings)) {
                // Convert plain object to proper settings object.
                settings = this.stage.transitions.createSettings(settings);
              }
              if (!this._transitions) {
                this._transitions = {};
              }
              var current = this._transitions[property];
              if (current && current.isTransition) {
                // Runtime settings change.
                current.settings = settings;
                return current;
              } else {
                // Initially, only set the settings and upgrade to a 'real' transition when it is used.
                this._transitions[property] = settings;
              }
            }
          }
          _removeTransition(property) {
            if (this._transitions) {
              delete this._transitions[property];
            }
          }
          getSmooth(property, v) {
            var t = this._getTransition(property);
            if (t && t.isAttached()) {
              return t.targetValue;
            } else {
              return v;
            }
          }
          setSmooth(property, v, settings) {
            if (settings) {
              this._setTransition(property, settings);
            }
            var t = this._getTransition(property);
            t.start(v);
            return t;
          }
          get flex() {
            return this.__core.flex;
          }
          set flex(v) {
            this.__core.flex = v;
          }
          get flexItem() {
            return this.__core.flexItem;
          }
          set flexItem(v) {
            this.__core.flexItem = v;
          }
          static isColorProperty(property) {
            return property.toLowerCase().indexOf("color") >= 0;
          }
          static getMerger(property) {
            if (Element.isColorProperty(property)) {
              return StageUtils.mergeColors;
            } else {
              return StageUtils.mergeNumbers;
            }
          }
          toJSON() {
            var ref = [`${this.constructor.name}`];
            var tree = {};
            tree[ref] = {};
            if (this.hasChildren()) {
              Element.collectChildren(tree[ref], this.__childList);
            } else {
              tree[ref] = _objectSpread({}, Element.getProperties(this));
            }
            return tree;
          }
          static collectChildren(tree, children) {
            var childList = children;
            for (var i = 0, j = childList.length; i < j; i++) {
              var element = childList.getAt(i);
              var ref = `${element.__ref || `Element-${element.id}`}`;
              var properties = this.getProperties(element);
              tree[ref] = _objectSpread({}, properties);
              if (element.hasChildren()) {
                tree[ref].children = {};
                this.collectChildren(tree[ref].children, element.__childList);
              }
            }
          }
          static getProperties(element) {
            var props = {};
            var list = ["alpha", "active", "attached", "boundsMargin", "color", "clipping", "enabled", "h", "id", "isComponent", "mount", "mountY", "mountX", "pivot", "pivotX", "pivotY", "ref", "renderOfScreen", "renderToTexture", "scale", "scaleX", "scaleY", "state", "tag", "visible", "w", "x", "y", "zIndex", "!!flex", "!!flexItem", "hasFocus()", "hasFinalFocus()"];
            var n = list.length;
            while (n--) {
              var key = list[n];
              var getBoolean = /^!{2}/;
              var _isFunction = /\(\)$/;
              if (getBoolean.test(key)) {
                key = key.substring(2, key.length);
                props[key] = !!element[key];
              } else if (_isFunction.test(key)) {
                key = key.substring(0, key.length - 2);
                if (typeof element[key] === "function") {
                  props[key] = element[key]();
                }
              } else {
                props[key] = element[key];
              }
            }
            return _objectSpread(_objectSpread({}, props), element.getNonDefaults());
          }
        };

        // This gives a slight performance benefit compared to extending EventEmitter.
        EventEmitter.addAsMixin(Element$1);
        Element$1.prototype.isElement = 1;
        Element$1.id = 1;

        // Getters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
        Element$1.PROP_GETTERS = new Map();

        // Setters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
        Element$1.PROP_SETTERS = new Map();

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class StateMachine {
          constructor() {
            StateMachine.setupStateMachine(this);
          }
          static setupStateMachine(target) {
            var targetConstructor = target.constructor;
            var router = StateMachine.create(targetConstructor);
            Object.setPrototypeOf(target, router.prototype);
            target.constructor = targetConstructor;
            target._initStateMachine();
          }

          /**
           * Creates a state machine implementation.
           * It extends the original type and should be used when creating new instances.
           * The original type is available as static property 'original', and it must be used when subclassing as follows:
           * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
           * @param {Class} type
           * @returns {StateMachine}
           */
          static create(type) {
            if (!type.hasOwnProperty('_sm')) {
              // Only need to run once.
              var stateMachineType = new StateMachineType(type);
              type._sm = stateMachineType;
            }
            return type._sm.router;
          }

          /**
           * Calls the specified method if it exists.
           * @param {string} event
           * @param {*...} args
           */
          fire(event) {
            if (this._hasMethod(event)) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return this[event](...args);
            }
          }

          /**
           * Returns the current state path (for example "Initialized.Loading").
           * @returns {string}
           * @protected
           */
          _getState() {
            return this._state.__path;
          }

          /**
           * Returns true iff statePath is (an ancestor of) currentStatePath.
           * @param {string} statePath
           * @param {string} currentStatePath
           * @returns {Boolean}
           * @protected
           */
          _inState(statePath) {
            var currentStatePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._state.__path;
            var state = this._sm.getStateByPath(statePath);
            var currentState = this._sm.getStateByPath(currentStatePath);
            var level = state.__level;
            var stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
            return stateAtLevel === state;
          }

          /**
           * Returns true if the specified class member is defined for the currently set state.
           * @param {string} name
           * @returns {boolean}
           * @protected
           */
          _hasMember(name) {
            return !!this.constructor.prototype[name];
          }

          /**
           * Returns true if the specified class member is a method for the currently set state.
           * @param {string} name
           * @returns {boolean}
           * @protected
           */
          _hasMethod(name) {
            var member = this.constructor.prototype[name];
            return !!member && typeof member === "function";
          }

          /**
           * Switches to the specified state.
           * @param {string} statePath
           *   Substates are seperated by a underscores (for example "Initialized.Loading").
           * @param {*[]} [args]
           *   Args that are supplied in $enter and $exit events.
           * @protected
           */
          _setState(statePath, args) {
            var setStateId = ++this._setStateCounter;
            this._setStateId = setStateId;
            if (this._state.__path !== statePath) {
              // Performance optimization.
              var newState = this._sm._stateMap[statePath];
              if (!newState) {
                // Check for super state.
                newState = this._sm.getStateByPath(statePath);
              }
              var prevState = this._state;
              var hasDifferentEnterMethod = newState.prototype.$enter !== this._state.prototype.$enter;
              var hasDifferentExitMethod = newState.prototype.$exit !== this._state.prototype.$exit;
              if (hasDifferentEnterMethod || hasDifferentExitMethod) {
                var sharedState = StateMachine._getSharedState(this._state, newState);
                var context = {
                  newState: newState.__path,
                  prevState: prevState.__path,
                  sharedState: sharedState.__path
                };
                var sharedLevel = sharedState.__level;
                if (hasDifferentExitMethod) {
                  var exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
                  for (var i = 0, n = exitStates.length; i < n; i++) {
                    this.__setState(exitStates[i]);
                    this._callExit(this._state, args, context);
                    var stateChangeOverridden = this._setStateId !== setStateId;
                    if (stateChangeOverridden) {
                      return;
                    }
                  }
                }
                if (hasDifferentEnterMethod) {
                  var enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
                  for (var _i16 = 0, _n12 = enterStates.length; _i16 < _n12; _i16++) {
                    this.__setState(enterStates[_i16]);
                    this._callEnter(this._state, args, context);
                    var _stateChangeOverridden = this._setStateId !== setStateId;
                    if (_stateChangeOverridden) {
                      return;
                    }
                  }
                }
              }
              this.__setState(newState);
              if (this._changedState) {
                var _context = {
                  newState: newState.__path,
                  prevState: prevState.__path
                };
                if (args) {
                  this._changedState(_context, ...args);
                } else {
                  this._changedState(_context);
                }
              }
              if (this._onStateChange) {
                var _context2 = {
                  newState: newState.__path,
                  prevState: prevState.__path
                };
                this._onStateChange(_context2);
              }
            }
          }
          _callEnter(state) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var context = arguments.length > 2 ? arguments[2] : undefined;
            var hasParent = !!state.__parent;
            if (state.prototype.$enter) {
              if (!hasParent || state.__parent.prototype.$enter !== state.prototype.$enter) {
                state.prototype.$enter.apply(this, [context, ...args]);
              }
            }
          }
          _callExit(state) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var context = arguments.length > 2 ? arguments[2] : undefined;
            var hasParent = !!state.__parent;
            if (state.prototype.$exit) {
              if (!hasParent || state.__parent.prototype.$exit !== state.prototype.$exit) {
                state.prototype.$exit.apply(this, [context, ...args]);
              }
            }
          }
          __setState(state) {
            this._state = state;
            this._stateIndex = state.__index;
            this.constructor = state;
          }
          _initStateMachine() {
            this._state = null;
            this._stateIndex = 0;
            this._setStateCounter = 0;
            this._sm = this._routedType._sm;
            this.__setState(this._sm.getStateByPath(""));
            var context = {
              newState: "",
              prevState: undefined,
              sharedState: undefined
            };
            this._callEnter(this._state, [], context);
            this._onStateChange = undefined;
          }

          /**
           * Between multiple member names, select the one specified in the deepest state.
           * If multiple member names are specified in the same deepest state, the first one in the array is returned.
           * @param {string[]} memberNames
           * @returns {string|undefined}
           * @protected
           */
          _getMostSpecificHandledMember(memberNames) {
            var cur = this._state;
            do {
              for (var i = 0, n = memberNames.length; i < n; i++) {
                var memberName = memberNames[i];
                if (!cur.__parent) {
                  if (cur.prototype[memberName]) {
                    return memberName;
                  }
                } else {
                  var alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
                  if (this[alias]) {
                    return memberName;
                  }
                }
              }
              cur = cur.__parent;
            } while (cur);
          }
          static _getStatesUntilLevel(state, level) {
            var states = [];
            while (state.__level > level) {
              states.push(state);
              state = state.__parent;
            }
            return states;
          }
          static _getSharedState(state1, state2) {
            var state1Array = StateMachine._getAncestorStates(state1);
            var state2Array = StateMachine._getAncestorStates(state2);
            var n = Math.min(state1Array.length, state2Array.length);
            for (var i = 0; i < n; i++) {
              if (state1Array[i] !== state2Array[i]) {
                return state1Array[i - 1];
              }
            }
            return state1Array[n - 1];
          }
          static _getAncestorStates(state) {
            var result = [];
            do {
              result.push(state);
            } while (state = state.__parent);
            return result.reverse();
          }
          static _getStateAtLevel(state, level) {
            if (level > state.__level) {
              return undefined;
            }
            while (level < state.__level) {
              state = state.__parent;
            }
            return state;
          }
        }
        class StateMachineType {
          constructor(type) {
            this._type = type;
            this._router = null;
            this.init();
          }
          get router() {
            return this._router;
          }
          init() {
            this._router = this._createRouter();
            this._stateMap = this._getStateMap();
            this._addStateMemberDelegatorsToRouter();
          }
          _createRouter() {
            var type = this._type;
            var router = class StateMachineRouter extends type {
              constructor() {
                super(...arguments);
                if (!this.constructor.hasOwnProperty('_isRouter')) {
                  throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
                }
              }
            };
            router._isRouter = true;
            router.prototype._routedType = type;
            router.original = type;
            this._mixinStateMachineMethods(router);
            return router;
          }
          _mixinStateMachineMethods(router) {
            // Mixin the state machine methods, so that we reuse the methods instead of re-creating them.
            var names = Object.getOwnPropertyNames(StateMachine.prototype);
            for (var i = 0, n = names.length; i < n; i++) {
              var _name2 = names[i];
              if (_name2 !== "constructor") {
                var descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, _name2);
                Object.defineProperty(router.prototype, _name2, descriptor);
              }
            }
          }
          _addStateMemberDelegatorsToRouter() {
            var members = this._getAllMemberNames();
            members.forEach(member => {
              this._addMemberRouter(member);
            });
          }

          /**
           * @note We are generating code because it yields much better performance.
           */
          _addMemberRouter(member) {
            var statePaths = Object.keys(this._stateMap);
            var descriptors = [];
            var aliases = [];
            statePaths.forEach((statePath, index) => {
              var state = this._stateMap[statePath];
              var descriptor = this._getDescriptor(state, member);
              if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                var alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;
                if (!this._router.prototype.hasOwnProperty(alias)) {
                  Object.defineProperty(this._router.prototype, alias, descriptor);
                }
              } else {
                descriptors[index] = null;
                aliases[index] = null;
              }
            });
            var type = undefined;
            descriptors.forEach(descriptor => {
              if (descriptor) {
                var descType = this._getDescriptorType(descriptor);
                if (type && type !== descType) {
                  console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
                  return;
                }
                type = descType;
              }
            });
            switch (type) {
              case "method":
                this._addMethodRouter(member, descriptors, aliases);
                break;
              case "getter":
                this._addGetterSetterRouters(member);
                break;
              case "property":
                console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!");
                break;
            }
          }
          _getDescriptor(state, member) {
            var isValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => true;
            var type = state;
            var curState = state;
            do {
              var descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
              if (descriptor) {
                if (isValid(descriptor)) {
                  descriptor._source = curState;
                  return descriptor;
                }
              }
              type = Object.getPrototypeOf(type);
              if (type && type.hasOwnProperty('__state')) {
                curState = type;
              }
            } while (type && type.prototype);
            return undefined;
          }
          _getDescriptorType(descriptor) {
            if (descriptor.get || descriptor.set) {
              return 'getter';
            } else {
              if (typeof descriptor.value === "function") {
                return 'method';
              } else {
                return 'property';
              }
            }
          }
          static _supportsSpread() {
            if (this.__supportsSpread === undefined) {
              this.__supportsSpread = false;
              try {
                var func = new Function("return [].concat(...arguments);");
                func();
                this.__supportsSpread = true;
              } catch (e) {}
            }
            return this.__supportsSpread;
          }
          _addMethodRouter(member, descriptors, aliases) {
            var code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js", "var i = this._stateIndex;"];
            var cur = aliases[0];
            var supportsSpread = StateMachineType._supportsSpread();
            for (var i = 1, n = aliases.length; i < n; i++) {
              var alias = aliases[i];
              if (alias !== cur) {
                if (cur) {
                  if (supportsSpread) {
                    code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
                  } else {
                    code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
                  }
                } else {
                  code.push(`if (i < ${i}) return ; else`);
                }
              }
              cur = alias;
            }
            if (cur) {
              if (supportsSpread) {
                code.push(`return this["${cur}"](...arguments);`);
              } else {
                code.push(`return this["${cur}"].apply(this, arguments);`);
              }
            } else {
              code.push(`;`);
            }
            var functionBody = code.join("\n");
            var router = new Function([], functionBody);
            var descriptor = {
              value: router
            };
            Object.defineProperty(this._router.prototype, member, descriptor);
          }
          _addGetterSetterRouters(member) {
            var getter = this._getGetterRouter(member);
            var setter = this._getSetterRouter(member);
            var descriptor = {
              get: getter,
              set: setter
            };
            Object.defineProperty(this._router.prototype, member, descriptor);
          }
          _getGetterRouter(member) {
            var statePaths = Object.keys(this._stateMap);
            var aliases = [];
            statePaths.forEach((statePath, index) => {
              var state = this._stateMap[statePath];
              var descriptor = this._getDescriptor(state, member, descriptor => descriptor.get);
              if (descriptor) {
                // Add to prototype.
                var alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;
                if (!this._router.prototype.hasOwnProperty(alias)) {
                  Object.defineProperty(this._router.prototype, alias, descriptor);
                }
              } else {
                aliases[index] = null;
              }
            });
            var code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js", "var i = this._stateIndex;"];
            var cur = aliases[0];
            for (var i = 1, n = aliases.length; i < n; i++) {
              var alias = aliases[i];
              if (alias !== cur) {
                if (cur) {
                  code.push(`if (i < ${i}) return this["${cur}"]; else`);
                } else {
                  code.push(`if (i < ${i}) return ; else`);
                }
              }
              cur = alias;
            }
            if (cur) {
              code.push(`return this["${cur}"];`);
            } else {
              code.push(`;`);
            }
            var functionBody = code.join("\n");
            var router = new Function([], functionBody);
            return router;
          }
          _getSetterRouter(member) {
            var statePaths = Object.keys(this._stateMap);
            var aliases = [];
            statePaths.forEach((statePath, index) => {
              var state = this._stateMap[statePath];
              var descriptor = this._getDescriptor(state, member, descriptor => descriptor.set);
              if (descriptor) {
                // Add to prototype.
                var alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;
                if (!this._router.prototype.hasOwnProperty(alias)) {
                  Object.defineProperty(this._router.prototype, alias, descriptor);
                }
              } else {
                aliases[index] = null;
              }
            });
            var code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js", "var i = this._stateIndex;"];
            var cur = aliases[0];
            for (var i = 1, n = aliases.length; i < n; i++) {
              var alias = aliases[i];
              if (alias !== cur) {
                if (cur) {
                  code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
                } else {
                  code.push(`if (i < ${i}) ; else`);
                }
              }
              cur = alias;
            }
            if (cur) {
              code.push(`this["${cur}"] = arg;`);
            } else {
              code.push(`;`);
            }
            var functionBody = code.join("\n");
            var router = new Function(["arg"], functionBody);
            return router;
          }
          static getStateMemberAlias(path, member) {
            return "$" + (path ? path + "." : "") + member;
          }
          _getAllMemberNames() {
            var stateMap = this._stateMap;
            var map = Object.keys(stateMap);
            var members = new Set();
            map.forEach(statePath => {
              if (statePath === "") {
                // Root state can be skipped: if the method only occurs in the root state, we don't need to re-delegate it based on state.
                return;
              }
              var state = stateMap[statePath];
              var names = this._getStateMemberNames(state);
              names.forEach(name => {
                members.add(name);
              });
            });
            return [...members];
          }
          _getStateMemberNames(state) {
            var type = state;
            var members = new Set();
            var isRoot = this._type === state;
            do {
              var names = this._getStateMemberNamesForType(type);
              names.forEach(name => {
                members.add(name);
              });
              type = Object.getPrototypeOf(type);
            } while (type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));
            return members;
          }
          _getStateMemberNamesForType(type) {
            var memberNames = Object.getOwnPropertyNames(type.prototype);
            return memberNames.filter(memberName => {
              return memberName !== "constructor" && !StateMachineType._isStateLocalMember(memberName);
            });
          }
          static _isStateLocalMember(memberName) {
            return memberName === "$enter" || memberName === "$exit";
          }
          getStateByPath(statePath) {
            if (this._stateMap[statePath]) {
              return this._stateMap[statePath];
            }

            // Search for closest match.
            var parts = statePath.split(".");
            while (parts.pop()) {
              var _statePath = parts.join(".");
              if (this._stateMap[_statePath]) {
                return this._stateMap[_statePath];
              }
            }
          }
          _getStateMap() {
            if (!this._stateMap) {
              this._stateMap = this._createStateMap();
            }
            return this._stateMap;
          }
          _createStateMap() {
            var stateMap = {};
            this._addState(this._type, null, "", stateMap);
            return stateMap;
          }
          _addState(state, parentState, name, stateMap) {
            state.__state = true;
            state.__name = name;
            this._addStaticStateProperty(state, parentState);
            var parentPath = parentState ? parentState.__path : "";
            var path = (parentPath ? parentPath + "." : "") + name;
            state.__path = path;
            state.__level = parentState ? parentState.__level + 1 : 0;
            state.__parent = parentState;
            state.__index = Object.keys(stateMap).length;
            stateMap[path] = state;
            var states = state._states;
            if (states) {
              var isInheritedFromParent = parentState && parentState._states === states;
              if (!isInheritedFromParent) {
                var subStates = state._states();
                subStates.forEach(subState => {
                  var stateName = StateMachineType._getStateName(subState);
                  this._addState(subState, state, stateName, stateMap);
                });
              }
            }
          }
          static _getStateName(state) {
            var name = state.name;
            var index = name.indexOf('$');
            if (index > 0) {
              // Strip off rollup name suffix.
              return name.substr(0, index);
            }
            return name;
          }
          _addStaticStateProperty(state, parentState) {
            if (parentState) {
              var isClassStateLevel = parentState && !parentState.__parent;
              if (isClassStateLevel) {
                this._router[state.__name] = state;
              } else {
                parentState[state.__name] = state;
              }
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * @extends StateMachine
         */
        class Component extends Element$1 {
          constructor(stage, properties) {
            super(stage);

            // Encapsulate tags to prevent leaking.
            this.tagRoot = true;
            if (Utils$2.isObjectLiteral(properties)) {
              Object.assign(this, properties);
            }
            this.__initialized = false;
            this.__firstActive = false;
            this.__firstEnable = false;
            this.__signals = undefined;
            this.__passSignals = undefined;
            this.__construct();

            // Quick-apply template.
            var func = this.constructor.getTemplateFunc(this);
            func.f(this, func.a);
            this._build();
          }
          __start() {
            StateMachine.setupStateMachine(this);
            this._onStateChange = Component.prototype.__onStateChange;
          }
          get state() {
            return this._getState();
          }
          __onStateChange() {
            /* FIXME: Workaround for case, where application was shut but component still lives */
            if (this.application) {
              this.application.updateFocusPath();
            }
          }
          _refocus() {
            /* FIXME: Workaround for case, where application was shut but component still lives */
            if (this.application) {
              this.application.updateFocusPath();
            }
          }
          static bindProp(name) {
            var func = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return {
              __propertyBinding: true,
              __name: name,
              __func: func
            };
          }
          __bindProperty(propObj, targetObj, targetProp) {
            var _this = this;
            // 1. find binding position: find object and property name to be bound
            var obj = targetObj;
            var prop = targetProp;
            var propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];

            // 2. create setters for every given dependency
            var _loop3 = function _loop3() {
              var propName = propDependencies[i];
              var func = propObj.__func ? propObj.__func : context => context[propName];
              if (!_this.hasOwnProperty(propName)) {
                _this[`__prop_bindings_${propName}`] = [{
                  __obj: obj,
                  __prop: prop,
                  __func: func
                }];
                Object.defineProperty(_this, propName, {
                  set: value => {
                    _this[`__prop_${propName}`] = value;
                    var _iterator20 = _createForOfIteratorHelper(_this[`__prop_bindings_${propName}`]),
                      _step20;
                    try {
                      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                        var _step20$value = _step20.value,
                          __obj = _step20$value.__obj,
                          __prop = _step20$value.__prop,
                          __func = _step20$value.__func;
                        __obj[__prop] = __func(_this);
                      }
                    } catch (err) {
                      _iterator20.e(err);
                    } finally {
                      _iterator20.f();
                    }
                  },
                  get: () => _this[`__prop_${propName}`]
                });
              } else {
                _this[`__prop_bindings_${propName}`].push({
                  __obj: obj,
                  __prop: prop,
                  __func: func
                });
              }
            };
            for (var i = 0; i < propDependencies.length; i++) {
              _loop3();
            }
          }

          /**
           * Returns a high-performance template patcher.
           */
          static getTemplateFunc(ctx) {
            // We need a different template function per patch id.
            var name = "_templateFunc";

            // Be careful with class-based static inheritance.
            var hasName = '__has' + name;
            if (this[hasName] !== this) {
              this[hasName] = this;
              this[name] = this.parseTemplate(this._template(ctx));
            }
            return this[name];
          }
          static parseTemplate(obj) {
            var context = {
              loc: [],
              store: [],
              rid: 0
            };
            this.parseTemplateRec(obj, context, "element");
            var code = context.loc.join(";\n");
            var f = new Function("element", "store", code);
            return {
              f: f,
              a: context.store
            };
          }
          static parseTemplateRec(obj, context, cursor) {
            var store = context.store;
            var loc = context.loc;
            var keys = Object.keys(obj);
            keys.forEach(key => {
              var value = obj[key];
              if (Utils$2.isUcChar(key.charCodeAt(0))) {
                // Value must be expanded as well.
                if (Utils$2.isObjectLiteral(value)) {
                  // Ref.
                  var childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
                  var type = value.type ? value.type : Element$1;
                  if (type === Element$1) {
                    loc.push(`var ${childCursor} = element.stage.createElement()`);
                  } else {
                    store.push(type);
                    loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
                  }
                  loc.push(`${childCursor}.ref = "${key}"`);
                  context.rid++;

                  // Enter sub.
                  this.parseTemplateRec(value, context, childCursor);
                  loc.push(`${cursor}.childList.add(${childCursor})`);
                } else if (Utils$2.isObject(value)) {
                  // Dynamic assignment.
                  store.push(value);
                  loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
                }
              } else {
                if (key === "text") {
                  var propKey = cursor + "__text";
                  loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
                  if (value.__propertyBinding === true) {
                    // Allow binding entire objects to text property
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                  } else {
                    this.parseTemplatePropRec(value, context, propKey);
                  }
                } else if (key === "shader" && Utils$2.isObjectLiteral(value)) {
                  var shaderCursor = `${cursor}["shader"]`;
                  store.push(value);
                  loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                  this.parsePropertyBindings(value, context, shaderCursor);
                } else if (key === "texture" && Utils$2.isObjectLiteral(value)) {
                  var _propKey = cursor + "__texture";
                  var _type = value.type;
                  if (_type) {
                    store.push(_type);
                    loc.push(`var ${_propKey} = new store[${store.length - 1}](${cursor}.stage)`);
                    this.parseTemplatePropRec(value, context, _propKey);
                    loc.push(`${cursor}["${key}"] = ${_propKey}`);
                  } else {
                    loc.push(`${_propKey} = ${cursor}.texture`);
                    this.parseTemplatePropRec(value, context, _propKey);
                  }
                } else if (Utils$2.isObjectLiteral(value) && value.__propertyBinding === true) {
                  store.push(value);
                  loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else {
                  // Property;
                  if (Utils$2.isNumber(value)) {
                    loc.push(`${cursor}["${key}"] = ${value}`);
                  } else if (Utils$2.isBoolean(value)) {
                    loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                  } else if (Utils$2.isObject(value) || Array.isArray(value)) {
                    // Dynamic assignment.
                    // Because literal objects may contain dynamics, we store the full object.
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                  } else {
                    // String etc.
                    loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                  }
                }
              }
            });
          }
          static parseTemplatePropRec(obj, context, cursor) {
            var store = context.store;
            var loc = context.loc;
            var keys = Object.keys(obj);
            keys.forEach(key => {
              if (key !== "type") {
                var value = obj[key];
                if (Utils$2.isNumber(value)) {
                  loc.push(`${cursor}["${key}"] = ${value}`);
                } else if (Utils$2.isBoolean(value)) {
                  loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                } else if (Utils$2.isObject(value) && value.__propertyBinding === true) {
                  store.push(value);
                  loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else if (Utils$2.isObject(value) || Array.isArray(value)) {
                  // Dynamic assignment.
                  // Because literal objects may contain dynamics, we store the full object.
                  store.push(value);
                  loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                } else {
                  // String etc.
                  loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                }
              }
            });
          }
          static parsePropertyBindings(obj, context, cursor) {
            var store = context.store;
            var loc = context.loc;
            var keys = Object.keys(obj);
            keys.forEach(key => {
              if (key !== "type") {
                var value = obj[key];
                if (Utils$2.isObjectLiteral(value) && value.__propertyBinding === true) {
                  store.push(value);
                  loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                }
              }
            });
          }
          _onSetup() {
            if (!this.__initialized) {
              this._setup();
            }
          }
          _setup() {}
          _onAttach() {
            if (!this.__initialized) {
              this.__init();
              this.__initialized = true;
            }
            this._attach();
          }
          _attach() {}
          _onDetach() {
            this._detach();
          }
          _detach() {}
          _onEnabled() {
            if (!this.__firstEnable) {
              this._firstEnable();
              this.__firstEnable = true;
            }
            this._enable();
          }
          _firstEnable() {}
          _enable() {}
          _onDisabled() {
            this._disable();
          }
          _disable() {}
          _onActive() {
            if (!this.__firstActive) {
              this._firstActive();
              this.__firstActive = true;
            }
            this._active();
          }
          _firstActive() {}
          _active() {}
          _onInactive() {
            this._inactive();
          }
          _inactive() {}
          get application() {
            return this.stage.application;
          }
          __construct() {
            this._construct();
          }
          _construct() {}
          _build() {}
          __init() {
            this._init();
          }
          _init() {}
          _focus(newTarget, prevTarget) {}
          _unfocus(newTarget) {}
          _focusChange(target, newTarget) {}
          _getFocused() {
            // Override to delegate focus to child components.
            return this;
          }
          _setFocusSettings(settings) {
            // Override to add custom settings. See Application._handleFocusSettings().
          }
          _handleFocusSettings(settings) {
            // Override to react on custom settings. See Application._handleFocusSettings().
          }
          static _template() {
            return {};
          }
          hasFinalFocus() {
            var path = this.application._focusPath;
            return path && path.length && path[path.length - 1] === this;
          }
          hasFocus() {
            var path = this.application._focusPath;
            return path && path.indexOf(this) >= 0;
          }
          get cparent() {
            return Component.getParent(this);
          }
          seekAncestorByType(type) {
            var c = this.cparent;
            while (c) {
              if (c.constructor === type) {
                return c;
              }
              c = c.cparent;
            }
          }
          getSharedAncestorComponent(element) {
            var ancestor = this.getSharedAncestor(element);
            while (ancestor && !ancestor.isComponent) {
              ancestor = ancestor.parent;
            }
            return ancestor;
          }
          get signals() {
            return this.__signals;
          }
          set signals(v) {
            if (!Utils$2.isObjectLiteral(v)) {
              this._throwError("Signals: specify an object with signal-to-fire mappings");
            }
            this.__signals = v;
          }
          set alterSignals(v) {
            if (!Utils$2.isObjectLiteral(v)) {
              this._throwError("Signals: specify an object with signal-to-fire mappings");
            }
            if (!this.__signals) {
              this.__signals = {};
            }
            for (var key in v) {
              var d = v[key];
              if (d === undefined) {
                delete this.__signals[key];
              } else {
                this.__signals[key] = v;
              }
            }
          }
          get passSignals() {
            return this.__passSignals || {};
          }
          set passSignals(v) {
            this.__passSignals = Object.assign(this.__passSignals || {}, v);
          }
          set alterPassSignals(v) {
            if (!Utils$2.isObjectLiteral(v)) {
              this._throwError("Signals: specify an object with signal-to-fire mappings");
            }
            if (!this.__passSignals) {
              this.__passSignals = {};
            }
            for (var key in v) {
              var d = v[key];
              if (d === undefined) {
                delete this.__passSignals[key];
              } else {
                this.__passSignals[key] = v;
              }
            }
          }

          /**
           * Signals the parent of the specified event.
           * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
           * @param {string} event
           * @param {...*} args
           */
          signal(event) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            return this._signal(event, args);
          }
          _signal(event, args) {
            var signalParent = this._getParentSignalHandler();
            if (signalParent) {
              if (this.__signals) {
                var fireEvent = this.__signals[event];
                if (fireEvent === false) {
                  // Ignore event.
                  return;
                }
                if (fireEvent) {
                  if (fireEvent === true) {
                    fireEvent = event;
                  }
                  if (Utils$2.isFunction(fireEvent)) {
                    return fireEvent(...args);
                  }
                  if (signalParent._hasMethod(fireEvent)) {
                    return signalParent[fireEvent](...args);
                  }
                }
              }
              var passSignal = this.__passSignals && this.__passSignals[event];
              if (passSignal) {
                // Bubble up.
                if (passSignal && passSignal !== true) {
                  // Replace signal name.
                  event = passSignal;
                }
                return signalParent._signal(event, args);
              }
            }
          }
          _getParentSignalHandler() {
            return this.cparent ? this.cparent._getSignalHandler() : null;
          }
          _getSignalHandler() {
            if (this._signalProxy) {
              return this.cparent ? this.cparent._getSignalHandler() : null;
            }
            return this;
          }
          get _signalProxy() {
            return false;
          }
          fireAncestors(name) {
            if (!name.startsWith('$')) {
              throw new Error("Ancestor event name must be prefixed by dollar sign.");
            }
            var parent = this._getParentSignalHandler();
            if (parent) {
              for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
                args[_key4 - 1] = arguments[_key4];
              }
              return parent._doFireAncestors(name, args);
            }
          }
          _doFireAncestors(name, args) {
            if (this._hasMethod(name)) {
              return this.fire(name, ...args);
            } else {
              var signalParent = this._getParentSignalHandler();
              if (signalParent) {
                return signalParent._doFireAncestors(name, args);
              }
            }
          }
          static collectSubComponents(subs, element) {
            if (element.hasChildren()) {
              var childList = element.__childList;
              for (var i = 0, n = childList.length; i < n; i++) {
                var child = childList.getAt(i);
                if (child.isComponent) {
                  subs.push(child);
                } else {
                  Component.collectSubComponents(subs, child);
                }
              }
            }
          }
          static getComponent(element) {
            var parent = element;
            while (parent && !parent.isComponent) {
              parent = parent.parent;
            }
            return parent;
          }
          static getParent(element) {
            return Component.getComponent(element.parent);
          }
        }
        Component.prototype.isComponent = true;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CoreQuadList {
          constructor(ctx) {
            this.ctx = ctx;
            this.quadTextures = [];
            this.quadElements = [];
          }
          get length() {
            return this.quadTextures.length;
          }
          reset() {
            this.quadTextures = [];
            this.quadElements = [];
            this.dataLength = 0;
          }
          getElement(index) {
            return this.quadElements[index]._element;
          }
          getElementCore(index) {
            return this.quadElements[index];
          }
          getTexture(index) {
            return this.quadTextures[index];
          }
          getTextureWidth(index) {
            var nativeTexture = this.quadTextures[index];
            if (nativeTexture.w) {
              // Render texture;
              return nativeTexture.w;
            } else {
              return this.quadElements[index]._displayedTextureSource.w;
            }
          }
          getTextureHeight(index) {
            var nativeTexture = this.quadTextures[index];
            if (nativeTexture.h) {
              // Render texture;
              return nativeTexture.h;
            } else {
              return this.quadElements[index]._displayedTextureSource.h;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLCoreQuadList extends CoreQuadList {
          constructor(ctx) {
            super(ctx);

            // Allocate a fairly big chunk of memory that should be enough to support ~100000 (default) quads.
            // We do not (want to) handle memory overflow.
            var byteSize = ctx.stage.getOption('bufferMemory');
            this.dataLength = 0;
            this.data = new ArrayBuffer(byteSize);
            this.floats = new Float32Array(this.data);
            this.uints = new Uint32Array(this.data);
          }
          getAttribsDataByteOffset(index) {
            // Where this quad can be found in the attribs buffer.
            return index * 80;
          }
          getQuadContents() {
            // Debug: log contents of quad buffer.
            var floats = this.floats;
            var uints = this.uints;
            var lines = [];
            for (var i = 1; i <= this.length; i++) {
              var str = 'entry ' + i + ': ';
              for (var j = 0; j < 4; j++) {
                var b = i * 20 + j * 4;
                str += floats[b] + ',' + floats[b + 1] + ':' + floats[b + 2] + ',' + floats[b + 3] + '[' + uints[b + 4].toString(16) + '] ';
              }
              lines.push(str);
            }
            return lines;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CoreQuadOperation {
          constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
            this.ctx = ctx;
            this.shader = shader;
            this.shaderOwner = shaderOwner;
            this.renderTextureInfo = renderTextureInfo;
            this.scissor = scissor;
            this.index = index;
            this.length = 0;
          }
          get quads() {
            return this.ctx.renderState.quads;
          }
          getTexture(index) {
            return this.quads.getTexture(this.index + index);
          }
          getElementCore(index) {
            return this.quads.getElementCore(this.index + index);
          }
          getElement(index) {
            return this.quads.getElement(this.index + index);
          }
          getElementWidth(index) {
            return this.getElement(index).renderWidth;
          }
          getElementHeight(index) {
            return this.getElement(index).renderHeight;
          }
          getTextureWidth(index) {
            return this.quads.getTextureWidth(this.index + index);
          }
          getTextureHeight(index) {
            return this.quads.getTextureHeight(this.index + index);
          }
          getRenderWidth() {
            if (this.renderTextureInfo) {
              return this.renderTextureInfo.w;
            } else {
              return this.ctx.stage.w;
            }
          }
          getRenderHeight() {
            if (this.renderTextureInfo) {
              return this.renderTextureInfo.h;
            } else {
              return this.ctx.stage.h;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLCoreQuadOperation extends CoreQuadOperation {
          constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
            super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
            this.extraAttribsDataByteOffset = 0;
          }
          getAttribsDataByteOffset(index) {
            // Where this quad can be found in the attribs buffer.
            return this.quads.getAttribsDataByteOffset(this.index + index);
          }

          /**
           * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
           * @param x
           * @param y
           * @return {number[]}
           */
          getNormalRenderTextureCoords(x, y) {
            var coords = this.shaderOwner.getRenderTextureCoords(x, y);
            coords[0] /= this.getRenderWidth();
            coords[1] /= this.getRenderHeight();
            coords[0] = coords[0] * 2 - 1;
            coords[1] = 1 - coords[1] * 2;
            return coords;
          }
          getProjection() {
            if (this.renderTextureInfo === null) {
              return this.ctx.renderExec._projection;
            } else {
              return this.renderTextureInfo.nativeTexture.projection;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CoreRenderExecutor {
          constructor(ctx) {
            this.ctx = ctx;
            this.renderState = ctx.renderState;
            this.gl = this.ctx.stage.gl;
          }
          destroy() {}
          _reset() {
            this._bindRenderTexture(null);
            this._setScissor(null);
            this._clearRenderTexture();
          }
          execute() {
            this._reset();
            var qops = this.renderState.quadOperations;
            var i = 0,
              n = qops.length;
            while (i < n) {
              this._processQuadOperation(qops[i]);
              i++;
            }
          }
          _processQuadOperation(quadOperation) {
            if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
              // Ignore quad operations when we are 're-using' another texture as the render texture result.
              return;
            }
            this._setupQuadOperation(quadOperation);
            this._execQuadOperation(quadOperation);
          }
          _setupQuadOperation(quadOperation) {}
          _execQuadOperation(op) {
            // Set render texture.
            var nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;
            if (this._renderTexture !== nativeTexture) {
              this._bindRenderTexture(nativeTexture);
            }
            if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
              this._setScissor(null);
              this._clearRenderTexture();
              op.renderTextureInfo.cleared = true;
              this._setScissor(op.scissor);
            } else {
              this._setScissor(op.scissor);
            }
            this._renderQuadOperation(op);
          }
          _renderQuadOperation(op) {}
          _bindRenderTexture(renderTexture) {
            this._renderTexture = renderTexture;
          }
          _clearRenderTexture(renderTexture) {}
          _setScissor(area) {}
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLCoreRenderExecutor extends CoreRenderExecutor {
          constructor(ctx) {
            super(ctx);
            this.gl = this.ctx.stage.gl;
            this.init();
          }
          init() {
            var gl = this.gl;

            // Create new sharable buffer for params.
            this._attribsBuffer = gl.createBuffer();
            var maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);

            // Init webgl arrays.
            var allIndices = new Uint16Array(maxQuads * 6);

            // fill the indices with the quads to draw.
            for (var i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
              allIndices[i] = j;
              allIndices[i + 1] = j + 1;
              allIndices[i + 2] = j + 2;
              allIndices[i + 3] = j;
              allIndices[i + 4] = j + 2;
              allIndices[i + 5] = j + 3;
            }

            // The quads buffer can be (re)used to draw a range of quads.
            this._quadsBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);

            // The matrix that causes the [0,0 - W,H] box to map to [-1,-1 - 1,1] in the end results.
            this._projection = new Float32Array([2 / this.ctx.stage.coordsWidth, -2 / this.ctx.stage.coordsHeight]);
          }
          destroy() {
            super.destroy();
            this.gl.deleteBuffer(this._attribsBuffer);
            this.gl.deleteBuffer(this._quadsBuffer);
          }
          _reset() {
            super._reset();
            var gl = this.gl;
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
            gl.disable(gl.DEPTH_TEST);
            this._stopShaderProgram();
            this._setupBuffers();
          }
          _setupBuffers() {
            var gl = this.gl;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
            var element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
          }
          _setupQuadOperation(quadOperation) {
            super._setupQuadOperation(quadOperation);
            this._useShaderProgram(quadOperation.shader, quadOperation);
          }
          _renderQuadOperation(op) {
            var shader = op.shader;
            if (op.length || op.shader.addEmpty()) {
              shader.beforeDraw(op);
              shader.draw(op);
              shader.afterDraw(op);
            }
          }

          /**
           * @param {WebGLShader} shader;
           * @param {CoreQuadOperation} operation;
           */
          _useShaderProgram(shader, operation) {
            if (!shader.hasSameProgram(this._currentShaderProgram)) {
              if (this._currentShaderProgram) {
                this._currentShaderProgram.stopProgram();
              }
              shader.useProgram();
              this._currentShaderProgram = shader;
            }
            shader.setupUniforms(operation);
          }
          _stopShaderProgram() {
            if (this._currentShaderProgram) {
              // The currently used shader program should be stopped gracefully.
              this._currentShaderProgram.stopProgram();
              this._currentShaderProgram = null;
            }
          }
          _bindRenderTexture(renderTexture) {
            super._bindRenderTexture(renderTexture);
            var gl = this.gl;
            if (!this._renderTexture) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.viewport(0, 0, this.ctx.stage.w, this.ctx.stage.h);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
              gl.viewport(0, 0, this._renderTexture.w, this._renderTexture.h);
            }
          }
          _clearRenderTexture() {
            super._clearRenderTexture();
            var gl = this.gl;
            if (!this._renderTexture) {
              var glClearColor = this.ctx.stage.getClearColor();
              if (glClearColor) {
                gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            } else {
              // Clear texture.
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
          }
          _setScissor(area) {
            super._setScissor(area);
            if (this._scissor === area) {
              return;
            }
            this._scissor = area;
            var gl = this.gl;
            if (!area) {
              gl.disable(gl.SCISSOR_TEST);
            } else {
              gl.enable(gl.SCISSOR_TEST);
              var _precision2 = this.ctx.stage.getRenderPrecision();
              var y = area[1];
              if (this._renderTexture === null) {
                // Flip.
                y = this.ctx.stage.h / _precision2 - (area[1] + area[3]);
              }
              gl.scissor(Math.round(area[0] * _precision2), Math.round(y * _precision2), Math.round(area[2] * _precision2), Math.round(area[3] * _precision2));
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CoreRenderState {
          constructor(ctx) {
            this.ctx = ctx;
            this.stage = ctx.stage;
            this.defaultShader = this.stage.renderer.getDefaultShader(ctx);
            this.renderer = ctx.stage.renderer;
            this.quads = this.renderer.createCoreQuadList(ctx);
          }
          reset() {
            this._renderTextureInfo = null;
            this._scissor = null;
            this._shader = null;
            this._shaderOwner = null;
            this._realShader = null;
            this._check = false;
            this.quadOperations = [];
            this._texturizer = null;
            this._texturizerTemporary = false;
            this._quadOperation = null;
            this.quads.reset();
            this._temporaryTexturizers = [];
            this._isCachingTexturizer = false;
          }
          get length() {
            return this.quads.quadTextures.length;
          }
          setShader(shader, owner) {
            if (this._shaderOwner !== owner || this._realShader !== shader) {
              // Same shader owner: active shader is also the same.
              // Prevent any shader usage to save performance.

              this._realShader = shader;
              if (shader.useDefault()) {
                // Use the default shader when possible to prevent unnecessary program changes.
                shader = this.defaultShader;
              }
              if (this._shader !== shader || this._shaderOwner !== owner) {
                this._shader = shader;
                this._shaderOwner = owner;
                this._check = true;
              }
            }
          }
          get renderTextureInfo() {
            return this._renderTextureInfo;
          }
          setScissor(area) {
            if (this._scissor !== area) {
              if (area) {
                this._scissor = area;
              } else {
                this._scissor = null;
              }
              this._check = true;
            }
          }
          getScissor() {
            return this._scissor;
          }
          setRenderTextureInfo(renderTextureInfo) {
            if (this._renderTextureInfo !== renderTextureInfo) {
              this._renderTextureInfo = renderTextureInfo;
              this._scissor = null;
              this._check = true;
            }
          }

          /**
           * Sets the texturizer to be drawn during subsequent addQuads.
           * @param {ElementTexturizer} texturizer
           */
          setTexturizer(texturizer) {
            var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            this._texturizer = texturizer;
            this._cacheTexturizer = cache;
          }
          set isCachingTexturizer(v) {
            this._isCachingTexturizer = v;
          }
          get isCachingTexturizer() {
            return this._isCachingTexturizer;
          }
          addQuad(elementCore) {
            if (!this._quadOperation) {
              this._createQuadOperation();
            } else if (this._check && this._hasChanges()) {
              this._finishQuadOperation();
              this._check = false;
            }
            var nativeTexture = null;
            if (this._texturizer) {
              nativeTexture = this._texturizer.getResultTexture();
              if (!this._cacheTexturizer) {
                // We can release the temporary texture immediately after finalizing this quad operation.
                this._temporaryTexturizers.push(this._texturizer);
              }
            }
            if (!nativeTexture) {
              nativeTexture = elementCore._displayedTextureSource.nativeTexture;
            }
            if (this._renderTextureInfo) {
              if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
                // The texture might be reusable under some conditions. We will check them in ElementCore.renderer.
                this._renderTextureInfo.nativeTexture = nativeTexture;
                this._renderTextureInfo.offset = this.length;
              } else {
                // It is not possible to reuse another texture when there is more than one quad.
                this._renderTextureInfo.nativeTexture = null;
              }
              this._renderTextureInfo.empty = false;
            }
            this.quads.quadTextures.push(nativeTexture);
            this.quads.quadElements.push(elementCore);
            this._quadOperation.length++;
            this.renderer.addQuad(this, this.quads, this.length - 1);
          }
          finishedRenderTexture() {
            if (this._renderTextureInfo.nativeTexture) {
              // There was only one texture drawn in this render texture.
              // Check if we can reuse it so that we can optimize out an unnecessary render texture operation.
              // (it should exactly span this render texture).
              if (!this._isRenderTextureReusable()) {
                this._renderTextureInfo.nativeTexture = null;
              }
            }
          }
          _isRenderTextureReusable() {
            var offset = this._renderTextureInfo.offset;
            return this.quads.quadTextures[offset].w === this._renderTextureInfo.w && this.quads.quadTextures[offset].h === this._renderTextureInfo.h && this.renderer.isRenderTextureReusable(this, this._renderTextureInfo);
          }
          _hasChanges() {
            var q = this._quadOperation;
            if (this._shader !== q.shader) return true;
            if (this._shaderOwner !== q.shaderOwner) return true;
            if (this._renderTextureInfo !== q.renderTextureInfo) return true;
            if (this._scissor !== q.scissor) {
              if (this._scissor[0] !== q.scissor[0] || this._scissor[1] !== q.scissor[1] || this._scissor[2] !== q.scissor[2] || this._scissor[3] !== q.scissor[3]) {
                return true;
              }
            }
            return false;
          }
          _finishQuadOperation() {
            var create = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            if (this._quadOperation) {
              if (this._quadOperation.length || this._shader.addEmpty()) {
                if (!this._quadOperation.scissor || this._quadOperation.scissor[2] > 0 && this._quadOperation.scissor[3] > 0) {
                  // Ignore empty clipping regions.
                  this.quadOperations.push(this._quadOperation);
                }
              }
              if (this._temporaryTexturizers.length) {
                for (var i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
                  // We can now reuse these render-to-textures in subsequent stages.
                  // Huge performance benefit when filtering (fast blur).
                  this._temporaryTexturizers[i].releaseRenderTexture();
                }
                this._temporaryTexturizers = [];
              }
              this._quadOperation = null;
            }
            if (create) {
              this._createQuadOperation();
            }
          }
          _createQuadOperation() {
            this._quadOperation = this.renderer.createCoreQuadOperation(this.ctx, this._shader, this._shaderOwner, this._renderTextureInfo, this._scissor, this.length);
            this._check = false;
          }
          finish() {
            if (this._quadOperation) {
              // Add remaining.
              this._finishQuadOperation(false);
            }
            this.renderer.finishRenderState(this);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Base functionality for shader setup/destroy.
         */
        class WebGLShaderProgram {
          constructor(vertexShaderSource, fragmentShaderSource) {
            this.vertexShaderSource = vertexShaderSource;
            this.fragmentShaderSource = fragmentShaderSource;
            this._program = null;
            this._uniformLocations = new Map();
            this._attributeLocations = new Map();
            this._currentUniformValues = {};
          }
          compile(gl) {
            if (this._program) return;
            this.gl = gl;
            this._program = gl.createProgram();
            var glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
            var glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
            gl.attachShader(this._program, glVertShader);
            gl.attachShader(this._program, glFragShader);
            gl.linkProgram(this._program);

            // if linking fails, then log and cleanup
            if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
              console.error('[Lightning] Error: Could not initialize shader.');
              console.error('[Lightning] gl.VALIDATE_STATUS', gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
              console.error('[Lightning] gl.getError()', gl.getError());

              // if there is a program info log, log it
              if (gl.getProgramInfoLog(this._program) !== '') {
                console.warn('[Lightning] Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(this._program));
              }
              gl.deleteProgram(this._program);
              this._program = null;
            }

            // clean up some shaders
            gl.deleteShader(glVertShader);
            gl.deleteShader(glFragShader);
          }
          _glCompile(type, src) {
            var shader = this.gl.createShader(type);
            this.gl.shaderSource(shader, src);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
              console.error('[Lightning]', this.constructor.name, 'Type: ' + (type === this.gl.VERTEX_SHADER ? 'vertex shader' : 'fragment shader'));
              console.error('[Lightning]', this.gl.getShaderInfoLog(shader));
              var idx = 0;
              console.error('[Lightning]', "========== source ==========\n" + src.split("\n").map(line => "" + ++idx + ": " + line).join("\n"));
              return null;
            }
            return shader;
          }
          getUniformLocation(name) {
            var location = this._uniformLocations.get(name);
            if (location === undefined) {
              location = this.gl.getUniformLocation(this._program, name);
              this._uniformLocations.set(name, location);
            }
            return location;
          }
          getAttribLocation(name) {
            var location = this._attributeLocations.get(name);
            if (location === undefined) {
              location = this.gl.getAttribLocation(this._program, name);
              this._attributeLocations.set(name, location);
            }
            return location;
          }
          destroy() {
            if (this._program) {
              this.gl.deleteProgram(this._program);
              this._program = null;
            }
          }
          get glProgram() {
            return this._program;
          }
          get compiled() {
            return !!this._program;
          }
          _valueEquals(v1, v2) {
            // Uniform value is either a typed array or a numeric value.
            if (v1.length && v2.length) {
              for (var i = 0, n = v1.length; i < n; i++) {
                if (v1[i] !== v2[i]) return false;
              }
              return true;
            } else {
              return v1 === v2;
            }
          }
          _valueClone(v) {
            if (v.length) {
              return v.slice(0);
            } else {
              return v;
            }
          }
          setUniformValue(name, value, glFunction) {
            var v = this._currentUniformValues[name];
            if (v === undefined || !this._valueEquals(v, value)) {
              var clonedValue = this._valueClone(value);
              this._currentUniformValues[name] = clonedValue;
              var loc = this.getUniformLocation(name);
              if (loc) {
                var isMatrix = glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv;
                if (isMatrix) {
                  glFunction.call(this.gl, loc, false, clonedValue);
                } else {
                  glFunction.call(this.gl, loc, clonedValue);
                }
              }
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLShader extends Shader {
          constructor(ctx) {
            super(ctx);
            var stage = ctx.stage;
            this._program = stage.renderer.shaderPrograms.get(this.constructor);
            if (!this._program) {
              this._program = new WebGLShaderProgram(this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);

              // Let the vbo context perform garbage collection.
              stage.renderer.shaderPrograms.set(this.constructor, this._program);
            }
            this.gl = stage.gl;
          }
          get glProgram() {
            return this._program.glProgram;
          }
          _init() {
            if (!this._initialized) {
              this.initialize();
              this._initialized = true;
            }
          }
          initialize() {
            this._program.compile(this.gl);
          }
          get initialized() {
            return this._initialized;
          }
          _uniform(name) {
            return this._program.getUniformLocation(name);
          }
          _attrib(name) {
            return this._program.getAttribLocation(name);
          }
          _setUniform(name, value, glFunction) {
            this._program.setUniformValue(name, value, glFunction);
          }
          useProgram() {
            this._init();
            this.gl.useProgram(this.glProgram);
            this.beforeUsage();
            this.enableAttribs();
          }
          stopProgram() {
            this.afterUsage();
            this.disableAttribs();
          }
          hasSameProgram(other) {
            // For performance reasons, we first check for identical references.
            return other && (other === this || other._program === this._program);
          }
          beforeUsage() {
            // Override to set settings other than the default settings (blend mode etc).
          }
          afterUsage() {
            // All settings changed in beforeUsage should be reset here.
          }
          enableAttribs() {}
          disableAttribs() {}
          getExtraAttribBytesPerVertex() {
            return 0;
          }
          getVertexAttribPointerOffset(operation) {
            return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
          }
          setExtraAttribsInBuffer(operation) {
            // Set extra attrib data in in operation.quads.data/floats/uints, starting from
            // operation.extraAttribsBufferByteOffset.
          }
          setupUniforms(operation) {
            // Set all shader-specific uniforms.
            // Notice that all uniforms should be set, even if they have not been changed within this shader instance.
            // The uniforms are shared by all shaders that have the same type (and shader program).
          }
          _getProjection(operation) {
            return operation.getProjection();
          }
          getFlipY(operation) {
            return this._getProjection(operation)[1] < 0;
          }
          beforeDraw(operation) {}
          draw(operation) {}
          afterDraw(operation) {}
          cleanup() {
            this._initialized = false;
            // Program takes little resources, so it is only destroyed when the full stage is destroyed.
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var DefaultShader$1 = class DefaultShader extends WebGLShader {
          enableAttribs() {
            // Enables the attribs in the shader program.
            var gl = this.gl;
            gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
            gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
            if (this._attrib("aTextureCoord") !== -1) {
              gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
              gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
            }
            if (this._attrib("aColor") !== -1) {
              // Some shaders may ignore the color.
              gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
              gl.enableVertexAttribArray(this._attrib("aColor"));
            }
          }
          disableAttribs() {
            // Disables the attribs in the shader program.
            var gl = this.gl;
            gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
            if (this._attrib("aTextureCoord") !== -1) {
              gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
            }
            if (this._attrib("aColor") !== -1) {
              gl.disableVertexAttribArray(this._attrib("aColor"));
            }
          }
          setupUniforms(operation) {
            this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
          }
          draw(operation) {
            var gl = this.gl;
            var length = operation.length;
            if (length) {
              var glTexture = operation.getTexture(0);
              var pos = 0;
              for (var i = 0; i < length; i++) {
                var tx = operation.getTexture(i);
                if (glTexture !== tx) {
                  gl.bindTexture(gl.TEXTURE_2D, glTexture);
                  gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                  glTexture = tx;
                  pos = i;
                }
              }
              if (pos < length) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
              }
            }
          }
        };
        DefaultShader$1.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        DefaultShader$1.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Renderer {
          constructor(stage) {
            this.stage = stage;
            this._defaultShader = undefined;
          }
          gc(aggressive) {}
          destroy() {}
          getDefaultShader() {
            var ctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stage.ctx;
            if (!this._defaultShader) {
              this._defaultShader = this._createDefaultShader(ctx);
            }
            return this._defaultShader;
          }
          _createDefaultShader(ctx) {}
          isValidShaderType(shaderType) {
            return shaderType.prototype instanceof this._getShaderBaseType();
          }
          createShader(ctx, settings) {
            var shaderType = settings.type;
            // If shader type is not correct, use a different platform.
            if (!this.isValidShaderType(shaderType)) {
              var convertedShaderType = this._getShaderAlternative(shaderType);
              if (!convertedShaderType) {
                console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
                return this._createDefaultShader(ctx);
              }
              return new convertedShaderType(ctx);
            } else {
              var shader = new shaderType(ctx);
              Base.patchObject(this, settings);
              return shader;
            }
          }
          _getShaderBaseType() {}
          _getShaderAlternative(shaderType) {
            return this.getDefaultShader();
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
            console.warn('[Lightning] copyRenderTexture not supported by renderer');
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLRenderer extends Renderer {
          constructor(stage) {
            super(stage);
            this.shaderPrograms = new Map();
            this._compressedTextureExtensions = {
              astc: stage.gl.getExtension('WEBGL_compressed_texture_astc'),
              etc1: stage.gl.getExtension('WEBGL_compressed_texture_etc1'),
              s3tc: stage.gl.getExtension('WEBGL_compressed_texture_s3tc'),
              pvrtc: stage.gl.getExtension('WEBGL_compressed_texture_pvrtc')
            };
          }
          getCompressedTextureExtensions() {
            return this._compressedTextureExtensions;
          }
          destroy() {
            this.shaderPrograms.forEach(shaderProgram => shaderProgram.destroy());
          }
          _createDefaultShader(ctx) {
            return new DefaultShader$1(ctx);
          }
          _getShaderBaseType() {
            return WebGLShader;
          }
          _getShaderAlternative(shaderType) {
            return shaderType.getWebGL && shaderType.getWebGL();
          }
          createCoreQuadList(ctx) {
            return new WebGLCoreQuadList(ctx);
          }
          createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
            return new WebGLCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
          }
          createCoreRenderExecutor(ctx) {
            return new WebGLCoreRenderExecutor(ctx);
          }
          createCoreRenderState(ctx) {
            return new CoreRenderState(ctx);
          }
          createRenderTexture(w, h, pw, ph) {
            var gl = this.stage.gl;
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            glTexture.params = {};
            glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
            glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
            glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
            glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
            glTexture.options = {
              format: gl.RGBA,
              internalFormat: gl.RGBA,
              type: gl.UNSIGNED_BYTE
            };

            // We need a specific framebuffer for every render texture.
            glTexture.framebuffer = gl.createFramebuffer();
            glTexture.projection = new Float32Array([2 / w, 2 / h]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
            return glTexture;
          }
          freeRenderTexture(glTexture) {
            var gl = this.stage.gl;
            gl.deleteFramebuffer(glTexture.framebuffer);
            gl.deleteTexture(glTexture);
          }
          _getBytesPerPixel(fmt, type) {
            var gl = this.stage.gl;
            if (fmt === gl.RGBA) {
              switch (type) {
                case gl.UNSIGNED_BYTE:
                  return 4;
                case gl.UNSIGNED_SHORT_4_4_4_4:
                  return 2;
                case gl.UNSIGNED_SHORT_5_5_5_1:
                  return 2;
                default:
                  throw new Error('Invalid type specified for GL_RGBA format');
              }
            } else if (fmt === gl.RGB) {
              switch (type) {
                case gl.UNSIGNED_BYTE:
                  return 3;
                case gl.UNSIGNED_BYTE_5_6_5:
                  return 2;
                default:
                  throw new Error('Invalid type specified for GL_RGB format');
              }
            } else {
              throw new Error('Invalid format specified in call to _getBytesPerPixel()');
            }
          }
          uploadTextureSource(textureSource, options) {
            var gl = this.stage.gl;
            var source = options.source;
            var compressed = false;
            if (options.renderInfo) {
              compressed = options.renderInfo.compressed || false;
            }
            var format = {
              premultiplyAlpha: true,
              hasAlpha: true
            };
            if (options && options.hasOwnProperty('premultiplyAlpha')) {
              format.premultiplyAlpha = options.premultiplyAlpha;
            }
            if (options && options.hasOwnProperty('flipBlueRed')) {
              format.flipBlueRed = options.flipBlueRed;
            }
            if (options && options.hasOwnProperty('hasAlpha')) {
              format.hasAlpha = options.hasAlpha;
            }
            if (!format.hasAlpha) {
              format.premultiplyAlpha = false;
            }
            format.texParams = options.texParams || {};
            format.texOptions = options.texOptions || {};
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);
            if (Utils$2.isNode) {
              gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
            }
            var texParams = format.texParams;
            if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
            if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
            if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
            if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
            Object.keys(texParams).forEach(key => {
              var value = texParams[key];
              gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
            });
            if (compressed) {
              this.stage.platform.uploadCompressedGlTexture(gl, textureSource, source);
              return glTexture;
            }
            var texOptions = format.texOptions;
            texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
            texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
            texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
            if (options && options.imageRef) {
              texOptions.imageRef = options.imageRef;
            }
            this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);
            glTexture.params = Utils$2.cloneObjShallow(texParams);
            glTexture.options = Utils$2.cloneObjShallow(texOptions);

            // calculate bytes per pixel for vram usage tracking
            glTexture.bytesPerPixel = this._getBytesPerPixel(texOptions.format, texOptions.type);
            return glTexture;
          }
          freeTextureSource(textureSource) {
            this.stage.gl.deleteTexture(textureSource.nativeTexture);
          }
          addQuad(renderState, quads, index) {
            var offset = index * 20;
            var elementCore = quads.quadElements[index];
            var r = elementCore._renderContext;
            var floats = renderState.quads.floats;
            var uints = renderState.quads.uints;
            var mca = StageUtils.mergeColorAlpha;
            if (r.tb !== 0 || r.tc !== 0) {
              floats[offset++] = r.px;
              floats[offset++] = r.py;
              floats[offset++] = elementCore._ulx;
              floats[offset++] = elementCore._uly;
              uints[offset++] = mca(elementCore._colorUl, r.alpha);
              floats[offset++] = r.px + elementCore._w * r.ta;
              floats[offset++] = r.py + elementCore._w * r.tc;
              floats[offset++] = elementCore._brx;
              floats[offset++] = elementCore._uly;
              uints[offset++] = mca(elementCore._colorUr, r.alpha);
              floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
              floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
              floats[offset++] = elementCore._brx;
              floats[offset++] = elementCore._bry;
              uints[offset++] = mca(elementCore._colorBr, r.alpha);
              floats[offset++] = r.px + elementCore._h * r.tb;
              floats[offset++] = r.py + elementCore._h * r.td;
              floats[offset++] = elementCore._ulx;
              floats[offset++] = elementCore._bry;
              uints[offset] = mca(elementCore._colorBl, r.alpha);
            } else {
              // Simple.
              var cx = r.px + elementCore._w * r.ta;
              var cy = r.py + elementCore._h * r.td;
              floats[offset++] = r.px;
              floats[offset++] = r.py;
              floats[offset++] = elementCore._ulx;
              floats[offset++] = elementCore._uly;
              uints[offset++] = mca(elementCore._colorUl, r.alpha);
              floats[offset++] = cx;
              floats[offset++] = r.py;
              floats[offset++] = elementCore._brx;
              floats[offset++] = elementCore._uly;
              uints[offset++] = mca(elementCore._colorUr, r.alpha);
              floats[offset++] = cx;
              floats[offset++] = cy;
              floats[offset++] = elementCore._brx;
              floats[offset++] = elementCore._bry;
              uints[offset++] = mca(elementCore._colorBr, r.alpha);
              floats[offset++] = r.px;
              floats[offset++] = cy;
              floats[offset++] = elementCore._ulx;
              floats[offset++] = elementCore._bry;
              uints[offset] = mca(elementCore._colorBl, r.alpha);
            }
          }
          isRenderTextureReusable(renderState, renderTextureInfo) {
            var offset = renderState._renderTextureInfo.offset * 80 / 4;
            var floats = renderState.quads.floats;
            var uints = renderState.quads.uints;
            return floats[offset] === 0 && floats[offset + 1] === 0 && floats[offset + 2] === 0 && floats[offset + 3] === 0 && uints[offset + 4] === 0xFFFFFFFF && floats[offset + 5] === renderTextureInfo.w && floats[offset + 6] === 0 && floats[offset + 7] === 1 && floats[offset + 8] === 0 && uints[offset + 9] === 0xFFFFFFFF && floats[offset + 10] === renderTextureInfo.w && floats[offset + 11] === renderTextureInfo.h && floats[offset + 12] === 1 && floats[offset + 13] === 1 && uints[offset + 14] === 0xFFFFFFFF && floats[offset + 15] === 0 && floats[offset + 16] === renderTextureInfo.h && floats[offset + 17] === 0 && floats[offset + 18] === 1 && uints[offset + 19] === 0xFFFFFFFF;
          }
          finishRenderState(renderState) {
            // Set extra shader attribute data.
            var offset = renderState.length * 80;
            for (var i = 0, n = renderState.quadOperations.length; i < n; i++) {
              renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
              var extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
              offset += extra;
              if (extra) {
                renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
              }
            }
            renderState.quads.dataLength = offset;
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
            var gl = this.stage.gl;
            gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
            var precision = renderTexture.precision;
            gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, precision * (options.sx || 0), precision * (options.sy || 0), precision * (options.x || 0), precision * (options.y || 0), precision * (options.w || renderTexture.ow), precision * (options.h || renderTexture.oh));
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dCoreQuadList extends CoreQuadList {
          constructor(ctx) {
            super(ctx);
            this.renderContexts = [];
            this.modes = [];
          }
          setRenderContext(index, v) {
            this.renderContexts[index] = v;
          }
          setSimpleTc(index, v) {
            if (v) {
              this.modes[index] |= 1;
            } else {
              this.modes[index] -= this.modes[index] & 1;
            }
          }
          setWhite(index, v) {
            if (v) {
              this.modes[index] |= 2;
            } else {
              this.modes[index] -= this.modes[index] & 2;
            }
          }
          getRenderContext(index) {
            return this.renderContexts[index];
          }
          getSimpleTc(index) {
            return this.modes[index] & 1;
          }
          getWhite(index) {
            return this.modes[index] & 2;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dCoreQuadOperation extends CoreQuadOperation {
          getRenderContext(index) {
            return this.quads.getRenderContext(this.index + index);
          }
          getSimpleTc(index) {
            return this.quads.getSimpleTc(this.index + index);
          }
          getWhite(index) {
            return this.quads.getWhite(this.index + index);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dCoreRenderExecutor extends CoreRenderExecutor {
          init() {
            this._mainRenderTexture = this.ctx.stage.getCanvas();
          }
          _renderQuadOperation(op) {
            var shader = op.shader;
            if (op.length || op.shader.addEmpty()) {
              var target = this._renderTexture || this._mainRenderTexture;
              shader.beforeDraw(op, target);
              shader.draw(op, target);
              shader.afterDraw(op, target);
            }
          }
          _clearRenderTexture() {
            var ctx = this._getContext();
            var clearColor = [0, 0, 0, 0];
            if (this._mainRenderTexture.ctx === ctx) {
              clearColor = this.ctx.stage.getClearColor();
            }
            var renderTexture = ctx.canvas;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
              ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
            } else {
              ctx.fillStyle = StageUtils.getRgbaStringFromArray(clearColor);
              // Do not use fillRect because it produces artifacts.
              ctx.globalCompositeOperation = 'copy';
              ctx.beginPath();
              ctx.rect(0, 0, renderTexture.width, renderTexture.height);
              ctx.closePath();
              ctx.fill();
              ctx.globalCompositeOperation = 'source-over';
            }
          }
          _getContext() {
            if (this._renderTexture) {
              return this._renderTexture.ctx;
            } else {
              return this._mainRenderTexture.ctx;
            }
          }
          _restoreContext() {
            var ctx = this._getContext();
            ctx.restore();
            ctx.save();
            ctx._scissor = null;
          }
          _setScissor(area) {
            var ctx = this._getContext();
            if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
              // Clipping is stored in the canvas context state.
              // We can't reset clipping alone so we need to restore the full context.
              this._restoreContext();
              var _precision3 = this.ctx.stage.getRenderPrecision();
              if (area) {
                ctx.beginPath();
                ctx.rect(Math.round(area[0] * _precision3), Math.round(area[1] * _precision3), Math.round(area[2] * _precision3), Math.round(area[3] * _precision3));
                ctx.closePath();
                ctx.clip();
              }
              ctx._scissor = area;
            }
          }
          static _equalScissorAreas(canvas, area, current) {
            if (!area) {
              area = [0, 0, canvas.width, canvas.height];
            }
            if (!current) {
              current = [0, 0, canvas.width, canvas.height];
            }
            return Utils$2.equalValues(area, current);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dShader extends Shader {
          beforeDraw(operation) {}
          draw(operation) {}
          afterDraw(operation) {}
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class DefaultShader extends C2dShader {
          constructor(ctx) {
            super(ctx);
            this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
            this._tintManager = this.ctx.stage.renderer.tintManager;
          }
          draw(operation, target) {
            var ctx = target.ctx;
            var length = operation.length;
            for (var i = 0; i < length; i++) {
              var tx = operation.getTexture(i);
              var vc = operation.getElementCore(i);
              var rc = operation.getRenderContext(i);
              var white = operation.getWhite(i);
              var stc = operation.getSimpleTc(i);

              //@todo: try to optimize out per-draw transform setting. split translate, transform.
              var _precision4 = this.ctx.stage.getRenderPrecision();
              ctx.setTransform(rc.ta * _precision4, rc.tc * _precision4, rc.tb * _precision4, rc.td * _precision4, rc.px * _precision4, rc.py * _precision4);
              var rect = tx === this._rectangleTexture;
              var info = {
                operation,
                target,
                index: i,
                rect
              };
              if (rect) {
                // Check for gradient.
                if (white) {
                  ctx.fillStyle = 'white';
                } else {
                  this._setColorGradient(ctx, vc);
                }
                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                ctx.fillRect(0, 0, vc.w, vc.h);
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
              } else {
                // @todo: set image smoothing based on the texture.

                // @todo: optimize by registering whether identity texcoords are used.
                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);

                // @todo: test if rounding yields better performance.

                // Notice that simple texture coords can be turned on even though vc._ulx etc are not simple, because
                //  we are rendering a render-to-texture (texcoords were stashed). Same is true for 'white' color btw.
                var sourceX = stc ? 0 : vc._ulx * tx.w;
                var sourceY = stc ? 0 : vc._uly * tx.h;
                var sourceW = (stc ? 1 : vc._brx - vc._ulx) * tx.w;
                var sourceH = (stc ? 1 : vc._bry - vc._uly) * tx.h;
                var colorize = !white;
                if (colorize) {
                  // @todo: cache the tint texture for better performance.

                  // Draw to intermediate texture with background color/gradient.
                  // This prevents us from having to create a lot of render texture canvases.

                  // Notice that we don't support (non-rect) gradients, only color tinting for c2d. We'll just take the average color.
                  var color = vc._colorUl;
                  if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
                    color = StageUtils.mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
                  }
                  var alpha = (color / 16777216 | 0) / 255.0;
                  ctx.globalAlpha *= alpha;
                  var rgb = color & 0x00FFFFFF;
                  var tintTexture = this._tintManager.getTintTexture(tx, rgb);

                  // Actually draw result.
                  ctx.fillStyle = 'white';
                  ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                } else {
                  ctx.fillStyle = 'white';
                  ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                }
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
              }
            }
          }
          _setColorGradient(ctx, vc) {
            var w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : vc.w;
            var h = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vc.h;
            var transparency = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
            var color = vc._colorUl;
            var gradient;
            //@todo: quick single color check.
            //@todo: cache gradient/fill style (if possible, probably context-specific).

            if (vc._colorUl === vc._colorUr) {
              if (vc._colorBl === vc._colorBr) {
                if (vc._colorUl === vc.colorBl) ;else {
                  // Vertical gradient.
                  gradient = ctx.createLinearGradient(0, 0, 0, h);
                  if (transparency) {
                    gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
                    gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBl));
                  } else {
                    gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
                    gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBl));
                  }
                }
              }
            } else {
              if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
                // Horizontal gradient.
                gradient = ctx.createLinearGradient(0, 0, w, 0);
                if (transparency) {
                  gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
                  gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBr));
                } else {
                  gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
                  gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBr));
                }
              }
            }
            if (gradient) {
              ctx.fillStyle = gradient;
            } else {
              ctx.fillStyle = transparency ? StageUtils.getRgbaString(color) : StageUtils.getRgbString(color);
            }
          }
          _beforeDrawEl(info) {}
          _afterDrawEl(info) {}
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dTextureTintManager {
          constructor(stage) {
            this.stage = stage;
            this._usedMemory = 0;
            this._cachedNativeTextures = new Set();
          }
          destroy() {
            this.gc(true);
          }
          _addMemoryUsage(delta) {
            this._usedMemory += delta;
            this.stage.addMemoryUsage(delta);
          }
          delete(nativeTexture) {
            // Should be called when native texture is cleaned up.
            if (this._hasCache(nativeTexture)) {
              var cache = this._getCache(nativeTexture);
              var prevMemUsage = cache.memoryUsage;
              cache.clear();
              this._cachedNativeTextures.delete(nativeTexture);
              this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
            }
          }
          getTintTexture(nativeTexture, color) {
            var frame = this.stage.frameCounter;
            this._cachedNativeTextures.add(nativeTexture);
            var cache = this._getCache(nativeTexture);
            var item = cache.get(color);
            item.lf = frame;
            if (item.tx) {
              if (nativeTexture.update > item.u) {
                // Native texture was updated in the mean time: renew.
                this._tintTexture(item.tx, nativeTexture, color);
              }
              return item.tx;
            } else {
              var before = cache.memoryUsage;

              // Find blanco tint texture.
              var target = cache.reuseTexture(frame);
              if (target) {
                target.ctx.clearRect(0, 0, target.width, target.height);
              } else {
                // Allocate new.
                target = document.createElement('canvas');
                target.width = nativeTexture.w;
                target.height = nativeTexture.h;
                target.ctx = target.getContext('2d');
              }
              this._tintTexture(target, nativeTexture, color);
              cache.set(color, target, frame);
              var after = cache.memoryUsage;
              if (after !== before) {
                this._addMemoryUsage(after - before);
              }
              return target;
            }
          }
          _tintTexture(target, source, color) {
            var col = color.toString(16);
            while (col.length < 6) {
              col = "0" + col;
            }
            target.ctx.fillStyle = '#' + col;
            target.ctx.globalCompositeOperation = 'copy';
            target.ctx.fillRect(0, 0, source.w, source.h);
            target.ctx.globalCompositeOperation = 'multiply';
            target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);

            // Alpha-mix the texture.
            target.ctx.globalCompositeOperation = 'destination-in';
            target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
          }
          _hasCache(nativeTexture) {
            return !!nativeTexture._tintCache;
          }
          _getCache(nativeTexture) {
            if (!nativeTexture._tintCache) {
              nativeTexture._tintCache = new C2dTintCache(nativeTexture);
            }
            return nativeTexture._tintCache;
          }
          gc() {
            var aggressive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var frame = this.stage.frameCounter;
            var delta = 0;
            this._cachedNativeTextures.forEach(texture => {
              var cache = this._getCache(texture);
              if (aggressive) {
                delta += cache.memoryUsage;
                cache.clear();
              } else {
                var before = cache.memoryUsage;
                cache.cleanup(frame);
                cache.releaseBlancoTextures();
                delta += cache.memoryUsage - before;
              }
            });
            if (aggressive) {
              this._cachedNativeTextures.clear();
            }
            if (delta) {
              this._addMemoryUsage(delta);
            }
          }
        }
        class C2dTintCache {
          constructor(nativeTexture) {
            this._tx = nativeTexture;
            this._colors = new Map();
            this._blancoTextures = null;
            this._lastCleanupFrame = 0;
            this._memTextures = 0;
          }
          get memoryUsage() {
            return this._memTextures * this._tx.w * this._tx.h;
          }
          releaseBlancoTextures() {
            this._memTextures -= this._blancoTextures.length;
            this._blancoTextures = [];
          }
          clear() {
            // Dereference the textures.
            this._blancoTextures = null;
            this._colors.clear();
            this._memTextures = 0;
          }
          get(color) {
            var item = this._colors.get(color);
            if (!item) {
              item = {
                lf: -1,
                tx: undefined,
                u: -1
              };
              this._colors.set(color, item);
            }
            return item;
          }
          set(color, texture, frame) {
            var item = this.get(color);
            item.lf = frame;
            item.tx = texture;
            item.u = frame;
            this._memTextures++;
          }
          cleanup(frame) {
            // We only need to clean up once per frame.
            if (this._lastCleanupFrame !== frame) {
              // We limit blanco textures reuse to one frame only to prevent memory usage growth.
              this._blancoTextures = [];
              this._colors.forEach((item, color) => {
                // Clean up entries that were not used last frame.
                if (item.lf < frame - 1) {
                  if (item.tx) {
                    // Keep as reusable blanco texture.
                    this._blancoTextures.push(item.tx);
                  }
                  this._colors.delete(color);
                }
              });
              this._lastCleanupFrame = frame;
            }
          }
          reuseTexture(frame) {
            // Try to reuse textures, because creating them every frame is expensive.
            this.cleanup(frame);
            if (this._blancoTextures && this._blancoTextures.length) {
              this._memTextures--;
              return this._blancoTextures.pop();
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class C2dRenderer extends Renderer {
          constructor(stage) {
            super(stage);
            this.tintManager = new C2dTextureTintManager(stage);
            this.setupC2d(this.stage.c2d.canvas);
          }
          destroy() {
            this.tintManager.destroy();
          }
          _createDefaultShader(ctx) {
            return new DefaultShader(ctx);
          }
          _getShaderBaseType() {
            return C2dShader;
          }
          _getShaderAlternative(shaderType) {
            return shaderType.getC2d && shaderType.getC2d();
          }
          createCoreQuadList(ctx) {
            return new C2dCoreQuadList(ctx);
          }
          createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
            return new C2dCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
          }
          createCoreRenderExecutor(ctx) {
            return new C2dCoreRenderExecutor(ctx);
          }
          createCoreRenderState(ctx) {
            return new CoreRenderState(ctx);
          }
          createRenderTexture(w, h, pw, ph) {
            var canvas = document.createElement('canvas');
            canvas.width = pw;
            canvas.height = ph;
            this.setupC2d(canvas);
            return canvas;
          }
          freeRenderTexture(nativeTexture) {
            this.tintManager.delete(nativeTexture);
          }
          gc(aggressive) {
            this.tintManager.gc(aggressive);
          }
          uploadTextureSource(textureSource, options) {
            // For canvas, we do not need to upload.
            if (options.source.buffer) {
              // Convert RGBA buffer to canvas.
              var _canvas = document.createElement('canvas');
              _canvas.width = options.w;
              _canvas.height = options.h;
              var imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
              _canvas.getContext('2d').putImageData(imageData, 0, 0);
              return _canvas;
            }
            return options.source;
          }
          freeTextureSource(textureSource) {
            this.tintManager.delete(textureSource.nativeTexture);
          }
          addQuad(renderState, quads, index) {
            // Render context changes while traversing so we save it by ref.
            var elementCore = quads.quadElements[index];
            quads.setRenderContext(index, elementCore._renderContext);
            quads.setWhite(index, elementCore.isWhite());
            quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
          }
          isRenderTextureReusable(renderState, renderTextureInfo) {
            // @todo: check render coords/matrix, maybe move this to core?
            return false;
          }
          finishRenderState(renderState) {}
          setupC2d(canvas) {
            var ctx = canvas.getContext('2d');
            canvas.ctx = ctx;
            ctx._scissor = null;

            // Save base state so we can restore the defaults later.
            canvas.ctx.save();
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SparkShader extends WebGLShader {
          enableAttribs() {
            // Enables the attribs in the shader program.
            var gl = this.gl;
            gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
            gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
            if (this._attrib("aTextureCoord") !== -1) {
              gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
              gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
            }
            if (this._attrib("aColor") !== -1) {
              // Some shaders may ignore the color.
              gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
              gl.enableVertexAttribArray(this._attrib("aColor"));
            }
          }
          disableAttribs() {
            // Disables the attribs in the shader program.
            var gl = this.gl;
            gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
            if (this._attrib("aTextureCoord") !== -1) {
              gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
            }
            if (this._attrib("aColor") !== -1) {
              gl.disableVertexAttribArray(this._attrib("aColor"));
            }
          }
          setupUniforms(operation) {
            this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
          }
          draw(operation) {
            var gl = this.gl;
            var length = operation.length;
            if (length) {
              var glTexture = operation.getTexture(0);
              var pos = 0;
              for (var i = 0; i < length; i++) {
                var tx = operation.getTexture(i);
                if (glTexture !== tx) {
                  if (glTexture.options && glTexture.options.imageRef) {
                    var elementPostion = i > 0 ? i - 1 : i;
                    var _precision5 = this.ctx.stage.getOption('precision');
                    var vc = operation.getElementCore(elementPostion);
                    this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px * _precision5, vc._worldContext.py * _precision5, vc._colorUl, vc);
                  } else {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                  }
                  glTexture = tx;
                  pos = i;
                }
              }
              if (pos < length) {
                if (glTexture.options && glTexture.options.imageRef) {
                  var _precision6 = this.ctx.stage.getOption('precision');
                  var _vc = operation.getElementCore(pos);
                  this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, _vc._worldContext.px * _precision6, _vc._worldContext.py * _precision6, _vc._colorUl, _vc);
                } else {
                  gl.bindTexture(gl.TEXTURE_2D, glTexture);
                  gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                }
              }
            }
          }
        }
        SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SparkRenderer extends WebGLRenderer {
          constructor(stage) {
            super(stage);
          }
          _createDefaultShader(ctx) {
            return new SparkShader(ctx);
          }
          createCoreRenderExecutor(ctx) {
            global.beginDrawing();
            var ret = super.createCoreRenderExecutor(ctx);
            global.endDrawing();
            return ret;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ImageWorker {
          constructor() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            this._items = new Map();
            this._id = 0;
            this._initWorker();
          }
          destroy() {
            if (this._worker) {
              this._worker.terminate();
            }
          }
          _initWorker() {
            var code = `(${createWorker.toString()})()`;
            var blob = new Blob([code.replace('"use strict";', '')]); // firefox adds "use strict"; to any function which might block worker execution so knock it off
            var blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
              type: 'application/javascript; charset=utf-8'
            });
            this._worker = new Worker(blobURL);
            this._worker.postMessage({
              type: 'config',
              config: {
                path: window.location.href,
                protocol: window.location.protocol
              }
            });
            this._worker.onmessage = e => {
              if (e.data && e.data.id) {
                var id = e.data.id;
                var item = this._items.get(id);
                if (item) {
                  if (e.data.type == 'data') {
                    this.finish(item, e.data.info);
                  } else {
                    this.error(item, e.data.info);
                  }
                }
              }
            };
          }
          create(src) {
            var id = ++this._id;
            var item = new ImageWorkerImage(this, id, src);
            this._items.set(id, item);
            this._worker.postMessage({
              type: "add",
              id: id,
              src: src
            });
            return item;
          }
          cancel(image) {
            this._worker.postMessage({
              type: "cancel",
              id: image.id
            });
            this._items.delete(image.id);
          }
          error(image, info) {
            image.error(info);
            this._items.delete(image.id);
          }
          finish(image, info) {
            image.load(info);
            this._items.delete(image.id);
          }
        }
        class ImageWorkerImage {
          constructor(manager, id, src) {
            this._manager = manager;
            this._id = id;
            this._src = src;
            this._onError = null;
            this._onLoad = null;
          }
          get id() {
            return this._id;
          }
          get src() {
            return this._src;
          }
          set onError(f) {
            this._onError = f;
          }
          set onLoad(f) {
            this._onLoad = f;
          }
          cancel() {
            this._manager.cancel(this);
          }
          load(info) {
            if (this._onLoad) {
              this._onLoad(info);
            }
          }
          error(info) {
            if (this._onError) {
              this._onError(info);
            }
          }
        }

        /**
         * Notice that, within the createWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
         *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
         */
        var createWorker = function createWorker() {
          function ImageWorkerServer() {
            this.items = new Map();
            var t = this;
            onmessage = function onmessage(e) {
              t._receiveMessage(e);
            };
          }
          ImageWorkerServer.isPathAbsolute = function (path) {
            return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == 'data:';
          };
          ImageWorkerServer.prototype._receiveMessage = function (e) {
            if (e.data.type === 'config') {
              this.config = e.data.config;
              var base = this.config.path;
              // the constructing of the basepath fails
              // if location.hash contains a slash
              var hasHashPath = /#.*?\//;
              if (hasHashPath.test(base)) {
                base = base.replace(/#.*$/, '');
              }
              var parts = base.split("/");
              parts.pop();
              this._relativeBase = parts.join("/") + "/";
            } else if (e.data.type === 'add') {
              this.add(e.data.id, e.data.src);
            } else if (e.data.type === 'cancel') {
              this.cancel(e.data.id);
            }
          };
          ImageWorkerServer.prototype.add = function (id, src) {
            // Convert relative URLs.
            if (!ImageWorkerServer.isPathAbsolute(src)) {
              src = this._relativeBase + src;
            }
            if (src.substr(0, 2) === "//") {
              // This doesn't work for image workers.
              src = this.config.protocol + src;
            }
            var item = new ImageWorkerServerItem(id, src);
            var t = this;
            item.onFinish = function (result) {
              t.finish(item, result);
            };
            item.onError = function (info) {
              t.error(item, info);
            };
            this.items.set(id, item);
            item.start();
          };
          ImageWorkerServer.prototype.cancel = function (id) {
            var item = this.items.get(id);
            if (item) {
              item.cancel();
              this.items.delete(id);
            }
          };
          ImageWorkerServer.prototype.finish = function (item, _ref4) {
            var imageBitmap = _ref4.imageBitmap,
              hasAlphaChannel = _ref4.hasAlphaChannel;
            postMessage({
              type: "data",
              id: item.id,
              info: {
                imageBitmap,
                hasAlphaChannel
              }
            }, [imageBitmap]);
            this.items.delete(item.id);
          };
          ImageWorkerServer.prototype.error = function (item, _ref5) {
            var type = _ref5.type,
              message = _ref5.message;
            postMessage({
              type: "error",
              id: item.id,
              info: {
                type,
                message
              }
            });
            this.items.delete(item.id);
          };
          ImageWorkerServer.isWPEBrowser = function () {
            return navigator.userAgent.indexOf("WPE") !== -1;
          };
          function ImageWorkerServerItem(id, src) {
            this._onError = undefined;
            this._onFinish = undefined;
            this._id = id;
            this._src = src;
            this._xhr = undefined;
            this._mimeType = undefined;
            this._canceled = false;
          }
          Object.defineProperty(ImageWorkerServerItem.prototype, 'id', {
            get: function get() {
              return this._id;
            }
          });
          Object.defineProperty(ImageWorkerServerItem.prototype, 'onFinish', {
            get: function get() {
              return this._onFinish;
            },
            set: function set(f) {
              this._onFinish = f;
            }
          });
          Object.defineProperty(ImageWorkerServerItem.prototype, 'onError', {
            get: function get() {
              return this._onError;
            },
            set: function set(f) {
              this._onError = f;
            }
          });
          ImageWorkerServerItem.prototype.start = function () {
            this._xhr = new XMLHttpRequest();
            this._xhr.open("GET", this._src, true);
            this._xhr.responseType = "blob";
            var t = this;
            this._xhr.onerror = function (oEvent) {
              t.error({
                type: "connection",
                message: "Connection error"
              });
            };
            this._xhr.onload = function (oEvent) {
              var blob = t._xhr.response;
              t._mimeType = blob.type;
              t._createImageBitmap(blob);
            };
            this._xhr.send();
          };
          ImageWorkerServerItem.prototype._createImageBitmap = function (blob) {
            var t = this;
            createImageBitmap(blob, {
              premultiplyAlpha: 'premultiply',
              colorSpaceConversion: 'none',
              imageOrientation: 'none'
            }).then(function (imageBitmap) {
              t.finish({
                imageBitmap,
                hasAlphaChannel: t._hasAlphaChannel()
              });
            }).catch(function (e) {
              t.error({
                type: "parse",
                message: "Error parsing image data"
              });
            });
          };
          ImageWorkerServerItem.prototype._hasAlphaChannel = function () {
            if (ImageWorkerServer.isWPEBrowser()) {
              // When using unaccelerated rendering image (https://github.com/WebPlatformForEmbedded/WPEWebKit/blob/wpe-20170728/Source/WebCore/html/ImageBitmap.cpp#L52),
              // everything including JPG images are in RGBA format. Upload is way faster when using an alpha channel.
              // @todo: after hardware acceleration is fixed and re-enabled, JPG should be uploaded in RGB to get the best possible performance and memory usage.
              return true;
            } else {
              return this._mimeType.indexOf("image/png") !== -1;
            }
          };
          ImageWorkerServerItem.prototype.cancel = function () {
            if (this._canceled) return;
            if (this._xhr) {
              this._xhr.abort();
            }
            this._canceled = true;
          };
          ImageWorkerServerItem.prototype.error = function (type, message) {
            if (!this._canceled && this._onError) {
              this._onError({
                type,
                message
              });
            }
          };
          ImageWorkerServerItem.prototype.finish = function (info) {
            if (!this._canceled && this._onFinish) {
              this._onFinish(info);
            }
          };
          new ImageWorkerServer();
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Platform-specific functionality.
         */
        class WebPlatform {
          init(stage) {
            this.stage = stage;
            this._looping = false;
            this._awaitingLoop = false;

            // Alternative handler to avoid RAF when idle
            this._loopHandler = null;
            this._idleLoopCounter = 0;
            this._idleLoopDelay = 60;
            if (this.stage.getOption("useImageWorker")) {
              if (!window.createImageBitmap || !window.Worker) {
                console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
              } else {
                this._imageWorker = new ImageWorker();
              }
            }
            this._registerVisibilityChangeHandler();
          }
          destroy() {
            if (this._imageWorker) {
              this._imageWorker.destroy();
            }
            this._removeKeyHandler();
            this._removeClickHandler();
            this._removeHoverHandler();
            this._removeScrollWheelHandler();
            this._removeVisibilityChangeHandler();
          }
          startLoop() {
            this._looping = true;
            if (!this._awaitingLoop) {
              this.loop();
            }
          }
          stopLoop() {
            this._looping = false;
          }
          switchLoop() {
            if (this._idleLoopCounter < this._idleLoopDelay) {
              this._idleLoopCounter++;
              return;
            }
            if (!this.stage.ctx.hasRenderUpdates()) {
              this.stopLoop();
              this._loopHandler = setInterval(() => {
                this.stage.updateFrame();
                this.stage.idleFrame();
                if (this.stage.ctx.hasRenderUpdates()) {
                  clearInterval(this._loopHandler);
                  this.startLoop();
                }
              }, 1000 / 60);
            } else {
              this._idleLoopCounter = 0;
            }
          }
          loop() {
            var self = this;
            var lp = function lp() {
              self._awaitingLoop = false;
              if (self._looping) {
                self.stage.updateFrame();
                if (self.stage.getOption("pauseRafLoopOnIdle")) {
                  self.switchLoop();
                }
                self.stage.renderFrame();
                requestAnimationFrame(lp);
                self._awaitingLoop = true;
              }
            };
            requestAnimationFrame(lp);
          }
          uploadCompressedGlTexture(gl, textureSource, source, options) {
            var view = !source.pvr ? new DataView(source.mipmaps[0]) : source.mipmaps[0];
            gl.compressedTexImage2D(gl.TEXTURE_2D, 0, source.glInternalFormat, source.pixelWidth, source.pixelHeight, 0, view);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          }
          uploadGlTexture(gl, textureSource, source, options) {
            if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || window.ImageBitmap && source instanceof ImageBitmap) {
              // Web-specific data types.
              gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
            } else if (source instanceof HTMLCanvasElement) {
              if (Utils$2.isZiggo || this.stage.getOption("forceTxCanvasSource")) {
                // Ziggo EOS and Selene have issues with getImageData implementation causing artifacts.
                gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
              } else if (source.width > 0 && source.height > 0) {
                // Workaround for some browsers (e.g. Tizen) as they do not convert canvas data to texture correctly, sometimes causing artifacts.
                // Width/Height check added because of https://github.com/rdkcentral/Lightning/issues/412
                var ctx = source.getContext('2d');
                gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
              }
            } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
            }
          }

          /**
           * KTX File format specification
           * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
           **/
          handleKtxLoad(cb, src) {
            var self = this;
            return function () {
              var arraybuffer = this.response;
              var view = new DataView(arraybuffer);

              // identifier, big endian
              var targetIdentifier = 3632701469;
              if (targetIdentifier !== view.getUint32(0) + view.getUint32(4) + view.getUint32(8)) {
                cb('Parsing failed: identifier ktx mismatch:', src);
              }
              var littleEndian = view.getUint32(12) === 16909060 ? true : false;
              var data = {
                glType: view.getUint32(16, littleEndian),
                glTypeSize: view.getUint32(20, littleEndian),
                glFormat: view.getUint32(24, littleEndian),
                glInternalFormat: view.getUint32(28, littleEndian),
                glBaseInternalFormat: view.getUint32(32, littleEndian),
                pixelWidth: view.getUint32(36, littleEndian),
                pixelHeight: view.getUint32(40, littleEndian),
                pixelDepth: view.getUint32(44, littleEndian),
                numberOfArrayElements: view.getUint32(48, littleEndian),
                numberOfFaces: view.getUint32(52, littleEndian),
                numberOfMipmapLevels: view.getUint32(56, littleEndian),
                bytesOfKeyValueData: view.getUint32(60, littleEndian),
                kvps: [],
                mipmaps: [],
                get width() {
                  return this.pixelWidth;
                },
                get height() {
                  return this.pixelHeight;
                }
              };
              var props = obj => {
                var p = [];
                for (var v in obj) {
                  p.push(obj[v]);
                }
                return p;
              };
              var formats = Object.values(self.stage.renderer.getCompressedTextureExtensions()).filter(obj => obj != null).map(obj => props(obj)).reduce((prev, current) => prev.concat(current));
              if (!formats.includes(data.glInternalFormat)) {
                console.warn("[Lightning] Unrecognized texture extension format:", src, data.glInternalFormat, self.stage.renderer.getCompressedTextureExtensions());
              }
              var offset = 64;
              // Key Value Pairs of data start at byte offset 64
              // But the only known kvp is the API version, so skipping parsing.
              offset += data.bytesOfKeyValueData;
              for (var i = 0; i < data.numberOfMipmapLevels; i++) {
                var imageSize = view.getUint32(offset);
                offset += 4;
                data.mipmaps.push(view.buffer.slice(offset, imageSize));
                offset += imageSize;
              }
              cb(null, {
                source: data,
                renderInfo: {
                  src: src,
                  compressed: true
                }
              });
            };
          }
          handlePvrLoad(cb, src) {
            return function () {
              // pvr header length in 32 bits
              var pvrHeaderLength = 13;
              // for now only we only support: COMPRESSED_RGB_ETC1_WEBGL
              var pvrFormatEtc1 = 0x8D64;
              var pvrWidth = 7;
              var pvrHeight = 6;
              var pvrMipmapCount = 11;
              var pvrMetadata = 12;
              var arrayBuffer = this.response;
              var header = new Int32Array(arrayBuffer, 0, pvrHeaderLength);
              var dataOffset = header[pvrMetadata] + 52;
              var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
              var data = {
                glInternalFormat: pvrFormatEtc1,
                pixelWidth: header[pvrWidth],
                pixelHeight: header[pvrHeight],
                numberOfMipmapLevels: header[pvrMipmapCount],
                mipmaps: [],
                pvr: true,
                get width() {
                  return this.pixelWidth;
                },
                get height() {
                  return this.pixelHeight;
                }
              };
              var offset = 0;
              var width = data.pixelWidth;
              var height = data.pixelHeight;
              for (var i = 0; i < data.numberOfMipmapLevels; i++) {
                var level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
                var view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
                data.mipmaps.push(view);
                offset += level;
                width = width >> 1;
                height = height >> 1;
              }
              cb(null, {
                source: data,
                renderInfo: {
                  src: src,
                  compressed: true
                }
              });
            };
          }
          loadSrcTexture(_ref6, cb) {
            var src = _ref6.src,
              hasAlpha = _ref6.hasAlpha;
            var cancelCb = undefined;
            var isPng = src.indexOf(".png") >= 0 || src.substr(0, 21) == 'data:image/png;base64';
            var isKtx = src.indexOf('.ktx') >= 0;
            var isPvr = src.indexOf('.pvr') >= 0;
            if (isKtx || isPvr) {
              var request = new XMLHttpRequest();
              request.addEventListener("load", isKtx ? this.handleKtxLoad(cb, src) : this.handlePvrLoad(cb, src));
              request.open("GET", src);
              request.responseType = "arraybuffer";
              request.send();
              cancelCb = function cancelCb() {
                request.abort();
              };
            } else if (this._imageWorker) {
              // WPE-specific image parser.
              var image = this._imageWorker.create(src);
              image.onError = function (err) {
                return cb("Image load error");
              };
              image.onLoad = function (_ref7) {
                var imageBitmap = _ref7.imageBitmap,
                  hasAlphaChannel = _ref7.hasAlphaChannel;
                cb(null, {
                  source: imageBitmap,
                  renderInfo: {
                    src: src,
                    compressed: false
                  },
                  hasAlpha: hasAlphaChannel,
                  premultiplyAlpha: true
                });
              };
              cancelCb = function cancelCb() {
                image.cancel();
              };
            } else {
              var _image = new Image();

              // On the PS4 platform setting the `crossOrigin` attribute on
              // images can cause CORS failures.
              if (!(src.substr(0, 5) == "data:") && !Utils$2.isPS4) {
                // Base64.
                _image.crossOrigin = "Anonymous";
              }
              _image.onerror = function (err) {
                // Ignore error message when cancelled.
                if (_image.src) {
                  return cb("Image load error");
                }
              };
              _image.onload = function () {
                cb(null, {
                  source: _image,
                  renderInfo: {
                    src: src,
                    compressed: false
                  },
                  hasAlpha: isPng || hasAlpha
                });
              };
              _image.src = src;
              cancelCb = function cancelCb() {
                _image.onerror = null;
                _image.onload = null;
                _image.removeAttribute('src');
              };
            }
            return cancelCb;
          }
          createWebGLContext(w, h) {
            var canvas = this.stage.getOption('canvas') || document.createElement('canvas');
            if (w && h) {
              canvas.width = w;
              canvas.height = h;
            }
            var opts = {
              alpha: true,
              antialias: false,
              premultipliedAlpha: true,
              stencil: true,
              preserveDrawingBuffer: false
            };
            var gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
            if (!gl) {
              throw new Error('This browser does not support webGL.');
            }
            return gl;
          }
          createCanvasContext(w, h) {
            var canvas = this.stage.getOption('canvas') || document.createElement('canvas');
            if (w && h) {
              canvas.width = w;
              canvas.height = h;
            }
            var c2d = canvas.getContext('2d');
            if (!c2d) {
              throw new Error('This browser does not support 2d canvas.');
            }
            return c2d;
          }
          getHrTime() {
            return window.performance ? window.performance.now() : new Date().getTime();
          }
          getDrawingCanvas() {
            // We can't reuse this canvas because textures may load async.
            return document.createElement('canvas');
          }
          getTextureOptionsForDrawingCanvas(canvas) {
            var options = {};
            options.source = canvas;
            return options;
          }
          nextFrame(changes) {
            /* WebGL blits automatically */
          }
          registerKeydownHandler(keyhandler) {
            this._keydownListener = e => {
              keyhandler(e);
            };
            window.addEventListener('keydown', this._keydownListener);
          }
          registerKeyupHandler(keyhandler) {
            this._keyupListener = e => {
              keyhandler(e);
            };
            window.addEventListener('keyup', this._keyupListener);
          }
          _removeKeyHandler() {
            if (this._keydownListener) {
              window.removeEventListener('keydown', this._keydownListener);
            }
            if (this._keyupListener) {
              window.removeEventListener('keyup', this._keyupListener);
            }
          }
          registerClickHandler(clickHandler) {
            this._clickListener = e => {
              clickHandler(e);
            };
            window.addEventListener('mousedown', this._clickListener);
          }
          _removeClickHandler() {
            if (this._clickListener) {
              window.removeEventListener('mousedown', this._clickListener);
            }
          }
          registerHoverHandler(hoverHandler) {
            this._hoverListener = e => {
              hoverHandler(e);
            };
            window.addEventListener('mousemove', this._hoverListener);
          }
          _removeHoverHandler() {
            if (this._hoverListener) {
              window.removeEventListener('mousemove', this._hoverListener);
            }
          }
          registerScrollWheelHandler(registerScrollWheelHandler) {
            this._scrollWheelListener = e => {
              registerScrollWheelHandler(e);
            };
            window.addEventListener('wheel', this._scrollWheelListener);
          }
          _removeScrollWheelHandler() {
            if (this._scrollWheelListener) {
              window.removeEventListener('wheel', this._scrollWheelListener);
            }
          }

          /**
           * Fix for issue reported at: https://github.com/WebPlatformForEmbedded/WPEWebKit/issues/882
           */
          _registerVisibilityChangeHandler() {
            this._visibilityChangeHandler = () => {
              if (document.visibilityState === 'visible') {
                this.stage.root.core.setHasRenderUpdates(2);
                this.stage.renderFrame();
              }
            };
            document.addEventListener('visibilitychange', this._visibilityChangeHandler);
          }
          _removeVisibilityChangeHandler() {
            if (this._visibilityChangeHandler) {
              document.removeEventListener('visibilitychange', this._visibilityChangeHandler);
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class PlatformLoader {
          static load(options) {
            if (options.platform) {
              return options.platform;
            } else {
              return WebPlatform;
            }
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Utils$1 = class Utils {
          static isFunction(value) {
            return typeof value === 'function';
          }
          static isNumber(value) {
            return typeof value === 'number';
          }
          static isInteger(value) {
            return typeof value === 'number' && value % 1 === 0;
          }
          static isBoolean(value) {
            return value === true || value === false;
          }
          static isString(value) {
            return typeof value == 'string';
          }
          static isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          static isPlainObject(value) {
            var type = typeof value;
            return !!value && type == 'object';
          }
          static isObjectLiteral(value) {
            return typeof value === 'object' && value && value.constructor === Object;
          }
          static getArrayIndex(index, arr) {
            return Utils.getModuloIndex(index, arr.length);
          }
          static equalValues(v1, v2) {
            if (typeof v1 !== typeof v2) return false;
            if (Utils.isObjectLiteral(v1)) {
              return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
            } else if (Array.isArray(v1)) {
              return Array.isArray(v2) && Utils.equalArrays(v1, v2);
            } else {
              return v1 === v2;
            }
          }
          static equalObjectLiterals(obj1, obj2) {
            var keys1 = Object.keys(obj1);
            var keys2 = Object.keys(obj2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            for (var i = 0, n = keys1.length; i < n; i++) {
              var k1 = keys1[i];
              var k2 = keys2[i];
              if (k1 !== k2) {
                return false;
              }
              var v1 = obj1[k1];
              var v2 = obj2[k2];
              if (!Utils.equalValues(v1, v2)) {
                return false;
              }
            }
            return true;
          }
          static equalArrays(v1, v2) {
            if (v1.length !== v2.length) {
              return false;
            }
            for (var i = 0, n = v1.length; i < n; i++) {
              if (!this.equalValues(v1[i], v2[i])) {
                return false;
              }
            }
            return true;
          }
        };

        /**
         * Maintains the state of a WebGLRenderingContext.
         */
        class WebGLState {
          constructor(id, gl) {
            this._id = id;
            this._gl = gl;
            this._program = undefined;
            this._buffers = new Map();
            this._framebuffers = new Map();
            this._renderbuffers = new Map();

            // Contains vertex attribute definition arrays (enabled, size, type, normalized, stride, offset).
            this._vertexAttribs = new Array(16);
            this._nonDefaultFlags = new Set();
            this._settings = new Map();
            this._textures = new Array(8);
            this._maxTexture = 0;
            this._activeTexture = gl.TEXTURE0;
            this._pixelStorei = new Array(5);
          }
          _getDefaultFlag(cap) {
            return cap === this._gl.DITHER;
          }
          setFlag(cap, v) {
            var def = this._getDefaultFlag(cap);
            if (v === def) {
              return this._nonDefaultFlags.delete(cap);
            } else {
              if (!this._nonDefaultFlags.has(cap)) {
                this._nonDefaultFlags.add(cap);
                return true;
              } else {
                return false;
              }
            }
          }
          setBuffer(target, buffer) {
            var change = this._buffers.get(target) !== buffer;
            this._buffers.set(target, buffer);
            if (change && target === this._gl.ARRAY_BUFFER) {
              // When the array buffer is changed all attributes are cleared.
              this._vertexAttribs = [];
            }
            return change;
          }
          setFramebuffer(target, buffer) {
            var change = this._framebuffers.get(target) !== buffer;
            this._framebuffers.set(target, buffer);
            return change;
          }
          setRenderbuffer(target, buffer) {
            var change = this._renderbuffers.get(target) !== buffer;
            this._renderbuffers.set(target, buffer);
            return change;
          }
          setProgram(program) {
            var change = this._program !== program;
            this._program = program;
            return change;
          }
          setSetting(func, v) {
            var s = this._settings.get(func);
            var change = !s || !Utils$1.equalValues(s, v);
            this._settings.set(func, v);
            return change;
          }
          disableVertexAttribArray(index) {
            var va = this._vertexAttribs[index];
            if (va && va[5]) {
              va[5] = false;
              return true;
            }
            return false;
          }
          enableVertexAttribArray(index) {
            var va = this._vertexAttribs[index];
            if (va) {
              if (!va[0]) {
                va[0] = true;
                return true;
              }
            } else {
              this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
              return true;
            }
            return false;
          }
          vertexAttribPointer(index, props) {
            var va = this._vertexAttribs[index];
            var equal = false;
            if (va) {
              equal = va[0] === props[0] && va[1] === props[1] && va[2] === props[2] && va[3] === props[3] && va[4] === props[4];
            }
            if (equal) {
              return false;
            } else {
              props[5] = va ? va[5] : false;
              return true;
            }
          }
          setActiveTexture(texture) {
            var changed = this._activeTexture !== texture;
            this._activeTexture = texture;
            return changed;
          }
          bindTexture(target, texture) {
            var activeIndex = WebGLState._getTextureIndex(this._activeTexture);
            this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
            var current = this._textures[activeIndex];
            var targetIndex = WebGLState._getTextureTargetIndex(target);
            if (current) {
              if (current[targetIndex] === texture) {
                return false;
              }
              current[targetIndex] = texture;
              return true;
            } else {
              if (texture) {
                this._textures[activeIndex] = [];
                this._textures[activeIndex][targetIndex] = texture;
                return true;
              } else {
                return false;
              }
            }
          }
          setPixelStorei(pname, param) {
            var i = WebGLState._getPixelStoreiIndex(pname);
            var change = !Utils$1.equalValues(this._pixelStorei[i], param);
            this._pixelStorei[i] = param;
            return change;
          }
          migrate(s) {
            var t = this;

            // Warning: migrate should call the original prototype methods directly.

            this._migrateFlags(t, s);

            // useProgram
            if (s._program !== t._program) {
              this._gl._useProgram(s._program);
            }
            this._migrateFramebuffers(t, s);
            this._migrateRenderbuffers(t, s);
            var buffersChanged = this._migrateBuffers(t, s);
            this._migrateAttributes(t, s, buffersChanged);
            this._migrateFlags(t, s);
            this._migrateSettings(t, s);
            this._migratePixelStorei(t, s);
            this._migrateTextures(t, s);
          }
          _migratePixelStorei(t, s) {
            for (var i = 0, n = t._pixelStorei.length; i < n; i++) {
              if (t._pixelStorei[i] !== s._pixelStorei[i]) {
                var value = s._pixelStorei[i] !== undefined ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
                this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
              }
            }
          }
          _migrateTextures(t, s) {
            var max = Math.max(t._maxTexture, s._maxTexture);
            var activeTexture = t._activeTexture;
            for (var i = 0; i < max; i++) {
              var sTargets = s._textures[i];
              var tTargets = t._textures[i];
              var textureNumb = WebGLState._getTextureByIndex(i);
              var targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
              for (var j = 0, n = targetMax; j < n; j++) {
                var target = WebGLState._getTextureTargetByIndex(j);
                if (activeTexture !== textureNumb) {
                  this._gl._activeTexture(textureNumb);
                  activeTexture = textureNumb;
                }
                var texture = sTargets && sTargets[j] || null;
                this._gl._bindTexture(target, texture);
              }
            }
            if (s._activeTexture !== activeTexture) {
              this._gl._activeTexture(s._activeTexture);
            }
          }
          _migrateBuffers(t, s) {
            s._buffers.forEach((framebuffer, target) => {
              if (t._buffers.get(target) !== framebuffer) {
                this._gl._bindBuffer(target, framebuffer);
              }
            });
            t._buffers.forEach((buffer, target) => {
              var b = s._buffers.get(target);
              if (b === undefined) {
                this._gl._bindBuffer(target, null);
              }
            });
            return s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER);
          }
          _migrateFramebuffers(t, s) {
            s._framebuffers.forEach((framebuffer, target) => {
              if (t._framebuffers.get(target) !== framebuffer) {
                this._gl._bindFramebuffer(target, framebuffer);
              }
            });
            t._framebuffers.forEach((framebuffer, target) => {
              var fb = s._framebuffers.get(target);
              if (fb === undefined) {
                this._gl._bindFramebuffer(target, null);
              }
            });
          }
          _migrateRenderbuffers(t, s) {
            s._renderbuffers.forEach((renderbuffer, target) => {
              if (t._renderbuffers.get(target) !== renderbuffer) {
                this._gl._bindRenderbuffer(target, renderbuffer);
              }
            });
            t._renderbuffers.forEach((renderbuffer, target) => {
              var fb = s._renderbuffers.get(target);
              if (fb === undefined) {
                this._gl._bindRenderbuffer(target, null);
              }
            });
          }
          _migrateAttributes(t, s, buffersChanged) {
            if (!buffersChanged) {
              t._vertexAttribs.forEach((attrib, index) => {
                if (!s._vertexAttribs[index]) {
                  // We can't 'delete' a vertex attrib so we'll disable it.
                  this._gl._disableVertexAttribArray(index);
                }
              });
              s._vertexAttribs.forEach((attrib, index) => {
                this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
                if (attrib[5]) {
                  this._gl._enableVertexAttribArray(index);
                } else {
                  this._gl._disableVertexAttribArray(index);
                }
              });
            } else {
              // When buffers are changed, previous attributes were reset automatically.
              s._vertexAttribs.forEach((attrib, index) => {
                if (attrib[0]) {
                  // Do not set vertex attrib pointer when it was just the default value.
                  this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
                }
                if (attrib[5]) {
                  this._gl._enableVertexAttribArray(index);
                }
              });
            }
          }
          _migrateSettings(t, s) {
            var defaults = this.constructor.getDefaultSettings();
            t._settings.forEach((value, func) => {
              var name = func.name || func.xname;
              if (!s._settings.has(func)) {
                var args = defaults.get(name);
                if (Utils$1.isFunction(args)) {
                  args = args(this._gl);
                }
                // We are actually setting the setting for optimization purposes.
                s._settings.set(func, args);
                func.apply(this._gl, args);
              }
            });
            s._settings.forEach((value, func) => {
              var tValue = t._settings.get(func);
              if (!tValue || !Utils$1.equalValues(tValue, value)) {
                func.apply(this._gl, value);
              }
            });
          }
          _migrateFlags(t, s) {
            t._nonDefaultFlags.forEach(setting => {
              if (!s._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                  this._gl._enable(setting);
                } else {
                  this._gl._disable(setting);
                }
              }
            });
            s._nonDefaultFlags.forEach(setting => {
              if (!t._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                  this._gl._disable(setting);
                } else {
                  this._gl._enable(setting);
                }
              }
            });
          }
          static getDefaultSettings() {
            if (!this._defaultSettings) {
              this._defaultSettings = new Map();
              var d = this._defaultSettings;
              var g = WebGLRenderingContext.prototype;
              d.set("viewport", function (gl) {
                return [0, 0, gl.canvas.width, gl.canvas.height];
              });
              d.set("scissor", function (gl) {
                return [0, 0, gl.canvas.width, gl.canvas.height];
              });
              d.set("blendColor", [0, 0, 0, 0]);
              d.set("blendEquation", [g.FUNC_ADD]);
              d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
              d.set("blendFunc", [g.ONE, g.ZERO]);
              d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
              d.set("clearColor", [0, 0, 0, 0]);
              d.set("clearDepth", [1]);
              d.set("clearStencil", [0]);
              d.set("colorMask", [true, true, true, true]);
              d.set("cullFace", [g.BACK]);
              d.set("depthFunc", [g.LESS]);
              d.set("depthMask", [true]);
              d.set("depthRange", [0, 1]);
              d.set("frontFace", [g.CCW]);
              d.set("lineWidth", [1]);
              d.set("polygonOffset", [0, 0]);
              d.set("sampleCoverage", [1, false]);
              d.set("stencilFunc", [g.ALWAYS, 0, 1]);
              d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
              d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
              d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
              d.set("stencilMask", [1]);
              d.set("_stencilMaskSeparateFront", [1]);
              d.set("_stencilMaskSeparateBack", [1]);
              d.set("_stencilMaskSeparateFrontAndBack", [1]);
              d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
              d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
              d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
              d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
              d.set("vertexAttrib1f", []);
              d.set("vertexAttrib1fv", []);
              d.set("vertexAttrib2f", []);
              d.set("vertexAttrib2fv", []);
              d.set("vertexAttrib3f", []);
              d.set("vertexAttrib3fv", []);
              d.set("vertexAttrib4f", []);
              d.set("vertexAttrib4fv", []);
            }
            return this._defaultSettings;
          }
          static _getTextureTargetIndex(target) {
            switch (target) {
              case 0x0DE1:
                /* TEXTURE_2D */
                return 0;
              case 0x8513:
                /* TEXTURE_CUBE_MAP */
                return 1;
              default:
                // Shouldn't happen.
                throw new Error('Unknown texture target: ' + target);
            }
          }
          static _getTextureTargetByIndex(index) {
            if (!this._textureTargetIndices) {
              this._textureTargetIndices = [0x0DE1, 0x8513];
            }
            return this._textureTargetIndices[index];
          }
          static _getTextureIndex(index) {
            return index - 0x84C0 /* GL_TEXTURE0 */;
          }

          static _getTextureByIndex(index) {
            return index + 0x84C0;
          }
          static _getPixelStoreiIndex(pname) {
            switch (pname) {
              case 0x0D05:
                /* PACK_ALIGNMENT */
                return 0;
              case 0x0CF5:
                /* UNPACK_ALIGNMENT */
                return 1;
              case 0x9240:
                /* UNPACK_FLIP_Y_WEBGL */
                return 2;
              case 0x9241:
                /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */
                return 3;
              case 0x9243:
                /* UNPACK_COLORSPACE_CONVERSION_WEBGL */
                return 4;
              //@todo: support WebGL2 properties, see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
              case 0x9245:
                /* UNPACK_FLIP_BLUE_RED */
                return 5;
              default:
                // Shouldn't happen.
                throw new Error('Unknown pixelstorei: ' + pname);
            }
          }
          static _getPixelStoreiByIndex(index) {
            if (!this._pixelStoreiIndices) {
              this._pixelStoreiIndices = [0x0D05, 0x0CF5, 0x9240, 0x9241, 0x9243];
            }
            return this._pixelStoreiIndices[index];
          }
          static _getDefaultPixelStoreiByIndex(index) {
            if (!this._pixelStoreiDefaults) {
              this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
            }
            return this._pixelStoreiDefaults[index];
          }
        }
        class WebGLStateManager {
          _initStateManager() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";
            this._states = {};
            this._state = this._getState(id);
          }
          _getState(id) {
            if (!this._states[id]) {
              this._states[id] = new WebGLState(id, this);
            }
            return this._states[id];
          }
          switchState() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";
            if (this._state._id !== id) {
              var newState = this._getState(id);
              this._state.migrate(newState);
              this._state = newState;
            }
          }
          $useProgram(program) {
            if (this._state.setProgram(program)) this._useProgram(program);
          }
          $bindBuffer(target, fb) {
            if (this._state.setBuffer(target, fb)) this._bindBuffer(target, fb);
          }
          $bindFramebuffer(target, fb) {
            if (this._state.setFramebuffer(target, fb)) this._bindFramebuffer(target, fb);
          }
          $bindRenderbuffer(target, fb) {
            if (this._state.setRenderbuffer(target, fb)) this._bindRenderbuffer(target, fb);
          }
          $enable(cap) {
            if (this._state.setFlag(cap, true)) this._enable(cap);
          }
          $disable(cap) {
            if (this._state.setFlag(cap, false)) this._disable(cap);
          }
          $viewport(x, y, w, h) {
            if (this._state.setSetting(this._viewport, [x, y, w, h])) this._viewport(x, y, w, h);
          }
          $scissor(x, y, w, h) {
            if (this._state.setSetting(this._scissor, [x, y, w, h])) this._scissor(x, y, w, h);
          }
          $disableVertexAttribArray(index) {
            if (this._state.disableVertexAttribArray(index)) this._disableVertexAttribArray(index);
          }
          $enableVertexAttribArray(index) {
            if (this._state.enableVertexAttribArray(index)) this._enableVertexAttribArray(index);
          }
          $vertexAttribPointer(index, size, type, normalized, stride, offset) {
            if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset])) this._vertexAttribPointer(index, size, type, normalized, stride, offset);
          }
          $activeTexture(texture) {
            if (this._state.setActiveTexture(texture)) this._activeTexture(texture);
          }
          $bindTexture(target, texture) {
            if (this._state.bindTexture(target, texture)) this._bindTexture(target, texture);
          }
          $pixelStorei(pname, param) {
            if (this._state.setPixelStorei(pname, param)) {
              this._pixelStorei(pname, param);
            }
          }
          $stencilFuncSeparate(face, func, ref, mask) {
            var f;
            switch (face) {
              case this.FRONT:
                f = this._stencilFuncSeparateFront;
                break;
              case this.BACK:
                f = this._stencilFuncSeparateBack;
                break;
              case this.FRONT_AND_BACK:
                f = this._stencilFuncSeparateFrontAndBack;
                break;
            }
            if (this._state.setSetting(f, [func, ref, mask])) f.apply(this, [func, ref, mask]);
          }
          _stencilFuncSeparateFront(func, ref, mask) {
            this._stencilFuncSeparate(this.FRONT, func, ref, mask);
          }
          _stencilFuncSeparateBack(func, ref, mask) {
            this._stencilFuncSeparate(this.BACK, func, ref, mask);
          }
          _stencilFuncSeparateFrontAndBack(func, ref, mask) {
            this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
          }
          $stencilMaskSeparate(face, mask) {
            var f;
            switch (face) {
              case this.FRONT:
                f = this._stencilMaskSeparateFront;
                break;
              case this.BACK:
                f = this._stencilMaskSeparateBack;
                break;
              case this.FRONT_AND_BACK:
                f = this._stencilMaskSeparateFrontAndBack;
                break;
            }
            if (this._state.setSetting(f, [mask])) f.apply(this, [mask]);
          }
          _stencilMaskSeparateFront(mask) {
            this._stencilMaskSeparate(this.FRONT, mask);
          }
          _stencilMaskSeparateBack(mask) {
            this._stencilMaskSeparate(this.BACK, mask);
          }
          _stencilMaskSeparateFrontAndBack(mask) {
            this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
          }
          $stencilOpSeparate(face, fail, zfail, zpass) {
            var f;
            switch (face) {
              case this.FRONT:
                f = this._stencilOpSeparateFront;
                break;
              case this.BACK:
                f = this._stencilOpSeparateBack;
                break;
              case this.FRONT_AND_BACK:
                f = this._stencilOpSeparateFrontAndBack;
                break;
            }
            if (this._state.setSetting(f, [fail, zfail, zpass])) f.apply(this, [fail, zfail, zpass]);
          }
          _stencilOpSeparateFront(fail, zfail, zpass) {
            this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
          }
          _stencilOpSeparateBack(fail, zfail, zpass) {
            this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
          }
          _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
            this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
          }
          $blendColor(red, green, blue, alpha) {
            if (this._state.setSetting(this._blendColor, [red, green, blue, alpha])) this._blendColor(red, green, blue, alpha);
          }
          $blendEquation(mode) {
            if (this._state.setSetting(this._blendEquation, [mode])) this._blendEquation(mode);
          }
          $blendEquationSeparate(modeRGB, modeAlpha) {
            if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha])) this._blendEquationSeparate(modeRGB, modeAlpha);
          }
          $blendFunc(sfactor, dfactor) {
            if (this._state.setSetting(this._blendFunc, [sfactor, dfactor])) this._blendFunc(sfactor, dfactor);
          }
          $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha])) this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
          }
          $clearColor(red, green, blue, alpha) {
            if (this._state.setSetting(this._clearColor, [red, green, blue, alpha])) this._clearColor(red, green, blue, alpha);
          }
          $clearDepth(depth) {
            if (this._state.setSetting(this._clearDepth, [depth])) this._clearDepth(depth);
          }
          $clearStencil(s) {
            if (this._state.setSetting(this._clearStencil, [s])) this._clearStencil(s);
          }
          $colorMask(red, green, blue, alpha) {
            if (this._state.setSetting(this._colorMask, [red, green, blue, alpha])) this._colorMask(red, green, blue, alpha);
          }
          $cullFace(mode) {
            if (this._state.setSetting(this._cullFace, [mode])) this._cullFace(mode);
          }
          $depthFunc(func) {
            if (this._state.setSetting(this._depthFunc, [func])) this._depthFunc(func);
          }
          $depthMask(flag) {
            if (this._state.setSetting(this._depthMask, [flag])) this._depthMask(flag);
          }
          $depthRange(zNear, zFar) {
            if (this._state.setSetting(this._depthRange, [zNear, zFar])) this._depthRange(zNear, zFar);
          }
          $frontFace(mode) {
            if (this._state.setSetting(this._frontFace, [mode])) this._frontFace(mode);
          }
          $lineWidth(width) {
            if (this._state.setSetting(this._lineWidth, [width])) this._lineWidth(width);
          }
          $polygonOffset(factor, units) {
            if (this._state.setSetting(this._polygonOffset, [factor, units])) this._polygonOffset(factor, units);
          }
          $sampleCoverage(value, invert) {
            if (this._state.setSetting(this._sampleCoverage, [value, invert])) this._sampleCoverage(value, invert);
          }
          $stencilFunc(func, ref, mask) {
            if (this._state.setSetting(this._stencilFunc, [func, ref, mask])) this._stencilFunc(func, ref, mask);
          }
          $stencilMask(mask) {
            if (this._state.setSetting(this._stencilMask, [mask])) this._stencilMask(mask);
          }
          $stencilOp(fail, zfail, zpass) {
            if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass])) this._stencilOp(fail, zfail, zpass);
          }
          $vertexAttrib1f(indx, x) {
            if (this._state.setSetting(this._vertexAttrib1f, [indx, x])) this._vertexAttrib1f(indx, x);
          }
          $vertexAttrib1fv(indx, values) {
            if (this._state.setSetting(this._vertexAttrib1fv, [indx, values])) this._vertexAttrib1fv(indx, values);
          }
          $vertexAttrib2f(indx, x, y) {
            if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y])) this._vertexAttrib2f(indx, x, y);
          }
          $vertexAttrib2fv(indx, values) {
            if (this._state.setSetting(this._vertexAttrib2fv, [indx, values])) this._vertexAttrib2fv(indx, values);
          }
          $vertexAttrib3f(indx, x, y, z) {
            if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z])) this._vertexAttrib3f(indx, x, y, z);
          }
          $vertexAttrib3fv(indx, values) {
            if (this._state.setSetting(this._vertexAttrib3fv, [indx, values])) this._vertexAttrib3fv(indx, values);
          }
          $vertexAttrib4f(indx, x, y, z, w) {
            if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w])) this._vertexAttrib4f(indx, x, y, z, w);
          }
          $vertexAttrib4fv(indx, values) {
            if (this._state.setSetting(this._vertexAttrib4fv, [indx, values])) this._vertexAttrib4fv(indx, values);
          }

          /**
           * Sets up the rendering context for context sharing.
           * @param {WebGLRenderingContext} gl
           * @param {string} id
           */
          static enable(gl) {
            var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "default";
            var names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
            gl.__proto__;
            names.forEach(name => {
              if (name !== "constructor") {
                var method = WebGLStateManager.prototype[name];
                if (name.charAt(0) === "$") {
                  name = name.substr(1);
                }
                if (gl[name] !== method) {
                  if (gl[name]) {
                    if (!gl[name].name) {
                      // We do this for compatibility with the Chrome WebGL Inspector plugin.
                      gl[name].xname = name;
                    }
                    gl['_' + name] = gl[name];
                  }
                  gl[name] = method;
                }
              }
            });
            WebGLStateManager.prototype._initStateManager.call(gl, id);
            return gl;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TextureManager {
          constructor(stage) {
            this.stage = stage;

            /**
             * The currently used amount of texture memory.
             * @type {number}
             */
            this._usedMemory = 0;

            /**
             * All uploaded texture sources.
             * @type {TextureSource[]}
             */
            this._uploadedTextureSources = [];

            /**
             * The texture source lookup id to texture source hashmap.
             * @type {Map<String, TextureSource>}
             */
            this.textureSourceHashmap = new Map();
          }
          get usedMemory() {
            return this._usedMemory;
          }
          destroy() {
            for (var i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
              this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
            }
            this.textureSourceHashmap.clear();
            this._usedMemory = 0;
          }
          getReusableTextureSource(id) {
            return this.textureSourceHashmap.get(id);
          }
          getTextureSource(func, id) {
            // Check if texture source is already known.
            var textureSource = id ? this.textureSourceHashmap.get(id) : null;
            if (!textureSource) {
              // Create new texture source.
              textureSource = new TextureSource(this, func);
              if (id) {
                textureSource.lookupId = id;
                this.textureSourceHashmap.set(id, textureSource);
              }
            }
            return textureSource;
          }
          uploadTextureSource(textureSource, options) {
            if (textureSource.isLoaded()) return;
            this._addMemoryUsage(textureSource.w * textureSource.h);

            // Load texture.
            var nativeTexture = this._nativeUploadTextureSource(textureSource, options);
            textureSource._nativeTexture = nativeTexture;

            // We attach w and h to native texture (we need it in CoreRenderState._isRenderTextureReusable).
            nativeTexture.w = textureSource.w;
            nativeTexture.h = textureSource.h;
            nativeTexture.update = this.stage.frameCounter;
            this._uploadedTextureSources.push(textureSource);
            this.addToLookupMap(textureSource);

            // add VRAM tracking if using the webgl renderer
            this._updateVramUsage(textureSource, 1);
          }
          _addMemoryUsage(delta) {
            this._usedMemory += delta;
            this.stage.addMemoryUsage(delta);
          }
          _updateVramUsage(textureSource, sign) {
            var nativeTexture = textureSource.nativeTexture;
            var usage;

            // do nothing if webgl isn't even supported
            if (!Stage.isWebglSupported()) return;

            // or if there is no native texture
            if (!textureSource.isLoaded()) return;

            // or, finally, if there is no bytes per pixel specified
            if (!nativeTexture.hasOwnProperty('bytesPerPixel') || isNaN(nativeTexture.bytesPerPixel)) return;
            usage = sign * (textureSource.w * textureSource.h * nativeTexture.bytesPerPixel);
            this.stage.addVramUsage(usage, textureSource.hasAlpha);
          }
          addToLookupMap(textureSource) {
            var lookupId = textureSource.lookupId;
            if (lookupId) {
              if (!this.textureSourceHashmap.has(lookupId)) {
                this.textureSourceHashmap.set(lookupId, textureSource);
              }
            }
          }
          gc() {
            this.freeUnusedTextureSources();
            this._cleanupLookupMap();
          }
          freeUnusedTextureSources() {
            var remainingTextureSources = [];
            for (var i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
              var ts = this._uploadedTextureSources[i];
              if (ts.allowCleanup()) {
                this._freeManagedTextureSource(ts);
              } else {
                remainingTextureSources.push(ts);
              }
            }
            this._uploadedTextureSources = remainingTextureSources;
            this._cleanupLookupMap();
          }
          _freeManagedTextureSource(textureSource) {
            if (textureSource.isLoaded()) {
              this._nativeFreeTextureSource(textureSource);
              this._addMemoryUsage(-textureSource.w * textureSource.h);

              // add VRAM tracking if using the webgl renderer
              this._updateVramUsage(textureSource, -1);
            }

            // Should be reloaded.
            textureSource.loadingSince = null;
          }
          _cleanupLookupMap() {
            // We keep those that still have value (are being loaded or already loaded, or are likely to be reused).
            this.textureSourceHashmap.forEach((textureSource, lookupId) => {
              if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                this.textureSourceHashmap.delete(lookupId);
              }
            });
          }

          /**
           * Externally free texture source.
           * @param textureSource
           */
          freeTextureSource(textureSource) {
            var index = this._uploadedTextureSources.indexOf(textureSource);
            var managed = index !== -1;
            if (textureSource.isLoaded()) {
              if (managed) {
                this._addMemoryUsage(-textureSource.w * textureSource.h);
                this._uploadedTextureSources.splice(index, 1);
              }
              this._nativeFreeTextureSource(textureSource);
            }

            // Should be reloaded.
            textureSource.loadingSince = null;
          }
          _nativeUploadTextureSource(textureSource, options) {
            return this.stage.renderer.uploadTextureSource(textureSource, options);
          }
          _nativeFreeTextureSource(textureSource) {
            this.stage.renderer.freeTextureSource(textureSource);
            textureSource.clearNativeTexture();
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Allows throttling of loading texture sources, keeping the app responsive.
         */
        class TextureThrottler {
          constructor(stage) {
            this.stage = stage;
            this.genericCancelCb = textureSource => {
              this._remove(textureSource);
            };
            this._sources = [];
            this._data = [];
          }
          destroy() {
            this._sources = [];
            this._data = [];
          }
          processSome() {
            if (this._sources.length) {
              var _start = Date.now();
              do {
                this._processItem();
              } while (this._sources.length && Date.now() - _start < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME);
            }
          }
          _processItem() {
            var source = this._sources.pop();
            var data = this._data.pop();
            if (source.isLoading()) {
              source.processLoadedSource(data);
            }
          }
          add(textureSource, data) {
            this._sources.push(textureSource);
            this._data.push(data);
          }
          _remove(textureSource) {
            var index = this._sources.indexOf(textureSource);
            if (index >= 0) {
              this._sources.splice(index, 1);
              this._data.splice(index, 1);
            }
          }
        }
        TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CoreContext {
          constructor(stage) {
            this.stage = stage;
            this.root = null;
            this.updateTreeOrder = 0;
            this.renderState = this.stage.renderer.createCoreRenderState(this);
            this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
            this.renderExec.init();
            this._usedMemory = 0;
            this._renderTexturePool = [];
            this._renderTextureId = 1;
            this._zSorts = [];
            this.renderToTextureCount = 0;
          }
          get usedMemory() {
            return this._usedMemory;
          }
          destroy() {
            this._renderTexturePool.forEach(texture => this._freeRenderTexture(texture));
            this._usedMemory = 0;
          }
          hasRenderUpdates() {
            return !!this.root._parent._hasRenderUpdates;
          }
          render() {
            // Clear flag to identify if anything changes before the next frame.
            this.root._parent._hasRenderUpdates = 0;
            this._render();
          }
          update() {
            this._update();

            // Due to the boundsVisibility flag feature (and onAfterUpdate hook), it is possible that other elements were
            // changed during the update loop (for example due to the txLoaded event). We process these changes immediately
            // (but not recursively to prevent infinite loops).
            if (this.root._hasUpdates) {
              this._update();
            }
            this._performForcedZSorts();
          }

          /**
           * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
           */
          _performForcedZSorts() {
            var n = this._zSorts.length;
            if (n) {
              // Forced z-sorts (ElementCore may force a z-sort in order to free memory/prevent memory leaks).
              for (var i = 0, _n13 = this._zSorts.length; i < _n13; i++) {
                if (this._zSorts[i].zSort) {
                  this._zSorts[i].sortZIndexedChildren();
                }
              }
              this._zSorts = [];
            }
          }
          _update() {
            this.updateTreeOrder = 0;
            this.root.update();
          }
          _render() {
            var debugFrame = this.stage.getOption('debugFrame');
            // Obtain a sequence of the quad operations.
            this._fillRenderState();
            if (this.stage.getOption('readPixelsBeforeDraw')) {
              this._readPixels();
            }

            // Now run them with the render executor.
            this._performRender();
            if (debugFrame) {
              console.log(`[Lightning] RTT Renders in frame: ${this.renderToTextureCount}`);
            }

            // Block OpenGL pipeline to prevent framebuffer flickering
            // on certain devices
            if (this.stage.getOption('readPixelsAfterDraw') && this.renderToTextureCount >= this.stage.getOption('readPixelsAfterDrawThreshold')) {
              if (debugFrame) {
                console.log(`[Lightning] readPixelsAfterDraw behavior triggered`);
              }
              this._readPixels();
            }
            this.renderToTextureCount = 0;
          }
          _readPixels() {
            var pixels = new Uint8Array(4);
            var gl = this.stage.gl;
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          }
          _fillRenderState() {
            this.renderState.reset();
            this.root.render();
            this.renderState.finish();
          }
          _performRender() {
            this.renderExec.execute();
          }
          _addMemoryUsage(delta) {
            this._usedMemory += delta;
            this.stage.addMemoryUsage(delta);
          }
          allocateRenderTexture(w, h) {
            var prec = this.stage.getRenderPrecision();
            var pw = Math.max(1, Math.round(w * prec));
            var ph = Math.max(1, Math.round(h * prec));

            // Search last item first, so that last released render texture is preferred (may cause memory cache benefits).
            var n = this._renderTexturePool.length;
            for (var i = n - 1; i >= 0; i--) {
              var _texture = this._renderTexturePool[i];
              // We don't want to reuse the same render textures within the same frame because that will create gpu stalls.
              if (_texture.w === pw && _texture.h === ph && _texture.update !== this.stage.frameCounter) {
                _texture.f = this.stage.frameCounter;
                this._renderTexturePool.splice(i, 1);
                return _texture;
              }
            }
            var texture = this._createRenderTexture(w, h, pw, ph);
            texture.precision = prec;
            return texture;
          }
          releaseRenderTexture(texture) {
            this._renderTexturePool.push(texture);
          }
          freeUnusedRenderTextures() {
            var maxAge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;
            // Clean up all textures that are no longer used.
            // This cache is short-lived because it is really just meant to supply running shaders that are
            // updated during a number of frames.
            var limit = this.stage.frameCounter - maxAge;
            this._renderTexturePool = this._renderTexturePool.filter(texture => {
              if (texture.f <= limit) {
                this._freeRenderTexture(texture);
                return false;
              }
              return true;
            });
          }
          _createRenderTexture(w, h, pw, ph) {
            this._addMemoryUsage(pw * ph);
            var texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
            texture.id = this._renderTextureId++;
            texture.f = this.stage.frameCounter;
            texture.ow = w;
            texture.oh = h;
            texture.w = pw;
            texture.h = ph;
            return texture;
          }
          _freeRenderTexture(nativeTexture) {
            this.stage.renderer.freeRenderTexture(nativeTexture);
            this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
            this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
          }
          forceZSort(elementCore) {
            this._zSorts.push(elementCore);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TransitionSettings {
          constructor(stage) {
            this.stage = stage;
            this._timingFunction = 'ease';
            this._timingFunctionImpl = StageUtils.getTimingFunction(this._timingFunction);
            this.delay = 0;
            this.duration = 0.2;
            this.merger = null;
          }
          get timingFunction() {
            return this._timingFunction;
          }
          set timingFunction(v) {
            this._timingFunction = v;
            this._timingFunctionImpl = StageUtils.getTimingFunction(v);
          }
          get timingFunctionImpl() {
            return this._timingFunctionImpl;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
        }
        TransitionSettings.prototype.isTransitionSettings = true;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TransitionManager {
          constructor(stage) {
            this.stage = stage;
            this.stage.on('frameStart', () => this.progress());

            /**
             * All transitions that are running and attached.
             * (we don't support transitions on un-attached elements to prevent memory leaks)
             * @type {Set<Transition>}
             */
            this.active = new Set();
            this.defaultTransitionSettings = new TransitionSettings(this.stage);
          }
          progress() {
            if (this.active.size) {
              var dt = this.stage.dt;
              var filter = false;
              this.active.forEach(function (a) {
                a.progress(dt);
                if (!a.isRunning()) {
                  filter = true;
                }
              });
              if (filter) {
                this.active = new Set([...this.active].filter(t => t.isRunning()));
              }
            }
          }
          createSettings(settings) {
            var transitionSettings = new TransitionSettings();
            Base.patchObject(transitionSettings, settings);
            return transitionSettings;
          }
          addActive(transition) {
            this.active.add(transition);
          }
          removeActive(transition) {
            this.active.delete(transition);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class MultiSpline {
          constructor() {
            this._clear();
          }
          _clear() {
            this._p = [];
            this._pe = [];
            this._idp = [];
            this._f = [];
            this._v = [];
            this._lv = [];
            this._sm = [];
            this._s = [];
            this._ve = [];
            this._sme = [];
            this._se = [];
            this._length = 0;
          }
          parse(rgba, def) {
            var i, n;
            if (!Utils$2.isObjectLiteral(def)) {
              def = {
                0: def
              };
            }
            var defaultSmoothness = 0.5;
            var items = [];
            for (var key in def) {
              if (def.hasOwnProperty(key)) {
                var obj = def[key];
                if (!Utils$2.isObjectLiteral(obj)) {
                  obj = {
                    v: obj
                  };
                }
                var p = parseFloat(key);
                if (key === "sm") {
                  defaultSmoothness = obj.v;
                } else if (!isNaN(p) && p >= 0 && p <= 2) {
                  obj.p = p;
                  obj.f = Utils$2.isFunction(obj.v);
                  obj.lv = obj.f ? obj.v(0, 0) : obj.v;
                  items.push(obj);
                }
              }
            }

            // Sort by progress value.
            items = items.sort(function (a, b) {
              return a.p - b.p;
            });
            n = items.length;
            for (i = 0; i < n; i++) {
              var last = i === n - 1;
              if (!items[i].hasOwnProperty('pe')) {
                // Progress.
                items[i].pe = last ? items[i].p <= 1 ? 1 : 2 /* support onetotwo stop */ : items[i + 1].p;
              } else {
                // Prevent multiple items at the same time.
                var max = i < n - 1 ? items[i + 1].p : 1;
                if (items[i].pe > max) {
                  items[i].pe = max;
                }
              }
              if (items[i].pe === items[i].p) {
                items[i].idp = 0;
              } else {
                items[i].idp = 1 / (items[i].pe - items[i].p);
              }
            }

            // Color merger: we need to split/combine RGBA components.

            // Calculate bezier helper values.;
            for (i = 0; i < n; i++) {
              if (!items[i].hasOwnProperty('sm')) {
                // Smoothness.;
                items[i].sm = defaultSmoothness;
              }
              if (!items[i].hasOwnProperty('s')) {
                // Slope.;
                if (i === 0 || i === n - 1 || items[i].p === 1 /* for onetotwo */) {
                  // Horizontal slope at start and end.;
                  items[i].s = rgba ? [0, 0, 0, 0] : 0;
                } else {
                  var pi = items[i - 1];
                  var ni = items[i + 1];
                  if (pi.p === ni.p) {
                    items[i].s = rgba ? [0, 0, 0, 0] : 0;
                  } else {
                    if (rgba) {
                      var nc = MultiSpline.getRgbaComponents(ni.lv);
                      var pc = MultiSpline.getRgbaComponents(pi.lv);
                      var d = 1 / (ni.p - pi.p);
                      items[i].s = [d * (nc[0] - pc[0]), d * (nc[1] - pc[1]), d * (nc[2] - pc[2]), d * (nc[3] - pc[3])];
                    } else {
                      items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
                    }
                  }
                }
              }
            }
            for (i = 0; i < n - 1; i++) {
              // Calculate value function.;
              if (!items[i].f) {
                var _last = i === n - 1;
                if (!items[i].hasOwnProperty('ve')) {
                  items[i].ve = _last ? items[i].lv : items[i + 1].lv;
                }

                // We can only interpolate on numeric values. Non-numeric values are set literally when reached time.
                if (Utils$2.isNumber(items[i].v) && Utils$2.isNumber(items[i].lv)) {
                  if (!items[i].hasOwnProperty('sme')) {
                    items[i].sme = _last ? defaultSmoothness : items[i + 1].sm;
                  }
                  if (!items[i].hasOwnProperty('se')) {
                    items[i].se = _last ? rgba ? [0, 0, 0, 0] : 0 : items[i + 1].s;
                  }

                  // Generate spline.;
                  if (rgba) {
                    items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                  } else {
                    items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                  }
                  items[i].f = true;
                }
              }
            }
            if (this.length) {
              this._clear();
            }
            for (i = 0, n = items.length; i < n; i++) {
              this._add(items[i]);
            }
          }
          _add(item) {
            this._p.push(item.p || 0);
            this._pe.push(item.pe || 0);
            this._idp.push(item.idp || 0);
            this._f.push(item.f || false);
            this._v.push(item.hasOwnProperty('v') ? item.v : 0 /* v might be false or null */);
            this._lv.push(item.lv || 0);
            this._sm.push(item.sm || 0);
            this._s.push(item.s || 0);
            this._ve.push(item.ve || 0);
            this._sme.push(item.sme || 0);
            this._se.push(item.se || 0);
            this._length++;
          }
          _getItem(p) {
            var n = this._length;
            if (!n) {
              return -1;
            }
            if (p < this._p[0]) {
              return 0;
            }
            for (var i = 0; i < n; i++) {
              if (this._p[i] <= p && p < this._pe[i]) {
                return i;
              }
            }
            return n - 1;
          }
          getValue(p) {
            var i = this._getItem(p);
            if (i === -1) {
              return undefined;
            } else {
              if (this._f[i]) {
                var o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
                return this._v[i](o);
              } else {
                return this._v[i];
              }
            }
          }
          get length() {
            return this._length;
          }
          static getRgbaComponents(argb) {
            var r = (argb / 65536 | 0) % 256;
            var g = (argb / 256 | 0) % 256;
            var b = argb % 256;
            var a = argb / 16777216 | 0;
            return [r, g, b, a];
          }
          static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
            // Normalize slopes because we use a spline that goes from 0 to 1.
            var dp = p2 - p1;
            s1 *= dp;
            s2 *= dp;
            var helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
            if (!helpers) {
              return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return v2 * p + v1 * (1 - p);
              };
            } else {
              return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.calculateSpline(helpers, p);
              };
            }
          }
          static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
            // Normalize slopes because we use a spline that goes from 0 to 1.
            var dp = p2 - p1;
            s1[0] *= dp;
            s1[1] *= dp;
            s1[2] *= dp;
            s1[3] *= dp;
            s2[0] *= dp;
            s2[1] *= dp;
            s2[2] *= dp;
            s2[3] *= dp;
            var cv1 = MultiSpline.getRgbaComponents(v1);
            var cv2 = MultiSpline.getRgbaComponents(v2);
            var helpers = [MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]), MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]), MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]), MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])];
            if (!helpers[0]) {
              return function (p) {
                // Linear.
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.mergeColors(v2, v1, p);
              };
            } else {
              return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.getArgbNumber([Math.min(255, MultiSpline.calculateSpline(helpers[0], p)), Math.min(255, MultiSpline.calculateSpline(helpers[1], p)), Math.min(255, MultiSpline.calculateSpline(helpers[2], p)), Math.min(255, MultiSpline.calculateSpline(helpers[3], p))]);
              };
            }
          }
          /**
           * Creates helpers to be used in the spline function.
           * @param {number} v1
           *   From value.
           * @param {number} v2
           *   To value.
           * @param {number} o1
           *   From smoothness (0 = linear, 1 = smooth).
           * @param {number} s1
           *   From slope (0 = horizontal, infinite = vertical).
           * @param {number} i2
           *   To smoothness.
           * @param {number} s2
           *   To slope.
           * @returns {Number[]}
           *   The helper values to be supplied to the spline function.
           *   If the configuration is actually linear, null is returned.
           */
          static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
            if (!o1 && !i2) {
              // Linear.
              return null;
            }

            // Cubic bezier points.
            // http://cubic-bezier.com/
            var csx = o1;
            var csy = v1 + s1 * o1;
            var cex = 1 - i2;
            var cey = v2 - s2 * i2;
            var xa = 3 * csx - 3 * cex + 1;
            var xb = -6 * csx + 3 * cex;
            var xc = 3 * csx;
            var ya = 3 * csy - 3 * cey + v2 - v1;
            var yb = 3 * (cey + v1) - 6 * csy;
            var yc = 3 * (csy - v1);
            var yd = v1;
            return [xa, xb, xc, ya, yb, yc, yd];
          }
          /**
           * Calculates the intermediate spline value based on the specified helpers.
           * @param {number[]} helpers
           *   Obtained from getSplineHelpers.
           * @param {number} p
           * @return {number}
           */
          static calculateSpline(helpers, p) {
            var xa = helpers[0];
            var xb = helpers[1];
            var xc = helpers[2];
            var ya = helpers[3];
            var yb = helpers[4];
            var yc = helpers[5];
            var yd = helpers[6];
            if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
              // Linear.
              return p;
            }

            // Find t for p.
            var t = 0.5,
              cbx,
              dx;
            for (var it = 0; it < 20; it++) {
              // Cubic bezier function: f(t)=t*(t*(t*a+b)+c).
              cbx = t * (t * (t * xa + xb) + xc);
              dx = p - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
              }

              // Cubic bezier derivative function: f'(t)=t*(t*(3*a)+2*b)+c
              var cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
              if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
              }
              t += dx / cbxd;
            }

            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            var minT = 0;
            var maxT = 1;
            for (var _it2 = 0; _it2 < 20; _it2++) {
              t = 0.5 * (minT + maxT);

              // Cubic bezier function: f(t)=t*(t*(t*a+b)+c)+d.
              cbx = t * (t * (t * xa + xb) + xc);
              dx = p - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
              }
              if (dx < 0) {
                maxT = t;
              } else {
                minT = t;
              }
            }
            return t;
          }
          static mergeColors(c1, c2, p) {
            var r1 = (c1 / 65536 | 0) % 256;
            var g1 = (c1 / 256 | 0) % 256;
            var b1 = c1 % 256;
            var a1 = c1 / 16777216 | 0;
            var r2 = (c2 / 65536 | 0) % 256;
            var g2 = (c2 / 256 | 0) % 256;
            var b2 = c2 % 256;
            var a2 = c2 / 16777216 | 0;
            var r = r1 * p + r2 * (1 - p);
            var g = g1 * p + g2 * (1 - p);
            var b = b1 * p + b2 * (1 - p);
            var a = a1 * p + a2 * (1 - p);
            return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
          }
          static getArgbNumber(rgba) {
            rgba[0] = Math.max(0, Math.min(255, rgba[0]));
            rgba[1] = Math.max(0, Math.min(255, rgba[1]));
            rgba[2] = Math.max(0, Math.min(255, rgba[2]));
            rgba[3] = Math.max(0, Math.min(255, rgba[3]));
            var v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
            if (v < 0) {
              v = 0xFFFFFFFF + v + 1;
            }
            return v;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class AnimationActionSettings {
          constructor(animationSettings) {
            this.animationSettings = animationSettings;

            /**
             * The selector that selects the elements.
             * @type {string}
             */
            this._selector = "";

            /**
             * The value items, ordered by progress offset.
             * @type {MultiSpline}
             * @private;
             */
            this._items = new MultiSpline();

            /**
             * The affected properties (paths).
             * @private;
             */
            this._props = [];

            /**
             * Property setters, indexed according to props.
             * @private;
             */
            this._propSetters = [];
            this._resetValue = undefined;
            this._hasResetValue = false;
            this._hasColorProperty = undefined;
          }
          getResetValue() {
            if (this._hasResetValue) {
              return this._resetValue;
            } else {
              return this._items.getValue(0);
            }
          }
          apply(element, p, factor) {
            var elements = this.getAnimatedElements(element);
            var v = this._items.getValue(p);
            if (v === undefined || !elements.length) {
              return;
            }
            if (factor !== 1) {
              // Stop factor.;
              var sv = this.getResetValue();
              if (Utils$2.isNumber(v) && Utils$2.isNumber(sv)) {
                if (this.hasColorProperty()) {
                  v = StageUtils.mergeColors(v, sv, factor);
                } else {
                  v = StageUtils.mergeNumbers(v, sv, factor);
                }
              }
            }

            // Apply transformation to all components.;
            var n = this._propSetters.length;
            var m = elements.length;
            for (var j = 0; j < m; j++) {
              for (var i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
              }
            }
          }
          getAnimatedElements(element) {
            return element.select(this._selector);
          }
          reset(element) {
            var elements = this.getAnimatedElements(element);
            var v = this.getResetValue();
            if (v === undefined || !elements.length) {
              return;
            }

            // Apply transformation to all components.
            var n = this._propSetters.length;
            var m = elements.length;
            for (var j = 0; j < m; j++) {
              for (var i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
              }
            }
          }
          set selector(v) {
            this._selector = v;
          }
          set t(v) {
            this.selector = v;
          }
          get resetValue() {
            return this._resetValue;
          }
          set resetValue(v) {
            this._resetValue = v;
            this._hasResetValue = v !== undefined;
          }
          set rv(v) {
            this.resetValue = v;
          }
          set value(v) {
            this._items.parse(this.hasColorProperty(), v);
          }
          set v(v) {
            this.value = v;
          }
          set properties(v) {
            if (!Array.isArray(v)) {
              v = [v];
            }
            this._props = [];
            v.forEach(prop => {
              this._props.push(prop);
              this._propSetters.push(Element$1.getSetter(prop));
            });
          }
          set property(v) {
            this._hasColorProperty = undefined;
            this.properties = v;
          }
          set p(v) {
            this.properties = v;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
          hasColorProperty() {
            if (this._hasColorProperty === undefined) {
              this._hasColorProperty = this._props.length ? Element$1.isColorProperty(this._props[0]) : false;
            }
            return this._hasColorProperty;
          }
        }
        AnimationActionSettings.prototype.isAnimationActionSettings = true;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class AnimationSettings {
          constructor() {
            /**
             * @type {AnimationActionSettings[]}
             */
            this._actions = [];
            this.delay = 0;
            this.duration = 1;
            this.repeat = 0;
            this.repeatOffset = 0;
            this.repeatDelay = 0;
            this.autostop = false;
            this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
            this._stopTimingFunction = 'ease';
            this._stopTimingFunctionImpl = StageUtils.getTimingFunction(this._stopTimingFunction);
            this.stopDuration = 0;
            this.stopDelay = 0;
          }
          get actions() {
            return this._actions;
          }
          set actions(v) {
            this._actions = [];
            for (var i = 0, n = v.length; i < n; i++) {
              var e = v[i];
              if (!e.isAnimationActionSettings) {
                var aas = new AnimationActionSettings(this);
                aas.patch(e);
                this._actions.push(aas);
              } else {
                this._actions.push(e);
              }
            }
          }

          /**
           * Applies the animation to the specified element, for the specified progress between 0 and 1.
           * @param {Element} element;
           * @param {number} p;
           * @param {number} factor;
           */
          apply(element, p) {
            var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            this._actions.forEach(function (action) {
              action.apply(element, p, factor);
            });
          }

          /**
           * Resets the animation to the reset values.
           * @param {Element} element;
           */
          reset(element) {
            this._actions.forEach(function (action) {
              action.reset(element);
            });
          }
          get stopTimingFunction() {
            return this._stopTimingFunction;
          }
          set stopTimingFunction(v) {
            this._stopTimingFunction = v;
            this._stopTimingFunctionImpl = StageUtils.getTimingFunction(v);
          }
          get stopTimingFunctionImpl() {
            return this._stopTimingFunctionImpl;
          }
          patch(settings) {
            Base.patchObject(this, settings);
          }
        }
        AnimationSettings.STOP_METHODS = {
          FADE: 'fade',
          REVERSE: 'reverse',
          FORWARD: 'forward',
          IMMEDIATE: 'immediate',
          ONETOTWO: 'onetotwo'
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Animation extends EventEmitter {
          constructor(manager, settings, element) {
            super();
            this.manager = manager;
            this._settings = settings;
            this._element = element;
            this._state = Animation.STATES.IDLE;
            this._p = 0;
            this._delayLeft = 0;
            this._repeatsLeft = 0;
            this._stopDelayLeft = 0;
            this._stopP = 0;
          }
          start() {
            if (this._element && this._element.attached) {
              this._p = 0;
              this._delayLeft = this.settings.delay;
              this._repeatsLeft = this.settings.repeat;
              this._state = Animation.STATES.PLAYING;
              this.emit('start');
              this.checkActive();
            } else {
              console.warn("[Lightning] Element must be attached before starting animation");
            }
          }
          play() {
            if (this._state === Animation.STATES.PAUSED) {
              // Continue.;
              this._state = Animation.STATES.PLAYING;
              this.checkActive();
              this.emit('resume');
            } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
              // Continue.;
              this._state = Animation.STATES.PLAYING;
              this.emit('stopContinue');
            } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
              // Restart.;
              this.start();
            }
          }
          pause() {
            if (this._state === Animation.STATES.PLAYING) {
              this._state = Animation.STATES.PAUSED;
              this.emit('pause');
            }
          }
          replay() {
            if (this._state == Animation.STATES.FINISHED) {
              this.start();
            } else {
              this.play();
            }
          }
          skipDelay() {
            this._delayLeft = 0;
            this._stopDelayLeft = 0;
          }
          finish() {
            if (this._state === Animation.STATES.PLAYING) {
              this._delayLeft = 0;
              this._p = 1;
            } else if (this._state === Animation.STATES.STOPPING) {
              this._stopDelayLeft = 0;
              this._p = 0;
            }
          }
          stop() {
            if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE) return;
            this._stopDelayLeft = this.settings.stopDelay || 0;
            if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.IMMEDIATE && !this._stopDelayLeft || this._delayLeft > 0) {
              // Stop upon next progress.;
              this._state = Animation.STATES.STOPPING;
              this.emit('stop');
            } else {
              if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
                this._stopP = 0;
              }
              this._state = Animation.STATES.STOPPING;
              this.emit('stop');
            }
            this.checkActive();
          }
          stopNow() {
            if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
              this._state = Animation.STATES.STOPPING;
              this._p = 0;
              this.emit('stop');
              this.reset();
              this._state = Animation.STATES.STOPPED;
              this.emit('stopFinish');
            }
          }
          isPaused() {
            return this._state === Animation.STATES.PAUSED;
          }
          isPlaying() {
            return this._state === Animation.STATES.PLAYING;
          }
          isStopping() {
            return this._state === Animation.STATES.STOPPING;
          }
          isFinished() {
            return this._state === Animation.STATES.FINISHED;
          }
          checkActive() {
            if (this.isActive()) {
              this.manager.addActive(this);
            }
          }
          isActive() {
            return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
          }
          progress(dt) {
            if (!this._element) return;
            this._progress(dt);
            this.apply();
          }
          _progress(dt) {
            if (this._state == Animation.STATES.STOPPING) {
              this._stopProgress(dt);
              return;
            }
            if (this._state != Animation.STATES.PLAYING) {
              return;
            }
            if (this._delayLeft > 0) {
              this._delayLeft -= dt;
              if (this._delayLeft < 0) {
                dt = -this._delayLeft;
                this._delayLeft = 0;
                this.emit('delayEnd');
              } else {
                return;
              }
            }
            if (this.settings.duration === 0) {
              this._p = 1;
            } else if (this.settings.duration > 0) {
              this._p += dt / this.settings.duration;
            }
            if (this._p >= 1) {
              // Finished!;
              if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
                if (this._repeatsLeft > 0) {
                  this._repeatsLeft--;
                }
                this._p = this.settings.repeatOffset;
                this.emit('progress', this._p);
                if (this.settings.repeatDelay) {
                  this._delayLeft = this.settings.repeatDelay;
                }
                this.emit('repeat', this._repeatsLeft);
              } else {
                this._p = 1;
                this.emit('progress', this._p);
                this._state = Animation.STATES.FINISHED;
                this.emit('finish');
                if (this.settings.autostop) {
                  this.stop();
                }
              }
            } else {
              this.emit('progress', this._p);
            }
          }
          _stopProgress(dt) {
            var duration = this._getStopDuration();
            if (this._stopDelayLeft > 0) {
              this._stopDelayLeft -= dt;
              if (this._stopDelayLeft < 0) {
                dt = -this._stopDelayLeft;
                this._stopDelayLeft = 0;
                this.emit('stopDelayEnd');
              } else {
                return;
              }
            }
            if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.IMMEDIATE) {
              this._state = Animation.STATES.STOPPED;
              this.emit('stopFinish');
            } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
              if (duration === 0) {
                this._p = 0;
              } else if (duration > 0) {
                this._p -= dt / duration;
              }
              if (this._p <= 0) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
              }
            } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FADE) {
              this._progressStopTransition(dt);
              if (this._stopP >= 1) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
              }
            } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.ONETOTWO) {
              if (this._p < 2) {
                if (duration === 0) {
                  this._p = 2;
                } else if (duration > 0) {
                  if (this._p < 1) {
                    this._p += dt / this.settings.duration;
                  } else {
                    this._p += dt / duration;
                  }
                }
                if (this._p >= 2) {
                  this._p = 2;
                  this._state = Animation.STATES.STOPPED;
                  this.emit('stopFinish');
                } else {
                  this.emit('progress', this._p);
                }
              }
            } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
              if (this._p < 1) {
                if (this.settings.duration == 0) {
                  this._p = 1;
                } else {
                  this._p += dt / this.settings.duration;
                }
                if (this._p >= 1) {
                  if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
                    this._p = 1;
                    this._state = Animation.STATES.STOPPED;
                    this.emit('stopFinish');
                  } else {
                    if (this._repeatsLeft > 0) {
                      this._repeatsLeft--;
                      this._p = 0;
                      this.emit('repeat', this._repeatsLeft);
                    } else {
                      this._p = 1;
                      this._state = Animation.STATES.STOPPED;
                      this.emit('stopFinish');
                    }
                  }
                } else {
                  this.emit('progress', this._p);
                }
              }
            }
          }
          _progressStopTransition(dt) {
            if (this._stopP < 1) {
              if (this._stopDelayLeft > 0) {
                this._stopDelayLeft -= dt;
                if (this._stopDelayLeft < 0) {
                  dt = -this._stopDelayLeft;
                  this._stopDelayLeft = 0;
                  this.emit('delayEnd');
                } else {
                  return;
                }
              }
              var duration = this._getStopDuration();
              if (duration == 0) {
                this._stopP = 1;
              } else {
                this._stopP += dt / duration;
              }
              if (this._stopP >= 1) {
                // Finished!;
                this._stopP = 1;
              }
            }
          }
          _getStopDuration() {
            return this.settings.stopDuration || this.settings.duration;
          }
          apply() {
            if (this._state === Animation.STATES.STOPPED) {
              this.reset();
            } else {
              var factor = 1;
              if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
                factor = 1 - this.settings.stopTimingFunctionImpl(this._stopP);
              }
              this._settings.apply(this._element, this._p, factor);
            }
          }
          reset() {
            this._settings.reset(this._element);
          }
          get state() {
            return this._state;
          }
          get p() {
            return this._p;
          }
          get delayLeft() {
            return this._delayLeft;
          }
          get element() {
            return this._element;
          }
          get frame() {
            return Math.round(this._p * this._settings.duration * 60);
          }
          get settings() {
            return this._settings;
          }
        }
        Animation.STATES = {
          IDLE: 0,
          PLAYING: 1,
          STOPPING: 2,
          STOPPED: 3,
          FINISHED: 4,
          PAUSED: 5
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class AnimationManager {
          constructor(stage) {
            this.stage = stage;
            this.stage.on('frameStart', () => this.progress());

            /**
             * All running animations on attached subjects.
             * @type {Set<Animation>}
             */
            this.active = new Set();
          }
          progress() {
            if (this.active.size) {
              var dt = this.stage.dt;
              var filter = false;
              this.active.forEach(function (a) {
                if (a.isActive()) {
                  a.progress(dt);
                } else {
                  filter = true;
                }
              });
              if (filter) {
                this.active = new Set([...this.active].filter(t => t.isActive()));
              }
            }
          }
          createAnimation(element, settings) {
            if (Utils$2.isObjectLiteral(settings)) {
              // Convert plain object to proper settings object.
              settings = this.createSettings(settings);
            }
            return new Animation(this, settings, element);
          }
          createSettings(settings) {
            var animationSettings = new AnimationSettings();
            Base.patchObject(animationSettings, settings);
            return animationSettings;
          }
          addActive(transition) {
            this.active.add(transition);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class RectangleTexture extends Texture {
          _getLookupId() {
            return '__whitepix';
          }
          _getSourceLoader() {
            return function (cb) {
              var whitePixel = new Uint8Array([255, 255, 255, 255]);
              cb(null, {
                source: whitePixel,
                w: 1,
                h: 1,
                permanent: true
              });
            };
          }
          isAutosizeTexture() {
            return false;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Stage extends EventEmitter {
          constructor() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            super();
            this._setOptions(options);
            this._usedMemory = 0;
            this._lastGcFrame = 0;

            // attempt to track VRAM usage more accurately by accounting for different color channels
            this._usedVramAlpha = 0;
            this._usedVramNonAlpha = 0;
            var platformType = Stage.platform ? Stage.platform : PlatformLoader.load(options);
            this.platform = new platformType();
            if (this.platform.init) {
              this.platform.init(this);
            }
            this.gl = null;
            this.c2d = null;
            var context = this.getOption('context');
            if (context) {
              if (context.useProgram) {
                this.gl = context;
              } else {
                this.c2d = context;
              }
            } else {
              if (Utils$2.isWeb && (!Stage.isWebglSupported() || this.getOption('canvas2d'))) {
                this.c2d = this.platform.createCanvasContext(this.getOption('w'), this.getOption('h'));
              } else {
                this.gl = this.platform.createWebGLContext(this.getOption('w'), this.getOption('h'));
              }
            }
            if (this.gl) {
              // Wrap in WebGLStateManager.
              // This prevents unnecessary double WebGL commands from being executed, and allows context switching.
              // Context switching is necessary when reusing the same context for Three.js.
              // Note that the user must make sure that the WebGL context is untouched before creating the application,
              //  when manually passing over a canvas or context in the options.
              WebGLStateManager.enable(this.gl, "lightning");
            }
            this._mode = this.gl ? 0 : 1;

            // Override width and height.
            if (this.getCanvas()) {
              this._options.w = this.getCanvas().width;
              this._options.h = this.getCanvas().height;
            }
            if (this._mode === 0) {
              if (Utils$2.isSpark) {
                this._renderer = new SparkRenderer(this);
              } else {
                this._renderer = new WebGLRenderer(this);
              }
            } else {
              this._renderer = new C2dRenderer(this);
            }
            this.setClearColor(this.getOption('clearColor'));
            this.frameCounter = 0;
            this.transitions = new TransitionManager(this);
            this.animations = new AnimationManager(this);
            this.textureManager = new TextureManager(this);
            this.textureThrottler = new TextureThrottler(this);
            this.startTime = 0;
            this.currentTime = 0;
            this.dt = 0;

            // Preload rectangle texture, so that we can skip some border checks for loading textures.
            this.rectangleTexture = new RectangleTexture(this);
            this.rectangleTexture.load();

            // Never clean up because we use it all the time.
            this.rectangleTexture.source.permanent = true;
            this.ctx = new CoreContext(this);
            this._updateSourceTextures = new Set();
          }
          get renderer() {
            return this._renderer;
          }
          static isWebglSupported() {
            if (Utils$2.isNode) {
              return true;
            }
            try {
              return !!window.WebGLRenderingContext;
            } catch (e) {
              return false;
            }
          }

          /**
           * Returns the rendering mode.
           * @returns {number}
           *  0: WebGL
           *  1: Canvas2d
           */
          get mode() {
            return this._mode;
          }
          isWebgl() {
            return this.mode === 0;
          }
          isC2d() {
            return this.mode === 1;
          }
          getOption(name) {
            return this._options[name];
          }
          _setOptions(o) {
            this._options = {};
            var opt = (name, def) => {
              var value = o[name];
              if (value === undefined) {
                this._options[name] = def;
              } else {
                this._options[name] = value;
              }
            };
            opt('canvas', null);
            opt('context', null);
            opt('w', 1920);
            opt('h', 1080);
            opt('srcBasePath', null);
            opt('memoryPressure', 24e6);
            opt('bufferMemory', 2e6);
            opt('textRenderIssueMargin', 0);
            opt('fontSharp', {
              precision: 0.6666666667,
              fontSize: 24
            });
            opt('clearColor', [0, 0, 0, 0]);
            opt('defaultFontFace', 'sans-serif');
            opt('fixedDt', 0);
            opt('useImageWorker', true);
            opt('autostart', true);
            opt('precision', 1);
            opt('canvas2d', false);
            opt('platform', null);
            opt('readPixelsBeforeDraw', false);
            opt('readPixelsAfterDraw', false);
            opt('readPixelsAfterDrawThreshold', 0);
            opt('debugFrame', false);
            opt('forceTxCanvasSource', false);
            opt('pauseRafLoopOnIdle', false);
          }
          setApplication(app) {
            this.application = app;
          }
          init() {
            if (this.application.getOption('debug') && this.platform._imageWorker) {
              console.log('[Lightning] Using image worker!');
            }
            if (this.application.getOption('debug') && this.c2d) {
              console.log('[Lightning] Using canvas2d renderer');
            }
            this.application.setAsRoot();
            if (this.getOption('autostart')) {
              this.platform.startLoop();
            }
          }
          destroy() {
            this.platform.stopLoop();
            this.platform.destroy();
            this.ctx.destroy();
            this.textureManager.destroy();
            this._renderer.destroy();
          }
          stop() {
            this.platform.stopLoop();
          }
          resume() {
            this.platform.startLoop();
          }
          get root() {
            return this.application;
          }
          getCanvas() {
            return this._mode ? this.c2d.canvas : this.gl.canvas;
          }
          getRenderPrecision() {
            return this._options.precision;
          }

          /**
           * Marks a texture for updating it's source upon the next drawFrame.
           * @param texture
           */
          addUpdateSourceTexture(texture) {
            if (this._updatingFrame) {
              // When called from the upload loop, we must immediately load the texture in order to avoid a 'flash'.
              texture._performUpdateSource();
            } else {
              this._updateSourceTextures.add(texture);
            }
          }
          removeUpdateSourceTexture(texture) {
            if (this._updateSourceTextures) {
              this._updateSourceTextures.delete(texture);
            }
          }
          hasUpdateSourceTexture(texture) {
            return this._updateSourceTextures && this._updateSourceTextures.has(texture);
          }
          _performUpdateSource() {
            if (this._updateSourceTextures.size) {
              this._updateSourceTextures.forEach(texture => {
                texture._performUpdateSource();
              });
              this._updateSourceTextures = new Set();
            }
          }
          _calculateDt() {
            this.startTime = this.currentTime;
            this.currentTime = this.platform.getHrTime();
            if (this._options.fixedDt) {
              this.dt = this._options.fixedDt;
            } else {
              this.dt = !this.startTime ? .02 : .001 * (this.currentTime - this.startTime);
            }
          }
          updateFrame() {
            this._calculateDt();
            this.emit('frameStart');
            this._performUpdateSource();
            this.emit('update');
          }
          idleFrame() {
            this.textureThrottler.processSome();
            this.emit('frameEnd');
            this.frameCounter++;
          }
          renderFrame() {
            var changes = this.ctx.hasRenderUpdates();

            // Update may cause textures to be loaded in sync, so by processing them here we may be able to show them
            // during the current frame already.
            this.textureThrottler.processSome();
            if (changes) {
              this._updatingFrame = true;
              this.ctx.update();
              this.ctx.render();
              this._updatingFrame = false;
            }
            this.platform.nextFrame(changes);
            this.emit('frameEnd');
            this.frameCounter++;
          }
          isUpdatingFrame() {
            return this._updatingFrame;
          }
          drawFrame() {
            // Maintain original functionality of `drawFrame()` while retaining the
            // RAF mitigration feature from: https://github.com/rdkcentral/Lightning/pull/402
            // The full functionality of this method is relied directly by our own unit tests and
            // the unit tests of third party users
            this.updateFrame();
            this.renderFrame();
          }
          forceRenderUpdate() {
            // Enforce re-rendering.
            if (this.root) {
              this.root.core._parent.setHasRenderUpdates(1);
            }
          }
          setClearColor(clearColor) {
            this.forceRenderUpdate();
            if (clearColor === null) {
              // Do not clear.
              this._clearColor = null;
            } else if (Array.isArray(clearColor)) {
              this._clearColor = clearColor;
            } else {
              this._clearColor = StageUtils.getRgbaComponentsNormalized(clearColor);
            }
          }
          getClearColor() {
            return this._clearColor;
          }
          createElement(settings) {
            if (settings) {
              return this.element(settings);
            } else {
              return new Element$1(this);
            }
          }
          createShader(settings) {
            return Shader.create(this, settings);
          }
          element(settings) {
            if (settings.isElement) return settings;
            var element;
            if (settings.type) {
              element = new settings.type(this);
            } else {
              element = new Element$1(this);
            }
            element.patch(settings);
            return element;
          }
          c(settings) {
            return this.element(settings);
          }
          get w() {
            return this._options.w;
          }
          get h() {
            return this._options.h;
          }
          get coordsWidth() {
            return this.w / this._options.precision;
          }
          get coordsHeight() {
            return this.h / this._options.precision;
          }
          addMemoryUsage(delta) {
            this._usedMemory += delta;
            if (this._lastGcFrame !== this.frameCounter) {
              if (this._usedMemory > this.getOption('memoryPressure')) {
                this.gc(false);
                if (this._usedMemory > this.getOption('memoryPressure') - 2e6) {
                  // Too few released. Aggressive cleanup.
                  this.gc(true);
                }
              }
            }
          }
          get usedMemory() {
            return this._usedMemory;
          }
          addVramUsage(delta, alpha) {
            if (alpha) {
              this._usedVramAlpha += delta;
            } else {
              this._usedVramNonAlpha += delta;
            }
          }
          get usedVramAlpha() {
            return this._usedVramAlpha;
          }
          get usedVramNonAlpha() {
            return this._usedVramNonAlpha;
          }
          get usedVram() {
            return this._usedVramAlpha + this._usedVramNonAlpha;
          }
          gc(aggressive) {
            if (this._lastGcFrame !== this.frameCounter) {
              this._lastGcFrame = this.frameCounter;
              var memoryUsageBefore = this._usedMemory;
              this.gcTextureMemory(aggressive);
              this.gcRenderTextureMemory(aggressive);
              this.renderer.gc(aggressive);
              if (this.application.getOption('debug')) {
                console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
                var other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
                console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
              }
            }
          }
          gcTextureMemory() {
            var aggressive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (aggressive && this.ctx.root.visible) {
              // Make sure that ALL textures are cleaned;
              this.ctx.root.visible = false;
              this.textureManager.gc();
              this.ctx.root.visible = true;
            } else {
              this.textureManager.gc();
            }
          }
          gcRenderTextureMemory() {
            var aggressive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (aggressive && this.root.visible) {
              // Make sure that ALL render textures are cleaned;
              this.root.visible = false;
              this.ctx.freeUnusedRenderTextures(0);
              this.root.visible = true;
            } else {
              this.ctx.freeUnusedRenderTextures(0);
            }
          }
          getDrawingCanvas() {
            return this.platform.getDrawingCanvas();
          }
          update() {
            this.ctx.update();
          }
          addServiceProvider(serviceprovider) {
            if (Utils$2.isSpark) {
              this.platform.addServiceProvider(serviceprovider);
            }
          }
          getChildrenByPosition(x, y) {
            var children = [];
            this.root.core.update();
            this.root.core.collectAtCoord(x, y, children);
            return children;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Application$1 = class Application extends Component {
          constructor() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var properties = arguments.length > 1 ? arguments[1] : undefined;
            // Save options temporarily to avoid having to pass it through the constructor.
            Application._temp_options = options;

            // Booting flag is used to postpone updateFocusSettings;
            Application.booting = true;
            var stage = new Stage(options.stage);
            super(stage, properties);
            Application.booting = false;
            this.__updateFocusCounter = 0;
            this.__keypressTimers = new Map();
            this.__hoveredChild = null;

            // We must construct while the application is not yet attached.
            // That's why we 'init' the stage later (which actually emits the attach event).
            this.stage.init();

            // Initially, the focus settings are updated after both the stage and application are constructed.
            this.updateFocusSettings();
            this.__keymap = this.getOption('keys');
            if (this.__keymap) {
              this.stage.platform.registerKeydownHandler(e => {
                this._receiveKeydown(e);
              });
              this.stage.platform.registerKeyupHandler(e => {
                this._receiveKeyup(e);
              });
            }
            if (this.getOption("enablePointer")) {
              this.stage.platform.registerClickHandler(e => {
                this._receiveClick(e);
              });
              this.stage.platform.registerHoverHandler(e => {
                this._receiveHover(e);
              });
              this.stage.platform.registerScrollWheelHandler(e => {
                this._recieveScrollWheel(e);
              });
              this.cursor = 'default';
            }
          }
          getOption(name) {
            return this.__options[name];
          }
          _setOptions(o) {
            this.__options = {};
            var opt = (name, def) => {
              var value = o[name];
              if (value === undefined) {
                this.__options[name] = def;
              } else {
                this.__options[name] = value;
              }
            };
            opt('debug', false);
            opt('keys', {
              38: "Up",
              40: "Down",
              37: "Left",
              39: "Right",
              13: "Enter",
              8: "Back",
              27: "Exit"
            });
            opt('enablePointer', false);
          }
          __construct() {
            this.stage.setApplication(this);
            this._setOptions(Application._temp_options);
            delete Application._temp_options;
            super.__construct();
          }
          __init() {
            super.__init();
            this.__updateFocus();
          }
          updateFocusPath() {
            this.__updateFocus();
          }
          __updateFocus() {
            var notOverridden = this.__updateFocusRec();
            if (!Application.booting && notOverridden) {
              this.updateFocusSettings();
            }
          }
          __updateFocusRec() {
            var updateFocusId = ++this.__updateFocusCounter;
            this.__updateFocusId = updateFocusId;
            var newFocusPath = this.__getFocusPath();
            var newFocusedComponent = newFocusPath[newFocusPath.length - 1];
            var prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : undefined;
            if (!prevFocusedComponent) {
              // Focus events.
              this._focusPath = [];
              for (var i = 0, n = newFocusPath.length; i < n; i++) {
                this._focusPath.push(newFocusPath[i]);
                this._focusPath[i]._focus(newFocusedComponent, undefined);
                var focusOverridden = this.__updateFocusId !== updateFocusId;
                if (focusOverridden) {
                  return false;
                }
              }
              return true;
            } else {
              var m = Math.min(this._focusPath.length, newFocusPath.length);
              var index;
              for (index = 0; index < m; index++) {
                if (this._focusPath[index] !== newFocusPath[index]) {
                  break;
                }
              }
              if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {
                if (this.getOption('debug')) {
                  console.log('[Lightning] Focus changed: ' + newFocusedComponent.getLocationString());
                }

                // Unfocus events.
                for (var _i17 = this._focusPath.length - 1; _i17 >= index; _i17--) {
                  var unfocusedElement = this._focusPath.pop();
                  unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
                  var _focusOverridden = this.__updateFocusId !== updateFocusId;
                  if (_focusOverridden) {
                    return false;
                  }
                }

                // Focus events.
                for (var _i18 = index, _n14 = newFocusPath.length; _i18 < _n14; _i18++) {
                  this._focusPath.push(newFocusPath[_i18]);
                  this._focusPath[_i18]._focus(newFocusedComponent, prevFocusedComponent);
                  var _focusOverridden2 = this.__updateFocusId !== updateFocusId;
                  if (_focusOverridden2) {
                    return false;
                  }
                }

                // Focus changed events.
                for (var _i19 = 0; _i19 < index; _i19++) {
                  this._focusPath[_i19]._focusChange(newFocusedComponent, prevFocusedComponent);
                }
              }
            }
            return true;
          }
          updateFocusSettings() {
            var focusedComponent = this._focusPath[this._focusPath.length - 1];

            // Get focus settings. These can be used for dynamic application-wide settings that depend on the
            // focus directly (such as the application background).
            var focusSettings = {};
            var defaultSetFocusSettings = Component.prototype._setFocusSettings;
            for (var i = 0, n = this._focusPath.length; i < n; i++) {
              if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
                this._focusPath[i]._setFocusSettings(focusSettings);
              }
            }
            var defaultHandleFocusSettings = Component.prototype._handleFocusSettings;
            for (var _i20 = 0, _n15 = this._focusPath.length; _i20 < _n15; _i20++) {
              if (this._focusPath[_i20]._handleFocusSettings !== defaultHandleFocusSettings) {
                this._focusPath[_i20]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
              }
            }
            this.__prevFocusSettings = focusSettings;
          }
          _handleFocusSettings(settings, prevSettings, focused, prevFocused) {
            // Override to handle focus-based settings.
          }
          __getFocusPath() {
            var path = [this];
            var current = this;
            do {
              var nextFocus = current._getFocused();
              if (!nextFocus || nextFocus === current) {
                // Found!;
                break;
              }
              var ptr = nextFocus.cparent;
              if (ptr === current) {
                path.push(nextFocus);
              } else {
                // Not an immediate child: include full path to descendant.
                var newParts = [nextFocus];
                do {
                  if (!ptr) {
                    current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
                  }
                  newParts.push(ptr);
                  ptr = ptr.cparent;
                } while (ptr !== current);

                // Add them reversed.
                for (var i = 0, n = newParts.length; i < n; i++) {
                  path.push(newParts[n - i - 1]);
                }
              }
              current = nextFocus;
            } while (true);
            return path;
          }
          get focusPath() {
            return this._focusPath;
          }

          /**
           * Injects an event in the state machines, top-down from application to focused component.
           */
          focusTopDownEvent(events) {
            var path = this.focusPath;
            var n = path.length;

            // Multiple events.
            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
              args[_key5 - 1] = arguments[_key5];
            }
            for (var i = 0; i < n; i++) {
              var event = path[i]._getMostSpecificHandledMember(events);
              if (event !== undefined) {
                var returnValue = path[i][event](...args);
                if (returnValue !== false) {
                  return true;
                }
              }
            }
            return false;
          }

          /**
           * Injects an event in the state machines, bottom-up from focused component to application.
           */
          focusBottomUpEvent(events) {
            var path = this.focusPath;
            var n = path.length;

            // Multiple events.
            for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {
              args[_key6 - 1] = arguments[_key6];
            }
            for (var i = n - 1; i >= 0; i--) {
              var event = path[i]._getMostSpecificHandledMember(events);
              if (event !== undefined) {
                var returnValue = path[i][event](...args);
                if (returnValue !== false) {
                  return true;
                }
              }
            }
            return false;
          }
          _receiveKeydown(e) {
            var obj = e;
            var key = this.__keymap[e.keyCode];
            var path = this.focusPath;
            var keys;
            if (key) {
              keys = Array.isArray(key) ? key : [key];
            }
            if (keys) {
              for (var i = 0, n = keys.length; i < n; i++) {
                var hasTimer = this.__keypressTimers.has(keys[i]);
                // prevent event from getting fired when the timeout is still active
                if (path[path.length - 1].longpress && hasTimer) {
                  return;
                }
                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
                  this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
                }
              }
            } else {
              if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
              }
            }
            this.updateFocusPath();
            var consumer = path[path.length - 1];
            if (keys && consumer.longpress) {
              for (var _i21 = 0, _n16 = keys.length; _i21 < _n16; _i21++) {
                this._startLongpressTimer(keys[_i21], consumer);
              }
            }
          }

          /**
           * Keyup listener
           * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
           *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
           *
           * @param e
           * @private
           */
          _receiveKeyup(e) {
            var obj = e;
            var key = this.__keymap[e.keyCode];
            var keys;
            if (key) {
              keys = Array.isArray(key) ? key : [key];
            }
            if (keys) {
              for (var i = 0, n = keys.length; i < n; i++) {
                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
                  this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
                }
              }
            } else {
              if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
              }
            }
            this.updateFocusPath();
            if (keys) {
              for (var _i22 = 0, _n17 = keys.length; _i22 < _n17; _i22++) {
                if (this.__keypressTimers.has(keys[_i22])) {
                  // keyup has fired before end of timeout so we clear it
                  clearTimeout(this.__keypressTimers.get(keys[_i22]));
                  // delete so we can register it again
                  this.__keypressTimers.delete(keys[_i22]);
                }
              }
            }
          }

          /**
           * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
           * before the timer goes off.
           *
           * If key is not release (keyup) the longpress handler will be fired.
           * Configuration can be via the Components template:
           *
           * static _template() {
           *     return {
           *         w:100, h:100,
           *         longpress:{up:700, down:500}
           *     }
           * }     *
           * // this will get called when up has been pressed for 700ms
           * _handleUpLong() {
           *
           * }
           *
           * @param key
           * @param element
           * @private
           */
          _startLongpressTimer(key, element) {
            var config = element.longpress;
            var lookup = key.toLowerCase();
            if (config[lookup]) {
              var _timeout = config[lookup];
              if (!Utils$2.isNumber(_timeout)) {
                element._throwError("config value for longpress must be a number");
              } else {
                this.__keypressTimers.set(key, setTimeout(() => {
                  if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                    this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
                  }
                  this.__keypressTimers.delete(key);
                }, _timeout || 500 /* prevent 0ms */));
              }
            }

            return;
          }
          _recieveScrollWheel(e) {
            var obj = e;
            var clientX = obj.clientX,
              clientY = obj.clientY;
            if (clientX <= this.stage.w && clientY <= this.stage.h) {
              if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
                this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
              }
            }
          }
          fireTopDownScrollWheelHandler(event, obj) {
            var children = this.stage.application.children;
            var affected = this._findChildren([], children).reverse();
            var n = affected.length;
            while (n--) {
              var child = affected[n];
              if (child && child[event]) {
                child._captureScroll(obj);
                return true;
              }
            }
            return false;
          }
          fireBottomUpScrollWheelHandler(event, obj) {
            var clientX = obj.clientX,
              clientY = obj.clientY;
            var target = this._getTargetChild(clientX, clientY);
            var child = target;

            // Search tree bottom up for a handler
            while (child !== null) {
              if (child && child[event]) {
                child._handleScroll(obj);
                return true;
              }
              child = child.parent;
            }
            return false;
          }
          _receiveClick(e) {
            var obj = e;
            var clientX = obj.clientX,
              clientY = obj.clientY;
            if (clientX <= this.stage.w && clientY <= this.stage.h) {
              this.stage.application.fireBottomUpClickHandler(obj);
            }
          }
          fireBottomUpClickHandler(obj) {
            var clientX = obj.clientX,
              clientY = obj.clientY;
            var target = this._getTargetChild(clientX, clientY);
            var child = target;

            // Search tree bottom up for a handler
            while (child !== null) {
              if (child && child["_handleClick"]) {
                child._handleClick(target);
                break;
              }
              child = child.parent;
            }
          }
          _receiveHover(e) {
            var obj = e;
            var clientX = obj.clientX,
              clientY = obj.clientY;
            if (clientX <= this.stage.w && clientY <= this.stage.h) {
              this.stage.application.fireBottomUpHoverHandler(obj);
            }
          }
          fireBottomUpHoverHandler(obj) {
            var clientX = obj.clientX,
              clientY = obj.clientY;
            var target = this._getTargetChild(clientX, clientY);

            // Only fire handlers when pointer target changes
            if (target !== this.__hoveredChild) {
              var hoveredBranch = new Set();
              var newHoveredBranch = new Set();
              if (target) {
                newHoveredBranch = new Set(target.getAncestors());
              }
              if (this.__hoveredChild) {
                hoveredBranch = new Set(this.__hoveredChild.getAncestors());
                var _iterator21 = _createForOfIteratorHelper([...hoveredBranch].filter(e => !newHoveredBranch.has(e))),
                  _step21;
                try {
                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                    var elem = _step21.value;
                    var c = Component.getComponent(elem);
                    if (c["_handleUnhover"]) {
                      c._handleUnhover(elem);
                    }
                    if (elem.parent && elem.parent.cursor) {
                      this.stage.getCanvas().style.cursor = elem.parent.cursor;
                    }
                  }
                } catch (err) {
                  _iterator21.e(err);
                } finally {
                  _iterator21.f();
                }
              }
              this.__hoveredChild = target;
              var diffBranch = [...newHoveredBranch].filter(e => !hoveredBranch.has(e));
              var _iterator22 = _createForOfIteratorHelper(diffBranch),
                _step22;
              try {
                for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                  var _elem = _step22.value;
                  var _c2 = Component.getComponent(_elem);
                  if (_c2["_handleHover"]) {
                    _c2._handleHover(_elem);
                  }
                }

                // New element hover cursor
              } catch (err) {
                _iterator22.e(err);
              } finally {
                _iterator22.f();
              }
              var lastElement = diffBranch[0];
              if (lastElement && lastElement.cursor) {
                this.stage.getCanvas().style.cursor = lastElement.cursor;
              }

              // Rerun _handleHover for target element in case it's been hovered
              // back from its child
              if (diffBranch.length === 0 && target) {
                var _c = Component.getComponent(target);
                if (_c["_handleHover"]) {
                  _c._handleHover(target);
                }
              }
            }
          }
          _getTargetChild(clientX, clientY) {
            var children = this.stage.application.children;
            var affected = this._findChildren([], children);
            var hoverableChildren = this._withinClickableRange(affected, clientX, clientY);
            hoverableChildren.sort((a, b) => {
              // Sort by zIndex and then id
              if (a.zIndex > b.zIndex) {
                return 1;
              } else if (a.zIndex < b.zIndex) {
                return -1;
              } else {
                return a.id > b.id ? 1 : -1;
              }
            });
            if (hoverableChildren.length) {
              // Assume target has highest zIndex (id when zIndex equal)
              return hoverableChildren.slice(-1)[0];
            } else {
              return null;
            }
          }
          _findChildren(bucket, children) {
            var n = children.length;
            while (n--) {
              var child = children[n];
              // only add active children
              if (child.__active && child.collision) {
                if (child.collision === true) {
                  bucket.push(child);
                }
                if (child.hasChildren()) {
                  this._findChildren(bucket, child.children);
                }
              }
            }
            return bucket;
          }
          _withinClickableRange(affectedChildren, cursorX, cursorY) {
            var _this2 = this;
            var n = affectedChildren.length;
            var candidates = [];

            // loop through affected children
            // and perform collision detection
            var _loop4 = function _loop4() {
              var child = affectedChildren[n];
              var precision = _this2.stage.getRenderPrecision();
              var ctx = child.core._worldContext;
              var cx = ctx.px * precision;
              var cy = ctx.py * precision;
              var cw = child.finalW * ctx.ta * precision;
              var ch = child.finalH * ctx.td * precision;
              if (cx > _this2.stage.w || cy > _this2.stage.h) {
                return "continue";
              }
              if (child.parent.core._scissor) {
                var scissor = child.parent.core._scissor.map(v => v * precision);
                if (!_this2._testCollision(cursorX, cursorY, ...scissor)) return "continue";
              }
              if (_this2._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
                candidates.push(child);
              }
            };
            while (n--) {
              var _ret2 = _loop4();
              if (_ret2 === "continue") continue;
            }
            return candidates;
          }
          _testCollision(px, py, cx, cy, cw, ch) {
            if (px >= cx && px <= cx + cw && py >= cy && py <= cy + ch) {
              return true;
            }
            return false;
          }
          destroy() {
            if (!this._destroyed) {
              this._destroy();
              this.stage.destroy();
              this._destroyed = true;
            }
          }
          _destroy() {
            // This forces the _detach, _disabled and _active events to be called.
            this.stage.setApplication(undefined);
            this._updateAttachedFlag();
            this._updateEnabledFlag();
            if (this.__keypressTimers.size) {
              var _iterator23 = _createForOfIteratorHelper(this.__keypressTimers.values()),
                _step23;
              try {
                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                  var timer = _step23.value;
                  clearTimeout(timer);
                }
              } catch (err) {
                _iterator23.e(err);
              } finally {
                _iterator23.f();
              }
              this.__keypressTimers.clear();
            }
          }
          getCanvas() {
            return this.stage.getCanvas();
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class StaticCanvasTexture extends Texture {
          constructor(stage) {
            super(stage);
            this._factory = undefined;
            this._lookupId = undefined;
          }
          set content(_ref8) {
            var factory = _ref8.factory,
              _ref8$lookupId = _ref8.lookupId,
              lookupId = _ref8$lookupId === void 0 ? undefined : _ref8$lookupId;
            this._factory = factory;
            this._lookupId = lookupId;
            this._changed();
          }
          _getIsValid() {
            return !!this._factory;
          }
          _getLookupId() {
            return this._lookupId;
          }
          _getSourceLoader() {
            var f = this._factory;
            return cb => {
              return f((err, canvas) => {
                if (err) {
                  return cb(err);
                }
                cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
              }, this.stage);
            };
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Tools {
          static getCanvasTexture(canvasFactory, lookupId) {
            return {
              type: StaticCanvasTexture,
              content: {
                factory: canvasFactory,
                lookupId: lookupId
              }
            };
          }
          static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
            if (!Array.isArray(radius)) {
              // upper-left, upper-right, bottom-right, bottom-left.
              radius = [radius, radius, radius, radius];
            }
            var factory = (cb, stage) => {
              if (Utils$2.isSpark) {
                stage.platform.createRoundRect(cb, stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
              } else {
                cb(null, this.createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
              }
            };
            var id = 'rect' + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
            return Tools.getCanvasTexture(factory, id);
          }
          static createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
            if (fill === undefined) fill = true;
            if (strokeWidth === undefined) strokeWidth = 0;
            var canvas = stage.platform.getDrawingCanvas();
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            canvas.width = w + strokeWidth + 2;
            canvas.height = h + strokeWidth + 2;
            ctx.beginPath();
            var x = 0.5 * strokeWidth + 1,
              y = 0.5 * strokeWidth + 1;
            ctx.moveTo(x + radius[0], y);
            ctx.lineTo(x + w - radius[1], y);
            ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
            ctx.lineTo(x + w, y + h - radius[2]);
            ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
            ctx.lineTo(x + radius[3], y + h);
            ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
            ctx.lineTo(x, y + radius[0]);
            ctx.arcTo(x, y, x + radius[0], y, radius[0]);
            ctx.closePath();
            if (fill) {
              if (Utils$2.isNumber(fillColor)) {
                ctx.fillStyle = StageUtils.getRgbaString(fillColor);
              } else {
                ctx.fillStyle = "white";
              }
              ctx.fill();
            }
            if (strokeWidth) {
              if (Utils$2.isNumber(strokeColor)) {
                ctx.strokeStyle = StageUtils.getRgbaString(strokeColor);
              } else {
                ctx.strokeStyle = "white";
              }
              ctx.lineWidth = strokeWidth;
              ctx.stroke();
            }
            return canvas;
          }
          static getShadowRect(w, h) {
            var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var blur = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
            var margin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : blur * 2;
            if (!Array.isArray(radius)) {
              // upper-left, upper-right, bottom-right, bottom-left.
              radius = [radius, radius, radius, radius];
            }
            var factory = (cb, stage) => {
              if (Utils$2.isSpark) {
                stage.platform.createShadowRect(cb, stage, w, h, radius, blur, margin);
              } else {
                cb(null, this.createShadowRect(stage, w, h, radius, blur, margin));
              }
            };
            var id = 'shadow' + [w, h, blur, margin].concat(radius).join(",");
            return Tools.getCanvasTexture(factory, id);
          }
          static createShadowRect(stage, w, h, radius, blur, margin) {
            var canvas = stage.platform.getDrawingCanvas();
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            canvas.width = w + margin * 2;
            canvas.height = h + margin * 2;

            // WpeWebKit bug: we experienced problems without this with shadows in noncompositedwebgl mode.
            ctx.globalAlpha = 0.01;
            ctx.fillRect(0, 0, 0.01, 0.01);
            ctx.globalAlpha = 1.0;
            ctx.shadowColor = StageUtils.getRgbaString(0xFFFFFFFF);
            ctx.fillStyle = StageUtils.getRgbaString(0xFFFFFFFF);
            ctx.shadowBlur = blur;
            ctx.shadowOffsetX = w + 10 + margin;
            ctx.shadowOffsetY = margin;
            ctx.beginPath();
            var x = -(w + 10);
            var y = 0;
            ctx.moveTo(x + radius[0], y);
            ctx.lineTo(x + w - radius[1], y);
            ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
            ctx.lineTo(x + w, y + h - radius[2]);
            ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
            ctx.lineTo(x + radius[3], y + h);
            ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
            ctx.lineTo(x, y + radius[0]);
            ctx.arcTo(x, y, x + radius[0], y, radius[0]);
            ctx.closePath();
            ctx.fill();
            return canvas;
          }
          static getSvgTexture(url, w, h) {
            var factory = (cb, stage) => {
              if (Utils$2.isSpark) {
                stage.platform.createSvg(cb, stage, url, w, h);
              } else {
                this.createSvg(cb, stage, url, w, h);
              }
            };
            var id = 'svg' + [w, h, url].join(",");
            return Tools.getCanvasTexture(factory, id);
          }
          static createSvg(cb, stage, url, w, h) {
            var canvas = stage.platform.getDrawingCanvas();
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            var img = new Image();
            img.onload = () => {
              canvas.width = w;
              canvas.height = h;
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              cb(null, canvas);
            };
            img.onError = err => {
              cb(err);
            };

            // On the PS4 platform setting the `crossOrigin` attribute on images
            // can cause CORS failures.
            if (!Utils$2.isPS4) {
              img.crossOrigin = "Anonymous";
            }
            img.src = url;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ObjMerger {
          static isMf(f) {
            return Utils$2.isFunction(f) && f.__mf;
          }
          static mf(f) {
            // Set as merge function.
            f.__mf = true;
            return f;
          }
          static merge(a, b) {
            var aks = Object.keys(a);
            var bks = Object.keys(b);
            if (!bks.length) {
              return a;
            }

            // Create index array for all elements.
            var ai = {};
            var bi = {};
            for (var i = 0, n = bks.length; i < n; i++) {
              var key = bks[i];
              ai[key] = -1;
              bi[key] = i;
            }
            for (var _i23 = 0, _n18 = aks.length; _i23 < _n18; _i23++) {
              var _key7 = aks[_i23];
              ai[_key7] = _i23;
              if (bi[_key7] === undefined) {
                bi[_key7] = -1;
              }
            }
            var aksl = aks.length;
            var result = {};
            for (var _i24 = 0, _n19 = bks.length; _i24 < _n19; _i24++) {
              var _key8 = bks[_i24];

              // Prepend all items in a that are not in b - before the now added b attribute.
              var aIndex = ai[_key8];
              var _curIndex = aIndex;
              while (--_curIndex >= 0) {
                var akey = aks[_curIndex];
                if (bi[akey] !== -1) {
                  // Already found? Stop processing.
                  // Not yet found but exists in b? Also stop processing: wait until we find it in b.
                  break;
                }
              }
              while (++_curIndex < aIndex) {
                var _akey = aks[_curIndex];
                result[_akey] = a[_akey];
              }
              var bv = b[_key8];
              var av = a[_key8];
              var r = void 0;
              if (this.isMf(bv)) {
                r = bv(av);
              } else {
                if (!Utils$2.isObjectLiteral(av) || !Utils$2.isObjectLiteral(bv)) {
                  r = bv;
                } else {
                  r = ObjMerger.merge(av, bv);
                }
              }

              // When marked as undefined, property is deleted.
              if (r !== undefined) {
                result[_key8] = r;
              }
            }

            // Append remaining final items in a.
            var curIndex = aksl;
            while (--curIndex >= 0) {
              var _akey2 = aks[curIndex];
              if (bi[_akey2] !== -1) {
                break;
              }
            }
            while (++curIndex < aksl) {
              var _akey3 = aks[curIndex];
              result[_akey3] = a[_akey3];
            }
            return result;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ObjectListProxy extends ObjectList {
          constructor(target) {
            super();
            this._target = target;
          }
          onAdd(item, index) {
            this._target.addAt(item, index);
          }
          onRemove(item, index) {
            this._target.removeAt(index);
          }
          onSync(removed, added, order) {
            this._target._setByArray(order);
          }
          onSet(item, index) {
            this._target.setAt(item, index);
          }
          onMove(item, fromIndex, toIndex) {
            this._target.setAt(item, toIndex);
          }
          createItem(object) {
            return this._target.createItem(object);
          }
          isItem(object) {
            return this._target.isItem(object);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ObjectListWrapper extends ObjectListProxy {
          constructor(target, wrap) {
            super(target);
            this._wrap = wrap;
          }
          wrap(item) {
            var wrapper = this._wrap(item);
            item._wrapper = wrapper;
            return wrapper;
          }
          onAdd(item, index) {
            item = this.wrap(item);
            super.onAdd(item, index);
          }
          onRemove(item, index) {
            super.onRemove(item, index);
          }
          onSync(removed, added, order) {
            added.forEach(a => this.wrap(a));
            order = order.map(a => a._wrapper);
            super.onSync(removed, added, order);
          }
          onSet(item, index) {
            item = this.wrap(item);
            super.onSet(item, index);
          }
          onMove(item, fromIndex, toIndex) {
            super.onMove(item, fromIndex, toIndex);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class NoiseTexture extends Texture {
          _getLookupId() {
            return '__noise';
          }
          _getSourceLoader() {
            var gl = this.stage.gl;
            return function (cb) {
              var noise = new Uint8Array(128 * 128 * 4);
              for (var i = 0; i < 128 * 128 * 4; i += 4) {
                var v = Math.floor(Math.random() * 256);
                noise[i] = v;
                noise[i + 1] = v;
                noise[i + 2] = v;
                noise[i + 3] = 255;
              }
              var texParams = {};
              if (gl) {
                texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
              }
              cb(null, {
                source: noise,
                w: 128,
                h: 128,
                texParams: texParams
              });
            };
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class HtmlTexture extends Texture {
          constructor(stage) {
            super(stage);
            this._htmlElement = undefined;
            this._scale = 1;
          }
          set htmlElement(v) {
            this._htmlElement = v;
            this._changed();
          }
          get htmlElement() {
            return this._htmlElement;
          }
          set scale(v) {
            this._scale = v;
            this._changed();
          }
          get scale() {
            return this._scale;
          }
          set html(v) {
            if (!v) {
              this.htmlElement = undefined;
            } else {
              var d = document.createElement('div');
              d.innerHTML = "<div>" + v + "</div>";
              this.htmlElement = d.firstElementChild;
            }
          }
          get html() {
            return this._htmlElement.innerHTML;
          }
          _getIsValid() {
            return this.htmlElement;
          }
          _getLookupId() {
            return this._scale + ":" + this._htmlElement.innerHTML;
          }
          _getSourceLoader() {
            var htmlElement = this._htmlElement;
            var scale = this._scale;
            return function (cb) {
              if (!window.html2canvas) {
                return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
              }
              var area = HtmlTexture.getPreloadArea();
              area.appendChild(htmlElement);
              html2canvas(htmlElement, {
                backgroundColor: null,
                scale: scale
              }).then(function (canvas) {
                area.removeChild(htmlElement);
                if (canvas.height === 0) {
                  return cb(new Error("Canvas height is 0"));
                }
                cb(null, {
                  source: canvas,
                  width: canvas.width,
                  height: canvas.height
                });
              }).catch(e => {
                console.error('[Lightning]', e);
              });
            };
          }
          static getPreloadArea() {
            if (!this._preloadArea) {
              // Preload area must be included in document body and must be visible to trigger html element rendering.
              this._preloadArea = document.createElement('div');
              if (this._preloadArea.attachShadow) {
                // Use a shadow DOM if possible to prevent styling from interfering.
                this._preloadArea.attachShadow({
                  mode: 'closed'
                });
              }
              this._preloadArea.style.opacity = 0;
              this._preloadArea.style.pointerEvents = 'none';
              this._preloadArea.style.position = 'fixed';
              this._preloadArea.style.display = 'block';
              this._preloadArea.style.top = '100vh';
              this._preloadArea.style.overflow = 'hidden';
              document.body.appendChild(this._preloadArea);
            }
            return this._preloadArea;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class StaticTexture extends Texture {
          constructor(stage, options) {
            super(stage);
            this._options = options;
          }
          set options(v) {
            if (this._options !== v) {
              this._options = v;
              this._changed();
            }
          }
          get options() {
            return this._options;
          }
          _getIsValid() {
            return !!this._options;
          }
          _getSourceLoader() {
            return cb => {
              cb(null, this._options);
            };
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ListComponent extends Component {
          constructor(stage) {
            super(stage);
            this._wrapper = super._children.a({});
            this._reloadVisibleElements = false;
            this._visibleItems = new Set();
            this._index = 0;
            this._started = false;

            /**
             * The transition definition that is being used when scrolling the items.
             * @type TransitionSettings
             */
            this._scrollTransitionSettings = this.stage.transitions.createSettings({});

            /**
             * The scroll area size in pixels per item.
             */
            this._itemSize = 100;
            this._viewportScrollOffset = 0;
            this._itemScrollOffset = 0;

            /**
             * Should the list jump when scrolling between end to start, or should it be continuous, like a carrousel?
             */
            this._roll = false;

            /**
             * Allows restricting the start scroll position.
             */
            this._rollMin = 0;

            /**
             * Allows restricting the end scroll position.
             */
            this._rollMax = 0;

            /**
             * Definition for a custom animation that is applied when an item is (partially) selected.
             * @type AnimationSettings
             */
            this._progressAnimation = null;

            /**
             * Inverts the scrolling direction.
             * @type {boolean}
             * @private
             */
            this._invertDirection = false;

            /**
             * Layout the items horizontally or vertically?
             * @type {boolean}
             * @private
             */
            this._horizontal = true;
            this.itemList = new ListItems(this);
          }
          _allowChildrenAccess() {
            return false;
          }
          get items() {
            return this.itemList.get();
          }
          set items(children) {
            this.itemList.patch(children);
          }
          start() {
            this._wrapper.transition(this.property, this._scrollTransitionSettings);
            this._scrollTransition = this._wrapper.transition(this.property);
            this._scrollTransition.on('progress', p => this.update());
            this.setIndex(0, true, true);
            this._started = true;
            this.update();
          }
          setIndex(index) {
            var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var closest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var nElements = this.length;
            if (!nElements) return;
            this.emit('unfocus', this.getElement(this.realIndex), this._index, this.realIndex);
            if (closest) {
              // Scroll to same offset closest to the index.
              var offset = Utils$2.getModuloIndex(index, nElements);
              var o = Utils$2.getModuloIndex(this.index, nElements);
              var diff = offset - o;
              if (diff > 0.5 * nElements) {
                diff -= nElements;
              } else if (diff < -0.5 * nElements) {
                diff += nElements;
              }
              this._index += diff;
            } else {
              this._index = index;
            }
            if (this._roll || this.viewportSize > this._itemSize * nElements) {
              this._index = Utils$2.getModuloIndex(this._index, nElements);
            }
            var direction = this._horizontal ^ this._invertDirection ? -1 : 1;
            var value = direction * this._index * this._itemSize;
            if (this._roll) {
              var min, max, scrollDelta;
              if (direction == 1) {
                max = (nElements - 1) * this._itemSize;
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
                max -= scrollDelta;
                min = this.viewportSize - (this._itemSize + scrollDelta);
                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;
                value = Math.max(Math.min(value, max), min);
              } else {
                max = nElements * this._itemSize - this.viewportSize;
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
                max += scrollDelta;
                var _min = scrollDelta;
                if (this._rollMin) _min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;
                value = Math.min(Math.max(-max, value), -_min);
              }
            }
            this._scrollTransition.start(value);
            if (immediate) {
              this._scrollTransition.finish();
            }
            this.emit('focus', this.getElement(this.realIndex), this._index, this.realIndex);
          }
          getAxisPosition() {
            var target = -this._scrollTransition._targetValue;
            var direction = this._horizontal ^ this._invertDirection ? -1 : 1;
            var value = -direction * this._index * this._itemSize;
            return this._viewportScrollOffset * this.viewportSize + (value - target);
          }
          update() {
            if (!this._started) return;
            var nElements = this.length;
            if (!nElements) return;
            var direction = this._horizontal ^ this._invertDirection ? -1 : 1;

            // Map position to index value.
            var v = this._horizontal ? this._wrapper.x : this._wrapper.y;
            var viewportSize = this.viewportSize;
            var scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
            v += scrollDelta;
            var s, e, ps, pe;
            if (direction == -1) {
              s = Math.floor(-v / this._itemSize);
              ps = 1 - (-v / this._itemSize - s);
              e = Math.floor((viewportSize - v) / this._itemSize);
              pe = (viewportSize - v) / this._itemSize - e;
            } else {
              s = Math.ceil(v / this._itemSize);
              ps = 1 + v / this._itemSize - s;
              e = Math.ceil((v - viewportSize) / this._itemSize);
              pe = e - (v - viewportSize) / this._itemSize;
            }
            if (this._roll || viewportSize > this._itemSize * nElements) {
              // Don't show additional items.
              if (e >= nElements) {
                e = nElements - 1;
                pe = 1;
              }
              if (s >= nElements) {
                s = nElements - 1;
                ps = 1;
              }
              if (e <= -1) {
                e = 0;
                pe = 1;
              }
              if (s <= -1) {
                s = 0;
                ps = 1;
              }
            }
            var offset = -direction * s * this._itemSize;
            var item;
            for (var index = s; direction == -1 ? index <= e : index >= e; direction == -1 ? index++ : index--) {
              var realIndex = Utils$2.getModuloIndex(index, nElements);
              var element = this.getElement(realIndex);
              item = element.parent;
              this._visibleItems.delete(item);
              if (this._horizontal) {
                item.x = offset + scrollDelta;
              } else {
                item.y = offset + scrollDelta;
              }
              var wasVisible = item.visible;
              item.visible = true;
              if (!wasVisible || this._reloadVisibleElements) {
                // Turned visible.
                this.emit('visible', index, realIndex);
              }
              if (this._progressAnimation) {
                var p = 1;
                if (index == s) {
                  p = ps;
                } else if (index == e) {
                  p = pe;
                }

                // Use animation to progress.
                this._progressAnimation.apply(element, p);
              }
              offset += this._itemSize;
            }

            // Handle item visibility.
            var self = this;
            this._visibleItems.forEach(function (invisibleItem) {
              invisibleItem.visible = false;
              self._visibleItems.delete(invisibleItem);
            });
            for (var _index = s; direction == -1 ? _index <= e : _index >= e; direction == -1 ? _index++ : _index--) {
              var _realIndex = Utils$2.getModuloIndex(_index, nElements);
              this._visibleItems.add(this.getWrapper(_realIndex));
            }
            this._reloadVisibleElements = false;
          }
          setPrevious() {
            this.setIndex(this._index - 1);
          }
          setNext() {
            this.setIndex(this._index + 1);
          }
          getWrapper(index) {
            return this._wrapper.children[index];
          }
          getElement(index) {
            var e = this._wrapper.children[index];
            return e ? e.children[0] : null;
          }
          reload() {
            this._reloadVisibleElements = true;
            this.update();
          }
          get element() {
            var e = this._wrapper.children[this.realIndex];
            return e ? e.children[0] : null;
          }
          get length() {
            return this._wrapper.children.length;
          }
          get property() {
            return this._horizontal ? 'x' : 'y';
          }
          get viewportSize() {
            return this._horizontal ? this.w : this.h;
          }
          get index() {
            return this._index;
          }
          get realIndex() {
            return Utils$2.getModuloIndex(this._index, this.length);
          }
          get itemSize() {
            return this._itemSize;
          }
          set itemSize(v) {
            this._itemSize = v;
            this.update();
          }
          get viewportScrollOffset() {
            return this._viewportScrollOffset;
          }
          set viewportScrollOffset(v) {
            this._viewportScrollOffset = v;
            this.update();
          }
          get itemScrollOffset() {
            return this._itemScrollOffset;
          }
          set itemScrollOffset(v) {
            this._itemScrollOffset = v;
            this.update();
          }
          get scrollTransitionSettings() {
            return this._scrollTransitionSettings;
          }
          set scrollTransitionSettings(v) {
            this._scrollTransitionSettings.patch(v);
          }
          set scrollTransition(v) {
            this._scrollTransitionSettings.patch(v);
          }
          get scrollTransition() {
            return this._scrollTransition;
          }
          get progressAnimation() {
            return this._progressAnimation;
          }
          set progressAnimation(v) {
            if (Utils$2.isObjectLiteral(v)) {
              this._progressAnimation = this.stage.animations.createSettings(v);
            } else {
              this._progressAnimation = v;
            }
            this.update();
          }
          get roll() {
            return this._roll;
          }
          set roll(v) {
            this._roll = v;
            this.update();
          }
          get rollMin() {
            return this._rollMin;
          }
          set rollMin(v) {
            this._rollMin = v;
            this.update();
          }
          get rollMax() {
            return this._rollMax;
          }
          set rollMax(v) {
            this._rollMax = v;
            this.update();
          }
          get invertDirection() {
            return this._invertDirection;
          }
          set invertDirection(v) {
            if (!this._started) {
              this._invertDirection = v;
            }
          }
          get horizontal() {
            return this._horizontal;
          }
          set horizontal(v) {
            if (v !== this._horizontal) {
              if (!this._started) {
                this._horizontal = v;
              }
            }
          }
        }
        class ListItems extends ObjectListWrapper {
          constructor(list) {
            var wrap = item => {
              var parent = item.stage.createElement();
              parent.add(item);
              parent.visible = false;
              return parent;
            };
            super(list._wrapper._children, wrap);
            this.list = list;
          }
          onAdd(item, index) {
            super.onAdd(item, index);
            this.checkStarted(index);
          }
          checkStarted(index) {
            this.list._reloadVisibleElements = true;
            if (!this.list._started) {
              this.list.start();
            } else {
              if (this.list.length === 1) {
                this.list.setIndex(0, true, true);
              } else {
                if (this.list._index >= this.list.length) {
                  this.list.setIndex(0);
                }
              }
              this.list.update();
            }
          }
          onRemove(item, index) {
            super.onRemove(item, index);
            var ri = this.list.realIndex;
            if (ri === index) {
              if (ri === this.list.length) {
                ri--;
              }
              if (ri >= 0) {
                this.list.setIndex(ri);
              }
            } else if (ri > index) {
              this.list.setIndex(ri - 1);
            }
            this.list._reloadVisibleElements = true;
          }
          onSet(item, index) {
            super.onSet(item, index);
            this.checkStarted(index);
          }
          onSync(removed, added, order) {
            super.onSync(removed, added, order);
            this.checkStarted(0);
          }
          get _signalProxy() {
            return true;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class LinearBlurShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._direction = new Float32Array([1, 0]);
            this._kernelRadius = 1;
          }
          get x() {
            return this._direction[0];
          }
          set x(v) {
            this._direction[0] = v;
            this.redraw();
          }
          get y() {
            return this._direction[1];
          }
          set y(v) {
            this._direction[1] = v;
            this.redraw();
          }
          get kernelRadius() {
            return this._kernelRadius;
          }
          set kernelRadius(v) {
            this._kernelRadius = v;
            this.redraw();
          }
          useDefault() {
            return this._kernelRadius === 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("direction", this._direction, this.gl.uniform2fv);
            this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);
            var w = operation.getRenderWidth();
            var h = operation.getRenderHeight();
            this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
          }
        }
        LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * 4x4 box blur shader which works in conjunction with a 50% rescale.
         */
        class BoxBlurShader extends DefaultShader$1 {
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var dx = 1.0 / operation.getTextureWidth(0);
            var dy = 1.0 / operation.getTextureHeight(0);
            this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
          }
        }
        BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class BlurShader extends DefaultShader {
          constructor(context) {
            super(context);
            this._kernelRadius = 1;
          }
          get kernelRadius() {
            return this._kernelRadius;
          }
          set kernelRadius(v) {
            this._kernelRadius = v;
            this.redraw();
          }
          useDefault() {
            return this._amount === 0;
          }
          _beforeDrawEl(_ref9) {
            var target = _ref9.target;
            target.ctx.filter = "blur(" + this._kernelRadius + "px)";
          }
          _afterDrawEl(_ref10) {
            var target = _ref10.target;
            target.ctx.filter = "none";
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class FastBlurComponent extends Component {
          static _template() {
            return {};
          }
          get wrap() {
            return this.tag("Wrap");
          }
          set content(v) {
            return this.wrap.content = v;
          }
          get content() {
            return this.wrap.content;
          }
          set padding(v) {
            this.wrap._paddingX = v;
            this.wrap._paddingY = v;
            this.wrap._updateBlurSize();
          }
          set paddingX(v) {
            this.wrap._paddingX = v;
            this.wrap._updateBlurSize();
          }
          set paddingY(v) {
            this.wrap._paddingY = v;
            this.wrap._updateBlurSize();
          }
          set amount(v) {
            return this.wrap.amount = v;
          }
          get amount() {
            return this.wrap.amount;
          }
          _onResize() {
            this.wrap.w = this.renderWidth;
            this.wrap.h = this.renderHeight;
          }
          get _signalProxy() {
            return true;
          }
          _build() {
            this.patch({
              Wrap: {
                type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent
              }
            });
          }
        }
        class C2dFastBlurComponent extends Component {
          static _template() {
            return {
              forceZIndexContext: true,
              rtt: true,
              Textwrap: {
                shader: {
                  type: BlurShader
                },
                Content: {}
              }
            };
          }
          constructor(stage) {
            super(stage);
            this._textwrap = this.sel("Textwrap");
            this._wrapper = this.sel("Textwrap>Content");
            this._amount = 0;
            this._paddingX = 0;
            this._paddingY = 0;
          }
          static getSpline() {
            if (!this._multiSpline) {
              this._multiSpline = new MultiSpline();
              this._multiSpline.parse(false, {
                0: 0,
                0.25: 1.5,
                0.5: 5.5,
                0.75: 18,
                1: 39
              });
            }
            return this._multiSpline;
          }
          get content() {
            return this.sel('Textwrap>Content');
          }
          set content(v) {
            this.sel('Textwrap>Content').patch(v, true);
          }
          set padding(v) {
            this._paddingX = v;
            this._paddingY = v;
            this._updateBlurSize();
          }
          set paddingX(v) {
            this._paddingX = v;
            this._updateBlurSize();
          }
          set paddingY(v) {
            this._paddingY = v;
            this._updateBlurSize();
          }
          _updateBlurSize() {
            var w = this.renderWidth;
            var h = this.renderHeight;
            var paddingX = this._paddingX;
            var paddingY = this._paddingY;
            this._wrapper.x = paddingX;
            this._textwrap.x = -paddingX;
            this._wrapper.y = paddingY;
            this._textwrap.y = -paddingY;
            this._textwrap.w = w + paddingX * 2;
            this._textwrap.h = h + paddingY * 2;
          }
          get amount() {
            return this._amount;
          }

          /**
           * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
           * Best results for non-fractional values.
           * @param v;
           */
          set amount(v) {
            this._amount = v;
            this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
          }
          static _amountToKernelRadius(v) {
            return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
          }
          get _signalProxy() {
            return true;
          }
        }
        class WebGLFastBlurComponent extends Component {
          static _template() {
            var onUpdate = function onUpdate(element, elementCore) {
              if (elementCore._recalc & 2 + 128) {
                var w = elementCore.w;
                var h = elementCore.h;
                var cur = elementCore;
                do {
                  cur = cur._children[0];
                  cur._element.w = w;
                  cur._element.h = h;
                } while (cur._children);
              }
            };
            return {
              Textwrap: {
                rtt: true,
                forceZIndexContext: true,
                renderOffscreen: true,
                Content: {}
              },
              Layers: {
                L0: {
                  rtt: true,
                  onUpdate: onUpdate,
                  renderOffscreen: true,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L1: {
                  rtt: true,
                  onUpdate: onUpdate,
                  renderOffscreen: true,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L2: {
                  rtt: true,
                  onUpdate: onUpdate,
                  renderOffscreen: true,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L3: {
                  rtt: true,
                  onUpdate: onUpdate,
                  renderOffscreen: true,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                }
              },
              Result: {
                shader: {
                  type: FastBlurOutputShader
                },
                visible: false
              }
            };
          }
          get _signalProxy() {
            return true;
          }
          constructor(stage) {
            super(stage);
            this._textwrap = this.sel("Textwrap");
            this._wrapper = this.sel("Textwrap>Content");
            this._layers = this.sel("Layers");
            this._output = this.sel("Result");
            this._amount = 0;
            this._paddingX = 0;
            this._paddingY = 0;
          }
          _buildLayers() {
            var filterShaderSettings = [{
              x: 1,
              y: 0,
              kernelRadius: 1
            }, {
              x: 0,
              y: 1,
              kernelRadius: 1
            }, {
              x: 1.5,
              y: 0,
              kernelRadius: 1
            }, {
              x: 0,
              y: 1.5,
              kernelRadius: 1
            }];
            var filterShaders = filterShaderSettings.map(s => {
              var shader = Shader.create(this.stage, Object.assign({
                type: LinearBlurShader
              }, s));
              return shader;
            });
            this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
            this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

            // Notice that 1.5 filters should be applied before 1.0 filters.
            this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
            this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
          }
          _setLayerTexture(element, texture, steps) {
            if (!steps.length) {
              element.texture = texture;
            } else {
              var _step24 = steps.pop();
              var child = element.stage.c({
                rtt: true,
                shader: _step24
              });

              // Recurse.
              this._setLayerTexture(child, texture, steps);
              element.childList.add(child);
            }
            return element;
          }
          get content() {
            return this.sel('Textwrap>Content');
          }
          set content(v) {
            this.sel('Textwrap>Content').patch(v, true);
          }
          set padding(v) {
            this._paddingX = v;
            this._paddingY = v;
            this._updateBlurSize();
          }
          set paddingX(v) {
            this._paddingX = v;
            this._updateBlurSize();
          }
          set paddingY(v) {
            this._paddingY = v;
            this._updateBlurSize();
          }
          getLayer(i) {
            return this._layers.sel("L" + i);
          }
          getLayerContents(i) {
            return this.getLayer(i).sel("Content");
          }
          _onResize() {
            this._updateBlurSize();
          }
          _updateBlurSize() {
            var w = this.renderWidth;
            var h = this.renderHeight;
            var paddingX = this._paddingX;
            var paddingY = this._paddingY;
            var fw = w + paddingX * 2;
            var fh = h + paddingY * 2;
            this._textwrap.w = fw;
            this._wrapper.x = paddingX;
            this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
            this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
            this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
            this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
            this._output.x = -paddingX;
            this._textwrap.x = -paddingX;
            this._output.w = fw;
            this._textwrap.h = fh;
            this._wrapper.y = paddingY;
            this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
            this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
            this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
            this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
            this._output.y = -paddingY;
            this._textwrap.y = -paddingY;
            this._output.h = fh;
            this.w = w;
            this.h = h;
          }

          /**
           * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
           * Best results for non-fractional values.
           * @param v;
           */
          set amount(v) {
            this._amount = v;
            this._update();
          }
          get amount() {
            return this._amount;
          }
          _update() {
            var v = Math.min(4, Math.max(0, this._amount));
            if (v === 0) {
              this._textwrap.renderToTexture = false;
              this._output.shader.otherTextureSource = null;
              this._output.visible = false;
            } else {
              this._textwrap.renderToTexture = true;
              this._output.visible = true;
              this.getLayer(0).visible = v > 0;
              this.getLayer(1).visible = v > 1;
              this.getLayer(2).visible = v > 2;
              this.getLayer(3).visible = v > 3;
              if (v <= 1) {
                this._output.texture = this._textwrap.getTexture();
                this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
                this._output.shader.a = v;
              } else if (v <= 2) {
                this._output.texture = this.getLayer(0).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
                this._output.shader.a = v - 1;
              } else if (v <= 3) {
                this._output.texture = this.getLayer(1).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
                this._output.shader.a = v - 2;
              } else if (v <= 4) {
                this._output.texture = this.getLayer(2).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
                this._output.shader.a = v - 3;
              }
            }
          }
          set shader(s) {
            super.shader = s;
            if (!this.renderToTexture) {
              console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
            }
          }
          _firstActive() {
            this._buildLayers();
          }
        }

        /**
         * Shader that combines two textures into one output.
         */
        class FastBlurOutputShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._a = 0;
            this._otherTextureSource = null;
          }
          get a() {
            return this._a;
          }
          set a(v) {
            this._a = v;
            this.redraw();
          }
          set otherTextureSource(v) {
            this._otherTextureSource = v;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("a", this._a, this.gl.uniform1f);
            this._setUniform("uSampler2", 1, this.gl.uniform1i);
          }
          beforeDraw(operation) {
            var glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;
            var gl = this.gl;
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.activeTexture(gl.TEXTURE0);
          }
        }
        FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class BloomComponent extends Component {
          static _template() {
            var onUpdate = function onUpdate(element, elementCore) {
              if (elementCore._recalc & 2 + 128) {
                var w = elementCore.w;
                var h = elementCore.h;
                var cur = elementCore;
                do {
                  cur = cur._children[0];
                  cur._element.w = w;
                  cur._element.h = h;
                } while (cur._children);
              }
            };
            return {
              Textwrap: {
                rtt: true,
                forceZIndexContext: true,
                renderOffscreen: true,
                BloomBase: {
                  shader: {
                    type: BloomBaseShader
                  },
                  Content: {}
                }
              },
              Layers: {
                L0: {
                  rtt: true,
                  onUpdate: onUpdate,
                  scale: 2,
                  pivot: 0,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L1: {
                  rtt: true,
                  onUpdate: onUpdate,
                  scale: 4,
                  pivot: 0,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L2: {
                  rtt: true,
                  onUpdate: onUpdate,
                  scale: 8,
                  pivot: 0,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                },
                L3: {
                  rtt: true,
                  onUpdate: onUpdate,
                  scale: 16,
                  pivot: 0,
                  visible: false,
                  Content: {
                    shader: {
                      type: BoxBlurShader
                    }
                  }
                }
              }
            };
          }
          get _signalProxy() {
            return true;
          }
          constructor(stage) {
            super(stage);
            this._textwrap = this.sel("Textwrap");
            this._wrapper = this.sel("Textwrap.Content");
            this._layers = this.sel("Layers");
            this._amount = 0;
            this._paddingX = 0;
            this._paddingY = 0;
          }
          _build() {
            var filterShaderSettings = [{
              x: 1,
              y: 0,
              kernelRadius: 3
            }, {
              x: 0,
              y: 1,
              kernelRadius: 3
            }, {
              x: 1.5,
              y: 0,
              kernelRadius: 3
            }, {
              x: 0,
              y: 1.5,
              kernelRadius: 3
            }];
            var filterShaders = filterShaderSettings.map(s => {
              var shader = this.stage.createShader(Object.assign({
                type: LinearBlurShader
              }, s));
              return shader;
            });
            this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
            this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

            // Notice that 1.5 filters should be applied before 1.0 filters.
            this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
            this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
          }
          _setLayerTexture(element, texture, steps) {
            if (!steps.length) {
              element.texture = texture;
            } else {
              var _step25 = steps.pop();
              var child = element.stage.c({
                rtt: true,
                shader: _step25
              });

              // Recurse.
              this._setLayerTexture(child, texture, steps);
              element.childList.add(child);
            }
            return element;
          }
          get content() {
            return this.sel('Textwrap.Content');
          }
          set content(v) {
            this.sel('Textwrap.Content').patch(v);
          }
          set padding(v) {
            this._paddingX = v;
            this._paddingY = v;
            this._updateBlurSize();
          }
          set paddingX(v) {
            this._paddingX = v;
            this._updateBlurSize();
          }
          set paddingY(v) {
            this._paddingY = v;
            this._updateBlurSize();
          }
          getLayer(i) {
            return this._layers.sel("L" + i);
          }
          getLayerContents(i) {
            return this.getLayer(i).sel("Content");
          }
          _onResize() {
            this._updateBlurSize();
          }
          _updateBlurSize() {
            var w = this.renderWidth;
            var h = this.renderHeight;
            var paddingX = this._paddingX;
            var paddingY = this._paddingY;
            var fw = w + paddingX * 2;
            var fh = h + paddingY * 2;
            this._textwrap.w = fw;
            this._wrapper.x = paddingX;
            this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
            this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
            this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
            this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
            this._textwrap.x = -paddingX;
            this._textwrap.h = fh;
            this._wrapper.y = paddingY;
            this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
            this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
            this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
            this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
            this._textwrap.y = -paddingY;
            this.w = w;
            this.h = h;
          }

          /**
           * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
           * Best results for non-fractional values.
           * @param v;
           */
          set amount(v) {
            this._amount = v;
            this._update();
          }
          get amount() {
            return this._amount;
          }
          _update() {
            var v = Math.min(4, Math.max(0, this._amount));
            if (v > 0) {
              this.getLayer(0).visible = v > 0;
              this.getLayer(1).visible = v > 1;
              this.getLayer(2).visible = v > 2;
              this.getLayer(3).visible = v > 3;
            }
          }
          set shader(s) {
            super.shader = s;
            if (!this.renderToTexture) {
              console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
            }
          }
          _firstActive() {
            this._build();
          }
        }
        class BloomBaseShader extends DefaultShader$1 {}
        BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SmoothScaleComponent extends Component {
          static _template() {
            return {
              ContentWrap: {
                renderOffscreen: true,
                forceZIndexContext: true,
                onAfterUpdate: SmoothScaleComponent._updateDimensions,
                Content: {}
              },
              Scale: {
                visible: false
              }
            };
          }
          constructor(stage) {
            super(stage);
            this._smoothScale = 1;
            this._iterations = 0;
          }
          get content() {
            return this.tag('Content');
          }
          set content(v) {
            this.tag('Content').patch(v, true);
          }
          get smoothScale() {
            return this._smoothScale;
          }
          set smoothScale(v) {
            if (this._smoothScale !== v) {
              var its = 0;
              while (v < 0.5 && its < 12) {
                its++;
                v = v * 2;
              }
              this.scale = v;
              this._setIterations(its);
              this._smoothScale = v;
            }
          }
          _setIterations(its) {
            if (this._iterations !== its) {
              var scalers = this.sel("Scale").childList;
              var content = this.sel("ContentWrap");
              while (scalers.length < its) {
                var first = scalers.length === 0;
                var texture = first ? content.getTexture() : scalers.last.getTexture();
                scalers.a({
                  rtt: true,
                  renderOffscreen: true,
                  texture: texture
                });
              }
              SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);
              var useScalers = its > 0;
              this.patch({
                ContentWrap: {
                  renderToTexture: useScalers
                },
                Scale: {
                  visible: useScalers
                }
              });
              for (var i = 0, n = scalers.length; i < n; i++) {
                scalers.getAt(i).patch({
                  visible: i < its,
                  renderOffscreen: i !== its - 1
                });
              }
              this._iterations = its;
            }
          }
          static _updateDimensions(contentWrap, force) {
            var content = contentWrap.children[0];
            var w = content.renderWidth;
            var h = content.renderHeight;
            if (w !== contentWrap.w || h !== contentWrap.h || force) {
              contentWrap.w = w;
              contentWrap.h = h;
              var scalers = contentWrap.parent.tag("Scale").children;
              for (var i = 0, n = scalers.length; i < n; i++) {
                w = w * 0.5;
                h = h * 0.5;
                scalers[i].w = w;
                scalers[i].h = h;
              }
            }
          }
          get _signalProxy() {
            return true;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class BorderComponent extends Component {
          static _template() {
            return {
              Content: {},
              Borders: {
                Top: {
                  rect: true,
                  visible: false,
                  mountY: 1
                },
                Right: {
                  rect: true,
                  visible: false
                },
                Bottom: {
                  rect: true,
                  visible: false
                },
                Left: {
                  rect: true,
                  visible: false,
                  mountX: 1
                }
              }
            };
          }
          get _signalProxy() {
            return true;
          }
          constructor(stage) {
            super(stage);
            this._borderTop = this.tag("Top");
            this._borderRight = this.tag("Right");
            this._borderBottom = this.tag("Bottom");
            this._borderLeft = this.tag("Left");
            this.onAfterUpdate = function (element) {
              var content = element.childList.first;
              var w = element.core.w || content.renderWidth;
              var h = element.core.h || content.renderHeight;
              element._borderTop.w = w;
              element._borderBottom.y = h;
              element._borderBottom.w = w;
              element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
              element._borderLeft.y = -element._borderTop.h;
              element._borderRight.x = w;
              element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
              element._borderRight.y = -element._borderTop.h;
            };
            this.borderWidth = 1;
          }
          get content() {
            return this.sel('Content');
          }
          set content(v) {
            this.sel('Content').patch(v, true);
          }
          get borderWidth() {
            return this.borderWidthTop;
          }
          get borderWidthTop() {
            return this._borderTop.h;
          }
          get borderWidthRight() {
            return this._borderRight.w;
          }
          get borderWidthBottom() {
            return this._borderBottom.h;
          }
          get borderWidthLeft() {
            return this._borderLeft.w;
          }
          set borderWidth(v) {
            this.borderWidthTop = v;
            this.borderWidthRight = v;
            this.borderWidthBottom = v;
            this.borderWidthLeft = v;
          }
          set borderWidthTop(v) {
            this._borderTop.h = v;
            this._borderTop.visible = v > 0;
          }
          set borderWidthRight(v) {
            this._borderRight.w = v;
            this._borderRight.visible = v > 0;
          }
          set borderWidthBottom(v) {
            this._borderBottom.h = v;
            this._borderBottom.visible = v > 0;
          }
          set borderWidthLeft(v) {
            this._borderLeft.w = v;
            this._borderLeft.visible = v > 0;
          }
          get colorBorder() {
            return this.colorBorderTop;
          }
          get colorBorderTop() {
            return this._borderTop.color;
          }
          get colorBorderRight() {
            return this._borderRight.color;
          }
          get colorBorderBottom() {
            return this._borderBottom.color;
          }
          get colorBorderLeft() {
            return this._borderLeft.color;
          }
          set colorBorder(v) {
            this.colorBorderTop = v;
            this.colorBorderRight = v;
            this.colorBorderBottom = v;
            this.colorBorderLeft = v;
          }
          set colorBorderTop(v) {
            this._borderTop.color = v;
          }
          set colorBorderRight(v) {
            this._borderRight.color = v;
          }
          set colorBorderBottom(v) {
            this._borderBottom.color = v;
          }
          set colorBorderLeft(v) {
            this._borderLeft.color = v;
          }
          get borderTop() {
            return this._borderTop;
          }
          set borderTop(settings) {
            this.borderTop.patch(settings);
          }
          get borderRight() {
            return this._borderRight;
          }
          set borderRight(settings) {
            this.borderRight.patch(settings);
          }
          get borderBottom() {
            return this._borderBottom;
          }
          set borderBottom(settings) {
            this.borderBottom.patch(settings);
          }
          get borderLeft() {
            return this._borderLeft;
          }
          set borderLeft(settings) {
            this.borderLeft.patch(settings);
          }
          set borders(settings) {
            this.borderTop = settings;
            this.borderLeft = settings;
            this.borderBottom = settings;
            this.borderRight = settings;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class WebGLGrayscaleShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._amount = 1;
          }
          static getC2d() {
            return C2dGrayscaleShader;
          }
          set amount(v) {
            this._amount = v;
            this.redraw();
          }
          get amount() {
            return this._amount;
          }
          useDefault() {
            return this._amount === 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("amount", this._amount, this.gl.uniform1f);
          }
        }
        WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;
        class C2dGrayscaleShader extends DefaultShader {
          constructor(context) {
            super(context);
            this._amount = 1;
          }
          static getWebGL() {
            return WebGLGrayscaleShader;
          }
          set amount(v) {
            this._amount = v;
            this.redraw();
          }
          get amount() {
            return this._amount;
          }
          useDefault() {
            return this._amount === 0;
          }
          _beforeDrawEl(_ref11) {
            var target = _ref11.target;
            target.ctx.filter = "grayscale(" + this._amount + ")";
          }
          _afterDrawEl(_ref12) {
            var target = _ref12.target;
            target.ctx.filter = "none";
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * This shader can be used to fix a problem that is known as 'gradient banding'.
         */
        class DitheringShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._noiseTexture = new NoiseTexture(ctx.stage);
            this._graining = 1 / 256;
            this._random = false;
          }
          set graining(v) {
            this._graining = v;
            this.redraw();
          }
          set random(v) {
            this._random = v;
            this.redraw();
          }
          setExtraAttribsInBuffer(operation) {
            // Make sure that the noise texture is uploaded to the GPU.
            this._noiseTexture.load();
            var offset = operation.extraAttribsDataByteOffset / 4;
            var floats = operation.quads.floats;
            var length = operation.length;
            for (var i = 0; i < length; i++) {
              // Calculate noise texture coordinates so that it spans the full element.
              var brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
              var bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();
              var ulx = 0;
              var uly = 0;
              if (this._random) {
                ulx = Math.random();
                uly = Math.random();
                brx += ulx;
                bry += uly;
                if (Math.random() < 0.5) {
                  // Flip for more randomness.
                  var t = ulx;
                  ulx = brx;
                  brx = t;
                }
                if (Math.random() < 0.5) {
                  // Flip for more randomness.
                  var _t2 = uly;
                  uly = bry;
                  bry = _t2;
                }
              }

              // Specify all corner points.
              floats[offset] = ulx;
              floats[offset + 1] = uly;
              floats[offset + 2] = brx;
              floats[offset + 3] = uly;
              floats[offset + 4] = brx;
              floats[offset + 5] = bry;
              floats[offset + 6] = ulx;
              floats[offset + 7] = bry;
              offset += 8;
            }
          }
          beforeDraw(operation) {
            var gl = this.gl;
            gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
            var glTexture = this._noiseTexture.source.nativeTexture;
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.activeTexture(gl.TEXTURE0);
          }
          getExtraAttribBytesPerVertex() {
            return 8;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
            this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
          }
          enableAttribs() {
            super.enableAttribs();
            var gl = this.gl;
            gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
          }
          disableAttribs() {
            super.disableAttribs();
            var gl = this.gl;
            gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
          }
          useDefault() {
            return this._graining === 0;
          }
          afterDraw(operation) {
            if (this._random) {
              this.redraw();
            }
          }
        }
        DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CircularPushShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._inputValue = 0;
            this._maxDerivative = 0.01;
            this._normalizedValue = 0;

            // The offset between buckets. A value between 0 and 1.
            this._offset = 0;
            this._amount = 0.1;
            this._aspectRatio = 1;
            this._offsetX = 0;
            this._offsetY = 0;
            this.buckets = 100;
          }
          get aspectRatio() {
            return this._aspectRatio;
          }
          set aspectRatio(v) {
            this._aspectRatio = v;
            this.redraw();
          }
          get offsetX() {
            return this._offsetX;
          }
          set offsetX(v) {
            this._offsetX = v;
            this.redraw();
          }
          get offsetY() {
            return this._offsetY;
          }
          set offsetY(v) {
            this._offsetY = v;
            this.redraw();
          }
          set amount(v) {
            this._amount = v;
            this.redraw();
          }
          get amount() {
            return this._amount;
          }
          set inputValue(v) {
            this._inputValue = v;
          }
          get inputValue() {
            return this._inputValue;
          }
          set maxDerivative(v) {
            this._maxDerivative = v;
          }
          get maxDerivative() {
            return this._maxDerivative;
          }
          set buckets(v) {
            if (v > 100) {
              console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
              v = 100;
            }

            // This should be set before starting.
            this._buckets = v;

            // Init values array in the correct length.
            this._values = new Uint8Array(this._getValues(v));
            this.redraw();
          }
          get buckets() {
            return this._buckets;
          }
          _getValues(n) {
            var v = [];
            for (var i = 0; i < n; i++) {
              v.push(this._inputValue);
            }
            return v;
          }

          /**
           * Progresses the shader with the specified (fractional) number of buckets.
           * @param {number} o;
           *   A number from 0 to 1 (1 = all buckets).
           */
          progress(o) {
            this._offset += o * this._buckets;
            var full = Math.floor(this._offset);
            this._offset -= full;
            this._shiftBuckets(full);
            this.redraw();
          }
          _shiftBuckets(n) {
            for (var i = this._buckets - 1; i >= 0; i--) {
              var targetIndex = i - n;
              if (targetIndex < 0) {
                this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                this._values[i] = 255 * this._normalizedValue;
              } else {
                this._values[i] = this._values[targetIndex];
              }
            }
          }
          set offset(v) {
            this._offset = v;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
            this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
            this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
            this._setUniform("amount", this._amount, this.gl.uniform1f);
            this._setUniform("offset", this._offset, this.gl.uniform1f);
            this._setUniform("buckets", this._buckets, this.gl.uniform1f);
            this._setUniform("uValueSampler", 1, this.gl.uniform1i);
          }
          useDefault() {
            return this._amount === 0;
          }
          beforeDraw(operation) {
            var gl = this.gl;
            gl.activeTexture(gl.TEXTURE1);
            if (!this._valuesTexture) {
              this._valuesTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              if (Utils$2.isNode) {
                gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
              }
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            } else {
              gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
            }

            // Upload new values.
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
            gl.activeTexture(gl.TEXTURE0);
          }
          cleanup() {
            if (this._valuesTexture) {
              this.gl.deleteTexture(this._valuesTexture);
            }
          }
        }
        CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class InversionShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._amount = 1;
          }
          set amount(v) {
            this._amount = v;
            this.redraw();
          }
          get amount() {
            return this._amount;
          }
          useDefault() {
            return this._amount === 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("amount", this._amount, this.gl.uniform1f);
          }
        }
        InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class OutlineShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._width = 5;
            this._col = 0xFFFFFFFF;
            this._color = [1, 1, 1, 1];
          }
          set width(v) {
            this._width = v;
            this.redraw();
          }
          get color() {
            return this._col;
          }
          set color(v) {
            if (this._col !== v) {
              var col = StageUtils.getRgbaComponentsNormalized(v);
              col[0] = col[0] * col[3];
              col[1] = col[1] * col[3];
              col[2] = col[2] * col[3];
              this._color = col;
              this.redraw();
              this._col = v;
            }
          }
          useDefault() {
            return this._width === 0 || this._col[3] === 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var gl = this.gl;
            this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
          }
          enableAttribs() {
            super.enableAttribs();
            this.gl.enableVertexAttribArray(this._attrib("aCorner"));
          }
          disableAttribs() {
            super.disableAttribs();
            this.gl.disableVertexAttribArray(this._attrib("aCorner"));
          }
          setExtraAttribsInBuffer(operation) {
            var offset = operation.extraAttribsDataByteOffset / 4;
            var floats = operation.quads.floats;
            var length = operation.length;
            for (var i = 0; i < length; i++) {
              var elementCore = operation.getElementCore(i);

              // We are setting attributes such that if the value is < 0 or > 1, a border should be drawn.
              var ddw = this._width / elementCore.w;
              var dw = ddw / (1 - 2 * ddw);
              var ddh = this._width / elementCore.h;
              var dh = ddh / (1 - 2 * ddh);

              // Specify all corner points.
              floats[offset] = -dw;
              floats[offset + 1] = -dh;
              floats[offset + 2] = 1 + dw;
              floats[offset + 3] = -dh;
              floats[offset + 4] = 1 + dw;
              floats[offset + 5] = 1 + dh;
              floats[offset + 6] = -dw;
              floats[offset + 7] = 1 + dh;
              offset += 8;
            }
          }
          beforeDraw(operation) {
            var gl = this.gl;
            gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
          }
          getExtraAttribBytesPerVertex() {
            return 8;
          }
        }
        OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * @see https://github.com/pixijs/pixi-filters/tree/master/filters/pixelate/src
         */
        class PixelateShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._size = new Float32Array([4, 4]);
          }
          get x() {
            return this._size[0];
          }
          set x(v) {
            this._size[0] = v;
            this.redraw();
          }
          get y() {
            return this._size[1];
          }
          set y(v) {
            this._size[1] = v;
            this.redraw();
          }
          get size() {
            return this._size[0];
          }
          set size(v) {
            this._size[0] = v;
            this._size[1] = v;
            this.redraw();
          }
          useDefault() {
            return this._size[0] === 0 && this._size[1] === 0;
          }
          static getWebGLImpl() {
            return WebGLPixelateShaderImpl;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var gl = this.gl;
            this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
          }
          getExtraAttribBytesPerVertex() {
            return 8;
          }
          enableAttribs() {
            super.enableAttribs();
            this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
          }
          disableAttribs() {
            super.disableAttribs();
            this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
          }
          setExtraAttribsInBuffer(operation) {
            var offset = operation.extraAttribsDataByteOffset / 4;
            var floats = operation.quads.floats;
            var length = operation.length;
            for (var i = 0; i < length; i++) {
              var w = operation.quads.getTextureWidth(operation.index + i);
              var h = operation.quads.getTextureHeight(operation.index + i);
              floats[offset] = w;
              floats[offset + 1] = h;
              floats[offset + 2] = w;
              floats[offset + 3] = h;
              floats[offset + 4] = w;
              floats[offset + 5] = h;
              floats[offset + 6] = w;
              floats[offset + 7] = h;
              offset += 8;
            }
          }
          beforeDraw(operation) {
            var gl = this.gl;
            gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
          }
        }
        PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class RadialFilterShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._radius = 0;
            this._cutoff = 1;
          }
          set radius(v) {
            this._radius = v;
            this.redraw();
          }
          get radius() {
            return this._radius;
          }
          set cutoff(v) {
            this._cutoff = v;
            this.redraw();
          }
          get cutoff() {
            return this._cutoff;
          }
          useDefault() {
            return this._radius === 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            // We substract half a pixel to get a better cutoff effect.
            this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
            this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
          }
        }
        RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;
        RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class RoundedRectangleShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._blend = 0;
            this._radius = [1, 1, 1, 1];
            this._stroke = 0;
            this._fc = 0x00ffffff;
            this._fillColor = this._getNormalizedColor(0xffffffff);
            this._strokeColor = this._getNormalizedColor(0x00ffffff);
          }
          set blend(p) {
            this._blend = Math.min(Math.max(p, 0), 1);
          }
          set radius(v) {
            if (Array.isArray(v)) {
              if (v.length === 2) {
                this._radius = [v[0], v[1], v[0], v[1]];
              } else if (v.length === 3) {
                this._radius = [v[0], v[1], v[2], this._radius[3]];
              } else if (v.length === 4) {
                this._radius = v;
              } else {
                this._radius = [v[0], v[0], v[0], v[0]];
              }
            } else {
              this._radius = [v, v, v, v];
            }
            this.redraw();
          }
          get radius() {
            return this._radius;
          }
          set topLeft(num) {
            this._radius[0] = num;
            this.redraw();
          }
          get topLeft() {
            return this._radius[0];
          }
          set topRight(num) {
            this._radius[1] = num;
            this.redraw();
          }
          get topRight() {
            return this._radius[1];
          }
          set bottomRight(num) {
            this._radius[2] = num;
            this.redraw();
          }
          get bottomRight() {
            return this._radius[2];
          }
          set bottomLeft(num) {
            this._radius[3] = num;
            this.redraw();
          }
          get bottomLeft() {
            return this._radius[4];
          }
          set strokeColor(argb) {
            this._sc = argb;
            this._strokeColor = this._getNormalizedColor(argb);
            this.redraw();
          }
          get strokeColor() {
            return this._sc;
          }
          set fillColor(argb) {
            this._fc = argb;
            this._fillColor = this._getNormalizedColor(argb);
            this.redraw();
          }
          get fillColor() {
            return this._fc;
          }
          set stroke(num) {
            this._stroke = num;
            this.redraw();
          }
          get stroke() {
            return this._stroke;
          }
          _getNormalizedColor(color) {
            var col = StageUtils.getRgbaComponentsNormalized(color);
            col[0] *= col[3];
            col[1] *= col[3];
            col[2] *= col[3];
            return new Float32Array(col);
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            var renderPrecision = this.ctx.stage.getRenderPrecision();
            var _radius = this._radius.map(r => (r + 0.5) * renderPrecision);
            this._setUniform('radius', new Float32Array(_radius), this.gl.uniform4fv);
            this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
            this._setUniform('blend', this._blend, this.gl.uniform1f);
            this._setUniform('strokeColor', this._strokeColor, this.gl.uniform4fv);
            this._setUniform('fillColor', this._fillColor, this.gl.uniform4fv);
            this._setUniform('stroke', this._stroke * renderPrecision, this.gl.uniform1f);
            this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
        }
        RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class FadeOutShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._fade = [0, 0, 0, 0];
          }
          set top(num) {
            this._fade[0] = num;
            this.redraw();
          }
          get top() {
            return this._fade[0];
          }
          set right(num) {
            this._fade[1] = num;
            this.redraw();
          }
          get right() {
            return this._fade[1];
          }
          set bottom(num) {
            this._fade[2] = num;
            this.redraw();
          }
          get bottom() {
            return this._fade[2];
          }
          set left(num) {
            this._fade[3] = num;
            this.redraw();
          }
          get left() {
            return this._fade[3];
          }
          set fade(v) {
            if (Array.isArray(v)) {
              if (v.length === 2) {
                this._fade = [v[0], v[1], v[0], v[1]];
              } else if (v.length === 3) {
                this._fade = [v[0], v[1], v[2], this._fade[3]];
              } else if (v.length === 4) {
                this._fade = v;
              } else {
                this._fade = [v[0], v[0], v[0], v[0]];
              }
            } else {
              this._fade = [v, v, v, v];
            }
            this.redraw();
          }
          get fade() {
            return this._fade;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            var renderPrecision = this.ctx.stage.getRenderPrecision();
            var fade = this._fade.map(f => f * renderPrecision);
            this._setUniform('fade', new Float32Array(fade), this.gl.uniform4fv);
            this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
        }
        FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class VignetteShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._magnitude = 1.3;
            this._intensity = 0.7;
            this._pivot = [0.5, 0.5];
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            this._setUniform("magnitude", this._magnitude, this.gl.uniform1f);
            this._setUniform("intensity", this._intensity, this.gl.uniform1f);
            this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
            this.redraw();
          }
          set pivot(v) {
            if (Array.isArray(v)) {
              this._pivot = v;
            } else {
              this._pivot = [v, v];
            }
            this.redraw();
          }
          get pivotX() {
            return this._pivot[0];
          }
          set pivotX(v) {
            this._pivot[0] = v;
            this.redraw();
          }
          get pivotY() {
            return this._pivot[1];
          }
          set pivotY(v) {
            this._pivot[1] = v;
            this.redraw();
          }
          get intensity() {
            return this._intensity;
          }
          set intensity(v) {
            this._intensity = v;
            this.redraw();
          }
          get magnitude() {
            return this._magnitude;
          }
          set magnitude(v) {
            this._magnitude = v;
            this.redraw();
          }
        }
        VignetteShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
        VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SpinnerShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._radius = 100;
            this._width = 50;
            this._period = 1;
            this._angle = 0.5;
            this._smooth = 0.005;
            this._color = 0xffffffff;
            this._backgroundColor = 0xff000000;
            this._time = Date.now();
          }
          set radius(v) {
            this._radius = v;
            this.redraw();
          }
          set width(v) {
            this._width = v;
            this.redraw();
          }
          set period(v) {
            this._period = v;
            this.redraw();
          }
          set angle(v) {
            this._angle = v;
            this.redraw();
          }
          set smooth(v) {
            this._smooth = v;
            this.redraw();
          }
          set color(v) {
            this._color = v;
            this.redraw();
          }
          set backgroundColor(v) {
            this._backgroundColor = v;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);
            var renderPrecision = this.ctx.stage.getRenderPrecision();
            this._setUniform('radius', this._radius * renderPrecision, this.gl.uniform1f);
            this._setUniform('width', this._width * renderPrecision, this.gl.uniform1f);
            this._setUniform('period', this._period, this.gl.uniform1f);
            this._setUniform('angle', this._angle, this.gl.uniform1f);
            this._setUniform('smooth', this._smooth, this.gl.uniform1f);
            this._setUniform('color', new Float32Array(StageUtils.getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
            this._setUniform('backgroundColor', new Float32Array(StageUtils.getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
            this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
            this.redraw();
          }
        }
        SpinnerShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
        SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class HoleShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;
            this._radius = 0;
          }
          get x() {
            return this._x;
          }
          set x(v) {
            this._x = v;
            this.redraw();
          }
          get y() {
            return this._y;
          }
          set y(v) {
            this._y = v;
            this.redraw();
          }
          get w() {
            return this._w;
          }
          set w(v) {
            this._w = v;
            this.redraw();
          }
          get h() {
            return this._h;
          }
          set h(v) {
            this._h = v;
            this.redraw();
          }
          get radius() {
            return this._radius;
          }
          set radius(v) {
            this._radius = v;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            var renderPrecision = this.ctx.stage.getRenderPrecision();
            this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
            this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
            this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
            this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
            this._setUniform('radius', (this._radius + .5) * renderPrecision, this.gl.uniform1f);
            this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
          useDefault() {
            return this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0;
          }
        }
        HoleShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
        HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class RadialGradientShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._pivot = [0, 0];
            this._ic = 0xffffffff;
            this._normalizedIC = this._getNormalizedColor(this._ic);
            this._oc = 0x00ffffff;
            this._normalizedOC = this._getNormalizedColor(this._oc);
            this._radius = 0;
          }
          set radiusX(v) {
            this.radius = v;
          }
          get radiusX() {
            return this._radius;
          }
          set radiusY(v) {
            this._radiusY = v;
            this.redraw();
          }
          get radiusY() {
            return this._radiusY;
          }
          set radius(v) {
            this._radius = v;
            this.redraw();
          }
          set innerColor(argb) {
            this._ic = argb;
            this._normalizedIC = this._getNormalizedColor(argb);
            this.redraw();
          }
          get innerColor() {
            return this._ic;
          }
          set outerColor(argb) {
            this._oc = argb;
            this._normalizedOC = this._getNormalizedColor(argb);
            this.redraw();
          }
          set color(argb) {
            this.innerColor = argb;
          }
          get color() {
            return this.innerColor;
          }
          get outerColor() {
            return this._ic;
          }
          set x(f) {
            this._x = f;
            this.redraw();
          }
          set y(f) {
            this._y = f;
            this.redraw();
          }
          set pivot(v) {
            if (Array.isArray(v) && v.length === 2) {
              this._pivot = v;
            } else if (Array.isArray(v)) {
              this._pivot = [v[0], v[1] || v[0]];
            } else {
              this._pivot = [v, v];
            }
            this.redraw();
          }
          get pivot() {
            return this._pivot[0];
          }
          set pivotY(f) {
            this._pivot[1] = f;
            this.redraw();
          }
          get pivotY() {
            return this._pivot[1];
          }
          set pivotX(f) {
            this._pivot[0] = f;
            this.redraw();
          }
          get pivotX() {
            return this._pivot[0];
          }
          _getNormalizedColor(color) {
            var col = StageUtils.getRgbaComponentsNormalized(color);
            col[0] *= col[3];
            col[1] *= col[3];
            col[2] *= col[3];
            return new Float32Array(col);
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            if (this._x) {
              this._pivot[0] = this._x / owner.w;
            }
            if (this._y) {
              this._pivot[1] = this._y / owner.h;
            }
            if (this._radius === 0) {
              this._radius = owner.w * 0.5;
            }
            this._setUniform('innerColor', this._normalizedIC, this.gl.uniform4fv);
            this._setUniform('fill', StageUtils.getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
            this._setUniform('outerColor', this._normalizedOC, this.gl.uniform4fv);
            this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
            this._setUniform('resolution', new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
            this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
            this._setUniform('radius', this._radius, this.gl.uniform1f);
            this._setUniform('radiusY', this._radiusY || this._radius, this.gl.uniform1f);
          }
        }
        RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Light3dShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._strength = 0.5;
            this._ambient = 0.5;
            this._fudge = 0.4;
            this._rx = 0;
            this._ry = 0;
            this._z = 0;
            this._pivotX = NaN;
            this._pivotY = NaN;
            this._pivotZ = 0;
            this._lightY = 0;
            this._lightZ = 0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var vr = operation.shaderOwner;
            var element = vr.element;
            var pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
            var pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
            var coords = vr.getRenderTextureCoords(pivotX, pivotY);

            // Counter normal rotation.

            var rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
            var gl = this.gl;
            this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
            this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
            this._setUniform("z", this._z, gl.uniform1f);
            this._setUniform("lightY", this.lightY, gl.uniform1f);
            this._setUniform("lightZ", this.lightZ, gl.uniform1f);
            this._setUniform("strength", this._strength, gl.uniform1f);
            this._setUniform("ambient", this._ambient, gl.uniform1f);
            this._setUniform("fudge", this._fudge, gl.uniform1f);
          }
          set strength(v) {
            this._strength = v;
            this.redraw();
          }
          get strength() {
            return this._strength;
          }
          set ambient(v) {
            this._ambient = v;
            this.redraw();
          }
          get ambient() {
            return this._ambient;
          }
          set fudge(v) {
            this._fudge = v;
            this.redraw();
          }
          get fudge() {
            return this._fudge;
          }
          get rx() {
            return this._rx;
          }
          set rx(v) {
            this._rx = v;
            this.redraw();
          }
          get ry() {
            return this._ry;
          }
          set ry(v) {
            this._ry = v;
            this.redraw();
          }
          get z() {
            return this._z;
          }
          set z(v) {
            this._z = v;
            this.redraw();
          }
          get pivotX() {
            return this._pivotX;
          }
          set pivotX(v) {
            this._pivotX = v + 1;
            this.redraw();
          }
          get pivotY() {
            return this._pivotY;
          }
          set pivotY(v) {
            this._pivotY = v + 1;
            this.redraw();
          }
          get lightY() {
            return this._lightY;
          }
          set lightY(v) {
            this._lightY = v;
            this.redraw();
          }
          get pivotZ() {
            return this._pivotZ;
          }
          set pivotZ(v) {
            this._pivotZ = v;
            this.redraw();
          }
          get lightZ() {
            return this._lightZ;
          }
          set lightZ(v) {
            this._lightZ = v;
            this.redraw();
          }
          useDefault() {
            return this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1;
          }
        }
        Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class PerspectiveShader extends DefaultShader$1 {
          constructor(ctx) {
            super(ctx);
            this._fudge = 0.2;
            this._rx = 0;
            this._ry = 0;
            this._z = 1.0;
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var vr = operation.shaderOwner;
            var element = vr.element;
            var pivotX = element.pivotX * vr.w;
            var pivotY = element.pivotY * vr.h;
            var coords = vr.getRenderTextureCoords(pivotX, pivotY);

            // Counter normal rotation.
            var rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
            var gl = this.gl;
            this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
            this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
            this._setUniform("z", this._z, gl.uniform1f);
            this._setUniform("fudge", this._fudge, gl.uniform1f);
          }
          set fudge(v) {
            this._fudge = v;
            this.redraw();
          }
          get fudge() {
            return this._fudge;
          }
          get rx() {
            return this._rx;
          }
          set rx(v) {
            this._rx = v;
            this.redraw();
          }
          get ry() {
            return this._ry;
          }
          set ry(v) {
            this._ry = v;
            this.redraw();
          }
          get z() {
            return this._z;
          }
          set z(v) {
            this._z = v;
            this.redraw();
          }
          useDefault() {
            return this._rx === 0 && this._ry === 0 && this._z === 0;
          }
        }
        PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
        PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class MagnifierShader extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;
            this._radius = 0;
            this._magnification = 0.6;
          }
          get x() {
            return this._x;
          }
          set x(v) {
            this._x = v;
            this.redraw();
          }
          get y() {
            return this._y;
          }
          set y(v) {
            this._y = v;
            this.redraw();
          }
          get w() {
            return this._w;
          }
          set w(v) {
            this._w = v;
            this.redraw();
          }
          get h() {
            return this._h;
          }
          set h(v) {
            this._h = v;
            this.redraw();
          }
          get magnification() {
            return this._magnification;
          }
          set magnification(v) {
            this._magnification = v;
            this.redraw();
          }
          get radius() {
            return this._radius;
          }
          set radius(v) {
            this._radius = v;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            var renderPrecision = this.ctx.stage.getRenderPrecision();
            this._setUniform('x', this._x * renderPrecision, this.gl.uniform1f);
            this._setUniform('y', this._y * renderPrecision, this.gl.uniform1f);
            this._setUniform('w', this._w * renderPrecision, this.gl.uniform1f);
            this._setUniform('h', this._h * renderPrecision, this.gl.uniform1f);
            this._setUniform('magnification', this._magnification, this.gl.uniform1f);
            this._setUniform('radius', (this._radius + 0.5) * renderPrecision, this.gl.uniform1f);
            this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
          useDefault() {
            return this._w === 0 && this._h === 0;
          }
        }
        MagnifierShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
        MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SpinnerShader2 extends DefaultShader$1 {
          constructor(context) {
            super(context);
            this._period = 1;
            this._stroke = 0;
            this._showDot = true;
            this._clockwise = true;
            this._bc = 0xff000000;
            this._normalizedBC = this._getNormalizedColor(this._bc);
            this._c = 0xffffffff;
            this._normalizedC = this._getNormalizedColor(this._c);
          }
          set radius(v) {
            if (v === 0) {
              v = 1;
            }
            this._radius = v;
          }
          set stroke(value) {
            this._stroke = Math.abs(value);
          }
          get stroke() {
            return this._stroke;
          }
          set color(argb) {
            this._c = argb;
            this._normalizedC = this._getNormalizedColor(argb);
          }
          get color() {
            return this._c;
          }
          set backgroundColor(argb) {
            this._bc = argb;
            this._normalizedBC = this._getNormalizedColor(argb);
          }
          get backgroundColor() {
            return this._sc;
          }
          set showDot(bool) {
            this._showDot = bool;
          }
          get showDot() {
            return this._showDot;
          }
          set clockwise(bool) {
            this._clockwise = bool;
          }
          get clockwise() {
            return this._clockwise;
          }
          set period(v) {
            this._period = v;
          }
          get period() {
            return this._period;
          }
          _getNormalizedColor(color) {
            var col = StageUtils.getRgbaComponentsNormalized(color);
            col[0] *= col[3];
            col[1] *= col[3];
            col[2] *= col[3];
            return new Float32Array(col);
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var owner = operation.shaderOwner;
            var radius = this._radius || owner._w / 2;
            if (this._stroke === 0) {
              this._stroke = radius * 0.33;
            }
            this._setUniform('resolution', new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
            this._setUniform('color', this._normalizedC, this.gl.uniform4fv);
            this._setUniform('backgroundColor', this._normalizedBC, this.gl.uniform4fv);
            this._setUniform('stroke', this._stroke, this.gl.uniform1f);
            this._setUniform('radius', radius, this.gl.uniform1f);
            this._setUniform('direction', this._clockwise ? -1 : 1, this.gl.uniform1f);
            this._setUniform('showDot', !!this._showDot, this.gl.uniform1f);
            this._setUniform('time', Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
            this._setUniform('period', this._period, this.gl.uniform1f);
            this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
            if (this._sc !== this._bc || this._stroke !== radius * 0.5) {
              this.redraw();
            }
          }
        }
        SpinnerShader2.spinSync = Date.now();
        SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var lightning = {
          Application: Application$1,
          Component,
          Base,
          Utils: Utils$2,
          StageUtils,
          Element: Element$1,
          Tools,
          Stage,
          ElementCore,
          ElementTexturizer,
          Texture,
          EventEmitter,
          shaders: {
            Grayscale: WebGLGrayscaleShader,
            BoxBlur: BoxBlurShader,
            Dithering: DitheringShader,
            CircularPush: CircularPushShader,
            Inversion: InversionShader,
            LinearBlur: LinearBlurShader,
            Outline: OutlineShader,
            Pixelate: PixelateShader,
            RadialFilter: RadialFilterShader,
            RoundedRectangle: RoundedRectangleShader,
            Spinner2: SpinnerShader2,
            FadeOut: FadeOutShader,
            Hole: HoleShader,
            Vignette: VignetteShader,
            Spinner: SpinnerShader,
            RadialGradient: RadialGradientShader,
            Light3d: Light3dShader,
            Perspective: PerspectiveShader,
            Magnifier: MagnifierShader,
            WebGLShader,
            WebGLDefaultShader: DefaultShader$1,
            C2dShader,
            C2dDefaultShader: DefaultShader,
            c2d: {
              Grayscale: C2dGrayscaleShader,
              Blur: BlurShader
            }
          },
          textures: {
            RectangleTexture,
            NoiseTexture,
            TextTexture,
            ImageTexture,
            HtmlTexture,
            StaticTexture,
            StaticCanvasTexture,
            SourceTexture
          },
          components: {
            FastBlurComponent,
            BloomComponent,
            SmoothScaleComponent,
            BorderComponent,
            ListComponent
          },
          tools: {
            ObjMerger,
            ObjectListProxy,
            ObjectListWrapper
          }
        };
        if (Utils$2.isWeb) {
          window.lng = lightning;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var ColorShift$1 = class ColorShift extends lightning.shaders.WebGLDefaultShader {
          set brightness(v) {
            this._brightness = (v - 50) / 100;
            this.redraw();
          }
          set contrast(v) {
            this._contrast = (v + 50) / 100;
            this.redraw();
          }
          set gamma(v) {
            this._gamma = (v + 50) / 100;
            this.redraw();
          }
          setupUniforms(operation) {
            super.setupUniforms(operation);
            var gl = this.gl;
            this._setUniform('colorAdjust', [this._brightness || 0.0, this._contrast || 1.0, this._gamma || 1.0], gl.uniform3fv);
          }
        };
        ColorShift$1.before = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
        
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec3 colorAdjust;
    
    const mat3 RGBtoOpponentMat = mat3(0.2814, -0.0971, -0.0930, 0.6938, 0.1458,-0.2529, 0.0638, -0.0250, 0.4665);
    const mat3 OpponentToRGBMat = mat3(1.1677, 0.9014, 0.7214, -6.4315, 2.5970, 0.1257, -0.5044, 0.0159, 2.0517);    
`;
        ColorShift$1.after = `    
    vec3 brightnessContrast(vec3 value, float brightness, float contrast)
    {
        return (value - 0.5) * contrast + 0.5 + brightness;
    }   
    
    vec3 updateGamma(vec3 value, float param)
    {
        return vec3(pow(abs(value.r), param),pow(abs(value.g), param),pow(abs(value.b), param));
    } 
       
    void main(void){
        vec4 fragColor = texture2D(uSampler, vTextureCoord);        
        vec4 color = filter(fragColor) * vColor;       
        
        vec3 bc = brightnessContrast(color.rgb,colorAdjust[0],colorAdjust[1]);        
        vec3 ga = updateGamma(bc.rgb, colorAdjust[2]);  
              
        gl_FragColor = vec4(ga.rgb, color.a);          
    }    
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ProtanopiaShader extends ColorShift$1 {}
        ProtanopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.20,  0.99, -0.19, 0.0);
        vec4 g = vec4( 0.16,  0.79,  0.04, 0.0);
        vec4 b = vec4( 0.01, -0.01,  1.00, 0.0);
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));      
    }    
    ${ColorShift$1.after} 
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class DeuteranopiaShader extends ColorShift$1 {}
        DeuteranopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.43,  0.72, -0.15, 0.0 );
        vec4 g = vec4( 0.34,  0.57,  0.09, 0.0 );
        vec4 b = vec4(-0.02,  0.03,  1.00, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
       
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));    
    }
    ${ColorShift$1.after}    
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class TritanopiaShader extends ColorShift$1 {}
        TritanopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.97,  0.11, -0.08, 0.0 );
        vec4 g = vec4( 0.02,  0.82,  0.16, 0.0 );
        vec4 b = vec4(-0.06,  0.88,  0.18, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }   
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= ((3.0 * opponentColor.z) - opponentColor.y) * 0.25;
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));
    }   
    ${ColorShift$1.after} 
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class NeutralShader extends ColorShift$1 {}
        NeutralShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 filter( vec4 color )
    {
        return color;
    }
    ${ColorShift$1.after}
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class MonochromacyShader extends ColorShift$1 {}
        MonochromacyShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 filter( vec4 color )
    {   
        float grey = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        return vec4(vec3(grey, grey, grey), 1.0 ); 
    }
    ${ColorShift$1.after}
`;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var colorshiftShader = type => {
          var shadersMap = {
            normal: NeutralShader,
            monochromacy: MonochromacyShader,
            deuteranopia: DeuteranopiaShader,
            tritanopia: TritanopiaShader,
            protanopia: ProtanopiaShader
          };
          type = typeof type === 'string' && type.toLowerCase() || null;
          return Object.keys(shadersMap).indexOf(type) > -1 ? shadersMap[type] : false;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Accessibility = {
          colorshift(component) {
            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
              brightness: 50,
              contrast: 50,
              gamma: 50
            };
            config = _objectSpread(_objectSpread({}, {
              brightness: 50,
              contrast: 50,
              gamma: 50
            }), config);
            var shader = type && colorshiftShader(type);
            if (shader) {
              Log$1.info('Accessibility Colorshift', type, config);
              component.rtt = true;
              component.shader = _objectSpread({
                type: shader
              }, config);
            } else {
              Log$1.info('Accessibility Colorshift', 'Disabled');
              component.rtt = false;
              component.shader = null;
            }
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Log;
        var Settings;
        var ApplicationInstance$1;
        var Ads$1;
        var Lightning;
        var initLightningSdkPlugin = {
          set log(v) {
            Log = v;
          },
          set settings(v) {
            Settings = v;
          },
          set ads(v) {
            Ads$1 = v;
          },
          set lightning(v) {
            Lightning = v;
          },
          set appInstance(v) {
            ApplicationInstance$1 = v;
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var initMetrics = config => {
          sendMetric = config.sendMetric;
        };
        var sendMetric = (type, event, params) => {
          Log.info('Sending metric', type, event, params);
        };

        // available metric per category
        var metrics$1 = {
          app: ['launch', 'loaded', 'ready', 'close'],
          page: ['view', 'leave'],
          user: ['click', 'input'],
          media: ['abort', 'canplay', 'ended', 'pause', 'play',
          // with some videos there occur almost constant suspend events ... should investigate
          // 'suspend',
          'volumechange', 'waiting', 'seeking', 'seeked']
        };

        // error metric function (added to each category)
        var errorMetric = function errorMetric(type, message, code, visible) {
          var params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
          params = _objectSpread({
            params
          }, {
            message,
            code,
            visible
          });
          sendMetric(type, 'error', params);
        };
        var Metric = function Metric(type, events) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return events.reduce((obj, event) => {
            obj[event] = function (name) {
              var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              params = _objectSpread(_objectSpread(_objectSpread({}, options), name ? {
                name
              } : {}), params);
              sendMetric(type, event, params);
            };
            return obj;
          }, {
            error(message, code, params) {
              errorMetric(type, message, code, params);
            },
            event(name, params) {
              sendMetric(type, name, params);
            }
          });
        };
        var Metrics = types => {
          return Object.keys(types).reduce((obj, type) => {
            // media metric works a bit different!
            // it's a function that accepts a url and returns an object with the available metrics
            // url is automatically passed as a param in every metric
            type === 'media' ? obj[type] = url => Metric(type, types[type], {
              url
            }) : obj[type] = Metric(type, types[type]);
            return obj;
          }, {
            error: errorMetric,
            event: sendMetric
          });
        };
        var Metrics$1 = Metrics(metrics$1);

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var formatLocale = locale => {
          if (locale && locale.length === 2) {
            return `${locale.toLowerCase()}-${locale.toUpperCase()}`;
          } else {
            return locale;
          }
        };
        var getLocale = defaultValue => {
          if ('language' in navigator) {
            var locale = formatLocale(navigator.language);
            return Promise.resolve(locale);
          } else {
            return Promise.resolve(defaultValue);
          }
        };
        var getLanguage = defaultValue => {
          if ('language' in navigator) {
            var _language = formatLocale(navigator.language).slice(0, 2);
            return Promise.resolve(_language);
          } else {
            return Promise.resolve(defaultValue);
          }
        };
        var getCountryCode = defaultValue => {
          if ('language' in navigator) {
            var countryCode = formatLocale(navigator.language).slice(3, 5);
            return Promise.resolve(countryCode);
          } else {
            return Promise.resolve(defaultValue);
          }
        };
        var hasOrAskForGeoLocationPermission = () => {
          return new Promise(resolve => {
            // force to prompt for location permission
            if (Settings.get('platform', 'forceBrowserGeolocation') === true) resolve(true);
            if ('permissions' in navigator && typeof navigator.permissions.query === 'function') {
              navigator.permissions.query({
                name: 'geolocation'
              }).then(status => {
                resolve(status.state === 'granted' || status.status === 'granted');
              });
            } else {
              resolve(false);
            }
          });
        };
        var getLatLon = defaultValue => {
          return new Promise(resolve => {
            hasOrAskForGeoLocationPermission().then(granted => {
              if (granted === true) {
                if ('geolocation' in navigator) {
                  navigator.geolocation.getCurrentPosition(
                  // success
                  result => result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
                  // error
                  () => resolve(defaultValue),
                  // options
                  {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                  });
                } else {
                  return queryForLatLon().then(result => resolve(result || defaultValue));
                }
              } else {
                return queryForLatLon().then(result => resolve(result || defaultValue));
              }
            });
          });
        };
        var queryForLatLon = () => {
          return new Promise(resolve => {
            fetch('https://geolocation-db.com/json/').then(response => response.json()).then(_ref13 => {
              var latitude = _ref13.latitude,
                longitude = _ref13.longitude;
              return latitude && longitude ? resolve([latitude, longitude]) : resolve(false);
            }).catch(() => resolve(false));
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var defaultProfile = {
          ageRating: 'adult',
          city: 'New York',
          zipCode: '27505',
          countryCode: () => getCountryCode('US'),
          ip: '127.0.0.1',
          household: 'b2244e9d4c04826ccd5a7b2c2a50e7d4',
          language: () => getLanguage('en'),
          latlon: () => getLatLon([40.7128, 74.006]),
          locale: () => getLocale('en-US'),
          mac: '00:00:00:00:00:00',
          operator: 'metrological',
          platform: 'metrological',
          packages: [],
          uid: 'ee6723b8-7ab3-462c-8d93-dbf61227998e',
          stbType: 'metrological'
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var getInfo = key => {
          var profile = _objectSpread(_objectSpread({}, defaultProfile), Settings.get('platform', 'profile'));
          return Promise.resolve(typeof profile[key] === 'function' ? profile[key]() : profile[key]);
        };
        var setInfo = (key, params) => {
          if (key in defaultProfile) return defaultProfile[key] = params;
        };
        var initProfile = config => {
          getInfo = config.getInfo ? config.getInfo : getInfo;
          setInfo = config.setInfo ? config.setInfo : setInfo;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var initPurchase = config => {
          if (config.billingUrl) config.billingUrl;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var defaultChannels = [{
          number: 1,
          name: 'Metro News 1',
          description: 'New York Cable News Channel',
          entitled: true,
          program: {
            title: 'The Morning Show',
            description: "New York's best morning show",
            startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(),
            // started 5 minutes ago
            duration: 60 * 30,
            // 30 minutes
            ageRating: 0
          }
        }, {
          number: 2,
          name: 'MTV',
          description: 'Music Television',
          entitled: true,
          program: {
            title: 'Beavis and Butthead',
            description: 'American adult animated sitcom created by Mike Judge',
            startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(),
            // started 20 minutes ago
            duration: 60 * 45,
            // 45 minutes
            ageRating: 18
          }
        }, {
          number: 3,
          name: 'NBC',
          description: 'NBC TV Network',
          entitled: false,
          program: {
            title: 'The Tonight Show Starring Jimmy Fallon',
            description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
            startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(),
            // started 10 minutes ago
            duration: 60 * 60,
            // 1 hour
            ageRating: 10
          }
        }];
        var channels = () => Settings.get('platform', 'tv', defaultChannels);
        var randomChannel = () => channels()[~~(channels.length * Math.random())];

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var currentChannel;
        var callbacks = {};
        var emit$1 = function emit$1(event) {
          for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key9 = 1; _key9 < _len6; _key9++) {
            args[_key9 - 1] = arguments[_key9];
          }
          callbacks[event] && callbacks[event].forEach(cb => {
            cb.apply(null, args);
          });
        };

        // local mock methods
        var methods = {
          getChannel() {
            if (!currentChannel) currentChannel = randomChannel();
            return new Promise((resolve, reject) => {
              if (currentChannel) {
                var channel = _objectSpread({}, currentChannel);
                delete channel.program;
                resolve(channel);
              } else {
                reject('No channel found');
              }
            });
          },
          getProgram() {
            if (!currentChannel) currentChannel = randomChannel();
            return new Promise((resolve, reject) => {
              currentChannel.program ? resolve(currentChannel.program) : reject('No program found');
            });
          },
          setChannel(number) {
            return new Promise((resolve, reject) => {
              if (number) {
                var newChannel = channels().find(c => c.number === number);
                if (newChannel) {
                  currentChannel = newChannel;
                  var channel = _objectSpread({}, currentChannel);
                  delete channel.program;
                  emit$1('channelChange', channel);
                  resolve(channel);
                } else {
                  reject('Channel not found');
                }
              } else {
                reject('No channel number supplied');
              }
            });
          }
        };
        var initTV = config => {
          methods = {};
          if (config.getChannel && typeof config.getChannel === 'function') {
            methods.getChannel = config.getChannel;
          }
          if (config.getProgram && typeof config.getProgram === 'function') {
            methods.getProgram = config.getProgram;
          }
          if (config.setChannel && typeof config.setChannel === 'function') {
            methods.setChannel = config.setChannel;
          }
          if (config.emit && typeof config.emit === 'function') {
            config.emit(emit$1);
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var initPin = config => {
          if (config.submit && typeof config.submit === 'function') {
            config.submit;
          }
          if (config.check && typeof config.check === 'function') {
            config.check;
          }
        };
        var executeAsPromise = function executeAsPromise(method) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var result;
          if (method && typeof method === 'function') {
            try {
              result = method.apply(context, args);
            } catch (e) {
              result = e;
            }
          } else {
            result = method;
          }

          // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
          if (result !== null && typeof result === 'object' && result.then && typeof result.then === 'function') {
            return result;
          }
          // otherwise make it into a promise
          else {
            return new Promise((resolve, reject) => {
              if (result instanceof Error) {
                reject(result);
              } else {
                resolve(result);
              }
            });
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var events$1 = {
          abort: 'Abort',
          canplay: 'CanPlay',
          canplaythrough: 'CanPlayThrough',
          durationchange: 'DurationChange',
          emptied: 'Emptied',
          encrypted: 'Encrypted',
          ended: 'Ended',
          error: 'Error',
          interruptbegin: 'InterruptBegin',
          interruptend: 'InterruptEnd',
          loadeddata: 'LoadedData',
          loadedmetadata: 'LoadedMetadata',
          loadstart: 'LoadStart',
          pause: 'Pause',
          play: 'Play',
          playing: 'Playing',
          progress: 'Progress',
          ratechange: 'Ratechange',
          seeked: 'Seeked',
          seeking: 'Seeking',
          stalled: 'Stalled',
          // suspend: 'Suspend', // this one is called a looooot for some videos
          timeupdate: 'TimeUpdate',
          volumechange: 'VolumeChange',
          waiting: 'Waiting'
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var autoSetupMixin = function autoSetupMixin(sourceObject) {
          var setup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
          var ready = false;
          var doSetup = () => {
            if (ready === false) {
              setup();
              ready = true;
            }
          };
          return Object.keys(sourceObject).reduce((obj, key) => {
            if (typeof sourceObject[key] === 'function') {
              obj[key] = function () {
                doSetup();
                return sourceObject[key].apply(sourceObject, arguments);
              };
            } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
              obj.__defineGetter__(key, function () {
                doSetup();
                return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
              });
            } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
              obj.__defineSetter__(key, function () {
                doSetup();
                return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(sourceObject, arguments);
              });
            } else {
              obj[key] = sourceObject[key];
            }
            return obj;
          }, {});
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var timeout = null;
        var easeExecution = (cb, delay) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            cb();
          }, delay);
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var VideoTexture = () => {
          return class VideoTexture extends Lightning.Component {
            static _template() {
              return {
                Video: {
                  alpha: 1,
                  visible: false,
                  pivot: 0.5,
                  texture: {
                    type: Lightning.textures.StaticTexture,
                    options: {}
                  }
                }
              };
            }
            set videoEl(v) {
              this._videoEl = v;
            }
            get videoEl() {
              return this._videoEl;
            }
            get videoView() {
              return this.tag('Video');
            }
            get videoTexture() {
              return this.videoView.texture;
            }
            get isVisible() {
              return this.videoView.alpha === 1 && this.videoView.visible === true;
            }
            _init() {
              this._createVideoTexture();
            }
            _createVideoTexture() {
              var stage = this.stage;
              var gl = stage.gl;
              var glTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              this.videoTexture.options = {
                source: glTexture,
                w: this.videoEl.width,
                h: this.videoEl.height
              };
              this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
              this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
            }
            start() {
              var stage = this.stage;
              this._lastTime = 0;
              if (!this._updateVideoTexture) {
                this._updateVideoTexture = () => {
                  if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
                    var gl = stage.gl;
                    var currentTime = new Date().getTime();
                    var getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();

                    // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
                    // We'll fallback to fixed 30fps in this case.
                    // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
                    var frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
                    var mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
                    if (mustUpdate) {
                      this._lastTime = currentTime;
                      this._lastFrame = frameCount;
                      try {
                        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                        this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                        this.videoView.visible = true;
                        this.videoTexture.options.w = this.videoEl.width;
                        this.videoTexture.options.h = this.videoEl.height;
                        var expectedAspectRatio = this.videoView.w / this.videoView.h;
                        var realAspectRatio = this.videoEl.width / this.videoEl.height;
                        if (expectedAspectRatio > realAspectRatio) {
                          this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                          this.videoView.scaleY = 1;
                        } else {
                          this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                          this.videoView.scaleX = 1;
                        }
                      } catch (e) {
                        Log.error('texImage2d video', e);
                        this.stop();
                      }
                      this.videoTexture.source.forceRenderUpdate();
                    }
                  }
                };
              }
              if (!this._updatingVideoTexture) {
                stage.on('frameStart', this._updateVideoTexture);
                this._updatingVideoTexture = true;
              }
            }
            stop() {
              var stage = this.stage;
              stage.removeListener('frameStart', this._updateVideoTexture);
              this._updatingVideoTexture = false;
              this.videoView.visible = false;
              if (this.videoTexture.options.source) {
                var gl = stage.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            }
            position(top, left) {
              this.videoView.patch({
                smooth: {
                  x: left,
                  y: top
                }
              });
            }
            size(width, height) {
              this.videoView.patch({
                smooth: {
                  w: width,
                  h: height
                }
              });
            }
            show() {
              this.videoView.setSmooth('alpha', 1);
            }
            hide() {
              this.videoView.setSmooth('alpha', 0);
            }
          };
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var mediaUrl$1 = url => url;
        var videoEl;
        var videoTexture;
        var metrics;
        var consumer$1;
        var precision = 1;
        var textureMode = false;
        var initVideoPlayer = config => {
          if (config.mediaUrl) {
            mediaUrl$1 = config.mediaUrl;
          }
        };
        // todo: add this in a 'Registry' plugin
        // to be able to always clean this up on app close
        var eventHandlers = {};
        var state$1 = {
          adsEnabled: false,
          playing: false,
          _playingAds: false,
          get playingAds() {
            return this._playingAds;
          },
          set playingAds(val) {
            if (this._playingAds !== val) {
              this._playingAds = val;
              fireOnConsumer$1(val === true ? 'AdStart' : 'AdEnd');
            }
          },
          skipTime: false,
          playAfterSeek: null
        };
        var hooks = {
          play() {
            state$1.playing = true;
          },
          pause() {
            state$1.playing = false;
          },
          seeked() {
            state$1.playAfterSeek === true && videoPlayerPlugin.play();
            state$1.playAfterSeek = null;
          },
          abort() {
            deregisterEventListeners();
          }
        };
        var withPrecision = val => Math.round(precision * val) + 'px';
        var fireOnConsumer$1 = (event, args) => {
          if (consumer$1) {
            consumer$1.fire('$videoPlayer' + event, args, videoEl.currentTime);
            consumer$1.fire('$videoPlayerEvent', event, args, videoEl.currentTime);
          }
        };
        var fireHook = (event, args) => {
          hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args);
        };
        var customLoader = null;
        var customUnloader = null;
        var loader$1 = (url, videoEl, config) => {
          return customLoader && typeof customLoader === 'function' ? customLoader(url, videoEl, config) : new Promise(resolve => {
            url = mediaUrl$1(url);
            videoEl.setAttribute('src', url);
            videoEl.load();
            resolve();
          });
        };
        var unloader = videoEl => {
          return customUnloader && typeof customUnloader === 'function' ? customUnloader(videoEl) : new Promise(resolve => {
            videoEl.removeAttribute('src');
            videoEl.load();
            resolve();
          });
        };
        var setupVideoTag = () => {
          var videoEls = document.getElementsByTagName('video');
          if (videoEls && videoEls.length) {
            return videoEls[0];
          } else {
            var _videoEl = document.createElement('video');
            var platformSettingsWidth = Settings.get('platform', 'width') ? Settings.get('platform', 'width') : 1920;
            var platformSettingsHeight = Settings.get('platform', 'height') ? Settings.get('platform', 'height') : 1080;
            _videoEl.setAttribute('id', 'video-player');
            _videoEl.setAttribute('width', withPrecision(platformSettingsWidth));
            _videoEl.setAttribute('height', withPrecision(platformSettingsHeight));
            _videoEl.style.position = 'absolute';
            _videoEl.style.zIndex = '1';
            _videoEl.style.display = 'none';
            _videoEl.style.visibility = 'hidden';
            _videoEl.style.top = withPrecision(0);
            _videoEl.style.left = withPrecision(0);
            _videoEl.style.width = withPrecision(platformSettingsWidth);
            _videoEl.style.height = withPrecision(platformSettingsHeight);
            document.body.appendChild(_videoEl);
            return _videoEl;
          }
        };
        var setUpVideoTexture = () => {
          if (!ApplicationInstance$1.tag('VideoTexture')) {
            var el = ApplicationInstance$1.stage.c({
              type: VideoTexture(),
              ref: 'VideoTexture',
              zIndex: 0,
              videoEl
            });
            ApplicationInstance$1.childList.addAt(el, 0);
          }
          return ApplicationInstance$1.tag('VideoTexture');
        };
        var registerEventListeners = () => {
          Log.info('VideoPlayer', 'Registering event listeners');
          Object.keys(events$1).forEach(event => {
            var handler = e => {
              // Fire a metric for each event (if it exists on the metrics object)
              if (metrics && metrics[event] && typeof metrics[event] === 'function') {
                metrics[event]({
                  currentTime: videoEl.currentTime
                });
              }
              // fire an internal hook
              fireHook(event, {
                videoElement: videoEl,
                event: e
              });

              // fire the event (with human friendly event name) to the consumer of the VideoPlayer
              fireOnConsumer$1(events$1[event], {
                videoElement: videoEl,
                event: e
              });
            };
            eventHandlers[event] = handler;
            videoEl.addEventListener(event, handler);
          });
        };
        var deregisterEventListeners = () => {
          Log.info('VideoPlayer', 'Deregistering event listeners');
          Object.keys(eventHandlers).forEach(event => {
            videoEl.removeEventListener(event, eventHandlers[event]);
          });
          eventHandlers = {};
        };
        var videoPlayerPlugin = {
          consumer(component) {
            consumer$1 = component;
          },
          loader(loaderFn) {
            customLoader = loaderFn;
          },
          unloader(unloaderFn) {
            customUnloader = unloaderFn;
          },
          position() {
            var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            videoEl.style.left = withPrecision(left);
            videoEl.style.top = withPrecision(top);
            if (textureMode === true) {
              videoTexture.position(top, left);
            }
          },
          size() {
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1920;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1080;
            videoEl.style.width = withPrecision(width);
            videoEl.style.height = withPrecision(height);
            videoEl.width = parseFloat(videoEl.style.width);
            videoEl.height = parseFloat(videoEl.style.height);
            if (textureMode === true) {
              videoTexture.size(width, height);
            }
          },
          area() {
            var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1920;
            var bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1080;
            var left = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            this.position(top, left);
            this.size(right - left, bottom - top);
          },
          open(url) {
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (!this.canInteract) return;
            metrics = Metrics$1.media(url);
            this.hide();
            deregisterEventListeners();
            if (this.src == url) {
              this.clear().then(this.open(url, config));
            } else {
              var adConfig = {
                enabled: state$1.adsEnabled,
                duration: 300
              };
              if (config.videoId) {
                adConfig.caid = config.videoId;
              }
              Ads$1.get(adConfig, consumer$1).then(ads => {
                state$1.playingAds = true;
                ads.prerolls().then(() => {
                  state$1.playingAds = false;
                  loader$1(url, videoEl, config).then(() => {
                    registerEventListeners();
                    this.show();
                    this.play();
                  }).catch(e => {
                    fireOnConsumer$1('error', {
                      videoElement: videoEl,
                      event: e
                    });
                  });
                });
              });
            }
          },
          reload() {
            if (!this.canInteract) return;
            var url = videoEl.getAttribute('src');
            this.close();
            this.open(url);
          },
          close() {
            Ads$1.cancel();
            if (state$1.playingAds) {
              state$1.playingAds = false;
              Ads$1.stop();
              // call self in next tick
              setTimeout(() => {
                this.close();
              });
            }
            if (!this.canInteract) return;
            this.clear();
            this.hide();
            deregisterEventListeners();
          },
          clear() {
            if (!this.canInteract) return;
            // pause the video first to disable sound
            this.pause();
            if (textureMode === true) videoTexture.stop();
            return unloader(videoEl).then(() => {
              fireOnConsumer$1('Clear', {
                videoElement: videoEl
              });
            });
          },
          play() {
            if (!this.canInteract) return;
            if (textureMode === true) videoTexture.start();
            executeAsPromise(videoEl.play, null, videoEl).catch(e => {
              fireOnConsumer$1('error', {
                videoElement: videoEl,
                event: e
              });
            });
          },
          pause() {
            if (!this.canInteract) return;
            videoEl.pause();
          },
          playPause() {
            if (!this.canInteract) return;
            this.playing === true ? this.pause() : this.play();
          },
          mute() {
            var muted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            if (!this.canInteract) return;
            videoEl.muted = muted;
          },
          loop() {
            var looped = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            videoEl.loop = looped;
          },
          seek(time) {
            if (!this.canInteract) return;
            if (!this.src) return;
            // define whether should continue to play after seek is complete (in seeked hook)
            if (state$1.playAfterSeek === null) {
              state$1.playAfterSeek = !!state$1.playing;
            }
            // pause before actually seeking
            this.pause();
            // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
            videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
          },
          skip(seconds) {
            if (!this.canInteract) return;
            if (!this.src) return;
            state$1.skipTime = (state$1.skipTime || videoEl.currentTime) + seconds;
            easeExecution(() => {
              this.seek(state$1.skipTime);
              state$1.skipTime = false;
            }, 300);
          },
          show() {
            if (!this.canInteract) return;
            if (textureMode === true) {
              videoTexture.show();
            } else {
              videoEl.style.display = 'block';
              videoEl.style.visibility = 'visible';
            }
          },
          hide() {
            if (!this.canInteract) return;
            if (textureMode === true) {
              videoTexture.hide();
            } else {
              videoEl.style.display = 'none';
              videoEl.style.visibility = 'hidden';
            }
          },
          enableAds() {
            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            state$1.adsEnabled = enabled;
          },
          /* Public getters */
          get duration() {
            return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
          },
          get currentTime() {
            return videoEl && videoEl.currentTime;
          },
          get muted() {
            return videoEl && videoEl.muted;
          },
          get looped() {
            return videoEl && videoEl.loop;
          },
          get src() {
            return videoEl && videoEl.getAttribute('src');
          },
          get playing() {
            return state$1.playing;
          },
          get playingAds() {
            return state$1.playingAds;
          },
          get canInteract() {
            // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
            return state$1.playingAds === false;
          },
          get top() {
            return videoEl && parseFloat(videoEl.style.top);
          },
          get left() {
            return videoEl && parseFloat(videoEl.style.left);
          },
          get bottom() {
            return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
          },
          get right() {
            return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
          },
          get width() {
            return videoEl && parseFloat(videoEl.style.width);
          },
          get height() {
            return videoEl && parseFloat(videoEl.style.height);
          },
          get visible() {
            if (textureMode === true) {
              return videoTexture.isVisible;
            } else {
              return videoEl && videoEl.style.display === 'block';
            }
          },
          get adsEnabled() {
            return state$1.adsEnabled;
          },
          // prefixed with underscore to indicate 'semi-private'
          // because it's not recommended to interact directly with the video element
          get _videoEl() {
            return videoEl;
          },
          get _consumer() {
            return consumer$1;
          }
        };
        var VideoPlayer = autoSetupMixin(videoPlayerPlugin, () => {
          precision = ApplicationInstance$1 && ApplicationInstance$1.stage && ApplicationInstance$1.stage.getRenderPrecision() || precision;
          videoEl = setupVideoTag();
          textureMode = Settings.get('platform', 'textureMode', false);
          if (textureMode === true) {
            videoEl.setAttribute('crossorigin', 'anonymous');
            videoTexture = setUpVideoTexture();
          }
        });

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var consumer;
        var getAds = () => {
          // todo: enable some default ads during development, maybe from the settings.json
          return Promise.resolve({
            prerolls: [],
            midrolls: [],
            postrolls: []
          });
        };
        var initAds = config => {
          if (config.getAds) {
            getAds = config.getAds;
          }
        };
        var state = {
          active: false
        };
        var playSlot = function playSlot() {
          var slot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return slot.reduce((promise, ad) => {
            return promise.then(() => {
              return playAd(ad);
            });
          }, Promise.resolve(null));
        };
        var playAd = ad => {
          return new Promise(resolve => {
            if (state.active === false) {
              Log$1.info('Ad', 'Skipping add due to inactive state');
              return resolve();
            }
            // is it safe to rely on videoplayer plugin already created the video tag?
            var videoEl = document.getElementsByTagName('video')[0];
            videoEl.style.display = 'block';
            videoEl.style.visibility = 'visible';
            videoEl.src = mediaUrl$1(ad.url);
            videoEl.load();
            var timeEvents = null;
            var timeout;
            var cleanup = () => {
              // remove all listeners
              Object.keys(handlers).forEach(handler => videoEl.removeEventListener(handler, handlers[handler]));
              resolve();
            };
            var handlers = {
              play() {
                Log$1.info('Ad', 'Play ad', ad.url);
                fireOnConsumer('Play', ad);
                sendBeacon(ad.callbacks, 'defaultImpression');
              },
              ended() {
                fireOnConsumer('Ended', ad);
                sendBeacon(ad.callbacks, 'complete');
                cleanup();
              },
              timeupdate() {
                if (!timeEvents && videoEl.duration) {
                  // calculate when to fire the time based events (now that duration is known)
                  timeEvents = {
                    firstQuartile: videoEl.duration / 4,
                    midPoint: videoEl.duration / 2,
                    thirdQuartile: videoEl.duration / 4 * 3
                  };
                  Log$1.info('Ad', 'Calculated quartiles times', {
                    timeEvents
                  });
                }
                if (timeEvents && timeEvents.firstQuartile && videoEl.currentTime >= timeEvents.firstQuartile) {
                  fireOnConsumer('FirstQuartile', ad);
                  delete timeEvents.firstQuartile;
                  sendBeacon(ad.callbacks, 'firstQuartile');
                }
                if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
                  fireOnConsumer('MidPoint', ad);
                  delete timeEvents.midPoint;
                  sendBeacon(ad.callbacks, 'midPoint');
                }
                if (timeEvents && timeEvents.thirdQuartile && videoEl.currentTime >= timeEvents.thirdQuartile) {
                  fireOnConsumer('ThirdQuartile', ad);
                  delete timeEvents.thirdQuartile;
                  sendBeacon(ad.callbacks, 'thirdQuartile');
                }
              },
              stalled() {
                fireOnConsumer('Stalled', ad);
                timeout = setTimeout(() => {
                  cleanup();
                }, 5000); // make timeout configurable
              },

              canplay() {
                timeout && clearTimeout(timeout);
              },
              error() {
                fireOnConsumer('Error', ad);
                cleanup();
              },
              // this doesn't work reliably on sky box, moved logic to timeUpdate event
              // loadedmetadata() {
              //   // calculate when to fire the time based events (now that duration is known)
              //   timeEvents = {
              //     firstQuartile: videoEl.duration / 4,
              //     midPoint: videoEl.duration / 2,
              //     thirdQuartile: (videoEl.duration / 4) * 3,
              //   }
              // },
              abort() {
                cleanup();
              }
              // todo: pause, resume, mute, unmute beacons
            };
            // add all listeners
            Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]));
            videoEl.play();
          });
        };
        var sendBeacon = (callbacks, event) => {
          if (callbacks && callbacks[event]) {
            Log$1.info('Ad', 'Sending beacon', event, callbacks[event]);
            return callbacks[event].reduce((promise, url) => {
              return promise.then(() => fetch(url)
              // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
              // note: for fetch failed http responses don't throw an Error :)
              .then(response => {
                if (response.status === 200) {
                  fireOnConsumer('Beacon' + event + 'Sent');
                } else {
                  fireOnConsumer('Beacon' + event + 'Failed' + response.status);
                }
                Promise.resolve(null);
              }).catch(() => {
                Promise.resolve(null);
              }));
            }, Promise.resolve(null));
          } else {
            Log$1.info('Ad', 'No callback found for ' + event);
          }
        };
        var fireOnConsumer = (event, args) => {
          if (consumer) {
            consumer.fire('$ad' + event, args);
            consumer.fire('$adEvent', event, args);
          }
        };
        var Ads = {
          get(config, videoPlayerConsumer) {
            if (config.enabled === false) {
              return Promise.resolve({
                prerolls() {
                  return Promise.resolve();
                }
              });
            }
            consumer = videoPlayerConsumer;
            return new Promise(resolve => {
              Log$1.info('Ad', 'Starting session');
              getAds(config).then(ads => {
                Log$1.info('Ad', 'API result', ads);
                resolve({
                  prerolls() {
                    if (ads.preroll) {
                      state.active = true;
                      fireOnConsumer('PrerollSlotImpression', ads);
                      sendBeacon(ads.preroll.callbacks, 'slotImpression');
                      return playSlot(ads.preroll.ads).then(() => {
                        fireOnConsumer('PrerollSlotEnd', ads);
                        sendBeacon(ads.preroll.callbacks, 'slotEnd');
                        state.active = false;
                      });
                    }
                    return Promise.resolve();
                  },
                  midrolls() {
                    return Promise.resolve();
                  },
                  postrolls() {
                    return Promise.resolve();
                  }
                });
              });
            });
          },
          cancel() {
            Log$1.info('Ad', 'Cancel Ad');
            state.active = false;
          },
          stop() {
            Log$1.info('Ad', 'Stop Ad');
            state.active = false;
            // fixme: duplication
            var videoEl = document.getElementsByTagName('video')[0];
            videoEl.pause();
            videoEl.removeAttribute('src');
          }
        };
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        var isMergeableObject = function isMergeableObject(value) {
          return isNonNullObject(value) && !isSpecial(value);
        };
        function isNonNullObject(value) {
          return !!value && typeof value === 'object';
        }
        function isSpecial(value) {
          var stringValue = Object.prototype.toString.call(value);
          return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
        }

        // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
        var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
        function isReactElement(value) {
          return value.$$typeof === REACT_ELEMENT_TYPE;
        }
        function emptyTarget(val) {
          return Array.isArray(val) ? [] : {};
        }
        function cloneUnlessOtherwiseSpecified(value, options) {
          return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
        }
        function defaultArrayMerge(target, source, options) {
          return target.concat(source).map(function (element) {
            return cloneUnlessOtherwiseSpecified(element, options);
          });
        }
        function getMergeFunction(key, options) {
          if (!options.customMerge) {
            return deepmerge;
          }
          var customMerge = options.customMerge(key);
          return typeof customMerge === 'function' ? customMerge : deepmerge;
        }
        function getEnumerableOwnPropertySymbols(target) {
          return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
            return Object.propertyIsEnumerable.call(target, symbol);
          }) : [];
        }
        function getKeys(target) {
          return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
        }
        function propertyIsOnObject(object, property) {
          try {
            return property in object;
          } catch (_) {
            return false;
          }
        }

        // Protects from prototype poisoning and unexpected merging up the prototype chain.
        function propertyIsUnsafe(target, key) {
          return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
          && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
          && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
        }

        function mergeObject(target, source, options) {
          var destination = {};
          if (options.isMergeableObject(target)) {
            getKeys(target).forEach(function (key) {
              destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
            });
          }
          getKeys(source).forEach(function (key) {
            if (propertyIsUnsafe(target, key)) {
              return;
            }
            if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
              destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
            } else {
              destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
            }
          });
          return destination;
        }
        function deepmerge(target, source, options) {
          options = options || {};
          options.arrayMerge = options.arrayMerge || defaultArrayMerge;
          options.isMergeableObject = options.isMergeableObject || isMergeableObject;
          // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
          // implementations can use it. The caller may not replace it.
          options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
          var sourceIsArray = Array.isArray(source);
          var targetIsArray = Array.isArray(target);
          var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
          if (!sourceAndTargetTypesMatch) {
            return cloneUnlessOtherwiseSpecified(source, options);
          } else if (sourceIsArray) {
            return options.arrayMerge(target, source, options);
          } else {
            return mergeObject(target, source, options);
          }
        }
        deepmerge.all = function deepmergeAll(array, options) {
          if (!Array.isArray(array)) {
            throw new Error('first argument should be an array');
          }
          return array.reduce(function (prev, next) {
            return deepmerge(prev, next, options);
          }, {});
        };
        var deepmerge_1 = deepmerge;
        var cjs = deepmerge_1;
        var Deepmerge = /*@__PURE__*/getDefaultExportFromCjs(cjs);

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var warned = false;
        var deprecated = function deprecated() {
          var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          if (force === true || warned === false) {
            console.warn(["The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'Language'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language'].join('\n\n'));
          }
          warned = true;
        };
        class Locale {
          constructor() {
            this.__enabled = false;
          }

          /**
           * Loads translation object from external json file.
           *
           * @param {String} path Path to resource.
           * @return {Promise}
           */
          load(path) {
            var _this3 = this;
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              return _regeneratorRuntime().wrap(function _callee$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    if (_this3.__enabled) {
                      _context3.next = 2;
                      break;
                    }
                    return _context3.abrupt("return");
                  case 2:
                    _context3.next = 4;
                    return fetch(path).then(resp => resp.json()).then(resp => {
                      _this3.loadFromObject(resp);
                    });
                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }, _callee);
            }))();
          }

          /**
           * Sets language used by module.
           *
           * @param {String} lang
           */
          setLanguage(lang) {
            deprecated();
            this.__enabled = true;
            this.language = lang;
          }

          /**
           * Returns reference to translation object for current language.
           *
           * @return {Object}
           */
          get tr() {
            deprecated(true);
            return this.__trObj[this.language];
          }

          /**
           * Loads translation object from existing object (binds existing object).
           *
           * @param {Object} trObj
           */
          loadFromObject(trObj) {
            deprecated();
            var fallbackLanguage = 'en';
            if (Object.keys(trObj).indexOf(this.language) === -1) {
              Log$1.warn('No translations found for: ' + this.language);
              if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
                Log$1.warn('Using fallback language: ' + fallbackLanguage);
                this.language = fallbackLanguage;
              } else {
                var error = 'No translations found for fallback language: ' + fallbackLanguage;
                Log$1.error(error);
                throw Error(error);
              }
            }
            this.__trObj = trObj;
            for (var _i25 = 0, _Object$values = Object.values(this.__trObj); _i25 < _Object$values.length; _i25++) {
              var lang = _Object$values[_i25];
              for (var _i26 = 0, _Object$keys = Object.keys(lang); _i26 < _Object$keys.length; _i26++) {
                var str = _Object$keys[_i26];
                lang[str] = new LocalizedString(lang[str]);
              }
            }
          }
        }

        /**
         * Extended string class used for localization.
         */
        class LocalizedString extends String {
          /**
           * Returns formatted LocalizedString.
           * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
           *
           * E.g.:
           * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
           * A and B and A
           *
           * @param  {...any} args List of arguments for placeholders.
           */
          format() {
            for (var _len7 = arguments.length, args = new Array(_len7), _key10 = 0; _key10 < _len7; _key10++) {
              args[_key10] = arguments[_key10];
            }
            var sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this);
            return new LocalizedString(sub);
          }
        }
        var Locale$1 = new Locale();

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class VersionLabel extends lightning.Component {
          static _template() {
            return {
              rect: true,
              color: 0xbb0078ac,
              h: 40,
              w: 100,
              x: w => w - 50,
              y: h => h - 50,
              mount: 1,
              Text: {
                w: _w3 => _w3,
                h: _h => _h,
                y: 5,
                x: 20,
                text: {
                  fontSize: 22,
                  lineHeight: 26
                }
              }
            };
          }
          _firstActive() {
            this.tag('Text').text = `APP - v${this.version}\nSDK - v${this.sdkVersion}`;
            this.tag('Text').loadTexture();
            this.w = this.tag('Text').renderWidth + 40;
            this.h = this.tag('Text').renderHeight + 5;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        class FpsIndicator extends lightning.Component {
          static _template() {
            return {
              rect: true,
              color: 0xffffffff,
              texture: lightning.Tools.getRoundRect(80, 80, 40),
              h: 80,
              w: 80,
              x: 100,
              y: 100,
              mount: 1,
              Background: {
                x: 3,
                y: 3,
                texture: lightning.Tools.getRoundRect(72, 72, 36),
                color: 0xff008000
              },
              Counter: {
                w: _w4 => _w4,
                h: _h2 => _h2,
                y: 10,
                text: {
                  fontSize: 32,
                  textAlign: 'center'
                }
              },
              Text: {
                w: _w5 => _w5,
                h: _h3 => _h3,
                y: 48,
                text: {
                  fontSize: 15,
                  textAlign: 'center',
                  text: 'FPS'
                }
              }
            };
          }
          _setup() {
            this.config = _objectSpread(_objectSpread({}, {
              log: false,
              interval: 500,
              threshold: 1
            }), Settings$1.get('platform', 'showFps'));
            this.fps = 0;
            this.lastFps = this.fps - this.config.threshold;
            var fpsCalculator = () => {
              this.fps = ~~(1 / this.stage.dt);
            };
            this.stage.on('frameStart', fpsCalculator);
            this.stage.off('framestart', fpsCalculator);
            this.interval = setInterval(this.showFps.bind(this), this.config.interval);
          }
          _firstActive() {
            this.showFps();
          }
          _detach() {
            clearInterval(this.interval);
          }
          showFps() {
            if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return;
            this.lastFps = this.fps;
            // green
            var bgColor = 0xff008000;
            // orange
            if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500;
            // red
            else if (this.fps <= 20) bgColor = 0xffff0000;
            this.tag('Background').setSmooth('color', bgColor);
            this.tag('Counter').text = `${this.fps}`;
            this.config.log && Log$1.info('FPS', this.fps);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var fetchJson = file => {
          return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
              if (xhr.readyState == XMLHttpRequest.DONE) {
                // file protocol returns 0
                // http(s) protocol returns 200
                if (xhr.status === 0 || xhr.status === 200) resolve(JSON.parse(xhr.responseText));else reject(xhr.statusText);
              }
            };
            xhr.open('GET', file);
            xhr.send(null);
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var basePath;
        var proxyUrl;
        var initUtils = config => {
          basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'));
          if (config.proxyUrl) {
            proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
          }
        };
        var Utils = {
          asset(relPath) {
            return basePath + relPath;
          },
          proxyUrl(url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url;
          },
          makeQueryString() {
            return makeQueryString(...arguments);
          },
          // since imageworkers don't work without protocol
          ensureUrlWithProtocol() {
            return ensureUrlWithProtocol(...arguments);
          }
        };
        var ensureUrlWithProtocol = url => {
          if (/^\/[^/]/i.test(url) && /^(?:file:)/i.test(window.location.protocol)) {
            return window.location.protocol + '//' + url;
          }
          if (/^\/\//.test(url)) {
            return window.location.protocol + url;
          }
          if (!/^(?:https?:)/i.test(url)) {
            return window.location.origin + url;
          }
          return url;
        };
        var makeFullStaticPath = function makeFullStaticPath() {
          var pathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
          var path = arguments.length > 1 ? arguments[1] : undefined;
          // ensure path has traling slash
          path = path.charAt(path.length - 1) !== '/' ? path + '/' : path;

          // if path is URL, we assume it's already the full static path, so we just return it
          if (/^(?:https?:)?(?:\/\/)/.test(path)) {
            return path;
          }
          if (path.charAt(0) === '/') {
            return path;
          } else {
            // cleanup the pathname (i.e. remove possible index.html)
            pathname = cleanUpPathName(pathname);

            // remove possible leading dot from path
            path = path.charAt(0) === '.' ? path.substr(1) : path;
            // ensure path has leading slash
            path = path.charAt(0) !== '/' ? '/' + path : path;
            return pathname + path;
          }
        };
        var cleanUpPathName = pathname => {
          if (pathname.slice(-1) === '/') return pathname.slice(0, -1);
          var parts = pathname.split('/');
          if (parts[parts.length - 1].indexOf('.') > -1) parts.pop();
          return parts.join('/');
        };
        var makeQueryString = function makeQueryString(url) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'url';
          // add operator as an option
          options.operator = 'metrological'; // Todo: make this configurable (via url?)
          // add type (= url or qr) as an option, with url as the value
          options[type] = url;
          return Object.keys(options).map(key => {
            return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key]);
          }).join('&');
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var meta = {};
        var translations = {};
        var language = null;
        var initLanguage = function initLanguage(file) {
          var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return new Promise((resolve, reject) => {
            fetchJson(file).then(json => {
              setTranslations(json);
              // set language (directly or in a promise)
              typeof language === 'object' && 'then' in language && typeof language.then === 'function' ? language.then(lang => setLanguage(lang).then(resolve).catch(reject)).catch(e => {
                Log$1.error(e);
                reject(e);
              }) : setLanguage(language).then(resolve).catch(reject);
            }).catch(() => {
              var error = 'Language file ' + file + ' not found';
              Log$1.error(error);
              reject(error);
            });
          });
        };
        var setTranslations = obj => {
          if ('meta' in obj) {
            meta = _objectSpread({}, obj.meta);
            delete obj.meta;
          }
          translations = obj;
        };
        var setLanguage = lng => {
          language = null;
          return new Promise((resolve, reject) => {
            if (lng in translations) {
              language = lng;
            } else {
              if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
                language = meta.map[lng];
              } else if ('default' in meta && meta.default in translations) {
                var error = 'Translations for Language ' + language + ' not found. Using default language ' + meta.default;
                Log$1.warn(error);
                language = meta.default;
              } else {
                var _error = 'Translations for Language ' + language + ' not found.';
                Log$1.error(_error);
                reject(_error);
              }
            }
            if (language) {
              Log$1.info('Setting language to', language);
              var translationsObj = translations[language];
              if (typeof translationsObj === 'object') {
                resolve();
              } else if (typeof translationsObj === 'string') {
                var url = Utils.asset(translationsObj);
                fetchJson(url).then(json => {
                  // save the translations for this language (to prevent loading twice)
                  translations[language] = json;
                  resolve();
                }).catch(e => {
                  var error = 'Error while fetching ' + url;
                  Log$1.error(error, e);
                  reject(error);
                });
              }
            }
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var registry = {
          eventListeners: [],
          timeouts: [],
          intervals: [],
          targets: []
        };
        var Registry = {
          // Timeouts
          setTimeout(cb, timeout) {
            for (var _len8 = arguments.length, params = new Array(_len8 > 2 ? _len8 - 2 : 0), _key11 = 2; _key11 < _len8; _key11++) {
              params[_key11 - 2] = arguments[_key11];
            }
            var timeoutId = setTimeout(() => {
              registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
              cb.apply(null, params);
            }, timeout, params);
            Log$1.info('Set Timeout', 'ID: ' + timeoutId);
            registry.timeouts.push(timeoutId);
            return timeoutId;
          },
          clearTimeout(timeoutId) {
            if (registry.timeouts.indexOf(timeoutId) > -1) {
              registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
              Log$1.info('Clear Timeout', 'ID: ' + timeoutId);
              clearTimeout(timeoutId);
            } else {
              Log$1.error('Clear Timeout', 'ID ' + timeoutId + ' not found');
            }
          },
          clearTimeouts() {
            registry.timeouts.forEach(timeoutId => {
              this.clearTimeout(timeoutId);
            });
          },
          // Intervals
          setInterval(cb, interval) {
            for (var _len9 = arguments.length, params = new Array(_len9 > 2 ? _len9 - 2 : 0), _key12 = 2; _key12 < _len9; _key12++) {
              params[_key12 - 2] = arguments[_key12];
            }
            var intervalId = setInterval(() => {
              registry.intervals.filter(id => id !== intervalId);
              cb.apply(null, params);
            }, interval, params);
            Log$1.info('Set Interval', 'ID: ' + intervalId);
            registry.intervals.push(intervalId);
            return intervalId;
          },
          clearInterval(intervalId) {
            if (registry.intervals.indexOf(intervalId) > -1) {
              registry.intervals = registry.intervals.filter(id => id !== intervalId);
              Log$1.info('Clear Interval', 'ID: ' + intervalId);
              clearInterval(intervalId);
            } else {
              Log$1.error('Clear Interval', 'ID ' + intervalId + ' not found');
            }
          },
          clearIntervals() {
            registry.intervals.forEach(intervalId => {
              this.clearInterval(intervalId);
            });
          },
          // Event listeners
          addEventListener(target, event, handler) {
            target.addEventListener(event, handler);
            var targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
            registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
            registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
            registry.eventListeners[targetIndex][event].push(handler);
            Log$1.info('Add eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
          },
          removeEventListener(target, event, handler) {
            var targetIndex = registry.targets.indexOf(target);
            if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
              registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter(fn => fn !== handler);
              Log$1.info('Remove eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
              target.removeEventListener(event, handler);
            } else {
              Log$1.error('Remove eventListener', 'Not found', 'Target', target, 'Event: ' + event, 'Handler', handler.toString());
            }
          },
          // if `event` is omitted, removes all registered event listeners for target
          // if `target` is also omitted, removes all registered event listeners
          removeEventListeners(target, event) {
            if (target && event) {
              var targetIndex = registry.targets.indexOf(target);
              if (targetIndex > -1) {
                registry.eventListeners[targetIndex][event].forEach(handler => {
                  this.removeEventListener(target, event, handler);
                });
              }
            } else if (target) {
              var _targetIndex = registry.targets.indexOf(target);
              if (_targetIndex > -1) {
                Object.keys(registry.eventListeners[_targetIndex]).forEach(_event => {
                  this.removeEventListeners(target, _event);
                });
              }
            } else {
              Object.keys(registry.eventListeners).forEach(targetIndex => {
                this.removeEventListeners(registry.targets[targetIndex]);
              });
            }
          },
          // Clear everything (to be called upon app close for proper cleanup)
          clear() {
            this.clearTimeouts();
            this.clearIntervals();
            this.removeEventListeners();
            registry.eventListeners = [];
            registry.timeouts = [];
            registry.intervals = [];
            registry.targets = [];
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var isObject$2 = v => {
          return typeof v === 'object' && v !== null;
        };
        var isString$2 = v => {
          return typeof v === 'string';
        };
        var getRgbaComponents = argb => {
          return {
            r: (argb / 65536 | 0) % 256,
            g: (argb / 256 | 0) % 256,
            b: argb * 1 % 256,
            a: argb / 16777216 | 0
          };
        };
        var mergeColors = (c1, c2, p) => {
          var r1 = (c1 / 65536 | 0) % 256;
          var g1 = (c1 / 256 | 0) % 256;
          var b1 = c1 % 256;
          var a1 = c1 / 16777216 | 0;
          var r2 = (c2 / 65536 | 0) % 256;
          var g2 = (c2 / 256 | 0) % 256;
          var b2 = c2 % 256;
          var a2 = c2 / 16777216 | 0;
          var r = r1 * p + r2 * (1 - p);
          var g = g1 * p + g2 * (1 - p);
          var b = b1 * p + b2 * (1 - p);
          var a = a1 * p + a2 * (1 - p);
          return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
        };
        var calculateAlpha = (argb, p) => {
          if (p > 1) {
            p /= 100;
          } else if (p < 0) {
            p = 0;
          }
          var r = (argb / 65536 | 0) % 256;
          var g = (argb / 256 | 0) % 256;
          var b = argb % 256;
          return (r << 16) + (g << 8) + b + (Math.round(p * 255) | 0) * 16777216;
        };
        var getArgbNumber = rgba => {
          rgba[0] = Math.max(0, Math.min(255, rgba[0]));
          rgba[1] = Math.max(0, Math.min(255, rgba[1]));
          rgba[2] = Math.max(0, Math.min(255, rgba[2]));
          rgba[3] = Math.max(0, Math.min(255, rgba[3]));
          var v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
          if (v < 0) {
            v = 0xffffffff + v + 1;
          }
          return v;
        };
        var argbToHSLA = argb => {
          var col = getRgbaComponents(argb);
          var r = col.r / 255;
          var g = col.g / 255;
          var b = col.b / 255;
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h = 0;
          var s = 0;
          var l = (min + max) * 0.5;
          if (l > 0) {
            var maxMin = max - min;
            if (maxMin > 0) {
              var r2 = (max - r) / maxMin;
              var g2 = (max - g) / maxMin;
              var b2 = (max - b) / maxMin;
              if (l < 0.5) {
                s = max + min;
              } else {
                s = 2 - max - min;
              }
              if (r === max && g === min) {
                h = 5.0 + b2;
              } else if (r === max) {
                h = 1.0 - g2;
              } else if (g === max && b === min) {
                h = 1.0 + r2;
              } else if (g === max) {
                h = 3.0 - b2;
              } else if (b === max) {
                h = 3.0 + g2;
              } else {
                h = 5.0 - r2;
              }
              h = h / 6;
            }
          }
          return {
            h: h % 1,
            s,
            l,
            a: col.a
          };
        };
        var hslaToARGB = hsla => {
          var r = 1;
          var g = 1;
          var b = 1;
          var h = hsla.h;
          var s = hsla.s;
          var l = hsla.l;
          if (h < 0) {
            h += 1;
          }
          var max = 0;
          if (l <= 0.5) {
            max = l * (1.0 + s);
          } else {
            max = l + s - l * s;
          }
          if (max > 0) {
            h *= 6.0;
            var min = l + l - max;
            var minMax = (max - min) / max;
            var sextant = Math.floor(h);
            var fract = h - sextant;
            var minMaxFract = max * minMax * fract;
            var mid1 = min + minMaxFract;
            var mid2 = max - minMaxFract;
            if (sextant === 0) {
              r = max;
              g = mid1;
              b = min;
            }
            if (sextant === 1) {
              r = mid2;
              g = max;
              b = min;
            }
            if (sextant === 2) {
              r = min;
              g = max;
              b = mid1;
            }
            if (sextant === 3) {
              r = min;
              g = mid2;
              b = max;
            }
            if (sextant === 4) {
              r = mid1;
              g = min;
              b = max;
            }
            if (sextant === 5) {
              r = max;
              g = min;
              b = mid2;
            }
          }
          return getArgbNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), hsla.a]);
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var colors = {
          white: '#ffffff',
          black: '#000000',
          red: '#ff0000',
          green: '#00ff00',
          blue: '#0000ff',
          yellow: '#feff00',
          cyan: '#00feff',
          magenta: '#ff00ff'
        };
        var normalizedColors = {
          //store for normalized colors
        };
        var addColors = (colorsToAdd, value) => {
          if (isObject$2(colorsToAdd)) {
            // clean up normalizedColors if they exist in the to be added colors
            Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color));
            colors = Object.assign({}, colors, colorsToAdd);
          } else if (isString$2(colorsToAdd) && value) {
            cleanUpNormalizedColors(colorsToAdd);
            colors[colorsToAdd] = value;
          }
        };
        var cleanUpNormalizedColors = color => {
          for (var c in normalizedColors) {
            if (c.indexOf(color) > -1) {
              delete normalizedColors[c];
            }
          }
        };
        var initColors = file => {
          return new Promise((resolve, reject) => {
            if (typeof file === 'object') {
              addColors(file);
              return resolve();
            }
            fetchJson(file).then(json => {
              addColors(json);
              return resolve();
            }).catch(() => {
              var error = 'Colors file ' + file + ' not found';
              Log$1.error(error);
              return reject(error);
            });
          });
        };
        var normalizeColorToARGB = color => {
          var targetColor = normalizedColors[color] || colors[color] || color;
          if (!targetColor) {
            targetColor = color;
          }
          var check = /^#([0-9A-F]{3}|[0-9A-F]{6})$/i;
          if (isString$2(targetColor) && check.test(targetColor)) {
            var hex = check.exec(targetColor)[1];
            if (hex.length === 3) {
              hex = hex.split('').map(value => {
                return value + value;
              }).join('');
            }
            targetColor = `0xff${hex}` * 1;
          }
          if (!normalizedColors[color]) {
            normalizedColors[color] = targetColor;
          }
          return targetColor || 0xffffffff;
        };
        var Colors = color => {
          return Color.generate(color);
        };
        var Color = {
          color: null,
          generate: function generate() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;
            if (normalizedColors[value]) {
              this.color = normalizedColors[value];
            } else {
              this.color = normalizeColorToARGB(value);
            }
            return this;
          },
          get() {
            return this.color;
          },
          alpha: function alpha(percentage) {
            this.color = calculateAlpha(this.color, Math.abs(percentage));
            return this;
          },
          darker(percentage) {
            var hsl = argbToHSLA(this.color);
            hsl.l = hsl.l * (1 - percentage);
            this.color = hslaToARGB(hsl);
            return this;
          },
          lighter(percentage) {
            var hsl = argbToHSLA(this.color);
            hsl.l = hsl.l + (1 - hsl.l) * percentage;
            this.color = hslaToARGB(hsl);
            return this;
          },
          saturation(percentage) {
            var hsl = argbToHSLA(this.color);
            hsl.s = percentage;
            this.color = hslaToARGB(hsl);
            return this;
          },
          lightness(percentage) {
            var hsl = argbToHSLA(this.color);
            hsl.l = percentage;
            this.color = hslaToARGB(hsl);
            return this;
          },
          hue(degrees) {
            var hsl = argbToHSLA(this.color);
            hsl.h = degrees;
            this.color = hslaToARGB(hsl);
            return this;
          },
          mix(argb, p) {
            this.color = mergeColors(this.color, argb, p);
            return this;
          }
        };
        var name = "@lightningjs/sdk";
        var version = "5.3.1";
        var license = "Apache-2.0";
        var types = "index.d.ts";
        var scripts = {
          postinstall: "node ./scripts/postinstall.js",
          lint: "eslint '**/*.js'",
          release: "npm publish --access public",
          typedoc: "typedoc --tsconfig tsconfig.typedoc.json",
          tsd: "tsd"
        };
        var husky = {
          hooks: {
            "pre-commit": "lint-staged"
          }
        };
        var dependencies = {
          "@babel/polyfill": "^7.11.5",
          "@lightningjs/core": "^2.7.0",
          "@metrological/sdk": "^1.0.0",
          "@michieljs/execute-as-promise": "^1.0.0",
          deepmerge: "^4.2.2",
          localcookies: "^2.0.0",
          shelljs: "^0.8.5",
          "url-polyfill": "^1.1.10",
          "whatwg-fetch": "^3.0.0"
        };
        var devDependencies = {
          "@babel/core": "^7.11.6",
          "@babel/plugin-transform-parameters": "^7.10.5 ",
          "@babel/plugin-transform-spread": "^7.11.0",
          "@babel/preset-env": "^7.11.5",
          "babel-eslint": "^10.1.0",
          eslint: "^7.10.0",
          "eslint-config-prettier": "^6.12.0",
          "eslint-plugin-prettier": "^3.1.4",
          husky: "^4.3.0",
          "lint-staged": "^10.4.0",
          prettier: "^1.19.1",
          rollup: "^1.32.1",
          "rollup-plugin-babel": "^4.4.0",
          tsd: "^0.22.0",
          typedoc: "^0.23.9"
        };
        var repository = {
          type: "git",
          url: "git@github.com:rdkcentral/Lightning-SDK.git"
        };
        var bugs = {
          url: "https://github.com/rdkcentral/Lightning-SDK/issues"
        };
        var packageInfo = {
          name: name,
          version: version,
          license: license,
          types: types,
          scripts: scripts,
          "lint-staged": {
            "*.js": ["eslint --fix"],
            "src/startApp.js": ["rollup -c ./rollup.config.js"]
          },
          husky: husky,
          dependencies: dependencies,
          devDependencies: devDependencies,
          repository: repository,
          bugs: bugs
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var AppInstance;
        var defaultOptions = {
          stage: {
            w: 1920,
            h: 1080,
            precision: 1,
            clearColor: 0x00000000,
            canvas2d: false
          },
          debug: false,
          defaultFontFace: 'RobotoRegular',
          keys: {
            8: 'Back',
            13: 'Enter',
            27: 'Menu',
            37: 'Left',
            38: 'Up',
            39: 'Right',
            40: 'Down',
            174: 'ChannelDown',
            175: 'ChannelUp',
            178: 'Stop',
            250: 'PlayPause',
            191: 'Search',
            // Use "/" for keyboard
            409: 'Search'
          }
        };
        var customFontFaces = [];
        var fontLoader = (fonts, store) => new Promise((resolve, reject) => {
          fonts.map(_ref14 => {
            var family = _ref14.family,
              url = _ref14.url,
              urls = _ref14.urls,
              descriptors = _ref14.descriptors;
            return () => {
              var src = urls ? urls.map(url => {
                return 'url(' + url + ')';
              }) : 'url(' + url + ')';
              var fontFace = new FontFace(family, src, descriptors || {});
              store.push(fontFace);
              Log$1.info('Loading font', family);
              document.fonts.add(fontFace);
              return fontFace.load();
            };
          }).reduce((promise, method) => {
            return promise.then(() => method());
          }, Promise.resolve(null)).then(resolve).catch(reject);
        });
        function Application(App, appData, platformSettings) {
          var width = platformSettings.width,
            height = platformSettings.height;
          if (width && height) {
            defaultOptions.stage['w'] = width;
            defaultOptions.stage['h'] = height;
            defaultOptions.stage['precision'] = width / 1920;
          }

          // support for 720p browser
          if (!width && !height && window.innerHeight === 720) {
            defaultOptions.stage['w'] = 1280;
            defaultOptions.stage['h'] = 720;
            defaultOptions.stage['precision'] = 1280 / 1920;
          }
          return class Application extends lightning.Application {
            constructor(options) {
              var config = Deepmerge(defaultOptions, options);
              // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
              if (options.stage.canvas) {
                config.stage.canvas = options.stage.canvas;
              }
              super(config);
              this.config = config;
            }
            static _template() {
              return {
                w: 1920,
                h: 1080
              };
            }
            colorshift() {
              var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              Accessibility.colorshift(this, type, config);
            }
            get keymapping() {
              return this.stage.application.config.keys;
            }

            /**
             * This function overrides the default keymap with the latest keymap.
             * @param customKeyMap
             * @param keepDuplicates
             */
            overrideKeyMap(customKeyMap) {
              var keepDuplicates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var baseKeyMap = this.stage.application.config.keys;
              Object.keys(customKeyMap).reduce((keymapping, key) => {
                // prevent duplicate values to exist in final keymapping (i.e. 2 keys triggering 'Back')
                if (!keepDuplicates) {
                  Object.keys(baseKeyMap).forEach(baseKey => {
                    if (baseKey != key && baseKeyMap[baseKey] == customKeyMap[key]) {
                      delete keymapping[baseKey];
                    }
                  });
                }
                keymapping[key] = customKeyMap[key];
                return keymapping;
              }, baseKeyMap);
              return baseKeyMap;
            }
            _setup() {
              Promise.all([this.loadFonts(App.config && App.config.fonts || App.getFonts && App.getFonts() || []),
              // to be deprecated
              Locale$1.load(App.config && App.config.locale || App.getLocale && App.getLocale()), App.language && this.loadLanguage(App.language()), App.colors && this.loadColors(App.colors())]).then(() => {
                Metrics$1.app.loaded();
                this.w = this.config.stage.w / this.config.stage.precision;
                this.h = this.config.stage.h / this.config.stage.precision;
                AppInstance = this.stage.c({
                  ref: 'App',
                  type: App,
                  zIndex: 1,
                  forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
                });
                this.childList.a(AppInstance);
                this._refocus();
                Log$1.info('App version', this.config.version);
                Log$1.info('SDK version', packageInfo.version);
                if (platformSettings.showVersion) {
                  this.childList.a({
                    ref: 'VersionLabel',
                    type: VersionLabel,
                    version: this.config.version,
                    sdkVersion: packageInfo.version,
                    zIndex: 1
                  });
                }
                if (platformSettings.showFps) {
                  this.childList.a({
                    ref: 'FpsCounter',
                    type: FpsIndicator,
                    zIndex: 1
                  });
                }
                super._setup();
              }).catch(console.error);
            }
            _handleBack() {
              this.closeApp();
            }
            _handleExit() {
              this.closeApp();
            }
            closeApp() {
              Log$1.info('Signaling App Close');
              if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
                platformSettings.onClose(...arguments);
              } else {
                this.close();
              }
            }
            close() {
              Log$1.info('Closing App');
              Settings$1.clearSubscribers();
              Registry.clear();
              this.childList.remove(this.tag('App'));
              this.cleanupFonts();
              // force texture garbage collect
              this.stage.gc();
              this.destroy();
            }
            loadFonts(fonts) {
              return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function' ? platformSettings.fontLoader(fonts, customFontFaces) : fontLoader(fonts, customFontFaces);
            }
            cleanupFonts() {
              if ('delete' in document.fonts) {
                customFontFaces.forEach(fontFace => {
                  Log$1.info('Removing font', fontFace.family);
                  document.fonts.delete(fontFace);
                });
              } else {
                Log$1.info('No support for removing manually-added fonts');
              }
            }
            loadLanguage(config) {
              var file = Utils.asset('translations.json');
              var language = config;
              if (typeof language === 'object') {
                language = config.language || null;
                file = config.file || file;
              }
              return initLanguage(file, language);
            }
            loadColors(config) {
              var file = Utils.asset('colors.json');
              if (config && (typeof config === 'string' || typeof config === 'object')) {
                file = config;
              }
              return initColors(file);
            }
            set focus(v) {
              this._focussed = v;
              this._refocus();
            }
            _getFocused() {
              return this._focussed || this.tag('App');
            }
          };
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ScaledImageTexture extends lightning.textures.ImageTexture {
          constructor(stage) {
            super(stage);
            this._scalingOptions = undefined;
          }
          set options(options) {
            this.resizeMode = this._scalingOptions = options;
          }
          _getLookupId() {
            return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`;
          }
          getNonDefaults() {
            var obj = super.getNonDefaults();
            if (this._src) {
              obj.src = this._src;
            }
            return obj;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var events = ['timeupdate', 'error', 'ended', 'loadeddata', 'canplay', 'play', 'playing', 'pause', 'loadstart', 'seeking', 'seeked', 'encrypted'];
        var mediaUrl = url => url;
        var initMediaPlayer = config => {
          if (config.mediaUrl) {
            mediaUrl = config.mediaUrl;
          }
        };
        class Mediaplayer extends lightning.Component {
          _construct() {
            this._skipRenderToTexture = false;
            this._metrics = null;
            this._textureMode = Settings$1.get('platform', 'textureMode') || false;
            Log$1.info('Texture mode: ' + this._textureMode);
            console.warn(["The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'VideoPlayer'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer'].join('\n\n'));
          }
          static _template() {
            return {
              Video: {
                VideoWrap: {
                  VideoTexture: {
                    visible: false,
                    pivot: 0.5,
                    texture: {
                      type: lightning.textures.StaticTexture,
                      options: {}
                    }
                  }
                }
              }
            };
          }
          set skipRenderToTexture(v) {
            this._skipRenderToTexture = v;
          }
          get textureMode() {
            return this._textureMode;
          }
          get videoView() {
            return this.tag('Video');
          }
          _init() {
            //re-use videotag if already there
            var videoEls = document.getElementsByTagName('video');
            if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];else {
              this.videoEl = document.createElement('video');
              this.videoEl.setAttribute('id', 'video-player');
              this.videoEl.style.position = 'absolute';
              this.videoEl.style.zIndex = '1';
              this.videoEl.style.display = 'none';
              this.videoEl.setAttribute('width', '100%');
              this.videoEl.setAttribute('height', '100%');
              this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible';
              document.body.appendChild(this.videoEl);
            }
            if (this.textureMode && !this._skipRenderToTexture) {
              this._createVideoTexture();
            }
            this.eventHandlers = [];
          }
          _registerListeners() {
            events.forEach(event => {
              var handler = e => {
                if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
                  this._metrics[event]({
                    currentTime: this.videoEl.currentTime
                  });
                }
                this.fire(event, {
                  videoElement: this.videoEl,
                  event: e
                });
              };
              this.eventHandlers.push(handler);
              this.videoEl.addEventListener(event, handler);
            });
          }
          _deregisterListeners() {
            Log$1.info('Deregistering event listeners MediaPlayer');
            events.forEach((event, index) => {
              this.videoEl.removeEventListener(event, this.eventHandlers[index]);
            });
            this.eventHandlers = [];
          }
          _attach() {
            this._registerListeners();
          }
          _detach() {
            this._deregisterListeners();
            this.close();
          }
          _createVideoTexture() {
            var stage = this.stage;
            var gl = stage.gl;
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            this.videoTexture.options = {
              source: glTexture,
              w: this.videoEl.width,
              h: this.videoEl.height
            };
          }
          _startUpdatingVideoTexture() {
            if (this.textureMode && !this._skipRenderToTexture) {
              var _stage = this.stage;
              if (!this._updateVideoTexture) {
                this._updateVideoTexture = () => {
                  if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
                    var gl = _stage.gl;
                    var currentTime = new Date().getTime();

                    // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
                    // We'll fallback to fixed 30fps in this case.
                    var frameCount = this.videoEl.webkitDecodedFrameCount;
                    var mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
                    if (mustUpdate) {
                      this._lastTime = currentTime;
                      this._lastFrame = frameCount;
                      try {
                        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                        this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                        this.videoTextureView.visible = true;
                        this.videoTexture.options.w = this.videoEl.videoWidth;
                        this.videoTexture.options.h = this.videoEl.videoHeight;
                        var expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                        var realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                        if (expectedAspectRatio > realAspectRatio) {
                          this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                          this.videoTextureView.scaleY = 1;
                        } else {
                          this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                          this.videoTextureView.scaleX = 1;
                        }
                      } catch (e) {
                        Log$1.error('texImage2d video', e);
                        this._stopUpdatingVideoTexture();
                        this.videoTextureView.visible = false;
                      }
                      this.videoTexture.source.forceRenderUpdate();
                    }
                  }
                };
              }
              if (!this._updatingVideoTexture) {
                _stage.on('frameStart', this._updateVideoTexture);
                this._updatingVideoTexture = true;
              }
            }
          }
          _stopUpdatingVideoTexture() {
            if (this.textureMode) {
              var _stage2 = this.stage;
              _stage2.removeListener('frameStart', this._updateVideoTexture);
              this._updatingVideoTexture = false;
              this.videoTextureView.visible = false;
              if (this.videoTexture.options.source) {
                var gl = _stage2.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
            }
          }
          updateSettings() {
            var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            // The Component that 'consumes' the media player.
            this._consumer = settings.consumer;
            if (this._consumer && this._consumer.getMediaplayerSettings) {
              // Allow consumer to add settings.
              settings = Object.assign(settings, this._consumer.getMediaplayerSettings());
            }
            if (!lightning.Utils.equalValues(this._stream, settings.stream)) {
              if (settings.stream && settings.stream.keySystem) {
                navigator.requestMediaKeySystemAccess(settings.stream.keySystem.id, settings.stream.keySystem.config).then(keySystemAccess => {
                  return keySystemAccess.createMediaKeys();
                }).then(createdMediaKeys => {
                  return this.videoEl.setMediaKeys(createdMediaKeys);
                }).then(() => {
                  if (settings.stream && settings.stream.src) this.open(settings.stream.src);
                }).catch(() => {
                  console.error('Failed to set up MediaKeys');
                });
              } else if (settings.stream && settings.stream.src) {
                // This is here to be backwards compatible, will be removed
                // in future sdk release
                if (Settings$1.get('app', 'hls')) {
                  if (!window.Hls) {
                    window.Hls = class Hls {
                      static isSupported() {
                        console.warn('hls-light not included');
                        return false;
                      }
                    };
                  }
                  if (window.Hls.isSupported()) {
                    if (!this._hls) this._hls = new window.Hls({
                      liveDurationInfinity: true
                    });
                    this._hls.loadSource(settings.stream.src);
                    this._hls.attachMedia(this.videoEl);
                    this.videoEl.style.display = 'block';
                  }
                } else {
                  this.open(settings.stream.src);
                }
              } else {
                this.close();
              }
              this._stream = settings.stream;
            }
            this._setHide(settings.hide);
            this._setVideoArea(settings.videoPos);
          }
          _setHide(hide) {
            if (this.textureMode) {
              this.tag('Video').setSmooth('alpha', hide ? 0 : 1);
            } else {
              this.videoEl.style.visibility = hide ? 'hidden' : 'visible';
            }
          }
          open(url) {
            var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
              hide: false,
              videoPosition: null
            };
            // prep the media url to play depending on platform (mediaPlayerplugin)
            url = mediaUrl(url);
            this._metrics = Metrics$1.media(url);
            Log$1.info('Playing stream', url);
            if (this.application.noVideo) {
              Log$1.info('noVideo option set, so ignoring: ' + url);
              return;
            }
            // close the video when opening same url as current (effectively reloading)
            if (this.videoEl.getAttribute('src') === url) {
              this.close();
            }
            this.videoEl.setAttribute('src', url);

            // force hide, then force show (in next tick!)
            // (fixes comcast playback rollover issue)
            this.videoEl.style.visibility = 'hidden';
            this.videoEl.style.display = 'none';
            setTimeout(() => {
              this.videoEl.style.display = 'block';
              this.videoEl.style.visibility = 'visible';
            });
            this._setHide(settings.hide);
            this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080]);
          }
          close() {
            // We need to pause first in order to stop sound.
            this.videoEl.pause();
            this.videoEl.removeAttribute('src');

            // force load to reset everything without errors
            this.videoEl.load();
            this._clearSrc();
            this.videoEl.style.display = 'none';
          }
          playPause() {
            if (this.isPlaying()) {
              this.doPause();
            } else {
              this.doPlay();
            }
          }
          get muted() {
            return this.videoEl.muted;
          }
          set muted(v) {
            this.videoEl.muted = v;
          }
          get loop() {
            return this.videoEl.loop;
          }
          set loop(v) {
            this.videoEl.loop = v;
          }
          isPlaying() {
            return this._getState() === 'Playing';
          }
          doPlay() {
            this.videoEl.play();
          }
          doPause() {
            this.videoEl.pause();
          }
          reload() {
            var url = this.videoEl.getAttribute('src');
            this.close();
            this.videoEl.src = url;
          }
          getPosition() {
            return Promise.resolve(this.videoEl.currentTime);
          }
          setPosition(pos) {
            this.videoEl.currentTime = pos;
          }
          getDuration() {
            return Promise.resolve(this.videoEl.duration);
          }
          seek(time) {
            var absolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            if (absolute) {
              this.videoEl.currentTime = time;
            } else {
              this.videoEl.currentTime += time;
            }
          }
          get videoTextureView() {
            return this.tag('Video').tag('VideoTexture');
          }
          get videoTexture() {
            return this.videoTextureView.texture;
          }
          _setVideoArea(videoPos) {
            if (lightning.Utils.equalValues(this._videoPos, videoPos)) {
              return;
            }
            this._videoPos = videoPos;
            if (this.textureMode) {
              this.videoTextureView.patch({
                smooth: {
                  x: videoPos[0],
                  y: videoPos[1],
                  w: videoPos[2] - videoPos[0],
                  h: videoPos[3] - videoPos[1]
                }
              });
            } else {
              var _precision7 = this.stage.getRenderPrecision();
              this.videoEl.style.left = Math.round(videoPos[0] * _precision7) + 'px';
              this.videoEl.style.top = Math.round(videoPos[1] * _precision7) + 'px';
              this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * _precision7) + 'px';
              this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * _precision7) + 'px';
            }
          }
          _fireConsumer(event, args) {
            if (this._consumer) {
              this._consumer.fire(event, args);
            }
          }
          _equalInitData(buf1, buf2) {
            if (!buf1 || !buf2) return false;
            if (buf1.byteLength != buf2.byteLength) return false;
            var dv1 = new Int8Array(buf1);
            var dv2 = new Int8Array(buf2);
            for (var i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false;
            return true;
          }
          error(args) {
            this._fireConsumer('$mediaplayerError', args);
            this._setState('');
            return '';
          }
          loadeddata(args) {
            this._fireConsumer('$mediaplayerLoadedData', args);
          }
          play(args) {
            this._fireConsumer('$mediaplayerPlay', args);
          }
          playing(args) {
            this._fireConsumer('$mediaplayerPlaying', args);
            this._setState('Playing');
          }
          canplay(args) {
            this.videoEl.play();
            this._fireConsumer('$mediaplayerStart', args);
          }
          loadstart(args) {
            this._fireConsumer('$mediaplayerLoad', args);
          }
          seeked() {
            this._fireConsumer('$mediaplayerSeeked', {
              currentTime: this.videoEl.currentTime,
              duration: this.videoEl.duration || 1
            });
          }
          seeking() {
            this._fireConsumer('$mediaplayerSeeking', {
              currentTime: this.videoEl.currentTime,
              duration: this.videoEl.duration || 1
            });
          }
          durationchange(args) {
            this._fireConsumer('$mediaplayerDurationChange', args);
          }
          encrypted(args) {
            var video = args.videoElement;
            var event = args.event;
            // FIXME: Double encrypted events need to be properly filtered by Gstreamer
            if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
              this._previousInitData = event.initData;
              this._fireConsumer('$mediaplayerEncrypted', args);
            }
          }
          static _states() {
            return [class Playing extends this {
              $enter() {
                this._startUpdatingVideoTexture();
              }
              $exit() {
                this._stopUpdatingVideoTexture();
              }
              timeupdate() {
                this._fireConsumer('$mediaplayerProgress', {
                  currentTime: this.videoEl.currentTime,
                  duration: this.videoEl.duration || 1
                });
              }
              ended(args) {
                this._fireConsumer('$mediaplayerEnded', args);
                this._setState('');
              }
              pause(args) {
                this._fireConsumer('$mediaplayerPause', args);
                this._setState('Playing.Paused');
              }
              _clearSrc() {
                this._fireConsumer('$mediaplayerStop', {});
                this._setState('');
              }
              static _states() {
                return [class Paused extends this {}];
              }
            }];
          }
        }
        class localCookie {
          constructor(e) {
            return e = e || {}, this.forceCookies = e.forceCookies || !1, !0 === this._checkIfLocalStorageWorks() && !0 !== e.forceCookies ? {
              getItem: this._getItemLocalStorage,
              setItem: this._setItemLocalStorage,
              removeItem: this._removeItemLocalStorage,
              clear: this._clearLocalStorage,
              keys: this._getLocalStorageKeys
            } : {
              getItem: this._getItemCookie,
              setItem: this._setItemCookie,
              removeItem: this._removeItemCookie,
              clear: this._clearCookies,
              keys: this._getCookieKeys
            };
          }
          _checkIfLocalStorageWorks() {
            if ("undefined" == typeof localStorage) return !1;
            try {
              return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), !0);
            } catch (e) {
              return !1;
            }
          }
          _getItemLocalStorage(e) {
            return window.localStorage.getItem(e);
          }
          _setItemLocalStorage(e, t) {
            return window.localStorage.setItem(e, t);
          }
          _removeItemLocalStorage(e) {
            return window.localStorage.removeItem(e);
          }
          _clearLocalStorage() {
            return window.localStorage.clear();
          }
          _getLocalStorageKeys() {
            return Object.keys(window.localStorage);
          }
          _getItemCookie(e) {
            var t = document.cookie.match(RegExp("(?:^|;\\s*)" + function (e) {
              return e.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
            }(e) + "=([^;]*)"));
            return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
          }
          _setItemCookie(e, t) {
            var o = new Date(),
              r = new Date(o.getTime() + 15768e7);
            document.cookie = `${e}=${t}; expires=${r.toUTCString()};`;
          }
          _removeItemCookie(e) {
            document.cookie = `${e}=;Max-Age=-99999999;`;
          }
          _clearCookies() {
            document.cookie.split(";").forEach(e => {
              document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
            });
          }
          _getCookieKeys() {
            return document.cookie.split(";").map(e => e.split("=")[0]);
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var namespace;
        var lc;
        var initStorage = () => {
          namespace = Settings$1.get('platform', 'id');
          // todo: pass options (for example to force the use of cookies)
          lc = new localCookie();
        };
        var namespacedKey = key => namespace ? [namespace, key].join('.') : key;
        var Storage = {
          get(key) {
            try {
              return JSON.parse(lc.getItem(namespacedKey(key)));
            } catch (e) {
              return null;
            }
          },
          set(key, value) {
            try {
              lc.setItem(namespacedKey(key), JSON.stringify(value));
              return true;
            } catch (e) {
              return false;
            }
          },
          remove(key) {
            lc.removeItem(namespacedKey(key));
          },
          clear() {
            if (namespace) {
              lc.keys().forEach(key => {
                // remove the item if in the namespace
                key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null;
              });
            } else {
              lc.clear();
            }
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
        var isWildcard = /^[!*$]$/;
        var hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
        var isNamedGroup = /^\/:/;

        /**
         * Test if a route is part regular expressed
         * and replace it for a simple character
         * @param route
         * @returns {*}
         */
        var stripRegex = function stripRegex(route) {
          var char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'R';
          // if route is part regular expressed we replace
          // the regular expression for a character to
          // simplify floor calculation and backtracking
          if (hasRegex.test(route)) {
            route = route.replace(hasRegex, char);
          }
          return route;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Create a local request register
         * @param flags
         * @returns {Map<any, any>}
         */
        var createRegister = flags => {
          var reg = new Map()
          // store user defined and router
          // defined flags in register
          ;
          [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
            reg.set(key, flags[key]);
          });
          return reg;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Request {
          constructor() {
            var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var navArgs = arguments.length > 1 ? arguments[1] : undefined;
            var storeCaller = arguments.length > 2 ? arguments[2] : undefined;
            /**
             * Hash we navigate to
             * @type {string}
             * @private
             */
            this._hash = hash;

            /**
             * Do we store previous hash in history
             * @type {boolean}
             * @private
             */
            this._storeCaller = storeCaller;

            /**
             * Request and navigate data
             * @type {Map}
             * @private
             */
            this._register = new Map();

            /**
             * Flag if the instance is created due to
             * this request
             * @type {boolean}
             * @private
             */
            this._isCreated = false;

            /**
             * Flag if the instance is shared between
             * previous and current request
             * @type {boolean}
             * @private
             */
            this._isSharedInstance = false;

            /**
             * Flag if the request has been cancelled
             * @type {boolean}
             * @private
             */
            this._cancelled = false;

            /**
             * if instance is shared between requests we copy state object
             * from instance before the new request overrides state
             * @type {null}
             * @private
             */
            this._copiedHistoryState = null;

            // if there are arguments attached to navigate()
            // we store them in new request
            if (isObject$1(navArgs)) {
              this._register = createRegister(navArgs);
            } else if (isBoolean$1(navArgs)) {
              // if second navigate() argument is explicitly
              // set to false we prevent the calling page
              // from ending up in history
              this._storeCaller = navArgs;
            }
            // @todo: remove because we can simply check
            // ._storeCaller property
            this._register.set(symbols.store, this._storeCaller);
          }
          cancel() {
            Log$1.debug('[router]:', `cancelled ${this._hash}`);
            this._cancelled = true;
          }
          get url() {
            return this._hash;
          }
          get register() {
            return this._register;
          }
          get hash() {
            return this._hash;
          }
          set hash(args) {
            this._hash = args;
          }
          get route() {
            return this._route;
          }
          set route(args) {
            this._route = args;
          }
          get provider() {
            return this._provider;
          }
          set provider(args) {
            this._provider = args;
          }
          get providerType() {
            return this._providerType;
          }
          set providerType(args) {
            this._providerType = args;
          }
          set page(args) {
            this._page = args;
          }
          get page() {
            return this._page;
          }
          set isCreated(args) {
            this._isCreated = args;
          }
          get isCreated() {
            return this._isCreated;
          }
          get isSharedInstance() {
            return this._isSharedInstance;
          }
          set isSharedInstance(args) {
            this._isSharedInstance = args;
          }
          get isCancelled() {
            return this._cancelled;
          }
          set copiedHistoryState(v) {
            this._copiedHistoryState = v;
          }
          get copiedHistoryState() {
            return this._copiedHistoryState;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Route {
          constructor() {
            var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            // keep backwards compatible
            var type = ['on', 'before', 'after'].reduce((acc, type) => {
              return isFunction$1(config[type]) ? type : acc;
            }, undefined);
            this._cfg = config;
            if (type) {
              this._provider = {
                type,
                request: config[type]
              };
            }
          }
          get path() {
            return this._cfg.path;
          }
          get name() {
            return this._cfg.name;
          }
          get component() {
            return this._cfg.component;
          }
          get options() {
            return this._cfg.options;
          }
          get widgets() {
            return this._cfg.widgets;
          }
          get cache() {
            return this._cfg.cache;
          }
          get hook() {
            return this._cfg.hook;
          }
          get beforeNavigate() {
            return this._cfg.beforeNavigate;
          }
          get provider() {
            return this._provider;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Simple route length calculation
         * @param route {string}
         * @returns {number} - floor
         */
        var getFloor = route => {
          return stripRegex(route).split('/').length;
        };

        /**
         * return all stored routes that live on the same floor
         * @param floor
         * @returns {Array}
         */
        var getRoutesByFloor = floor => {
          var matches = [];
          // simple filter of level candidates
          var _iterator24 = _createForOfIteratorHelper(routes$1.entries()),
            _step26;
          try {
            for (_iterator24.s(); !(_step26 = _iterator24.n()).done;) {
              var _step26$value = _slicedToArray(_step26.value, 1),
                route = _step26$value[0];
              if (getFloor(route) === floor) {
                matches.push(route);
              }
            }
          } catch (err) {
            _iterator24.e(err);
          } finally {
            _iterator24.f();
          }
          return matches;
        };

        /**
         * return a matching route by provided hash
         * hash: home/browse/12 will match:
         * route: home/browse/:categoryId
         * @param hash {string}
         * @returns {boolean|{}} - route
         */
        var getRouteByHash = hash => {
          // @todo: clean up on handleHash
          hash = hash.replace(/^#/, '');
          var getUrlParts = /(\/?:?[^/]+)/g;
          // grab possible candidates from stored routes
          var candidates = getRoutesByFloor(getFloor(hash));
          // break hash down in chunks
          var hashParts = hash.match(getUrlParts) || [];

          // to simplify the route matching and prevent look around
          // in our getUrlParts regex we get the regex part from
          // route candidate and store them so that we can reference
          // them when we perform the actual regex against hash
          var regexStore = [];
          var matches = candidates.filter(route => {
            var isMatching = true;
            // replace regex in route with lookup id => @@{storeId}@@
            if (hasRegex.test(route)) {
              var regMatches = route.match(hasRegex);
              if (regMatches && regMatches.length) {
                route = regMatches.reduce((fullRoute, regex) => {
                  var lookupId = regexStore.length;
                  fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`);
                  regexStore.push(regex.substring(1, regex.length - 1));
                  return fullRoute;
                }, route);
              }
            }
            var routeParts = route.match(getUrlParts) || [];
            for (var i = 0, j = routeParts.length; i < j; i++) {
              var routePart = routeParts[i];
              var hashPart = hashParts[i];

              // Since we support catch-all and regex driven name groups
              // we first test for regex lookup id and see if the regex
              // matches the value from the hash
              if (hasLookupId.test(routePart)) {
                var routeMatches = hasLookupId.exec(routePart);
                var storeId = routeMatches[1];
                var routeRegex = regexStore[storeId];

                // split regex and modifiers so we can use both
                // to create a new RegExp
                // eslint-disable-next-line
                var _regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
                if (_regMatches && _regMatches.length) {
                  var expression = _regMatches[1];
                  var modifiers = _regMatches[2];
                  var regex = new RegExp(`^/${expression}$`, modifiers);
                  if (!regex.test(hashPart)) {
                    isMatching = false;
                  }
                }
              } else if (isNamedGroup.test(routePart)) {
                // we kindly skip namedGroups because this is dynamic
                // we only need to the static and regex drive parts
                continue;
              } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
                isMatching = false;
              }
            }
            return isMatching;
          });
          if (matches.length) {
            if (matches.indexOf(hash) !== -1) {
              var match = matches[matches.indexOf(hash)];
              return routes$1.get(match);
            } else {
              // we give prio to static routes over dynamic
              matches = matches.sort(a => {
                return isNamedGroup.test(a) ? -1 : 1;
              });
              // would be strange if this fails
              // but still we test
              if (routeExists(matches[0])) {
                return routes$1.get(matches[0]);
              }
            }
          }
          return false;
        };
        var getValuesFromHash = function getValuesFromHash() {
          var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          var path = arguments.length > 1 ? arguments[1] : undefined;
          // replace the regex definition from the route because
          // we already did the matching part
          path = stripRegex(path, '');
          var getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
          var hashParts = hash.match(getUrlParts) || [];
          var routeParts = path.match(getUrlParts) || [];
          var getNamedGroup = /^\/:([\w-]+)\/?/;
          return routeParts.reduce((storage, value, index) => {
            var match = getNamedGroup.exec(value);
            if (match && match.length) {
              storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')));
            }
            return storage;
          }, new Map());
        };
        var getOption = (stack, prop) => {
          // eslint-disable-next-line
          if (stack && stack.hasOwnProperty(prop)) {
            return stack[prop];
          }
          // we explicitly return undefined since we're testing
          // for explicit test values
        };

        /**
         * create and return new Route instance
         * @param config
         */
        var createRoute = config => {
          // we need to provide a bit of additional logic
          // for the bootComponent
          if (config.path === '$') {
            var options = {
              preventStorage: true
            };
            if (isObject$1(config.options)) {
              options = _objectSpread(_objectSpread({}, config.options), options);
            }
            config.options = options;
            // if configured add reference to bootRequest
            // as router after provider
            if (bootRequest) {
              config.after = bootRequest;
            }
          }
          return new Route(config);
        };

        /**
         * Create a new Router request object
         * @param url
         * @param args
         * @param store
         * @returns {*}
         */
        var createRequest = (url, args, store) => {
          return new Request(url, args, store);
        };
        var getHashByName = obj => {
          if (!obj.to && !obj.name) {
            return false;
          }
          var route = getRouteByName(obj.to || obj.name);
          var hasDynamicGroup = /\/:([\w-]+)\/?/;
          var hash = route;

          // if route contains dynamic group
          // we replace them with the provided params
          if (hasDynamicGroup.test(route)) {
            if (obj.params) {
              var keys = Object.keys(obj.params);
              hash = keys.reduce((acc, key) => {
                return acc.replace(`:${key}`, obj.params[key]);
              }, route);
            }
            if (obj.query) {
              return `${hash}${objectToQueryString(obj.query)}`;
            }
          }
          return hash;
        };
        var getRouteByName = name => {
          var _iterator25 = _createForOfIteratorHelper(routes$1.entries()),
            _step27;
          try {
            for (_iterator25.s(); !(_step27 = _iterator25.n()).done;) {
              var _step27$value = _slicedToArray(_step27.value, 2),
                path = _step27$value[0],
                route = _step27$value[1];
              if (route.name === name) {
                return path;
              }
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }
          return false;
        };
        var keepActivePageAlive = (route, request) => {
          if (isString$1(route)) {
            var _routes = getRoutes();
            if (_routes.has(route)) {
              route = _routes.get(route);
            } else {
              return false;
            }
          }
          var register = request.register;
          var routeOptions = route.options;
          if (register.has('keepAlive')) {
            return register.get('keepAlive');
          } else if (routeOptions && routeOptions.keepAlive) {
            return routeOptions.keepAlive;
          }
          return false;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var emit = function emit(page) {
          var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (!isArray$1(events)) {
            events = [events];
          }
          events.forEach(e => {
            var event = `_on${ucfirst(e)}`;
            if (isFunction$1(page[event])) {
              page[event](params);
            }
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var activeWidget = null;
        var getReferences = () => {
          if (!widgetsHost) {
            return;
          }
          return widgetsHost.get().reduce((storage, widget) => {
            var key = widget.ref.toLowerCase();
            storage[key] = widget;
            return storage;
          }, {});
        };

        /**
         * update the visibility of the available widgets
         * for the current page / route
         * @param page
         */
        var updateWidgets = (widgets, page) => {
          // force lowercase lookup
          var configured = (widgets || []).map(ref => ref.toLowerCase());
          widgetsHost.forEach(widget => {
            widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
            if (widget.visible) {
              emit(widget, ['activated'], page);
            }
          });
          if (app$1.state === 'Widgets' && activeWidget && !activeWidget.visible) {
            app$1._setState('');
          }
        };
        var getWidgetByName = name => {
          name = ucfirst(name);
          return widgetsHost.getByRef(name) || false;
        };

        /**
         * delegate app focus to a on-screen widget
         * @param name - {string}
         */
        var focusWidget = name => {
          var widget = getWidgetByName(name);
          if (widget) {
            setActiveWidget(widget);

            // if app is already in 'Widgets' state we can assume that
            // focus has been delegated from one widget to another so
            // we need to set the new widget reference and trigger a
            // new focus calculation of Lightning's focuspath
            if (app$1.state === 'Widgets') {
              app$1.reload(activeWidget);
            } else {
              app$1._setState('Widgets', [activeWidget]);
            }
          }
        };
        var restoreFocus = () => {
          activeWidget = null;
          app$1._setState('');
        };
        var getActiveWidget = () => {
          return activeWidget;
        };
        var setActiveWidget = instance => {
          activeWidget = instance;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var createComponent = (stage, type) => {
          return stage.c({
            type,
            visible: false,
            widgets: getReferences()
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * Simple flat array that holds the visited hashes + state Object
         * so the router can navigate back to them
         * @type {Array}
         */
        var history = [];
        var updateHistory = request => {
          var hash = getActiveHash();
          if (!hash) {
            return;
          }

          // navigate storage flag
          var register = request.register;
          var forceNavigateStore = register.get(symbols.store);

          // test preventStorage on route configuration
          var activeRoute = getRouteByHash(hash);
          var preventStorage = getOption(activeRoute.options, 'preventStorage');

          // we give prio to navigate storage flag
          var store = isBoolean$1(forceNavigateStore) ? forceNavigateStore : !preventStorage;
          if (store) {
            var toStore = hash.replace(/^\//, '');
            var _location = locationInHistory(toStore);
            var stateObject = getStateObject(getActivePage(), request);
            var _routerConfig = getRouterConfig();

            // store hash if it's not a part of history or flag for
            // storage of same hash is true
            if (_location === -1 || _routerConfig.get('storeSameHash')) {
              history.push({
                hash: toStore,
                state: stateObject
              });
            } else {
              // if we visit the same route we want to sync history
              var prev = history.splice(_location, 1)[0];
              history.push({
                hash: prev.hash,
                state: stateObject
              });
            }
          }
        };
        var locationInHistory = hash => {
          for (var i = 0; i < history.length; i++) {
            if (history[i].hash === hash) {
              return i;
            }
          }
          return -1;
        };
        var getHistoryState = hash => {
          var state = null;
          if (history.length) {
            // if no hash is provided we get the last
            // pushed history record
            if (!hash) {
              var record = history[history.length - 1];
              // could be null
              state = record.state;
            } else {
              if (locationInHistory(hash) !== -1) {
                var _record = history[locationInHistory(hash)];
                state = _record.state;
              }
            }
          }
          return state;
        };
        var replaceHistoryState = function replaceHistoryState() {
          var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var hash = arguments.length > 1 ? arguments[1] : undefined;
          if (!history.length) {
            return;
          }
          var location = hash ? locationInHistory(hash) : history.length - 1;
          if (location !== -1 && isObject$1(state)) {
            history[location].state = state;
          }
        };
        var getStateObject = (page, request) => {
          // if the new request shared instance with the
          // previous request we used the copied state object
          if (request.isSharedInstance) {
            if (request.copiedHistoryState) {
              return request.copiedHistoryState;
            }
          } else if (page && isFunction$1(page.historyState)) {
            return page.historyState();
          }
          return null;
        };
        var getHistory = () => {
          return history.slice(0);
        };
        var setHistory = function setHistory() {
          var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          if (isArray$1(arr)) {
            history = arr;
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * @type {Lightning.Application}
         */
        var application;

        /**
         * Actual instance of the app
         * @type {Lightning.Component}
         */
        var app$1;

        /**
         * Component that hosts all routed pages
         * @type {Lightning.Component}
         */
        var pagesHost;

        /**
         * @type {Lightning.Stage}
         */
        var stage;

        /**
         * Platform driven Router configuration
         * @type {Map<string>}
         */
        var routerConfig;

        /**
         * Component that hosts all attached widgets
         * @type {Lightning.Component}
         */
        var widgetsHost;

        /**
         * Hash we point the browser to when we boot the app
         * and there is no deep-link provided
         * @type {string|Function}
         */
        var rootHash;

        /**
         * Boot request will fire before app start
         * can be used to execute some global logic
         * and can be configured
         */
        var bootRequest;

        /**
         * Flag if we need to update the browser location hash.
         * Router can work without.
         * @type {boolean}
         */
        var updateHash = true;

        /**
         * Will be called before a route starts, can be overridden
         * via routes config
         * @param from - route we came from
         * @param to - route we navigate to
         * @returns {Promise<*>}
         */
        // eslint-disable-next-line
        var beforeEachRoute = /*#__PURE__*/function () {
          var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(from, to) {
            return _regeneratorRuntime().wrap(function _callee2$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  return _context4.abrupt("return", true);
                case 1:
                case "end":
                  return _context4.stop();
              }
            }, _callee2);
          }));
          return function beforeEachRoute(_x3, _x4) {
            return _ref15.apply(this, arguments);
          };
        }();

        /**
         *  * Will be called after a navigate successfully resolved,
         * can be overridden via routes config
         */
        var afterEachRoute = () => {};

        /**
         * All configured routes
         * @type {Map<string, object>}
         */
        var routes$1 = new Map();

        /**
         * Store all page components per route
         * @type {Map<string, object>}
         */
        var components = new Map();

        /**
         * Flag if router has been initialised
         * @type {boolean}
         */
        var initialised = false;

        /**
         * Current page being rendered on screen
         * @type {null}
         */
        var activePage = null;
        var activeHash;
        var activeRoute;

        /**
         *  During the process of a navigation request a new
         *  request can start, to prevent unwanted behaviour
         *  the navigate()-method stores the last accepted hash
         *  so we can invalidate any prior requests
         */
        var lastAcceptedHash;

        /**
         * With on()-data providing behaviour the Router forced the App
         * in a Loading state. When the data-provider resolves we want to
         * change the state back to where we came from
         */
        var previousState;
        var mixin = app => {
          // by default the Router Baseclass provides the component
          // reference in which we store our pages
          if (app.pages) {
            pagesHost = app.pages.childList;
          }
          // if the app is using widgets we grab refs
          // and hide all the widgets
          if (app.widgets && app.widgets.children) {
            widgetsHost = app.widgets.childList;
            // hide all widgets on boot
            widgetsHost.forEach(w => w.visible = false);
          }
          app._handleBack = e => {
            step(-1);
            e.preventDefault();
          };
        };
        var bootRouter = (config, instance) => {
          var appInstance = config.appInstance,
            routes = config.routes;

          // if instance is provided and it's and Lightning Component instance
          if (instance && isPage(instance)) {
            app$1 = instance;
          }
          if (!app$1) {
            app$1 = appInstance || AppInstance;
          }
          application = app$1.application;
          pagesHost = application.childList;
          stage = app$1.stage;
          routerConfig = getConfigMap();
          mixin(app$1);
          if (isArray$1(routes)) {
            setup(config);
          } else if (isFunction$1(routes)) {
            console.warn('[Router]: Calling Router.route() directly is deprecated.');
            console.warn('Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
          }
        };
        var setup = config => {
          if (!initialised) {
            init(config);
          }
          config.routes.forEach(r => {
            var path = cleanHash(r.path);
            if (!routeExists(path)) {
              var route = createRoute(r);
              routes$1.set(path, route);
              // if route has a configured component property
              // we store it in a different map to simplify
              // the creating and destroying per route
              if (route.component) {
                var type = route.component;
                if (isComponentConstructor(type)) {
                  if (!routerConfig.get('lazyCreate')) {
                    type = createComponent(stage, type);
                    pagesHost.a(type);
                  }
                }
                components.set(path, type);
              }
            } else {
              console.error(`${path} already exists in routes configuration`);
            }
          });
        };
        var init = config => {
          rootHash = config.root;
          if (isFunction$1(config.boot)) {
            bootRequest = config.boot;
          }
          if (isBoolean$1(config.updateHash)) {
            updateHash = config.updateHash;
          }
          if (isFunction$1(config.beforeEachRoute)) {
            beforeEachRoute = config.beforeEachRoute;
          }
          if (isFunction$1(config.afterEachRoute)) {
            afterEachRoute = config.afterEachRoute;
          }
          if (config.bootComponent) {
            console.warn('[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes');
            console.warn('[Router]: setting { bootComponent } property will be deprecated in a future release');
            if (isPage(config.bootComponent)) {
              config.routes.push({
                path: '$',
                component: config.bootComponent,
                // we try to assign the bootRequest as after data-provider
                // so it will behave as any other component
                after: bootRequest || null,
                options: {
                  preventStorage: true
                }
              });
            } else {
              console.error(`[Router]: ${config.bootComponent} is not a valid boot component`);
            }
          }
          config.routes.forEach(item => {
            // replacing regexes with 'R' to avoid issues with pattern matching below
            var strippedPath = stripRegex(item.path);

            // Pattern to identify the last path of the route
            // It should start with "/:" + any word  and ends with "?"
            // It should be the last path of the route
            // valid => /player/:asset/:assetId? (:assetId is optional)
            // invalid => /player/:asset/:assetId?/test (:assetId? is not an optional path)
            // invalid => /player/:asset?/:assetId? (second path is not considered as an optional path)
            var pattern = /(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*\/:(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\?$/;
            if (pattern.test(strippedPath)) {
              var optionalPath = item.path.substring(0, item.path.lastIndexOf('/'));
              var originalPath = item.path.substring(0, item.path.lastIndexOf('?'));
              item.path = originalPath;
              //Create another entry with the optional path
              var optionalItem = _objectSpread({}, item);
              optionalItem.path = optionalPath;
              config.routes.push(optionalItem);
            }
          });
          initialised = true;
        };
        var storeComponent = (route, type) => {
          if (components.has(route)) {
            components.set(route, type);
          }
        };
        var getComponent = route => {
          if (components.has(route)) {
            return components.get(route);
          }
          return null;
        };
        /**
         * Test if router needs to update browser location hash
         * @returns {boolean}
         */
        var mustUpdateLocationHash = () => {
          if (!routerConfig || !routerConfig.size) {
            return false;
          }
          // we need support to either turn change hash off
          // per platform or per app
          var updateConfig = routerConfig.get('updateHash');
          return !(isBoolean$1(updateConfig) && !updateConfig || isBoolean$1(updateHash) && !updateHash);
        };

        /**
         * Will be called when a new navigate() request has completed
         * and has not been expired due to it's async nature
         * @param request
         */
        var onRequestResolved = request => {
          var hash = request.hash;
          var route = request.route;
          var register = request.register;
          var page = request.page;

          // clean up history if modifier is set
          if (getOption(route.options, 'clearHistory')) {
            setHistory([]);
          } else if (hash && !isWildcard.test(route.path)) {
            updateHistory(request);
          }

          // we only update the stackLocation if a route
          // is not expired before it resolves
          storeComponent(route.path, page);
          if (request.isSharedInstance || !request.isCreated) {
            emit(page, 'changed');
          } else if (request.isCreated) {
            emit(page, 'mounted');
          }

          // only update widgets if we have a host
          if (widgetsHost) {
            updateWidgets(route.widgets, page);
          }

          // we want to clean up if there is an
          // active page that is not being shared
          // between current and previous route
          if (getActivePage() && !request.isSharedInstance) {
            cleanUp(activePage, request);
          }

          // provide history object to active page
          if (register.get(symbols.historyState) && isFunction$1(page.historyState)) {
            page.historyState(register.get(symbols.historyState));
          }
          setActivePage(page);
          activeHash = request.hash;
          activeRoute = route.path;

          // cleanup all cancelled requests
          var _iterator26 = _createForOfIteratorHelper(navigateQueue.values()),
            _step28;
          try {
            for (_iterator26.s(); !(_step28 = _iterator26.n()).done;) {
              var _request = _step28.value;
              if (_request.isCancelled && _request.hash) {
                navigateQueue.delete(_request.hash);
              }
            }
          } catch (err) {
            _iterator26.e(err);
          } finally {
            _iterator26.f();
          }
          afterEachRoute(request);
          Log$1.info('[route]:', route.path);
          Log$1.info('[hash]:', hash);
        };
        var cleanUp = (page, request) => {
          var route = activeRoute;
          var register = request.register;
          var lazyDestroy = routerConfig.get('lazyDestroy');
          var destroyOnBack = routerConfig.get('destroyOnHistoryBack');
          var keepAlive = register.get('keepAlive');
          var isFromHistory = register.get(symbols.backtrack);
          var doCleanup = false;

          // if this request is executed due to a step back in history
          // and we have configured to destroy active page when we go back
          // in history or lazyDestory is enabled
          if (isFromHistory && (destroyOnBack || lazyDestroy)) {
            doCleanup = true;
          }

          // clean up if lazyDestroy is enabled and the keepAlive flag
          // in navigation register is false
          if (lazyDestroy && !keepAlive) {
            doCleanup = true;
          }

          // if the current and new request share the same route blueprint
          if (activeRoute === request.route.path) {
            doCleanup = true;
          }
          if (doCleanup) {
            // grab original class constructor if
            // statemachine routed else store constructor
            storeComponent(route, page._routedType || page.constructor);

            // actual remove of page from memory
            pagesHost.remove(page);

            // force texture gc() if configured
            // so we can cleanup textures in the same tick
            if (routerConfig.get('gcOnUnload')) {
              stage.gc();
            }
          } else {
            // If we're not removing the page we need to
            // reset it's properties
            page.patch({
              x: 0,
              y: 0,
              scale: 1,
              alpha: 1,
              visible: false
            });
          }
        };
        var getActiveHash = () => {
          return activeHash;
        };
        var setActivePage = page => {
          activePage = page;
        };
        var getActivePage = () => {
          return activePage;
        };
        var getActiveRoute = () => {
          return activeRoute;
        };
        var getLastHash = () => {
          return lastAcceptedHash;
        };
        var setLastHash = hash => {
          lastAcceptedHash = hash;
        };
        var setPreviousState = state => {
          previousState = state;
        };
        var getPreviousState = () => {
          return previousState;
        };
        var routeExists = key => {
          return routes$1.has(key);
        };
        var getRootHash = () => {
          return rootHash;
        };
        var getBootRequest = () => {
          return bootRequest;
        };
        var getRouterConfig = () => {
          return routerConfig;
        };
        var getRoutes = () => {
          return routes$1;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var isFunction$1 = v => {
          return typeof v === 'function';
        };
        var isObject$1 = v => {
          return typeof v === 'object' && v !== null;
        };
        var isBoolean$1 = v => {
          return typeof v === 'boolean';
        };
        var isPage = v => {
          if (v instanceof lightning.Element || isComponentConstructor(v)) {
            return true;
          }
          return false;
        };
        var isComponentConstructor = type => {
          return type.prototype && 'isComponent' in type.prototype;
        };
        var isArray$1 = v => {
          return Array.isArray(v);
        };
        var ucfirst = v => {
          return `${v.charAt(0).toUpperCase()}${v.slice(1)}`;
        };
        var isString$1 = v => {
          return typeof v === 'string';
        };
        var isPromise = method => {
          var result;
          if (isFunction$1(method)) {
            try {
              result = method.apply(null);
            } catch (e) {
              result = e;
            }
          } else {
            result = method;
          }
          return isObject$1(result) && isFunction$1(result.then);
        };
        var cleanHash = function cleanHash() {
          var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          return hash.replace(/^#/, '').replace(/\/+$/, '');
        };
        var getConfigMap = () => {
          var routerSettings = Settings$1.get('platform', 'router');
          var isObj = isObject$1(routerSettings);
          return ['backtrack', 'gcOnUnload', 'destroyOnHistoryBack', 'lazyCreate', 'lazyDestroy', 'reuseInstance', 'autoRestoreRemote', 'numberNavigation', 'updateHash', 'storeSameHash'].reduce((config, key) => {
            config.set(key, isObj ? routerSettings[key] : Settings$1.get('platform', key));
            return config;
          }, new Map());
        };
        var getQueryStringParams = function getQueryStringParams() {
          var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActiveHash();
          var resumeHash = getResumeHash();
          if ((hash === '$' || !hash) && resumeHash) {
            if (isString$1(resumeHash)) {
              hash = resumeHash;
            }
          }
          var parse = '';
          var getQuery = /([?&].*)/;
          var matches = getQuery.exec(hash);
          var params = {};
          if (document.location && document.location.search) {
            parse = document.location.search;
          }
          if (matches && matches.length) {
            var hashParams = matches[1];
            if (parse) {
              // if location.search is not empty we
              // remove the leading ? to create a
              // valid string
              hashParams = hashParams.replace(/^\?/, '');
              // we parse hash params last so they we can always
              // override search params with hash params
              parse = `${parse}&${hashParams}`;
            } else {
              parse = hashParams;
            }
          }
          if (parse) {
            var urlParams = new URLSearchParams(parse);
            var _iterator27 = _createForOfIteratorHelper(urlParams.entries()),
              _step29;
            try {
              for (_iterator27.s(); !(_step29 = _iterator27.n()).done;) {
                var _step29$value = _slicedToArray(_step29.value, 2),
                  key = _step29$value[0],
                  value = _step29$value[1];
                params[key] = value;
              }
            } catch (err) {
              _iterator27.e(err);
            } finally {
              _iterator27.f();
            }
            return params;
          } else {
            return false;
          }
        };
        var objectToQueryString = obj => {
          if (!isObject$1(obj)) {
            return '';
          }
          return '?' + Object.keys(obj).map(key => {
            return `${key}=${obj[key]}`;
          }).join('&');
        };
        var symbols = {
          route: Symbol('route'),
          hash: Symbol('hash'),
          store: Symbol('store'),
          fromHistory: Symbol('fromHistory'),
          expires: Symbol('expires'),
          resume: Symbol('resume'),
          backtrack: Symbol('backtrack'),
          historyState: Symbol('historyState'),
          queryParams: Symbol('queryParams')
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var dataHooks = {
          on: request => {
            setPreviousState(app$1.state || '');
            app$1._setState('Loading');
            return execProvider(request);
          },
          before: request => {
            return execProvider(request);
          },
          after: request => {
            try {
              execProvider(request, true);
            } catch (e) {
              // for now we fail silently
            }
            return Promise.resolve();
          }
        };
        var execProvider = (request, emitProvided) => {
          var route = request.route;
          var provider = route.provider;
          var expires = route.cache ? route.cache * 1000 : 0;
          var params = addPersistData(request);
          return provider.request(request.page, _objectSpread({}, params)).then(() => {
            request.page[symbols.expires] = Date.now() + expires;
            if (emitProvided) {
              emit(request.page, 'dataProvided');
            }
          }).catch(e => {
            request.page[symbols.expires] = Date.now();
            throw e;
          });
        };
        var addPersistData = _ref16 => {
          var page = _ref16.page,
            route = _ref16.route,
            hash = _ref16.hash,
            _ref16$register = _ref16.register,
            register = _ref16$register === void 0 ? new Map() : _ref16$register;
          var urlValues = getValuesFromHash(hash, route.path);
          var queryParams = getQueryStringParams(hash);
          var pageData = new Map([...urlValues, ...register]);
          var params = {};

          // make dynamic url data available to the page
          // as instance properties
          var _iterator28 = _createForOfIteratorHelper(pageData),
            _step30;
          try {
            for (_iterator28.s(); !(_step30 = _iterator28.n()).done;) {
              var _step30$value = _slicedToArray(_step30.value, 2),
                _name3 = _step30$value[0],
                value = _step30$value[1];
              params[_name3] = value;
            }
          } catch (err) {
            _iterator28.e(err);
          } finally {
            _iterator28.f();
          }
          if (queryParams) {
            params[symbols.queryParams] = queryParams;
          }

          // check navigation register for persistent data
          if (register.size) {
            var obj = {};
            var _iterator29 = _createForOfIteratorHelper(register),
              _step31;
            try {
              for (_iterator29.s(); !(_step31 = _iterator29.n()).done;) {
                var _step31$value = _slicedToArray(_step31.value, 2),
                  k = _step31$value[0],
                  v = _step31$value[1];
                obj[k] = v;
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
            page.persist = obj;
          }

          // make url data and persist data available
          // via params property
          page.params = params;
          emit(page, ['urlParams'], params);
          return params;
        };

        /**
         * Test if page passed cache-time
         * @param page
         * @returns {boolean}
         */
        var isPageExpired = page => {
          if (!page[symbols.expires]) {
            return false;
          }
          var expires = page[symbols.expires];
          var now = Date.now();
          return now >= expires;
        };
        var hasProvider = path => {
          if (routeExists(path)) {
            var record = routes$1.get(path);
            return !!record.provider;
          }
          return false;
        };
        var getProvider = route => {
          // @todo: fix, route already is passed in
          if (routeExists(route.path)) {
            var _routes$1$get = routes$1.get(route.path),
              provider = _routes$1$get.provider;
            return {
              type: provider.type,
              provider: provider.request
            };
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var fade = (i, o) => {
          return new Promise(resolve => {
            i.patch({
              alpha: 0,
              visible: true,
              smooth: {
                alpha: [1, {
                  duration: 0.5,
                  delay: 0.1
                }]
              }
            });
            // resolve on y finish
            i.transition('alpha').on('finish', () => {
              if (o) {
                o.visible = false;
              }
              resolve();
            });
          });
        };
        var crossFade = (i, o) => {
          return new Promise(resolve => {
            i.patch({
              alpha: 0,
              visible: true,
              smooth: {
                alpha: [1, {
                  duration: 0.5,
                  delay: 0.1
                }]
              }
            });
            if (o) {
              o.patch({
                smooth: {
                  alpha: [0, {
                    duration: 0.5,
                    delay: 0.3
                  }]
                }
              });
            }
            // resolve on y finish
            i.transition('alpha').on('finish', () => {
              resolve();
            });
          });
        };
        var moveOnAxes = (axis, direction, i, o) => {
          var bounds = axis === 'x' ? 1920 : 1080;
          return new Promise(resolve => {
            i.patch({
              [`${axis}`]: direction ? bounds * -1 : bounds,
              visible: true,
              smooth: {
                [`${axis}`]: [0, {
                  duration: 0.4,
                  delay: 0.2
                }]
              }
            });
            // out is optional
            if (o) {
              o.patch({
                [`${axis}`]: 0,
                smooth: {
                  [`${axis}`]: [direction ? bounds : bounds * -1, {
                    duration: 0.4,
                    delay: 0.2
                  }]
                }
              });
            }
            // resolve on y finish
            i.transition(axis).on('finish', () => {
              resolve();
            });
          });
        };
        var up = (i, o) => {
          return moveOnAxes('y', 0, i, o);
        };
        var down = (i, o) => {
          return moveOnAxes('y', 1, i, o);
        };
        var left = (i, o) => {
          return moveOnAxes('x', 0, i, o);
        };
        var right = (i, o) => {
          return moveOnAxes('x', 1, i, o);
        };
        var Transitions = {
          fade,
          crossFade,
          up,
          down,
          left,
          right
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * execute transition between new / old page and
         * toggle the defined widgets
         * @todo: platform override default transition
         * @param pageIn
         * @param pageOut
         */
        var executeTransition = function executeTransition(pageIn) {
          var pageOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var transition = pageIn.pageTransition || pageIn.easing;
          var hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
          var transitionsDisabled = getRouterConfig().get('disableTransitions');
          if (pageIn.easing) {
            console.warn('easing() method is deprecated and will be removed. Use pageTransition()');
          }

          // default behaviour is a visibility toggle
          if (!hasCustomTransitions || transitionsDisabled) {
            pageIn.visible = true;
            if (pageOut) {
              pageOut.visible = false;
            }
            return Promise.resolve();
          }
          if (transition) {
            var type;
            try {
              type = transition.call(pageIn, pageIn, pageOut);
            } catch (e) {
              type = 'crossFade';
            }
            if (isPromise(type)) {
              return type;
            }
            if (isString$1(type)) {
              var fn = Transitions[type];
              if (fn) {
                return fn(pageIn, pageOut);
              }
            }

            // keep backwards compatible for now
            if (pageIn.smoothIn) {
              // provide a smooth function that resolves itself
              // on transition finish
              var smooth = function smooth(p, v) {
                var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                return new Promise(resolve => {
                  pageIn.visible = true;
                  pageIn.setSmooth(p, v, args);
                  pageIn.transition(p).on('finish', () => {
                    resolve();
                  });
                });
              };
              return pageIn.smoothIn({
                pageIn,
                smooth
              });
            }
          }
          return Transitions.crossFade(pageIn, pageOut);
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /**
         * The actual loading of the component
         * */
        var load = /*#__PURE__*/function () {
          var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
            var expired, route;
            return _regeneratorRuntime().wrap(function _callee3$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  expired = false;
                  _context5.prev = 1;
                  _context5.next = 4;
                  return loader(request);
                case 4:
                  request = _context5.sent;
                  if (!(request && !request.isCancelled)) {
                    _context5.next = 12;
                    break;
                  }
                  // in case of on() providing we need to reset
                  // app state;
                  if (app$1.state === 'Loading') {
                    if (getPreviousState() === 'Widgets') {
                      app$1._setState('Widgets', [getActiveWidget()]);
                    } else {
                      app$1._setState('');
                    }
                  }
                  // Do page transition if instance
                  // is not shared between the routes
                  if (!(!request.isSharedInstance && !request.isCancelled)) {
                    _context5.next = 10;
                    break;
                  }
                  _context5.next = 10;
                  return executeTransition(request.page, getActivePage());
                case 10:
                  _context5.next = 13;
                  break;
                case 12:
                  expired = true;
                case 13:
                  if (!(expired || request.isCancelled)) {
                    _context5.next = 18;
                    break;
                  }
                  Log$1.debug('[router]:', `Rejected ${request.hash} because route to ${getLastHash()} started`);
                  if (request.isCreated && !request.isSharedInstance) {
                    // remove from render-tree
                    pagesHost.remove(request.page);
                  }
                  _context5.next = 20;
                  break;
                case 18:
                  onRequestResolved(request);
                  // resolve promise
                  return _context5.abrupt("return", request.page);
                case 20:
                  _context5.next = 25;
                  break;
                case 22:
                  _context5.prev = 22;
                  _context5.t0 = _context5["catch"](1);
                  if (!_context5.t0.route) {
                    console.error(_context5.t0);
                  } else if (!expired) {
                    // @todo: revisit
                    route = _context5.t0.route; // clean up history if modifier is set
                    if (getOption(route.options, 'clearHistory')) {
                      setHistory([]);
                    } else if (!isWildcard.test(route.path)) {
                      updateHistory(_context5.t0);
                    }
                    if (_context5.t0.isCreated && !_context5.t0.isSharedInstance) {
                      // remove from render-tree
                      pagesHost.remove(_context5.t0.page);
                    }
                    handleError(_context5.t0);
                  }
                case 25:
                case "end":
                  return _context5.stop();
              }
            }, _callee3, null, [[1, 22]]);
          }));
          return function load(_x5) {
            return _ref17.apply(this, arguments);
          };
        }();
        var loader = /*#__PURE__*/function () {
          var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
            var route, hash, register, type, isConstruct, provide, currentRoute, _getProvider, loadType, provider;
            return _regeneratorRuntime().wrap(function _callee4$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  route = request.route;
                  hash = request.hash;
                  register = request.register; // todo: grab from Route instance
                  type = getComponent(route.path);
                  isConstruct = isComponentConstructor(type);
                  provide = false; // if it's an instance bt we're not coming back from
                  // history we test if we can re-use this instance
                  if (!isConstruct && !register.get(symbols.backtrack)) {
                    if (!mustReuse(route)) {
                      type = type.constructor;
                      isConstruct = true;
                    }
                  }

                  // If page is Lightning Component instance
                  if (!isConstruct) {
                    request.page = type;
                    // if we have have a data route for current page
                    if (hasProvider(route.path)) {
                      if (isPageExpired(type) || type[symbols.hash] !== hash) {
                        provide = true;
                      }
                    }
                    currentRoute = getActivePage() && getActivePage()[symbols.route]; // if the new route is equal to the current route it means that both
                    // route share the Component instance and stack location / since this case
                    // is conflicting with the way before() and after() loading works we flag it,
                    // and check platform settings in we want to re-use instance
                    if (route.path === currentRoute) {
                      request.isSharedInstance = true;
                      // since we're re-using the instance we must attach
                      // historyState to the request to prevent it from
                      // being overridden.
                      if (isFunction$1(request.page.historyState)) {
                        request.copiedHistoryState = request.page.historyState();
                      }
                    }
                  } else {
                    request.page = createComponent(stage, type);
                    pagesHost.a(request.page);
                    // test if need to request data provider
                    if (hasProvider(route.path)) {
                      provide = true;
                    }
                    request.isCreated = true;
                  }

                  // we store hash and route as properties on the page instance
                  // that way we can easily calculate new behaviour on page reload
                  request.page[symbols.hash] = hash;
                  request.page[symbols.route] = route.path;
                  _context6.prev = 10;
                  if (!provide) {
                    _context6.next = 25;
                    break;
                  }
                  // extract attached data-provider for route
                  // we're processing
                  _getProvider = getProvider(route), loadType = _getProvider.type, provider = _getProvider.provider; // update running request
                  request.provider = provider;
                  request.providerType = loadType;
                  _context6.next = 17;
                  return dataHooks[loadType](request);
                case 17:
                  if (!(hash !== getLastHash())) {
                    _context6.next = 21;
                    break;
                  }
                  return _context6.abrupt("return", false);
                case 21:
                  if (request.providerType !== 'after') {
                    emit(request.page, 'dataProvided');
                  }
                  // resolve promise
                  return _context6.abrupt("return", request);
                case 23:
                  _context6.next = 27;
                  break;
                case 25:
                  addPersistData(request);
                  return _context6.abrupt("return", request);
                case 27:
                  _context6.next = 33;
                  break;
                case 29:
                  _context6.prev = 29;
                  _context6.t0 = _context6["catch"](10);
                  request.error = _context6.t0;
                  return _context6.abrupt("return", Promise.reject(request));
                case 33:
                case "end":
                  return _context6.stop();
              }
            }, _callee4, null, [[10, 29]]);
          }));
          return function loader(_x6) {
            return _ref18.apply(this, arguments);
          };
        }();
        var handleError = request => {
          if (request && request.error) {
            console.error(request.error);
          } else if (request) {
            Log$1.error(request);
          }
          if (request.page && routeExists('!')) {
            navigate('!', {
              request
            }, false);
          }
        };
        var mustReuse = route => {
          var opt = getOption(route.options, 'reuseInstance');
          var config = routerConfig.get('reuseInstance');

          // route always has final decision
          if (isBoolean$1(opt)) {
            return opt;
          }
          return !(isBoolean$1(config) && config === false);
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class RoutedApp extends lightning.Component {
          static _template() {
            return {
              Pages: {
                forceZIndexContext: true
              },
              /**
               * This is a default Loading page that will be made visible
               * during data-provider on() you CAN override in child-class
               */
              Loading: {
                rect: true,
                w: 1920,
                h: 1080,
                color: 0xff000000,
                visible: false,
                zIndex: 99,
                Label: {
                  mount: 0.5,
                  x: 960,
                  y: 540,
                  text: {
                    text: 'Loading..'
                  }
                }
              }
            };
          }
          static _states() {
            return [class Loading extends this {
              $enter() {
                this.tag('Loading').visible = true;
              }
              $exit() {
                this.tag('Loading').visible = false;
              }
            }, class Widgets extends this {
              $enter(args, widget) {
                // store widget reference
                this._widget = widget;

                // since it's possible that this behaviour
                // is non-remote driven we force a recalculation
                // of the focuspath
                this._refocus();
              }
              _getFocused() {
                // we delegate focus to selected widget
                // so it can consume remotecontrol presses
                return this._widget;
              }

              // if we want to widget to widget focus delegation
              reload(widget) {
                this._widget = widget;
                this._refocus();
              }
              _handleKey() {
                var restoreFocus = routerConfig.get('autoRestoreRemote');
                /**
                 * The Router used to delegate focus back to the page instance on
                 * every unhandled key. This is barely usefull in any situation
                 * so for now we offer the option to explicity turn that behaviour off
                 * so we don't don't introduce a breaking change.
                 */
                if (!isBoolean$1(restoreFocus) || restoreFocus === true) {
                  Router.focusPage();
                }
              }
            }];
          }

          /**
           * Return location where pages need to be stored
           */
          get pages() {
            return this.tag('Pages');
          }

          /**
           * Tell router where widgets are stored
           */
          get widgets() {
            return this.tag('Widgets');
          }

          /**
           * we MUST register _handleBack method so the Router
           * can override it
           * @private
           */
          _handleBack() {}

          /**
           * We MUST return Router.activePage() so the new Page
           * can listen to the remote-control.
           */
          _getFocused() {
            return Router.getActivePage();
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        /*
        rouThor ==[x]
         */
        var navigateQueue = new Map();
        var forcedHash = '';
        var resumeHash = '';

        /**
         * Start routing the app
         * @param config - route config object
         * @param instance - instance of the app
         */
        var startRouter = (config, instance) => {
          bootRouter(config, instance);
          registerListener();
          start();
        };

        // start translating url
        var start = () => {
          var hash = (getHash() || '').replace(/^#/, '');
          var bootKey = '$';
          var params = getQueryStringParams(hash);
          var bootRequest = getBootRequest();
          var rootHash = getRootHash();
          var isDirectLoad = hash.indexOf(bootKey) !== -1;

          // prevent direct reload of wildcard routes
          // expect bootComponent
          if (isWildcard.test(hash) && hash !== bootKey) {
            hash = '';
          }

          // store resume point for manual resume
          resumeHash = isDirectLoad ? rootHash : hash || rootHash;
          var ready = () => {
            if (!hash && rootHash) {
              if (isString$1(rootHash)) {
                navigate(rootHash);
              } else if (isFunction$1(rootHash)) {
                rootHash().then(res => {
                  if (isObject$1(res)) {
                    navigate(res.path, res.params);
                  } else {
                    navigate(res);
                  }
                });
              }
            } else {
              queue(hash);
              handleHashChange().then(() => {
                app$1._refocus();
              }).catch(e => {
                console.error(e);
              });
            }
          };
          if (routeExists(bootKey)) {
            if (hash && !isDirectLoad) {
              if (!getRouteByHash(hash)) {
                navigate('*', {
                  failedHash: hash
                });
                return;
              }
            }
            navigate(bootKey, {
              resume: resumeHash,
              reload: bootKey === hash
            }, false);
          } else if (isFunction$1(bootRequest)) {
            bootRequest(params).then(() => {
              ready();
            }).catch(e => {
              handleBootError(e);
            });
          } else {
            ready();
          }
        };
        var handleBootError = e => {
          if (routeExists('!')) {
            navigate('!', {
              request: {
                error: e
              }
            });
          } else {
            console.error(e);
          }
        };

        /**
         * start a new request
         * @param url
         * @param args
         * @param store
         */
        var navigate = function navigate(url) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var store = arguments.length > 2 ? arguments[2] : undefined;
          if (isObject$1(url)) {
            url = getHashByName(url);
            if (!url) {
              return;
            }
          }
          var hash = getHash();
          if (!mustUpdateLocationHash() && forcedHash) {
            hash = forcedHash;
          }
          if (hash.replace(/^#/, '') !== url) {
            // push request in the queue
            queue(url, args, store);
            if (mustUpdateLocationHash()) {
              setHash(url);
            } else {
              forcedHash = url;
              handleHashChange(url).then(() => {
                app$1._refocus();
              }).catch(e => {
                console.error(e);
              });
            }
          } else if (args.reload) {
            // push request in the queue
            queue(url, args, store);
            handleHashChange(url).then(() => {
              app$1._refocus();
            }).catch(e => {
              console.error(e);
            });
          }
        };
        var queue = function queue(hash) {
          var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var store = arguments.length > 2 ? arguments[2] : undefined;
          hash = cleanHash(hash);
          if (!navigateQueue.has(hash)) {
            var _iterator30 = _createForOfIteratorHelper(navigateQueue.values()),
              _step32;
            try {
              for (_iterator30.s(); !(_step32 = _iterator30.n()).done;) {
                var _request2 = _step32.value;
                _request2.cancel();
              }
            } catch (err) {
              _iterator30.e(err);
            } finally {
              _iterator30.f();
            }
            var request = createRequest(hash, args, store);
            navigateQueue.set(decodeURIComponent(hash), request);
            return request;
          }
          return false;
        };

        /**
         * Handle change of hash
         * @param override
         * @returns {Promise<void>}
         */
        var handleHashChange = /*#__PURE__*/function () {
          var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(override) {
            var hash, queueId, request, route, result, store;
            return _regeneratorRuntime().wrap(function _callee5$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  hash = cleanHash(override || getHash());
                  queueId = decodeURIComponent(hash);
                  request = navigateQueue.get(queueId); // handle hash updated manually
                  if (!request && !navigateQueue.size) {
                    request = queue(hash);
                  }
                  route = getRouteByHash(hash);
                  if (route) {
                    _context7.next = 8;
                    break;
                  }
                  if (routeExists('*')) {
                    navigate('*', {
                      failedHash: hash
                    });
                  } else {
                    console.error(`Unable to navigate to: ${hash}`);
                  }
                  return _context7.abrupt("return");
                case 8:
                  // update current processed request
                  request.hash = hash;
                  request.route = route;
                  _context7.next = 12;
                  return beforeEachRoute(getActiveHash(), request);
                case 12:
                  result = _context7.sent;
                  if (!(result && route.beforeNavigate)) {
                    _context7.next = 17;
                    break;
                  }
                  _context7.next = 16;
                  return route.beforeNavigate(getActiveHash(), request);
                case 16:
                  result = _context7.sent;
                case 17:
                  if (!isBoolean$1(result)) {
                    _context7.next = 22;
                    break;
                  }
                  if (!result) {
                    _context7.next = 20;
                    break;
                  }
                  return _context7.abrupt("return", resolveHashChange(request));
                case 20:
                  _context7.next = 25;
                  break;
                case 22:
                  // if navigation guard didn't return true
                  // we cancel the current request
                  request.cancel();
                  navigateQueue.delete(queueId);
                  if (isString$1(result)) {
                    navigate(result);
                  } else if (isObject$1(result)) {
                    store = true;
                    if (isBoolean$1(result.store)) {
                      store = result.store;
                    }
                    navigate(result.path, result.params, store);
                  }
                case 25:
                case "end":
                  return _context7.stop();
              }
            }, _callee5);
          }));
          return function handleHashChange(_x7) {
            return _ref19.apply(this, arguments);
          };
        }();

        /**
         * Continue processing the hash change if not blocked
         * by global or local hook
         * @param request - {}
         */
        var resolveHashChange = request => {
          var hash = request.hash;
          var route = request.route;
          var queueId = decodeURIComponent(hash);
          // store last requested hash so we can
          // prevent a route that resolved later
          // from displaying itself
          setLastHash(hash);
          if (route.path) {
            var component = getComponent(route.path);
            // if a hook is provided for the current route
            if (isFunction$1(route.hook)) {
              var urlParams = getValuesFromHash(hash, route.path);
              var params = {};
              var _iterator31 = _createForOfIteratorHelper(urlParams.keys()),
                _step33;
              try {
                for (_iterator31.s(); !(_step33 = _iterator31.n()).done;) {
                  var key = _step33.value;
                  params[key] = urlParams.get(key);
                }
              } catch (err) {
                _iterator31.e(err);
              } finally {
                _iterator31.f();
              }
              route.hook(app$1, _objectSpread({}, params));
            }
            // if there is a component attached to the route
            if (component) {
              // force page to root state to prevent shared state issues
              var _activePage = getActivePage();
              if (_activePage) {
                var keepAlive = keepActivePageAlive(getActiveRoute(), request);
                if (_activePage && route.path === getActiveRoute() && !keepAlive) {
                  _activePage._setState('');
                }
              }
              if (isPage(component)) {
                load(request).then(() => {
                  app$1._refocus();
                  navigateQueue.delete(queueId);
                });
              } else {
                // of the component is not a constructor
                // or a Component instance we can assume
                // that it's a dynamic import
                component().then(contents => {
                  return contents.default;
                }).then(module => {
                  storeComponent(route.path, module);
                  return load(request);
                }).then(() => {
                  app$1._refocus();
                  navigateQueue.delete(queueId);
                });
              }
            } else {
              navigateQueue.delete(queueId);
            }
          }
        };

        /**
         * Directional step in history
         * @param level
         */
        var step = function step() {
          var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          if (!level || isNaN(level)) {
            return false;
          }
          var history = getHistory();
          // for now we only support negative numbers
          level = Math.abs(level);

          // we can't step back past the amount
          // of history entries
          if (level > history.length) {
            if (isFunction$1(app$1._handleAppClose)) {
              return app$1._handleAppClose();
            }
            return app$1.application.closeApp();
          } else if (history.length) {
            // for now we only support history back
            var route = history.splice(history.length - level, level)[0];
            // store changed history
            setHistory(history);
            return navigate(route.hash, {
              [symbols.backtrack]: true,
              [symbols.historyState]: route.state
            }, false);
          } else if (routerConfig.get('backtrack')) {
            var hashLastPart = /(\/:?[\w%\s-]+)$/;
            var hash = stripRegex(getHash());
            var floor = getFloor(hash);

            // test if we got deep-linked
            if (floor > 1) {
              while (floor--) {
                // strip of last part
                hash = hash.replace(hashLastPart, '');
                // if we have a configured route
                // we navigate to it
                if (getRouteByHash(hash)) {
                  return navigate(hash, {
                    [symbols.backtrack]: true
                  }, false);
                }
              }
            }
          }
          return false;
        };

        /**
         * Resume Router's page loading process after
         * the BootComponent became visible;
         */
        var resume = () => {
          if (isString$1(resumeHash)) {
            navigate(resumeHash, false);
            resumeHash = '';
          } else if (isFunction$1(resumeHash)) {
            resumeHash().then(res => {
              resumeHash = '';
              if (isObject$1(res)) {
                navigate(res.path, res.params);
              } else {
                navigate(res);
              }
            });
          } else {
            console.warn('[Router]: resume() called but no hash found');
          }
        };

        /**
         * Force reload active hash
         */
        var reload = () => {
          if (!isNavigating()) {
            var hash = getActiveHash();
            navigate(hash, {
              reload: true
            }, false);
          }
        };

        /**
         * Query if the Router is still processing a Request
         * @returns {boolean}
         */
        var isNavigating = () => {
          if (navigateQueue.size) {
            var isProcessing = false;
            var _iterator32 = _createForOfIteratorHelper(navigateQueue.values()),
              _step34;
            try {
              for (_iterator32.s(); !(_step34 = _iterator32.n()).done;) {
                var request = _step34.value;
                if (!request.isCancelled) {
                  isProcessing = true;
                }
              }
            } catch (err) {
              _iterator32.e(err);
            } finally {
              _iterator32.f();
            }
            return isProcessing;
          }
          return false;
        };
        var getResumeHash = () => {
          return resumeHash;
        };

        /**
         * By default we return the location hash
         * @returns {string}
         */
        var getHash = () => {
          return document.location.hash;
        };

        /**
         * Update location hash
         * @param url
         */
        var setHash = url => {
          document.location.hash = url;
        };

        /**
         * This can be called from the platform / bootstrapper to override
         * the default getting and setting of the hash
         * @param config
         */
        var initRouter = config => {
          if (config.getHash) {
            getHash = config.getHash;
          }
          if (config.setHash) {
            setHash = config.setHash;
          }
        };

        /**
         * On hash change we start processing
         */
        var registerListener = () => {
          Registry.addEventListener(window, 'hashchange', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
            return _regeneratorRuntime().wrap(function _callee6$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  if (!mustUpdateLocationHash()) {
                    _context8.next = 9;
                    break;
                  }
                  _context8.prev = 1;
                  _context8.next = 4;
                  return handleHashChange();
                case 4:
                  _context8.next = 9;
                  break;
                case 6:
                  _context8.prev = 6;
                  _context8.t0 = _context8["catch"](1);
                  console.error(_context8.t0);
                case 9:
                case "end":
                  return _context8.stop();
              }
            }, _callee6, null, [[1, 6]]);
          })));
        };

        /**
         * Navigate to root hash
         */
        var root = () => {
          var rootHash = getRootHash();
          if (isString$1(rootHash)) {
            navigate(rootHash);
          } else if (isFunction$1(rootHash)) {
            rootHash().then(res => {
              if (isObject$1(res)) {
                navigate(res.path, res.params);
              } else {
                navigate(res);
              }
            });
          }
        };

        // export API
        var Router = {
          startRouter,
          navigate,
          resume,
          step,
          go: step,
          back: step.bind(null, -1),
          activePage: getActivePage,
          getActivePage() {
            // warning
            return getActivePage();
          },
          getActiveRoute,
          getActiveHash,
          focusWidget,
          getActiveWidget,
          restoreFocus,
          isNavigating,
          getHistory,
          setHistory,
          getHistoryState,
          replaceHistoryState,
          getQueryStringParams,
          reload,
          symbols,
          App: RoutedApp,
          // keep backwards compatible
          focusPage: restoreFocus,
          root: root,
          /**
           * Deprecated api methods
           */
          setupRoutes() {
            console.warn('Router: setupRoutes is deprecated, consolidate your configuration');
            console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
          },
          on() {
            console.warn('Router.on() is deprecated, consolidate your configuration');
            console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
          },
          before() {
            console.warn('Router.before() is deprecated, consolidate your configuration');
            console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
          },
          after() {
            console.warn('Router.after() is deprecated, consolidate your configuration');
            console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var ApplicationInstance;
        var Launch = (App, appSettings, platformSettings, appData) => {
          initSettings(appSettings, platformSettings);
          initUtils(platformSettings);
          initStorage();
          // Initialize plugins
          if (platformSettings.plugins) {
            platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
            platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
            platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
            platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
            platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
            platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
            platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
            platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
            platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
          }
          var app = Application(App, appData, platformSettings);
          initLightningSdkPlugin.log = Log$1;
          initLightningSdkPlugin.settings = Settings$1;
          initLightningSdkPlugin.ads = Ads;
          initLightningSdkPlugin.lightning = lightning;
          ApplicationInstance = new app(appSettings);
          initLightningSdkPlugin.appInstance = ApplicationInstance;
          return ApplicationInstance;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class SubtitleComponent extends lightning.Component {
          static _template() {
            return {
              visible: false,
              rect: true,
              color: 0x90000000,
              shader: {
                type: lightning.shaders.RoundedRectangle,
                radius: 5
              },
              Text: {
                y: 5,
                x: 20,
                text: {
                  textColor: 0xffffffff,
                  fontSize: 38,
                  lineHeight: 38 * 1.4,
                  textAlign: 'center',
                  wordWrap: true,
                  maxLines: 3,
                  shadow: true,
                  shadowColor: 0xff333333
                }
              }
            };
          }
          _init() {
            this._textTextureDefaults = new lightning.textures.TextTexture(this.stage).cloneArgs();
            this.tag('Text').on('txLoaded', _ref21 => {
              var _source = _ref21._source;
              this.w = _source.w + this.tag('Text').x * 2;
              this.h = _source.h;
              this.position();
            });
          }
          get textFormat() {
            var textTag = this.tag('Text').text;
            return {
              fontFace: textTag.fontFace || 'sans-serif',
              fontSize: textTag.fontSize,
              lineHeight: textTag.lineHeight,
              textAlign: textTag.textAlign,
              wordWrap: true,
              maxLines: textTag.maxLines
            };
          }
          show() {
            this.visible = true;
          }
          hide() {
            this.visible = false;
          }
          position() {
            this.x = this._calculateX(this.xPos);
            this.y = this._calculateY(this.yPos);
          }
          set viewportW(v) {
            this._viewportW = v;
            this.x = this._calculateX(this.xPos);
          }
          get viewportW() {
            return this._viewportW || this.application.finalW;
          }
          set viewportH(v) {
            this._viewportH = v;
            this.y = this._calculateY(this.yPos);
          }
          get viewportH() {
            return this._viewportH || this.application.finalH;
          }
          _calculateX(x) {
            if (x === 'center') {
              x = (this.viewportW - this.finalW) / 2;
            } else if (x === 'left') {
              x = 60;
            } else if (x === 'right') {
              x = this.viewportW - this.finalW - 60;
            }
            return x;
          }
          set xPos(v) {
            this._x = v;
            this.x = this._calculateX(v);
          }
          get xPos() {
            return this._x || 'center';
          }
          _calculateY(y) {
            if (y === 'center') {
              return (this.viewportH - this.finalH) / 2;
            } else if (y === 'top') {
              return 60;
            } else if (y === 'bottom') {
              return this.viewportH - this.finalH - 60;
            }
            return y;
          }
          set yPos(v) {
            this._y = v;
            this.y = this._calculateY(v);
          }
          get yPos() {
            return this._y || 'bottom';
          }
          set fontFamily(v) {
            this.tag('Text').text.fontFace = v;
          }
          set fontSize(v) {
            this.tag('Text').text.fontSize = v;
            this.tag('Text').text.lineHeight = v * 1.3;
          }
          set fontColor(v) {
            this.tag('Text').color = v;
          }
          set backgroundColor(v) {
            this.color = v;
          }
          _defineBreakpoint(text, breakpoint) {
            if (breakpoint >= this.maxWidth) return this.maxWidth;
            var info = lightning.textures.TextTexture.renderer(this.stage, this.stage.platform.getDrawingCanvas(), _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this._textTextureDefaults), this.textFormat), {
              wordWrapWidth: breakpoint
            }), {}, {
              text
            }))._calculateRenderInfo();
            if (info.width <= breakpoint && info.lines.length <= 2) {
              return breakpoint;
            } else {
              return this._defineBreakpoint(text, breakpoint * 1.25);
            }
          }
          set text(v) {
            this.alpha = 0;
            if (v && v.length) {
              var breakpoint = this._defineBreakpoint(v, 640);
              this.tag('Text').text.wordWrapWidth = breakpoint;
              this.tag('Text').text = v;
              this.alpha = 1;
            }
          }
          set textAlign(v) {
            this._textAlign = v;
            this.tag('Text').text.textAlign = v;
          }
          set maxWidth(v) {
            this._maxWidth = v;
          }
          get maxWidth() {
            return (this._maxWidth || 1200) - this.tag('Text').x * 2;
          }
          set maxLines(v) {
            this.tag('Text').text.maxLines = v;
          }
        }
        var theme = {
          colors: {
            background: 4279639853,
            primary: 4279509822,
            primaryLight: 4280169822,
            secondary: 4283596540,
            tertiary: 4284586236,
            accent: 4291485694,
            error: 4281685370,
            warning: 4281685370,
            info: 4281685370,
            white: 4294046193,
            yellow: 4294105945,
            accentGrey: {
              light: 4288784562,
              dark: 4282732896
            },
            dark: 4278584867,
            black: 4278190080
          }
        };
        var endp = ["/filters/dgnlsl30-movies-action?page=1&language=en&size=50", "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50", "/filters/marvel-movies?page=1&language=en&size=50", "/filters/gNAaDQJl13GS?page=1&language=en&size=100", "/filters/dgnlsl30-movies-action?page=1&language=en&size=50", "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50", "/filters/marvel-movies?page=1&language=en&size=50", "/filters/gNAaDQJl13GS?page=1&language=en&size=100", "/filters/dgnlsl30-movies-action?page=1&language=en&size=50", "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50", "/filters/marvel-movies?page=1&language=en&size=50", "/filters/gNAaDQJl13GS?page=1&language=en&size=100", "/filters/dgnlsl30-movies-action?page=1&language=en&size=50", "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50", "/filters/marvel-movies?page=1&language=en&size=50", "/filters/gNAaDQJl13GS?page=1&language=en&size=100"];
        var railName = ["Action Movies", "Only on Enlight", "Marvel Movies", "Drama Movies", "Romantic Comdey Movies", "Trending Now", "Comdey Movies", "Thriller Movies", "Action Movies", "Only on Enlight", "Marvel Movies", "Drama Movies", "Romantic Comdey Movies", "Trending Now", "Comdey Movies", "Thriller Movies", "Long Rail"];

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CollectionWrapper extends lightning.Component {
          static _template() {
            return {
              Wrapper: {}
            };
          }
          _construct() {
            this._direction = CollectionWrapper.DIRECTION.row;
            this._scrollTransitionSettings = this.stage.transitions.createSettings({});
            this._spacing = 0;
            this._autoResize = false;
            this._requestingItems = false;
            this._requestThreshold = 1;
            this._requestsEnabled = false;
            this._gcThreshold = 5;
            this._gcIncrement = 0;
            this._forceLoad = false;
            this.clear();
          }
          _setup() {
            this._updateScrollTransition();
          }
          _updateScrollTransition() {
            var axis = this._direction === 1 ? 'y' : 'x';
            this.wrapper.transition(axis, this._scrollTransitionSettings);
            this._scrollTransition = this.wrapper.transition(axis);
          }
          _indexChanged(obj) {
            var previous = obj.previousIndex,
              target = obj.index,
              max = obj.dataLength,
              mainIndex = obj.mainIndex,
              previousMainIndex = obj.previousMainIndex,
              lines = obj.lines;
            if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
              previous = previousMainIndex;
              target = mainIndex;
              max = lines;
            }
            if (this._requestsEnabled && !this._requestingItems) {
              if (target + this._requestThreshold >= max) {
                this.requestItems(false, obj);
              }
            }
            this._refocus();
            this.scrollCollectionWrapper(obj);
            if (obj.previousIndex !== obj.index) {
              this.signal('onIndexChanged', obj);
            }
          }
          requestItems() {
            var reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
            if (obj === undefined) {
              obj = {
                previous: 0,
                index: 0,
                max: 0
              };
            }
            this._requestingItems = true;
            this.signal('onRequestItems', obj).then(response => {
              if (response === false) {
                this.enableRequests = false;
              }
              this._requestingItems = false;
              if (reload) {
                this.clear();
              }
              var type = typeof response;
              if (Array.isArray(response) || type === 'object' || type === 'string' || type === 'number') {
                this.add(response);
              }
            });
          }
          setIndex(index) {
            var targetIndex = limitWithinRange(index, 0, this._items.length - 1);
            var previousIndex = this._index;
            this._index = targetIndex;
            this._indexChanged({
              previousIndex,
              index: targetIndex,
              dataLength: this._items.length
            });
            return previousIndex !== targetIndex;
          }
          clear() {
            this._uids = [];
            this._items = [];
            this._index = 0;
            if (this._scrollTransition) {
              this._scrollTransition.reset(0, 1);
            }
            if (this.wrapper) {
              var hadChildren = this.wrapper.children > 0;
              this.wrapper.patch({
                x: 0,
                y: 0,
                children: []
              });
              if (hadChildren) {
                this._collectGarbage(true);
              }
            }
          }
          add(item) {
            this.addAt(item);
          }
          addAt(item) {
            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._items.length;
            if (index >= 0 && index <= this._items.length) {
              if (!Array.isArray(item)) {
                item = [item];
              }
              var items = this._normalizeDataItems(item);
              this._items.splice(index, 0, ...items);
              this.plotItems();
              this.setIndex(this._index);
            } else {
              throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
            }
          }
          remove(target) {
            if (this.hasItems && target.assignedID) {
              var itemWrappers = this.itemWrappers;
              for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                if (itemWrappers[i] && itemWrappers[i].component.isAlive) {
                  item = itemWrappers[i].component;
                }
                if (target.assignedID === item.assignedID) {
                  return this.removeAt(i);
                }
              }
            } else {
              throw new Error('remove: item not found');
            }
          }
          removeAt(index) {
            var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            if (index < 0 && index >= this._items.length) {
              throw new Error('removeAt: The index ' + index + ' is out of bounds ' + this._items.length);
            }
            var item = this._items[index];
            this._items.splice(index, amount);
            this.plotItems();
            return item;
          }
          reload(item) {
            this.clear();
            this.add(item);
          }
          plotItems(items, options) {
            //placeholder
          }
          reposition() {
            var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 70;
            if (this._repositionDebounce) {
              clearTimeout(this._repositionDebounce);
            }
            this._repositionDebounce = setTimeout(() => {
              this.repositionItems();
            }, time);
          }
          repositionItems() {
            //placeHolder
            this.signal('onItemsRepositioned');
          }
          up() {
            return this._attemptNavigation(-1, 1);
          }
          down() {
            return this._attemptNavigation(1, 1);
          }
          left() {
            return this._attemptNavigation(-1, 0);
          }
          right() {
            return this._attemptNavigation(1, 0);
          }
          first() {
            return this.setIndex(0);
          }
          last() {
            return this.setIndex(this._items.length - 1);
          }
          next() {
            return this.setIndex(this._index + 1);
          }
          previous() {
            return this.setIndex(this._index - 1);
          }
          _attemptNavigation(shift, direction) {
            if (this.hasItems) {
              return this.navigate(shift, direction);
            }
            return false;
          }
          navigate(shift) {
            var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._direction;
            if (direction !== this._direction) {
              return false;
            }
            return this.setIndex(this._index + shift);
          }
          scrollCollectionWrapper(obj) {
            var previous = obj.previousIndex,
              target = obj.index,
              max = obj.dataLength,
              mainIndex = obj.mainIndex,
              previousMainIndex = obj.previousMainIndex,
              lines = obj.lines;
            if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
              previous = previousMainIndex;
              target = mainIndex;
              max = lines;
            }
            var _this$_getPlotPropert = this._getPlotProperties(this._direction),
              directionIsRow = _this$_getPlotPropert.directionIsRow,
              main = _this$_getPlotPropert.main,
              mainDim = _this$_getPlotPropert.mainDim,
              mainMarginFrom = _this$_getPlotPropert.mainMarginFrom,
              mainMarginTo = _this$_getPlotPropert.mainMarginTo;
            var cw = this.currentItemWrapper;
            var bound = this[mainDim];
            if (bound === 0) {
              bound = directionIsRow ? 1920 : 1080;
            }
            var offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
            var sizes = this._getItemSizes(cw);
            var marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
            var marginTo = sizes[mainMarginTo] || sizes.margin || 0;
            var scroll = this._scroll;
            if (!isNaN(scroll)) {
              if (scroll >= 0 && scroll <= 1) {
                scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
              } else {
                scroll = scroll - cw[main];
              }
            } else if (typeof scroll === 'function') {
              scroll = scroll.apply(this, [cw, obj]);
            } else if (typeof scroll === 'object') {
              var _scroll = scroll,
                _scroll$jump = _scroll.jump,
                jump = _scroll$jump === void 0 ? false : _scroll$jump,
                _scroll$after = _scroll.after,
                after = _scroll$after === void 0 ? false : _scroll$after,
                _scroll$backward = _scroll.backward,
                backward = _scroll$backward === void 0 ? 0.0 : _scroll$backward,
                _scroll$forward = _scroll.forward,
                forward = _scroll$forward === void 0 ? 1.0 : _scroll$forward;
              if (jump) {
                var mod = target % jump;
                if (mod === 0) {
                  scroll = marginFrom - cw[main];
                }
                if (mod === jump - 1) {
                  var actualSize = marginFrom + cw[mainDim] + marginTo;
                  scroll = mod * actualSize + marginFrom - cw[main];
                }
              } else if (after) {
                scroll = 0;
                if (target >= after - 1) {
                  var _actualSize = marginFrom + cw[mainDim] + marginTo;
                  scroll = (after - 1) * _actualSize + marginFrom - cw[main];
                }
              } else {
                var backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
                var forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
                if (target < max - 1 && previous < target && offset + cw[main] + cw[mainDim] > forwardBound) {
                  scroll = forwardBound - (cw[main] + cw[mainDim]);
                } else if (target > 0 && target < previous && offset + cw[main] < backwardBound) {
                  scroll = backwardBound - cw[main];
                } else if (target === max - 1) {
                  scroll = bound - (cw[main] + cw[mainDim]);
                } else if (target === 0) {
                  scroll = marginFrom - cw[main];
                }
              }
            } else if (isNaN(scroll)) {
              if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
                scroll = bound - (cw[main] + cw[mainDim]);
              } else if (target < previous && offset + cw[main] < 0) {
                scroll = marginFrom - cw[main];
              }
            }
            if (this.active && !isNaN(scroll) && this._scrollTransition) {
              if (this._scrollTransition.isRunning()) {
                this._scrollTransition.reset(scroll, 0.05);
              } else {
                this._scrollTransition.start(scroll);
              }
            } else if (!isNaN(scroll)) {
              this.wrapper[main] = scroll;
            }
          }
          $childInactive(_ref22) {
            var child = _ref22.child;
            if (typeof child === 'object') {
              var index = child.componentIndex;
              for (var key in this._items[index]) {
                if (child.component[key] !== undefined) {
                  this._items[index][key] = child.component[key];
                }
              }
            }
            this._collectGarbage();
          }
          $getChildComponent(_ref23) {
            var index = _ref23.index;
            return this._items[index];
          }
          _resizeWrapper(crossSize) {
            var obj = crossSize;
            if (!isNaN(crossSize)) {
              var _this$_getPlotPropert2 = this._getPlotProperties(this._direction),
                main = _this$_getPlotPropert2.main,
                mainDim = _this$_getPlotPropert2.mainDim,
                crossDim = _this$_getPlotPropert2.crossDim;
              var lastItem = this.wrapper.childList.last;
              obj = {
                [mainDim]: lastItem[main] + lastItem[mainDim],
                [crossDim]: crossSize
              };
            }
            this.wrapper.patch(obj);
            if (this._autoResize) {
              this.patch(obj);
            }
          }
          _generateUniqueID() {
            var id = '';
            while (this._uids[id] || id === '') {
              id = Math.random().toString(36).substr(2, 9);
            }
            this._uids[id] = true;
            return id;
          }
          _getPlotProperties(direction) {
            var directionIsRow = direction === 0;
            return {
              directionIsRow: directionIsRow ? true : false,
              mainDirection: directionIsRow ? 'rows' : 'columns',
              main: directionIsRow ? 'x' : 'y',
              mainDim: directionIsRow ? 'w' : 'h',
              mainMarginTo: directionIsRow ? 'marginRight' : 'marginBottom',
              mainMarginFrom: directionIsRow ? 'marginLeft' : 'marginTop',
              crossDirection: !directionIsRow ? 'columns' : 'rows',
              cross: directionIsRow ? 'y' : 'x',
              crossDim: directionIsRow ? 'h' : 'w',
              crossMarginTo: directionIsRow ? 'marginBottom' : 'marginRight',
              crossMarginFrom: directionIsRow ? 'marginTop' : 'marginLeft'
            };
          }
          _getItemSizes(item) {
            var itemType = item.type;
            if (item.component && item.component.__attached) {
              item = item.component;
            }
            return {
              w: item.w || itemType && itemType['width'],
              h: item.h || itemType && itemType['height'],
              margin: item.margin || itemType && itemType['margin'] || 0,
              marginLeft: item.marginLeft || itemType && itemType['marginLeft'],
              marginRight: item.marginRight || itemType && itemType['marginRight'],
              marginTop: item.marginTop || itemType && itemType['marginTop'],
              marginBottom: item.marginBottom || itemType && itemType['marginBottom']
            };
          }
          _collectGarbage(immediate) {
            this._gcIncrement++;
            if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
              this._gcIncrement = 0;
              this.stage.gc();
            }
          }
          _normalizeDataItems(array) {
            return array.map((item, index) => {
              return this._normalizeDataItem(item) || index;
            }).filter(item => {
              if (!isNaN(item)) {
                console.warn(`Item at index: ${item}, is not a valid item. Removing it from dataset`);
                return false;
              }
              return true;
            });
          }
          _normalizeDataItem(item, index) {
            if (typeof item === 'string' || typeof item === 'number') {
              item = {
                label: item.toString()
              };
            }
            if (typeof item === 'object') {
              var id = this._generateUniqueID();
              return _objectSpread({
                assignedID: id,
                type: this.itemType,
                collectionWrapper: this,
                isAlive: false
              }, item);
            }
            return index;
          }
          _normalizePixelToPercentage(value, max) {
            if (value && value > 1) {
              return value / max;
            }
            return value || 0;
          }
          _getFocused() {
            if (this.hasItems) {
              return this.currentItemWrapper;
            }
            return this;
          }
          _handleRight() {
            return this.right();
          }
          _handleLeft() {
            return this.left();
          }
          _handleUp() {
            return this.up();
          }
          _handleDown() {
            return this.down();
          }
          _inactive() {
            if (this._repositionDebounce) {
              clearTimeout(this._repositionDebounce);
            }
            this._collectGarbage(true);
          }
          static get itemType() {
            return undefined;
          }
          set forceLoad(bool) {
            this._forceLoad = bool;
          }
          get forceLoad() {
            return this._forceLoad;
          }
          get requestingItems() {
            return this._requestingItems;
          }
          set requestThreshold(num) {
            this._requestThreshold = num;
          }
          get requestThreshold() {
            return this._requestThreshold;
          }
          set enableRequests(bool) {
            this._requestsEnabled = bool;
          }
          get enableRequests() {
            return this._requestsEnabled;
          }
          set gcThreshold(num) {
            this._gcThreshold = num;
          }
          get gcThreshold() {
            return this._gcThreshold;
          }
          get wrapper() {
            return this.tag('Wrapper');
          }
          get hasItems() {
            return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
          }
          get currentItemWrapper() {
            return this.wrapper.children[this._index];
          }
          get currentItem() {
            return this.currentItemWrapper && this.currentItemWrapper.component || undefined;
          }
          set direction(string) {
            this._direction = CollectionWrapper.DIRECTION[string] || CollectionWrapper.DIRECTION.row;
          }
          get direction() {
            return Object.keys(CollectionWrapper.DIRECTION)[this._direction];
          }
          set items(array) {
            this.clear();
            this.add(array);
          }
          get items() {
            var itemWrappers = this.itemWrappers;
            return this._items.map((item, index) => {
              if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
                return itemWrappers[index].component;
              }
              return item;
            });
          }
          get length() {
            return this._items.length;
          }
          set index(index) {
            this.setIndex(index);
          }
          get itemWrappers() {
            return this.wrapper.children;
          }
          get index() {
            return this._index;
          }
          set scrollTransition(obj) {
            this._scrollTransitionSettings.patch(obj);
            if (this.active) {
              this._updateScrollTransition();
            }
          }
          get scrollTransition() {
            return this._scrollTransition;
          }
          set scroll(value) {
            this._scroll = value;
          }
          get scroll() {
            return this._scroll;
          }
          set autoResize(bool) {
            this._autoResize = bool;
          }
          get autoResize() {
            return this._autoResize;
          }
          set spacing(num) {
            this._spacing = num;
          }
          get spacing() {
            return this._spacing;
          }
        }
        CollectionWrapper.DIRECTION = {
          row: 0,
          column: 1
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Cursor extends lightning.Component {
          static _template() {
            return {
              alpha: 0
            };
          }
          _construct() {
            this._blink = true;
          }
          _init() {
            this._blinkAnimation = this.animation({
              duration: 1,
              repeat: -1,
              actions: [{
                p: 'alpha',
                v: {
                  0: 0,
                  0.5: 1,
                  1: 0
                }
              }]
            });
          }
          show() {
            if (this._blink) {
              this._blinkAnimation.start();
            } else {
              this.alpha = 1;
            }
          }
          hide() {
            if (this._blink) {
              this._blinkAnimation.stop();
            } else {
              this.alpha = 0;
            }
          }
          set blink(bool) {
            this._blink = bool;
            if (this.active) {
              if (bool) {
                this.show();
              } else {
                this.hide();
              }
            }
          }
          get blink() {
            return this._blink;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ItemWrapper extends lightning.Component {
          static _template() {
            return {
              clipbox: true
            };
          }
          create() {
            if (this.children.length > 0) {
              return;
            }
            var component = this.fireAncestors('$getChildComponent', {
              index: this.componentIndex
            });
            component.isAlive = true;
            var w = this.w,
              h = this.h,
              margin = this.margin,
              marginTop = this.marginTop,
              marginBottom = this.marginBottom,
              marginRight = this.marginRight,
              marginLeft = this.marginLeft;
            this.children = [_objectSpread(_objectSpread({}, component), {}, {
              w,
              h,
              margin,
              marginTop,
              marginRight,
              marginLeft,
              marginBottom
            })];
            if (this.hasFocus()) {
              this._refocus();
            }
          }
          get component() {
            return this.children[0] || this.fireAncestors('$getChildComponent', {
              index: this.componentIndex
            });
          }
          _setup() {
            if (this.forceLoad) {
              this.create();
            }
          }
          _active() {
            this.create();
          }
          _inactive() {
            if (!this.forceLoad) {
              this.children[0].isAlive = false;
              this.fireAncestors('$childInactive', {
                child: this
              });
              this.childList.clear();
            }
          }
          _getFocused() {
            return this.children && this.children[0] || this;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class KeyWrapper extends lightning.Component {
          static _template() {
            return {
              clipbox: true
            };
          }
          _update() {
            var currentKey = this.children && this.children[0];
            if (currentKey && currentKey.action === this._key.data.action) {
              currentKey.patch(_objectSpread({}, this._key));
            } else {
              this.children = [_objectSpread({
                type: this._key.keyType
              }, this._key)];
            }
            if (this.hasFocus()) {
              this._refocus();
            }
          }
          set key(obj) {
            this._key = obj;
            if (this.active) {
              this._update();
            }
          }
          get key() {
            return this._key;
          }
          _active() {
            this._update();
          }
          _inactive() {
            this.childList.clear();
          }
          _getFocused() {
            return this.children && this.children[0] || this;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var limitWithinRange = (num, min, max) => {
          return Math.min(Math.max(num, min), max);
        };
        var defineProperties = (component, props) => {
          props.forEach(prop => {
            Object.defineProperty(component, prop, {
              set: function set(value) {
                component[`_${prop}`] = value;
              },
              get: function get() {
                return component[`_${prop}`];
              }
            });
          });
        };
        var findIndexOfObject = (array, search, targetProp) => {
          for (var i = 0; i < array.length; i++) {
            if (array[i][targetProp] === search) {
              return i;
            }
          }
          return -1;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Grid extends CollectionWrapper {
          _construct() {
            this._crossSpacing = 5;
            this._mainSpacing = 5;
            this._rows = 0;
            this._columns = 0;
            super._construct();
          }
          clear() {
            super.clear();
            this._mainIndex = 0;
            this._crossIndex = 0;
            this._previous = undefined;
          }
          setIndex(index) {
            var targetIndex = limitWithinRange(index, 0, this._items.length - 1);
            var previousIndex = this._index;
            var _this$_findLocationOf = this._findLocationOfIndex(this._index),
              previousMainIndex = _this$_findLocationOf.mainIndex,
              previousCrossIndex = _this$_findLocationOf.crossIndex;
            var _this$_findLocationOf2 = this._findLocationOfIndex(targetIndex),
              mainIndex = _this$_findLocationOf2.mainIndex,
              crossIndex = _this$_findLocationOf2.crossIndex;
            this._mainIndex = mainIndex;
            this._crossIndex = crossIndex;
            this._previous = {
              mainIndex,
              crossIndex,
              realIndex: previousIndex
            };
            this._index = targetIndex;
            this._indexChanged({
              previousIndex,
              index: targetIndex,
              mainIndex,
              previousMainIndex,
              crossIndex,
              previousCrossIndex,
              lines: this._lines.length,
              dataLength: this._items.length
            });
          }
          _findLocationOfIndex(index) {
            for (var i = 0; i < this._lines.length; i++) {
              if (this._lines[i].includes(index)) {
                return {
                  mainIndex: i,
                  crossIndex: this._lines[i].indexOf(index)
                };
              }
            }
            return {
              mainIndex: -1,
              crossIndex: -1
            };
          }
          plotItems() {
            var items = this._items;
            var wrapper = this.wrapper;
            var _this$_getPlotPropert3 = this._getPlotProperties(this._direction),
              directionIsRow = _this$_getPlotPropert3.directionIsRow,
              mainDirection = _this$_getPlotPropert3.mainDirection,
              main = _this$_getPlotPropert3.main,
              mainDim = _this$_getPlotPropert3.mainDim,
              mainMarginTo = _this$_getPlotPropert3.mainMarginTo,
              mainMarginFrom = _this$_getPlotPropert3.mainMarginFrom,
              cross = _this$_getPlotPropert3.cross,
              crossDim = _this$_getPlotPropert3.crossDim,
              crossMarginTo = _this$_getPlotPropert3.crossMarginTo,
              crossMarginFrom = _this$_getPlotPropert3.crossMarginFrom;
            var crossSize = this[crossDim];
            var mainPos = 0,
              crossPos = 0,
              lineIndex = 0;
            var animateItems = [];
            var viewboundMain = directionIsRow ? 1920 : 1080;
            var viewboundCross = directionIsRow ? 1080 : 1920;
            var renderContext = this.core.renderContext;
            this._lines = [[]];
            //create empty line array
            var cl = [];
            var newChildren = items.map((item, index) => {
              var sizes = this._getItemSizes(item);
              var targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
              if (index === 0) {
                mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
              }
              if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
                var bil = this._getBiggestInLine(cl);
                mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
                crossPos = targetCrossFromMargin;
                this._lines.push([]);
                cl = [];
                lineIndex++;
              } else {
                crossPos += targetCrossFromMargin;
              }
              var ref = `IW-${item.assignedID}`;
              var tmp = mainPos;
              var tcp = crossPos;
              var existingItemWrapper = wrapper.tag(ref);
              if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext[`p${main}`] + wrapper[main] + mainPos <= viewboundMain || renderContext[`p${cross}`] + wrapper[cross] + crossPos <= viewboundCross))) {
                tmp = existingItemWrapper[main];
                tcp = existingItemWrapper[cross];
                animateItems.push(index);
              }
              var newItem = _objectSpread(_objectSpread({
                ref,
                type: ItemWrapper,
                componentIndex: index,
                forceLoad: this._forceLoad
              }, sizes), {}, {
                [`assigned${main.toUpperCase()}`]: mainPos,
                [`assigned${cross.toUpperCase()}`]: crossPos,
                [main]: tmp,
                [cross]: tcp
              });
              crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
              this._lines[lineIndex].push(index);
              cl.push(newItem);
              return newItem;
            });
            wrapper.children = newChildren;
            animateItems.forEach(index => {
              var item = wrapper.children[index];
              item.patch({
                smooth: {
                  x: item.assignedX,
                  y: item.assignedY
                }
              });
            });
            var biggestInLastLine = this._getBiggestInLine(cl);
            this._resizeWrapper({
              [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
              [crossDim]: crossSize
            });
          }
          repositionItems() {
            var wrapper = this.wrapper;
            if (!wrapper && wrapper.children.length) {
              return true;
            }
            var _this$_getPlotPropert4 = this._getPlotProperties(this._direction),
              main = _this$_getPlotPropert4.main,
              mainDim = _this$_getPlotPropert4.mainDim,
              mainMarginTo = _this$_getPlotPropert4.mainMarginTo,
              mainMarginFrom = _this$_getPlotPropert4.mainMarginFrom,
              cross = _this$_getPlotPropert4.cross,
              crossDim = _this$_getPlotPropert4.crossDim,
              crossMarginTo = _this$_getPlotPropert4.crossMarginTo,
              crossMarginFrom = _this$_getPlotPropert4.crossMarginFrom;
            var crossSize = this[crossDim];
            var mainPos = 0,
              crossPos = 0,
              lineIndex = 0;

            //create empty line array
            var cl = [];
            this.lines = [[]];
            wrapper.children.forEach((item, index) => {
              var sizes = this._getItemSizes(item);
              var targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
              if (index === 0) {
                mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
              }
              if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
                var bil = this._getBiggestInLine(cl);
                mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
                crossPos = targetCrossFromMargin;
                this._lines.push([]);
                cl = [];
                lineIndex++;
              } else {
                crossPos += targetCrossFromMargin;
              }
              item.patch({
                [`assigned${main.toUpperCase()}`]: mainPos,
                [`assigned${cross.toUpperCase()}`]: crossPos,
                [main]: mainPos,
                [cross]: crossPos
              });
              crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
              this._lines[lineIndex].push(index);
              cl.push(newItem);
            });
            var biggestInLastLine = this._getBiggestInLine(cl);
            this._resizeWrapper({
              [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
              [crossDim]: crossSize
            });
            super.repositionItems();
          }
          _getBiggestInLine(line) {
            var _this$_getPlotPropert5 = this._getPlotProperties(this._direction),
              mainDim = _this$_getPlotPropert5.mainDim;
            return line.reduce((biggestItem, newItem) => {
              if (newItem[mainDim] > biggestItem[mainDim]) {
                return newItem;
              }
              return biggestItem;
            });
          }
          navigate(shift, direction) {
            var _this$_getPlotPropert6 = this._getPlotProperties(this._direction),
              directionIsRow = _this$_getPlotPropert6.directionIsRow,
              cross = _this$_getPlotPropert6.cross,
              crossDim = _this$_getPlotPropert6.crossDim;
            var overCross = directionIsRow && direction === CollectionWrapper.DIRECTION.column || !directionIsRow && direction === CollectionWrapper.DIRECTION.row;
            var targetMainIndex = this._mainIndex + !!!overCross * shift;
            var targetCrossIndex = this._crossIndex + !!overCross * shift;
            var targetIndex = this._index;
            if (overCross && targetCrossIndex > -1 && targetCrossIndex <= this._lines[targetMainIndex].length) {
              if (this._lines[targetMainIndex][targetCrossIndex] !== undefined) {
                targetIndex = this._lines[targetMainIndex][targetCrossIndex];
                this._previous = undefined;
              }
            } else if (!overCross && targetMainIndex < this._lines.length && targetMainIndex > -1) {
              var targetLine = this._lines[targetMainIndex];
              if (this._previous && this._previous.mainIndex === targetMainIndex) {
                targetIndex = this._previous.realIndex;
                targetCrossIndex = this._previous.crossIndex;
              } else if (targetLine) {
                var currentItem = this.currentItemWrapper;
                var m = targetLine.map(item => {
                  var targetItem = this.wrapper.children[item];
                  if (targetItem[cross] <= currentItem[cross] && currentItem[cross] <= targetItem[cross] + targetItem[crossDim]) {
                    return targetItem[cross] + targetItem[crossDim] - currentItem[cross];
                  }
                  if (targetItem[cross] >= currentItem[cross] && targetItem[cross] <= currentItem[cross] + currentItem[crossDim]) {
                    return currentItem[cross] + currentItem[crossDim] - targetItem[cross];
                  }
                  return -1;
                });
                var acc = -1;
                var t = -1;
                for (var i = 0; i < m.length; i++) {
                  if (m[i] === -1 && acc > -1) {
                    break;
                  }
                  if (m[i] > acc) {
                    acc = m[i];
                    t = i;
                  }
                }
                if (t > -1) {
                  targetCrossIndex = t;
                  targetIndex = targetLine[t];
                }
              }
              this._previous = {
                mainIndex: this._mainIndex,
                crossIndex: this._crossIndex,
                realIndex: this._index
              };
            }
            if (this._index !== targetIndex) {
              this.setIndex(targetIndex);
              return true;
            }
            return false;
          }
          set rows(num) {
            this._rows = num;
            this.direction = 'row';
          }
          get rows() {
            return this._rows;
          }
          set columns(num) {
            this._columns = num;
            this.direction = 'column';
          }
          get columns() {
            return this._columns;
          }
          set crossSpacing(num) {
            this._crossSpacing = num;
          }
          get crossSpacing() {
            return this._crossSpacing;
          }
          set mainSpacing(num) {
            this._mainSpacing = num;
          }
          get mainSpacing() {
            return this._mainSpacing;
          }
          set spacing(num) {
            this._spacing = num;
            this._mainSpacing = num;
            this._crossSpacing = num;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class InputField extends lightning.Component {
          static _template() {
            return {
              PreLabel: {
                renderOffscreen: true
              },
              PostLabel: {
                renderOffscreen: true
              },
              Cursor: {
                type: Cursor,
                rect: true,
                w: 4,
                h: 54,
                x: 0,
                y: 0
              }
            };
          }
          _construct() {
            this._input = '';
            this._previousInput = '';
            this._description = '';
            this._cursorX = 0;
            this._cursorIndex = 0;
            this._passwordMask = '*';
            this._passwordMode = false;
            this._autoHideCursor = true;
            this._labelPositionStatic = true;
            this._maxLabelWidth = 0;
          }
          _init() {
            this.tag('PreLabel').on('txLoaded', () => {
              this._labelTxLoaded();
            });
            this.tag('PostLabel').on('txLoaded', () => {
              this._labelTxLoaded;
            });
          }
          onInputChanged(_ref24) {
            var _ref24$input = _ref24.input,
              input = _ref24$input === void 0 ? '' : _ref24$input;
            var targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
            this._input = input;
            this._update(targetIndex);
          }
          toggleCursor() {
            var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this._cursorVisible;
            this._cursorVisible = bool;
            this.cursor[bool ? 'show' : 'hide']();
          }
          _labelTxLoaded() {
            var preLabel = this.tag('PreLabel');
            var cursor = this.tag('Cursor');
            var postLabel = this.tag('PostLabel');
            this.h = preLabel.renderHeight || postLabel.renderHeight;
            cursor.x = preLabel.renderWidth + this._cursorX;
            postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
            this.setSmooth('x', this._labelOffset);
            if (!this.autoHideCursor) {
              this.toggleCursor(true);
            }
          }
          _update() {
            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var hasInput = this._input.length > 0;
            var pre = this._description + '';
            var post = '';
            if (hasInput) {
              pre = this._input.substring(0, index);
              post = this._input.substring(index, this._input.length);
              if (this._passwordMode) {
                pre = this._passwordMask.repeat(pre.length);
                post = this._passwordMask.repeat(post.length);
              }
              this.toggleCursor(true);
            } else if (this._autoHideCursor) {
              this.toggleCursor(false);
            }
            this.patch({
              PreLabel: {
                text: {
                  text: pre
                }
              },
              PostLabel: {
                text: {
                  text: post
                }
              }
            });
            if (this.h === 0) {
              this.tag('PreLabel').loadTexture();
              this.h = this.tag('PreLabel').renderHeight;
            }
            this._cursorIndex = index;
          }
          _handleRight() {
            this._update(Math.min(this._input.length, this._cursorIndex + 1));
          }
          _handleLeft() {
            this._update(Math.max(0, this._cursorIndex - 1));
          }
          _firstActive() {
            this._labelTxLoaded();
            this._update();
          }
          get input() {
            return this._input;
          }
          get hasInput() {
            return this._input.length > 0;
          }
          get cursorIndex() {
            return this._cursorIndex;
          }
          set inputText(obj) {
            this._inputText = obj;
            this.tag('PreLabel').patch({
              text: obj
            });
            this.tag('PostLabel').patch({
              text: obj
            });
          }
          get inputText() {
            return this._inputText;
          }
          set description(str) {
            this._description = str;
          }
          get description() {
            return this._description;
          }
          set cursor(obj) {
            if (obj.x) {
              this._cursorX = obj.x;
              delete obj.x;
            }
            this.tag('Cursor').patch(obj);
          }
          get cursor() {
            return this.tag('Cursor');
          }
          get cursorVisible() {
            return this._cursorVisible;
          }
          set autoHideCursor(bool) {
            this._autoHideCursor = bool;
          }
          get autoHideCursor() {
            return this._autoHideCursor;
          }
          set passwordMode(val) {
            this._passwordMode = val;
          }
          get passwordMode() {
            return this._passwordMode;
          }
          set passwordMask(str) {
            this._passwordMask = str;
          }
          get passwordmask() {
            return this._passwordMask;
          }

          // the width at which the text start scrolling
          set maxLabelWidth(val) {
            this._maxLabelWidth = val;
          }
          get maxLabelWidth() {
            return this._maxLabelWidth;
          }
          set labelPositionStatic(val) {
            this._labelPositionStatic = val;
          }
          get labelPositionStatic() {
            return this._labelPositionStatic;
          }
          get _labelOffset() {
            if (this._labelPositionStatic) return 0;
            var offset = this.maxLabelWidth - this.tag('Cursor').x;
            return offset < 0 ? offset : 0;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var Key$1 = class Key extends lightning.Component {
          static _template() {
            return {
              Background: {
                w: _w6 => _w6,
                h: _h4 => _h4,
                rect: true
              },
              Label: {
                mount: 0.5,
                x: w => w / 2,
                y: h => h / 2
              }
            };
          }
          _construct() {
            this._backgroundColors = {};
            this._labelColors = {};
          }
          set data(obj) {
            this._data = obj;
            this._update();
          }
          get data() {
            return this._data;
          }
          set labelText(obj) {
            this._labelText = obj;
            this.tag('Label').patch({
              text: obj
            });
          }
          get labelText() {
            return this._labelText;
          }
          set label(obj) {
            this.tag('Label').patch(obj);
          }
          get label() {
            return this.tag('Label');
          }
          set labelColors(obj) {
            this._labelColors = obj;
            this._update();
          }
          get labelColors() {
            return this._labelColors;
          }
          set backgroundColors(obj) {
            this._backgroundColors = obj;
            this._update();
          }
          get backgroundColors() {
            return this._backgroundColors;
          }
          set background(obj) {
            this.tag('Background').patch(obj);
          }
          get background() {
            return this.tag('Background');
          }
          _update() {
            if (!this.active) {
              return;
            }
            var _this$_data$label = this._data.label,
              label = _this$_data$label === void 0 ? '' : _this$_data$label;
            var hasFocus = this.hasFocus();
            var _this$_backgroundColo = this._backgroundColors,
              focused = _this$_backgroundColo.focused,
              _this$_backgroundColo2 = _this$_backgroundColo.unfocused,
              unfocused = _this$_backgroundColo2 === void 0 ? 0xff000000 : _this$_backgroundColo2;
            var _this$_labelColors = this._labelColors,
              labelFocused = _this$_labelColors.focused,
              _this$_labelColors$un = _this$_labelColors.unfocused,
              labelUnfocused = _this$_labelColors$un === void 0 ? 0xffffffff : _this$_labelColors$un;
            this.patch({
              Background: {
                color: hasFocus && focused ? focused : unfocused
              },
              Label: {
                text: {
                  text: label
                },
                color: hasFocus && labelFocused ? labelFocused : labelUnfocused
              }
            });
          }
          _firstActive() {
            this._update();
          }
          _focus() {
            var _this$_backgroundColo3 = this._backgroundColors,
              focused = _this$_backgroundColo3.focused,
              _this$_backgroundColo4 = _this$_backgroundColo3.unfocused,
              unfocused = _this$_backgroundColo4 === void 0 ? 0xff000000 : _this$_backgroundColo4;
            var _this$_labelColors2 = this._labelColors,
              labelFocused = _this$_labelColors2.focused,
              _this$_labelColors2$u = _this$_labelColors2.unfocused,
              labelUnfocused = _this$_labelColors2$u === void 0 ? 0xffffffff : _this$_labelColors2$u;
            this.patch({
              Background: {
                smooth: {
                  color: focused || unfocused
                }
              },
              Label: {
                smooth: {
                  color: labelFocused || labelUnfocused
                }
              }
            });
          }
          _unfocus() {
            var _this$_backgroundColo5 = this._backgroundColors.unfocused,
              unfocused = _this$_backgroundColo5 === void 0 ? 0xff000000 : _this$_backgroundColo5;
            var _this$_labelColors$un2 = this._labelColors.unfocused,
              labelUnfocused = _this$_labelColors$un2 === void 0 ? 0xffffffff : _this$_labelColors$un2;
            this.patch({
              Background: {
                smooth: {
                  color: unfocused
                }
              },
              Label: {
                smooth: {
                  color: labelUnfocused
                }
              }
            });
          }
          static get width() {
            return 80;
          }
          static get height() {
            return 80;
          }
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class Keyboard extends lightning.Component {
          static _template() {
            return {
              Keys: {
                w: _w7 => _w7
              }
            };
          }
          _construct() {
            this._input = '';
            this._inputField = undefined;
            this._maxCharacters = 56;
            this.navigationWrapAround = false;
            this.resetFocus();
          }
          resetFocus() {
            this._columnIndex = 0;
            this._rowIndex = 0;
            this._previousKey = null;
          }
          _setup() {
            this._keys = this.tag('Keys');
            this._update();
          }
          _update() {
            var _this$_config = this._config,
              layouts = _this$_config.layouts,
              _this$_config$buttonT = _this$_config.buttonTypes,
              buttonTypes = _this$_config$buttonT === void 0 ? {} : _this$_config$buttonT,
              _this$_config$styling = _this$_config.styling,
              styling = _this$_config$styling === void 0 ? {} : _this$_config$styling;
            if (!this._layout || this._layout && layouts[this._layout] === undefined) {
              console.error(`Configured layout "${this._layout}" does not exist. Picking first available: "${Object.keys(layouts)[0]}"`);
              this._layout = Object.keys(layouts)[0];
            }
            var _styling$horizontalSp = styling.horizontalSpacing,
              horizontalSpacing = _styling$horizontalSp === void 0 ? 0 : _styling$horizontalSp,
              _styling$verticalSpac = styling.verticalSpacing,
              verticalSpacing = _styling$verticalSpac === void 0 ? 0 : _styling$verticalSpac,
              _styling$align = styling.align,
              align = _styling$align === void 0 ? 'left' : _styling$align;
            var rowPosition = 0;
            var isEvent = /^[A-Z][A-Za-z0-9]{1}/;
            var hasLabel = /\:/;
            if (buttonTypes.default === undefined) {
              buttonTypes.default = Key$1;
            }
            this._keys.children = layouts[this._layout].map((row, rowIndex) => {
              var _ref25 = styling[`Row${rowIndex + 1}`] || {},
                _ref25$x = _ref25.x,
                x = _ref25$x === void 0 ? 0 : _ref25$x,
                _ref25$margin = _ref25.margin,
                margin = _ref25$margin === void 0 ? 0 : _ref25$margin,
                marginRight = _ref25.marginRight,
                marginLeft = _ref25.marginLeft,
                marginTop = _ref25.marginTop,
                marginBottom = _ref25.marginBottom,
                _ref25$spacing = _ref25.spacing,
                rowHorizontalSpacing = _ref25$spacing === void 0 ? horizontalSpacing || 0 : _ref25$spacing,
                _ref25$align = _ref25.align,
                rowAlign = _ref25$align === void 0 ? align : _ref25$align;
              var keyPosition = 0;
              var rowHeight = 0;
              var rowKeys = row.map((key, keyIndex) => {
                var origin = key;
                var keyType = buttonTypes.default;
                var action = 'Input';
                var label = key;
                if (isEvent.test(key)) {
                  if (hasLabel.test(key)) {
                    key = key.split(':');
                    label = key[1].toString();
                    key = key[0];
                  }
                  if (buttonTypes[key]) {
                    keyType = buttonTypes[key];
                    action = key.action || key;
                  }
                }
                var keySpacing = keyType.margin || keyType.type.margin;
                var _keyType = keyType,
                  _keyType$w = _keyType.w,
                  w = _keyType$w === void 0 ? keyType.type.width || 0 : _keyType$w,
                  _keyType$h = _keyType.h,
                  h = _keyType$h === void 0 ? keyType.type.height || 0 : _keyType$h,
                  _keyType$marginLeft = _keyType.marginLeft,
                  marginLeft = _keyType$marginLeft === void 0 ? keyType.type.marginLeft || keySpacing || 0 : _keyType$marginLeft,
                  _keyType$marginRight = _keyType.marginRight,
                  marginRight = _keyType$marginRight === void 0 ? keyType.type.marginRight || keySpacing || rowHorizontalSpacing : _keyType$marginRight;
                rowHeight = h > rowHeight ? h : rowHeight;
                var currentPosition = keyPosition + marginLeft;
                keyPosition += marginLeft + w + marginRight;
                return {
                  ref: `Key-{${keyIndex + 1}}`,
                  type: KeyWrapper,
                  keyboard: this,
                  x: currentPosition,
                  w,
                  h,
                  key: _objectSpread({
                    data: {
                      origin,
                      key,
                      label,
                      action
                    },
                    w,
                    h
                  }, keyType)
                };
              });
              var rowOffset = x + (marginLeft || margin);
              var rowMount = 0;
              if (this.w && rowAlign === 'center') {
                rowOffset = this.w / 2;
                rowMount = 0.5;
              }
              if (this.w && rowAlign === 'right') {
                rowOffset = this.w - (marginRight || margin);
                rowMount = 1;
              }
              var currentPosition = rowPosition + (marginTop || margin);
              rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
              return {
                ref: `Row-${rowIndex + 1}`,
                x: rowOffset,
                mountX: rowMount,
                w: keyPosition,
                y: currentPosition,
                children: rowKeys
              };
            });
            this._refocus();
          }
          _getFocused() {
            return this.currentKeyWrapper || this;
          }
          _handleRight() {
            return this.navigate('row', 1);
          }
          _handleLeft() {
            return this.navigate('row', -1);
          }
          _handleUp() {
            return this.navigate('column', -1);
          }
          _handleDown() {
            return this.navigate('column', 1);
          }
          _handleKey(_ref26) {
            var key = _ref26.key,
              _ref26$code = _ref26.code,
              code = _ref26$code === void 0 ? 'CustomKey' : _ref26$code;
            if (code === 'Backspace' && this._input.length === 0) {
              return false;
            }
            if (key === ' ') {
              key = 'Space';
            }
            var targetFound = this._findKey(key);
            if (targetFound) {
              this._handleEnter();
            }
            return targetFound;
          }
          _findKey(str) {
            var rows = this._config.layouts[this._layout];
            var i = 0,
              j = 0;
            for (; i < rows.length; i++) {
              for (j = 0; j < rows[i].length; j++) {
                var key = rows[i][j];
                if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
                  this._rowIndex = i;
                  this._columnIndex = j;
                  return true;
                }
              }
            }
            return false;
          }
          _handleEnter() {
            var _this$currentKey$data = this.currentKey.data,
              origin = _this$currentKey$data.origin,
              action = _this$currentKey$data.action;
            var event = {
              index: this._input.length,
              key: origin
            };
            if (this._inputField && this._inputField.cursorIndex) {
              event.index = this._inputField.cursorIndex;
            }
            if (action !== 'Input') {
              var split = event.key.split(':');
              var call = `on${split[0]}`;
              var eventFunction = this[call];
              event.key = split[1];
              if (eventFunction && eventFunction.apply && eventFunction.call) {
                eventFunction.call(this, event);
              }
              this.signal(call, _objectSpread({
                input: this._input,
                keyboard: this
              }, event));
            } else {
              this.addAt(event.key, event.index);
            }
          }
          _changeInput(input) {
            if (input.length > this._maxCharacters) {
              return;
            }
            var eventData = {
              previousInput: this._input,
              input: this._input = input
            };
            if (this._inputField && this._inputField.onInputChanged) {
              this._inputField.onInputChanged(eventData);
            }
            this.signal('onInputChanged', eventData);
          }
          focus(str) {
            this._findKey(str);
          }
          add(str) {
            this._changeInput(this._input + str);
          }
          addAt(str, index) {
            if (index > this._input.length - 1) {
              this.add(str);
            } else if (index > -1) {
              this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
            }
          }
          remove() {
            this._changeInput(this._input.substring(0, this._input.length - 1));
          }
          removeAt(index) {
            if (index > this._input.length - 1) {
              this.remove();
            } else if (index > -1) {
              this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
            }
          }
          clear() {
            this._changeInput('');
          }
          layout(key) {
            if (key === this._layout) {
              return;
            }
            this._layout = key;
            if (this.attached) {
              this.resetFocus();
              this._update();
            }
          }
          inputField(component) {
            if (component && component.isComponent) {
              this._rowIndex = 0;
              this._columnIndex = 0;
              this._input = component.input !== undefined ? component.input : '';
              this._inputField = component;
            } else {
              this._rowIndex = 0;
              this._columnIndex = 0;
              this._input = '';
              this._inputField = undefined;
            }
          }
          navigate(direction, shift) {
            var targetIndex = (direction === 'row' ? this._columnIndex : this._rowIndex) + shift;
            var currentRow = this.rows[this._rowIndex];
            if (direction === 'row' && targetIndex > -1 && targetIndex < currentRow.children.length) {
              this._previous = null;
              return this._columnIndex = targetIndex;
            } else if (direction === 'row' && this.navigationWrapAround) {
              this._previous = null;
              var rowLen = currentRow.children.length;
              return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
            }
            if (direction === 'column' && targetIndex > -1 && targetIndex < this.rows.length) {
              var currentRowIndex = this._rowIndex;
              var currentColumnIndex = this._columnIndex;
              if (this._previous && this._previous.row === targetIndex) {
                var tmp = this._previous.column;
                this._previous.column = this._columnIndex;
                this._columnIndex = tmp;
                this._rowIndex = this._previous.row;
              } else {
                var targetRow = this.rows[targetIndex];
                var currentKey = this.currentKeyWrapper;
                var _currentRow = this.rows[this._rowIndex];
                var currentX = _currentRow.x - _currentRow.w * _currentRow.mountX + currentKey.x;
                var m = targetRow.children.map(key => {
                  var keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
                  if (keyX <= currentX && currentX < keyX + key.w) {
                    return keyX + key.w - currentX;
                  }
                  if (keyX >= currentX && keyX <= currentX + currentKey.w) {
                    return currentX + currentKey.w - keyX;
                  }
                  return -1;
                });
                var acc = -1;
                var t = -1;
                for (var i = 0; i < m.length; i++) {
                  if (m[i] === -1 && acc > -1) {
                    break;
                  }
                  if (m[i] > acc) {
                    acc = m[i];
                    t = i;
                  }
                }
                if (t > -1) {
                  this._rowIndex = targetIndex;
                  this._columnIndex = t;
                } // if no next row found and wraparound is on, loop back to first row
                else if (this.navigationWrapAround) {
                  this._columnIndex = Math.min(this.rows[0].children.length - 1, this._columnIndex);
                  return this._rowIndex = 0;
                }
              }
              if (this._rowIndex !== currentRowIndex) {
                this._previous = {
                  column: currentColumnIndex,
                  row: currentRowIndex
                };
                return this._rowIndex = targetIndex;
              }
            } else if (direction === 'column' && this.navigationWrapAround) {
              this._previous = {
                column: this._columnIndex,
                row: this._rowIndex
              };
              var nrRows = this.rows.length;
              this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
              this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
            }
            return false;
          }
          onSpace(_ref27) {
            var index = _ref27.index;
            this.addAt(' ', index);
          }
          onBackspace(_ref28) {
            var index = _ref28.index;
            this.removeAt(index);
          }
          onClear() {
            this.clear();
          }
          onLayout(_ref29) {
            var key = _ref29.key;
            this.layout(key);
          }
          set config(obj) {
            this._config = obj;
            if (this.active) {
              this._update();
            }
          }
          get config() {
            return this._config;
          }
          set currentInputField(component) {
            this.inputField(component);
          }
          get currentInputField() {
            return this._inputField;
          }
          set currentLayout(str) {
            this.layout(str);
          }
          get currentLayout() {
            return this._layout;
          }
          set maxCharacters(num) {
            this._maxCharacters = num;
          }
          get maxCharacters() {
            return this._maxCharacters;
          }
          get rows() {
            return this._keys && this._keys.children;
          }
          get currentKeyWrapper() {
            return this.rows && this.rows[this._rowIndex].children[this._columnIndex];
          }
          get currentKey() {
            return this.currentKeyWrapper && this.currentKeyWrapper.key;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class List extends CollectionWrapper {
          plotItems() {
            var items = this._items;
            var wrapper = this.wrapper;
            var _this$_getPlotPropert7 = this._getPlotProperties(this._direction),
              directionIsRow = _this$_getPlotPropert7.directionIsRow,
              main = _this$_getPlotPropert7.main,
              mainDim = _this$_getPlotPropert7.mainDim,
              mainMarginTo = _this$_getPlotPropert7.mainMarginTo,
              mainMarginFrom = _this$_getPlotPropert7.mainMarginFrom,
              cross = _this$_getPlotPropert7.cross,
              crossDim = _this$_getPlotPropert7.crossDim;
            var crossPos = 0,
              crossSize = 0,
              position = 0;
            var animateItems = [];
            var viewboundMain = directionIsRow ? 1920 : 1080;
            var viewboundCross = directionIsRow ? 1080 : 1920;
            var renderContext = this.core.renderContext;
            var newChildren = items.map((item, index) => {
              var sizes = this._getItemSizes(item);
              position += sizes[mainMarginFrom] || sizes.margin || 0;
              if (crossSize < sizes[crossDim]) {
                crossSize = sizes[crossDim];
              }
              var ref = `IW-${item.assignedID}`;
              var mainPos = position;
              crossPos = item[cross] || crossPos;
              var tmp = mainPos;
              var tcp = crossPos;
              var existingItemWrapper = wrapper.tag(ref);
              if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext[`p${main}`] + wrapper[main] + mainPos <= viewboundMain || renderContext[`p${cross}`] + wrapper[cross] + crossPos <= viewboundCross))) {
                tmp = existingItemWrapper[main];
                tcp = existingItemWrapper[cross];
                animateItems.push(index);
              }
              position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
              return _objectSpread(_objectSpread({
                ref,
                type: ItemWrapper,
                componentIndex: index,
                forceLoad: this._forceLoad
              }, sizes), {}, {
                [`assigned${main.toUpperCase()}`]: mainPos,
                [`assigned${cross.toUpperCase()}`]: crossPos,
                [main]: tmp,
                [cross]: tcp
              });
            });
            wrapper.children = newChildren;
            animateItems.forEach(index => {
              var item = wrapper.children[index];
              item.patch({
                smooth: {
                  x: item.assignedX,
                  y: item.assignedY
                }
              });
            });
            this._resizeWrapper(crossSize);
          }
          repositionItems() {
            var wrapper = this.wrapper;
            if (!wrapper && wrapper.children.length) {
              return true;
            }
            var _this$_getPlotPropert8 = this._getPlotProperties(this._direction),
              main = _this$_getPlotPropert8.main,
              mainDim = _this$_getPlotPropert8.mainDim,
              mainMarginTo = _this$_getPlotPropert8.mainMarginTo,
              mainMarginFrom = _this$_getPlotPropert8.mainMarginFrom,
              cross = _this$_getPlotPropert8.cross,
              crossDim = _this$_getPlotPropert8.crossDim;
            var crossPos = 0,
              crossSize = 0,
              position = 0;
            wrapper.children.forEach(item => {
              var sizes = this._getItemSizes(item);
              position += sizes[mainMarginFrom] || sizes.margin || 0;
              crossPos = item[cross] || crossPos;
              if (crossSize < sizes[crossDim]) {
                crossSize = sizes[crossDim];
              }
              var mainPos = position;
              position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
              item.patch(_objectSpread({
                [`assigned${main.toUpperCase()}`]: mainPos,
                [`assigned${cross.toUpperCase()}`]: 0,
                [main]: mainPos,
                [cross]: crossPos
              }, sizes));
            });
            this._resizeWrapper(crossSize);
            super.repositionItems();
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ScrollingLabel extends lightning.Component {
          static _template() {
            return {
              LabelClipper: {
                w: _w8 => _w8,
                rtt: true,
                shader: {
                  type: lightning.shaders.FadeOut
                },
                LabelWrapper: {
                  Label: {
                    renderOffscreen: true
                  },
                  LabelCopy: {
                    renderOffscreen: true
                  }
                }
              }
            };
          }
          _construct() {
            this._autoStart = true;
            this._scrollAnimation = false;
            this._fade = 30;
            this._spacing = 30;
            this._label = {};
            this._align = 'left';
            this._animationSettings = {
              delay: 0.7,
              repeat: -1,
              stopMethod: 'immediate'
            };
          }
          _init() {
            var label = this.tag('Label');
            label.on('txLoaded', () => {
              this._update(label);
              this._updateAnimation(label);
              if (this._autoStart) {
                this.start();
              }
            });
          }
          _update() {
            var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
            var renderWidth = label.renderWidth;
            var noScroll = renderWidth <= this.renderWidth;
            var labelPos = 0;
            if (noScroll && this._align !== 'left') {
              labelPos = (this.renderWidth - renderWidth) * ScrollingLabel.ALIGN[this._align];
            }
            this.tag('LabelClipper').patch({
              h: label.renderHeight,
              shader: {
                right: noScroll ? 0 : this._fade
              },
              LabelWrapper: {
                x: 0,
                Label: {
                  x: labelPos
                },
                LabelCopy: {
                  x: renderWidth + this._spacing
                }
              }
            });
          }
          _updateAnimation() {
            var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
            if (this._scrollAnimation) {
              this._scrollAnimation.stopNow();
            }
            if (label.renderWidth > this.renderWidth) {
              if (!this._animationSettings.duration) {
                this._animationSettings.duration = label.renderWidth / 50;
              }
              this._scrollAnimation = this.animation(_objectSpread(_objectSpread({}, this._animationSettings), {}, {
                actions: [{
                  t: 'LabelWrapper',
                  p: 'x',
                  v: {
                    sm: 0,
                    0: 0,
                    1.0: -(label.renderWidth + this._spacing)
                  }
                }, {
                  t: 'LabelClipper',
                  p: 'shader.left',
                  v: {
                    0: 0,
                    0.2: this._fade,
                    0.8: this._fade,
                    1.0: 0
                  }
                }]
              }));
            }
          }
          start() {
            if (this._scrollAnimation) {
              this._scrollAnimation.stopNow();
              this.tag('LabelCopy').patch({
                text: this._label
              });
              this._scrollAnimation.start();
            }
          }
          stop() {
            if (this._scrollAnimation) {
              this._scrollAnimation.stopNow();
              this.tag('LabelCopy').text = '';
            }
          }
          set label(obj) {
            if (typeof obj === 'string') {
              obj = {
                text: obj
              };
            }
            this._label = _objectSpread(_objectSpread({}, this._label), obj);
            this.tag('Label').patch({
              text: obj
            });
          }
          get label() {
            return this.tag('Label');
          }
          set align(pos) {
            this._align = pos;
          }
          get align() {
            return this._align;
          }
          set autoStart(bool) {
            this._autoStart = bool;
          }
          get autoStart() {
            return this._autoStart;
          }
          set repeat(num) {
            this.animationSettings = {
              repeat: num
            };
          }
          get repeat() {
            return this._animationSettings.repeat;
          }
          set delay(num) {
            this.animationSettings = {
              delay: num
            };
          }
          get delay() {
            return this._animationSettings.delay;
          }
          set duration(num) {
            this.animationSettings = {
              duration: num
            };
          }
          get duration() {
            return this._animationSettings.duration;
          }
          set animationSettings(obj) {
            this._animationSettings = _objectSpread(_objectSpread({}, this._animationSettings), obj);
            if (this._scrollAnimation) {
              this._updateAnimation();
            }
          }
          get animationSettings() {
            return this._animationSettings;
          }
        }
        ScrollingLabel.ALIGN = {
          left: 0,
          center: 0.5,
          right: 1
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        var calcCarouselNavigation = (dir, current, min, max) => {
          var target = current + dir;
          if (target < min) {
            target = max;
          }
          if (target > max) {
            target = min;
          }
          return target;
        };
        class Stepper extends lightning.Component {
          static _template() {
            return {
              h: 80,
              w: 574,
              Focus: {
                alpha: 0,
                w: _w9 => _w9,
                h: _h5 => _h5,
                rect: true
              },
              Label: {
                x: 30,
                y: h => h * 0.5,
                mountY: 0.5,
                text: {
                  text: '',
                  fontSize: 22
                }
              },
              ValueWrapper: {
                x: w => w - 30,
                w: 200,
                h: _h6 => _h6,
                mountX: 1,
                Value: {
                  x: w => w * 0.5,
                  y: h => h * 0.5,
                  mountX: 0.5,
                  mountY: 0.5,
                  text: {
                    text: '',
                    fontSize: 22
                  }
                }
              }
            };
          }
          _construct() {
            this._focusColor = 0xff009245;
            this._labelColor = 0xff9d9d9d;
            this._labelColorFocused = 0xffffffff;
            this._padding = 30;
            this._max = 100;
            this._min = 0;
            this._value = 50;
            this._options = undefined;
            this._label = 'label';
            this._focusAnimation = null;
            defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding', 'max', 'min', 'focusAnimation']);
          }
          _update() {
            this.patch({
              Focus: {
                color: this._focusColor
              },
              Label: {
                x: this._padding,
                color: this._labelColor,
                text: {
                  text: this._label
                }
              },
              ValueWrapper: {
                x: w => w - this._padding,
                Value: {
                  color: this._labelColor,
                  text: {
                    text: this.optionValue || this.value
                  }
                }
              }
            });
            if (this.hasFocus()) {
              this._focus();
            }
          }
          _createFocusAnimation() {
            this._focusAnimation = this.animation({
              duration: 0.2,
              stopMethod: 'reverse',
              actions: [{
                t: 'Focus',
                p: 'alpha',
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                t: 'Label',
                p: 'color',
                v: {
                  0: this._labelColor,
                  1: this._labelColorFocused
                }
              }, {
                t: 'ValueWrapper.Value',
                p: 'color',
                v: {
                  0: this._labelColor,
                  1: this._labelColorFocused
                }
              }]
            });
          }
          _firstActive() {
            if (!this._focusAnimation) {
              this._createFocusAnimation();
            }
            this._update();
          }
          _navigate(dir) {
            this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
            var event = {
              value: this._value
            };
            if (this._options) {
              event.options = this._options;
            }
            this.fireAncestors('$onValueChanged', event);
            this.signal('onValueChanged', event);
          }
          _handleLeft() {
            this._navigate(-1);
          }
          _handleRight() {
            this._navigate(1);
          }
          _focus() {
            if (this._focusAnimation) {
              this._focusAnimation.start();
            }
          }
          _unfocus() {
            if (this._focusAnimation) {
              this._focusAnimation.stop();
            }
          }
          set label(str) {
            this._label = str;
            if (this.active) {
              this.tag('Label').text.text = str;
            }
          }
          get label() {
            return this._label;
          }
          set value(str) {
            this._value = str;
            if (this.active) {
              this.tag('Value').text.text = this.optionValue || this._value;
            }
          }
          get value() {
            return this._value;
          }
          get optionValue() {
            return this._options && this._options[this._value] && this._options[this._value].label || undefined;
          }
          set options(arr) {
            var refactor = arr.map(option => {
              if (typeof option === 'string') {
                return {
                  label: option
                };
              }
              return option;
            });
            this._value = 0;
            this._options = refactor;
            this._max = refactor.length - 1;
            this._update();
          }
          get options() {
            return this._options;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ArrowStepper extends Stepper {
          static _template() {
            return _objectSpread(_objectSpread({}, super._template()), {}, {
              ValueWrapper: {
                x: w => w - 30,
                w: 200,
                h: _h7 => _h7,
                mountX: 1,
                ArrowLeft: {
                  y: h => h * 0.5,
                  mountY: 0.5
                },
                Value: {
                  x: w => w * 0.5,
                  y: h => h * 0.5,
                  mountX: 0.5,
                  mountY: 0.5,
                  text: {
                    text: '',
                    fontSize: 22
                  }
                },
                ArrowRight: {
                  y: h => h * 0.5,
                  x: w => w,
                  mountY: 0.5,
                  mountX: 1
                }
              }
            });
          }
          _update() {
            this.patch({
              Focus: {
                color: this._focusColor
              },
              Label: {
                x: this._padding,
                color: this._labelColor,
                text: {
                  text: this._label
                }
              },
              ValueWrapper: {
                x: w => w - this._padding,
                ArrowLeft: {
                  color: this._labelColor
                },
                Value: {
                  color: this._labelColor,
                  text: {
                    text: this.optionValue || this.value
                  }
                },
                ArrowRight: {
                  color: this._labelColor
                }
              }
            });
            if (this.hasFocus()) {
              this._focus();
            }
          }
          _createFocusAnimation() {
            this._focusAnimation = this.animation({
              duration: 0.2,
              stopMethod: 'reverse',
              actions: [{
                t: 'Focus',
                p: 'alpha',
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                t: 'ValueWrapper.ArrowLeft',
                p: 'color',
                v: {
                  0: this._labelColor,
                  1: this._labelColorFocused
                }
              }, {
                t: 'ValueWrapper.Value',
                p: 'color',
                v: {
                  0: this._labelColor,
                  1: this._labelColorFocused
                }
              }, {
                t: 'ValueWrapper.ArrowRight',
                p: 'color',
                v: {
                  0: this._labelColor,
                  1: this._labelColorFocused
                }
              }]
            });
          }
          _firstActive() {
            if (!this._focusAnimation) {
              this._createFocusAnimation();
            }
            var arrowLeft = this.tag('ArrowLeft');
            var arrowRight = this.tag('ArrowRight');
            if (!(arrowLeft.src !== undefined && arrowLeft.text !== null)) {
              arrowLeft.text = {
                text: '\u25c0',
                fontSize: 18
              };
            }
            if (!(arrowRight.src !== undefined && arrowRight.text !== null)) {
              arrowRight.text = {
                text: '\u25b6',
                fontSize: 18
              };
            }
            this._update();
          }
        }
        class ColorShift extends lightning.Component {
          static _template() {
            return {
              w: 574,
              h: 240,
              List: {
                type: List,
                w: _w10 => _w10,
                h: _h8 => _h8,
                forceLoad: true,
                spacing: 0,
                direction: 'column'
              }
            };
          }
          _construct() {
            this._autoColorShift = true;
            this._focusColor = 0xff009245;
            this._labelColor = 0xff9d9d9d;
            this._labelColorFocused = 0xffffffff;
            this._options = [{
              type: 'neutral',
              label: 'normal'
            }, {
              type: 'protanopia',
              label: 'Protanopia'
            }, {
              type: 'deuteranopia',
              label: 'Deuteranopia'
            }, {
              type: 'tritanopia',
              label: 'Tritanopia'
            }, {
              type: 'monochromacy',
              label: 'Achromatopsia'
            }];
            defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'options', 'autoColorShift']);
          }
          _getFocused() {
            return this.tag('List');
          }
          _shiftColors() {
            if (this._autoColorShift && this.application && this.application.colorshift) {
              this.application.colorshift(this._settings.correction, this._settings);
            }
          }
          $onValueChanged() {
            var listItems = this.tag('List').items;
            var correction = listItems[0];
            this._settings = {
              correction: correction.options[correction.value].type,
              brightness: listItems[1].value,
              contrast: listItems[2].value,
              gamma: listItems[3].value
            };
            if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
              var steppers = listItems.slice(1);
              steppers.forEach(stepper => {
                stepper.value = 50;
              });
            }
            this._currentCorrection = this._settings.correction;
            this._shiftColors();
            this.signal('onColorShift', this._settings);
          }
          _update() {
            var list = this.tag('List');
            var steppers = ['Brightness', 'Contrast', 'Gamma'];
            var options = this._options;
            var settings = this._settings;
            var colors = {
              focusColor: this._focusColor,
              labelColor: this._labelColor,
              labelColorFocused: this._labelColorFocused
            };
            this._shiftColors();
            var settingItems = steppers.map(stepper => {
              var lowerC = stepper.toLocaleLowerCase();
              return _objectSpread({
                type: this[`${lowerC}Component`],
                label: stepper,
                value: settings[lowerC],
                w: this.finalW,
                h: 80
              }, colors);
            });
            settingItems.unshift(_objectSpread({
              type: this.correctionComponent,
              options,
              value: findIndexOfObject(options, settings.correction, 'type'),
              label: 'Color adjustment',
              w: this.finalW,
              h: 80
            }, colors));
            list.clear();
            list.add(settingItems);
          }
          _firstActive() {
            if (!this._settings) {
              this._settings = {
                correction: 'neutral',
                brightness: 50,
                contrast: 50,
                gamma: 50
              };
            }
            this._update();
          }
          set settings(obj) {
            this._settings = obj;
            if (this.active) {
              var listItems = this.tag('List').items;
              listItems[0] = findIndexOfObject(this._options, obj.correction, 'type');
              listItems[1] = obj.brightness || 50;
              listItems[2] = obj.contrast || 50;
              listItems[3] = obj.gamma || 50;
            }
          }
          get settings() {
            return this._settings;
          }
          get correctionTag() {
            return this.tag('List').items[0];
          }
          get brightnessTag() {
            return this.tag('List').items[1];
          }
          get contrastTag() {
            return this.tag('List').items[2];
          }
          get gammaTag() {
            return this.tag('List').items[3];
          }
          get adjustmentTags() {
            return this.tag('List').items;
          }
          set stepperComponent(component) {
            this._stepperComponent = component;
          }
          get stepperComponent() {
            return this._stepperComponent || ArrowStepper;
          }
          set correctionComponent(component) {
            this._correctionComponent = component;
          }
          get correctionComponent() {
            return this._correctionComponent || this.stepperComponent;
          }
          set brightnessComponent(component) {
            this._brightnessComponent = component;
          }
          get brightnessComponent() {
            return this._brightnessComponent || this.stepperComponent;
          }
          set contrastComponent(component) {
            this._contrastComponent = component;
          }
          get contrastComponent() {
            return this._contrastComponent || this.stepperComponent;
          }
          set gammaComponent(component) {
            this._gammaComponent = component;
          }
          get gammaComponent() {
            return this._gammaComponent || this.stepperComponent;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class CarouselItem extends lightning.Component {
          static _template() {
            return {
              Focus: {
                alpha: 0,
                x: w => w * 0.5,
                y: h => h * 0.5,
                mount: 0.5,
                w: 120,
                h: 50,
                rect: true,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 25
                }
              },
              Label: {
                x: w => w * 0.5,
                y: h => h * 0.5,
                mount: 0.5,
                renderOffscreen: true,
                text: {
                  text: '',
                  fontSize: 22
                }
              }
            };
          }
          _construct() {
            this._focusColor = 0xff009245;
            this._labelColor = 0xff9d9d9d;
            this._labelColorFocused = 0xffffffff;
            this._padding = 40;
            defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding']);
          }
          set label(str) {
            this.tag('Label').text.text = str;
            this._label = str;
          }
          get label() {
            return this._label;
          }
          _init() {
            var label = this.tag('Label');
            label.on('txLoaded', () => {
              this.patch({
                w: label.renderWidth,
                Focus: {
                  w: label.renderWidth + this._padding * 2
                }
              });
              if (this.collectionWrapper) {
                this.collectionWrapper.reposition();
              }
            });
          }
          _focus() {
            this.patch({
              Focus: {
                smooth: {
                  alpha: 1
                }
              },
              Label: {
                smooth: {
                  color: this._labelColorFocused
                }
              }
            });
          }
          _unfocus(target) {
            if (target.isCarouselItem === true) {
              this.patch({
                Focus: {
                  smooth: {
                    alpha: 0
                  }
                },
                Label: {
                  smooth: {
                    color: this._labelColor
                  }
                }
              });
            }
          }
          _firstActive() {
            this.patch({
              Focus: {
                color: this._focusColor
              },
              Label: {
                color: this._labelColor
              }
            });
            if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
              this._focus();
            }
          }
          get isCarouselItem() {
            return true;
          }
          static get width() {
            return 120;
          }
          static get height() {
            return 50;
          }
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2021 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */

        class ProgressBar extends lightning.Component {
          static _template() {
            return {
              w: 300,
              h: 10,
              Background: {
                w: _w11 => _w11,
                h: _h9 => _h9,
                rect: true,
                rtt: true,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 5
                },
                Progress: {
                  h: _h10 => _h10,
                  w: 10,
                  rect: true,
                  shader: {
                    type: lightning.shaders.RoundedRectangle,
                    radius: 0
                  }
                }
              }
            };
          }
          _construct() {
            this._progressColor = 0xff009245;
            this._progressColorFocused = undefined;
            this._backgroundColor = 0xff9d9d9d;
            this._backgroundColorFocused = undefined;
            this._backgroundRadius = 5;
            this._progressRadius = 0;
            this.value = 0.5;
            defineProperties(this, ['progressColor', 'backgroundColor', 'progressColorFocused', 'backgroundColorFocused']);
          }
          progress(p) {
            if (p > 1) {
              p = p / 100;
            }
            this._value = p;
            this.tag('Progress').w = this.w * p;
          }
          _createFocusAnimation() {
            this._focusAnimation = this.animation({
              duration: 0.2,
              stopMethod: 'reverse',
              actions: [{
                t: 'Background',
                p: 'color',
                v: {
                  0: this._backgroundColor,
                  1: this._backgroundColorFocused || this._backgroundColor
                }
              }, {
                t: 'Background.Progress',
                p: 'color',
                v: {
                  0: this._progressColor,
                  1: this._progressColorFocused || this._progressColor
                }
              }]
            });
          }
          _firstActive() {
            if (!this._focusAnimation) {
              this._createFocusAnimation();
            }
            this.patch({
              Background: {
                color: this._backgroundColor,
                shader: {
                  radius: this._backgroundRadius
                },
                Progress: {
                  color: this._progressColor,
                  shader: {
                    radius: this._progressRadius
                  }
                }
              }
            });
            this.progress(this._value);
            if (this.hasFocus()) {
              this._focus();
            }
          }
          _focus() {
            if (this._focusAnimation) {
              this._focusAnimation.start();
            }
          }
          _unfocus() {
            if (this._focusAnimation) {
              this._focusAnimation.stop();
            }
          }
          set value(p) {
            this._value = p;
            if (this.active) {
              this.progress(p);
            }
          }
          get value() {
            return this._value;
          }
          set backgroundRadius(num) {
            this._backgroundRadius = num;
            if (this.active) {
              this.tag('Background').shader.radius = num;
            }
          }
          get progressRadius() {
            return this._progressRadius;
          }
          set progressRadius(num) {
            this._progressRadius = num;
            if (this.active) {
              this.tag('Progress').shader.radius = num;
            }
          }
          get progressRadius() {
            return this._progressRadius;
          }
          get backgroundTag() {
            return this.tag('Background');
          }
          get progressTag() {
            return this.tag('Progress');
          }
        }
        class VideoSpecItem extends lightning.Component {
          static _template() {
            return {
              VideoSpec: {
                w: 120,
                h: 80,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 20,
                  stroke: 8,
                  strokeColor: theme.colors.accentGrey.light
                },
                color: theme.colors.accentGrey.light,
                Spec: {
                  mount: 0.5,
                  color: theme.colors.accentGrey.light,
                  text: {
                    fontSize: 22,
                    fontFace: "Saira Regular",
                    fontStyle: "400"
                  }
                }
              }
            };
          }
          set specData(spec) {
            this.patch({
              VideoSpec: {
                Spec: {
                  text: spec
                }
              }
            });
          }
          set customColor(color) {
            this.patch({
              VideoSpec: {
                shader: {
                  strokeColor: color
                },
                Spec: {
                  smooth: {
                    color
                  }
                }
              }
            });
          }
        }
        var cardSizes = {
          regular: {
            w: 216,
            h: 324,
            margin: 30,
            minimumCardsInViewport: 7
          },
          wide: {
            w: 324,
            h: 216,
            margin: 30,
            minimumCardsInViewport: 5
          }
        };
        class RailItem extends lightning.Component {
          constructor() {
            super(...arguments);
            this.data = {};
            this.index = 0;
            this.totalElements = 0;
            this.cardSize = cardSizes.regular;
            this.focused = false;
            this.railIndex = 0;
          }
          /**
           * This function is responsible for the creation and return of the UI template. This
           * function takes  no parameters and returns the template of the Rail Item component.
           *
           * @returns Template for the Rail Item Component.
           *
           */
          static _template() {
            return {
              rect: true,
              color: theme.colors.accentGrey.dark,
              shader: {
                type: lightning.shaders.RoundedRectangle,
                radius: 20
              },
              Image: {
                w: _w12 => _w12,
                h: _h11 => _h11,
                shader: {
                  type: lightning.shaders.FadeOut,
                  innerColor: theme.colors.black,
                  bottom: 200
                }
              },
              Label: {
                x: 10,
                y: 326.25,
                w: _w13 => _w13,
                color: theme.colors.accentGrey.light,
                text: {
                  fontSize: 22.5
                }
              },
              ProgressBar: {
                h: 5,
                w: 200,
                x: 10,
                y: cardSizes.regular.h - 20,
                type: ProgressBar,
                progressColorFocused: theme.colors.yellow,
                progressColor: theme.colors.yellow
              },
              VideoSpec: {
                visible: true,
                VideoSpec1: {
                  x: 55,
                  y: 25,
                  shader: null,
                  type: VideoSpecItem,
                  specData: "  16+  ",
                  customColor: theme.colors.yellow
                },
                VideoSpec2: {
                  x: 120,
                  y: 25,
                  shader: null,
                  type: VideoSpecItem,
                  specData: "  4k  ",
                  customColor: theme.colors.yellow
                },
                VideoSpec3: {
                  x: 175,
                  y: 25,
                  shader: null,
                  type: VideoSpecItem,
                  specData: "  cc  ",
                  customColor: theme.colors.yellow
                }
              },
              PlayButton: {
                h: 100,
                visible: false,
                text: {
                  fontSize: 35,
                  textColor: theme.colors.white,
                  textAlign: "left",
                  textIndent: 20,
                  textBaseline: "hanging",
                  text: "Play Video",
                  mountY: 0.5
                }
              }
            };
          }
          /**
           * Setter for setting the values for the item property.
           *
           * @Param The value that needs to be setted to the item property.
           *
           */
          set item(obj) {
            var label = obj.label,
              src = obj.src,
              data = obj.data,
              index = obj.index,
              totalElements = obj.totalElements,
              cardSize = obj.cardSize,
              railIndex = obj.railIndex;
            this.data = data;
            this.index = index;
            this.totalElements = totalElements;
            this.cardSize = cardSize;
            this.railIndex = railIndex;
            this.patch({
              Image: {
                src,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 20
                }
              },
              Label: {
                y: this.cardSize.h + 10,
                text: label === null || label === void 0 ? void 0 : label.toString()
              },
              w: this.cardSize.w,
              h: this.cardSize.h,
              ProgressBar: {
                x: 10,
                y: this.cardSize.h - 20,
                w: this.cardSize.w - 20,
                value: Math.floor(Math.random() * 101)
              }
            });
          }
          /**
          * This function overrides the default behaviour of keypress 'Enter'.
          * This functions checks the index to see the focused element and decides
          * the route to navigate.
          */
          _handleEnter() {
            Router.navigate(`content/railItem/${this.data.uid}`, {
              from: "Home",
              data: this.data
            });
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.focused = true;
            var cardData = {
              cardWidth: this.w,
              cardHeight: this.h,
              cardIndex: this.index,
              railTotalElements: this.totalElements,
              cardSize: this.cardSize,
              railIndex: this.railIndex
            };
            this.fireAncestors("$changeItemOnFocus", this.data, cardData);
            this.patch({
              // smooth: { color: theme.colors.secondary, scale: 1.1 },
              Label: {
                smooth: {
                  color: theme.colors.white
                }
              },
              Rectangle: {
                color: theme.colors.yellow,
                x: 10,
                y: _y => _y + 54,
                w: _w14 => _w14 - 20,
                h: 5,
                rect: true
              },
              PlayButton: {
                visible: true,
                color: theme.colors.yellow,
                y: this.cardSize.h / 2
              }
            });
            this.fireAncestors("$changeItemOnFocus", this.data, cardData);
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.focused = false;
            this.patch({
              // smooth: { color: theme.colors.accentGrey.dark, scale: 1.0 },
              Label: {
                smooth: {
                  color: theme.colors.accentGrey.light
                }
              },
              Rectangle: void 0,
              PlayButton: {
                visible: false
              }
            });
          }
        }
        function bind(fn, thisArg) {
          return function wrap() {
            return fn.apply(thisArg, arguments);
          };
        }

        // utils is a library of generic helper functions non-specific to axios

        var toString = Object.prototype.toString;
        var getPrototypeOf = Object.getPrototypeOf;
        var kindOf = (cache => thing => {
          var str = toString.call(thing);
          return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
        })(Object.create(null));
        var kindOfTest = type => {
          type = type.toLowerCase();
          return thing => kindOf(thing) === type;
        };
        var typeOfTest = type => thing => typeof thing === type;

        /**
         * Determine if a value is an Array
         *
         * @param {Object} val The value to test
         *
         * @returns {boolean} True if value is an Array, otherwise false
         */
        var isArray = Array.isArray;

        /**
         * Determine if a value is undefined
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if the value is undefined, otherwise false
         */
        var isUndefined = typeOfTest('undefined');

        /**
         * Determine if a value is a Buffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Buffer, otherwise false
         */
        function isBuffer(val) {
          return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
        }

        /**
         * Determine if a value is an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is an ArrayBuffer, otherwise false
         */
        var isArrayBuffer = kindOfTest('ArrayBuffer');

        /**
         * Determine if a value is a view on an ArrayBuffer
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
         */
        function isArrayBufferView(val) {
          var result;
          if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
            result = ArrayBuffer.isView(val);
          } else {
            result = val && val.buffer && isArrayBuffer(val.buffer);
          }
          return result;
        }

        /**
         * Determine if a value is a String
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a String, otherwise false
         */
        var isString = typeOfTest('string');

        /**
         * Determine if a value is a Function
         *
         * @param {*} val The value to test
         * @returns {boolean} True if value is a Function, otherwise false
         */
        var isFunction = typeOfTest('function');

        /**
         * Determine if a value is a Number
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Number, otherwise false
         */
        var isNumber = typeOfTest('number');

        /**
         * Determine if a value is an Object
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an Object, otherwise false
         */
        var isObject = thing => thing !== null && typeof thing === 'object';

        /**
         * Determine if a value is a Boolean
         *
         * @param {*} thing The value to test
         * @returns {boolean} True if value is a Boolean, otherwise false
         */
        var isBoolean = thing => thing === true || thing === false;

        /**
         * Determine if a value is a plain Object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a plain Object, otherwise false
         */
        var isPlainObject = val => {
          if (kindOf(val) !== 'object') {
            return false;
          }
          var prototype = getPrototypeOf(val);
          return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
        };

        /**
         * Determine if a value is a Date
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Date, otherwise false
         */
        var isDate = kindOfTest('Date');

        /**
         * Determine if a value is a File
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */
        var isFile = kindOfTest('File');

        /**
         * Determine if a value is a Blob
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Blob, otherwise false
         */
        var isBlob = kindOfTest('Blob');

        /**
         * Determine if a value is a FileList
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a File, otherwise false
         */
        var isFileList = kindOfTest('FileList');

        /**
         * Determine if a value is a Stream
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a Stream, otherwise false
         */
        var isStream = val => isObject(val) && isFunction(val.pipe);

        /**
         * Determine if a value is a FormData
         *
         * @param {*} thing The value to test
         *
         * @returns {boolean} True if value is an FormData, otherwise false
         */
        var isFormData = thing => {
          var pattern = '[object FormData]';
          return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
        };

        /**
         * Determine if a value is a URLSearchParams object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a URLSearchParams object, otherwise false
         */
        var isURLSearchParams = kindOfTest('URLSearchParams');

        /**
         * Trim excess whitespace off the beginning and end of a string
         *
         * @param {String} str The String to trim
         *
         * @returns {String} The String freed of excess whitespace
         */
        var trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

        /**
         * Iterate over an Array or an Object invoking a function for each item.
         *
         * If `obj` is an Array callback will be called passing
         * the value, index, and complete array for each item.
         *
         * If 'obj' is an Object callback will be called passing
         * the value, key, and complete object for each property.
         *
         * @param {Object|Array} obj The object to iterate
         * @param {Function} fn The callback to invoke for each item
         *
         * @param {Boolean} [allOwnKeys = false]
         * @returns {any}
         */
        function forEach(obj, fn) {
          var _ref30 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref30$allOwnKeys = _ref30.allOwnKeys,
            allOwnKeys = _ref30$allOwnKeys === void 0 ? false : _ref30$allOwnKeys;
          // Don't bother if no value provided
          if (obj === null || typeof obj === 'undefined') {
            return;
          }
          var i;
          var l;

          // Force an array if not already something iterable
          if (typeof obj !== 'object') {
            /*eslint no-param-reassign:0*/
            obj = [obj];
          }
          if (isArray(obj)) {
            // Iterate over array values
            for (i = 0, l = obj.length; i < l; i++) {
              fn.call(null, obj[i], i, obj);
            }
          } else {
            // Iterate over object keys
            var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
            var len = keys.length;
            var key;
            for (i = 0; i < len; i++) {
              key = keys[i];
              fn.call(null, obj[key], key, obj);
            }
          }
        }
        function findKey(obj, key) {
          key = key.toLowerCase();
          var keys = Object.keys(obj);
          var i = keys.length;
          var _key;
          while (i-- > 0) {
            _key = keys[i];
            if (key === _key.toLowerCase()) {
              return _key;
            }
          }
          return null;
        }
        var _global = (() => {
          /*eslint no-undef:0*/
          if (typeof globalThis !== "undefined") return globalThis;
          return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
        })();
        var isContextDefined = context => !isUndefined(context) && context !== _global;

        /**
         * Accepts varargs expecting each argument to be an object, then
         * immutably merges the properties of each object and returns result.
         *
         * When multiple objects contain the same key the later object in
         * the arguments list will take precedence.
         *
         * Example:
         *
         * ```js
         * var result = merge({foo: 123}, {foo: 456});
         * console.log(result.foo); // outputs 456
         * ```
         *
         * @param {Object} obj1 Object to merge
         *
         * @returns {Object} Result of all merge properties
         */
        function merge( /* obj1, obj2, obj3, ... */
        ) {
          var _ref31 = isContextDefined(this) && this || {},
            caseless = _ref31.caseless;
          var result = {};
          var assignValue = (val, key) => {
            var targetKey = caseless && findKey(result, key) || key;
            if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
              result[targetKey] = merge(result[targetKey], val);
            } else if (isPlainObject(val)) {
              result[targetKey] = merge({}, val);
            } else if (isArray(val)) {
              result[targetKey] = val.slice();
            } else {
              result[targetKey] = val;
            }
          };
          for (var i = 0, l = arguments.length; i < l; i++) {
            arguments[i] && forEach(arguments[i], assignValue);
          }
          return result;
        }

        /**
         * Extends object a by mutably adding to it the properties of object b.
         *
         * @param {Object} a The object to be extended
         * @param {Object} b The object to copy properties from
         * @param {Object} thisArg The object to bind function to
         *
         * @param {Boolean} [allOwnKeys]
         * @returns {Object} The resulting value of object a
         */
        var extend = function extend(a, b, thisArg) {
          var _ref32 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
            allOwnKeys = _ref32.allOwnKeys;
          forEach(b, (val, key) => {
            if (thisArg && isFunction(val)) {
              a[key] = bind(val, thisArg);
            } else {
              a[key] = val;
            }
          }, {
            allOwnKeys
          });
          return a;
        };

        /**
         * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
         *
         * @param {string} content with BOM
         *
         * @returns {string} content value without BOM
         */
        var stripBOM = content => {
          if (content.charCodeAt(0) === 0xFEFF) {
            content = content.slice(1);
          }
          return content;
        };

        /**
         * Inherit the prototype methods from one constructor into another
         * @param {function} constructor
         * @param {function} superConstructor
         * @param {object} [props]
         * @param {object} [descriptors]
         *
         * @returns {void}
         */
        var inherits = (constructor, superConstructor, props, descriptors) => {
          constructor.prototype = Object.create(superConstructor.prototype, descriptors);
          constructor.prototype.constructor = constructor;
          Object.defineProperty(constructor, 'super', {
            value: superConstructor.prototype
          });
          props && Object.assign(constructor.prototype, props);
        };

        /**
         * Resolve object with deep prototype chain to a flat object
         * @param {Object} sourceObj source object
         * @param {Object} [destObj]
         * @param {Function|Boolean} [filter]
         * @param {Function} [propFilter]
         *
         * @returns {Object}
         */
        var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
          var props;
          var i;
          var prop;
          var merged = {};
          destObj = destObj || {};
          // eslint-disable-next-line no-eq-null,eqeqeq
          if (sourceObj == null) return destObj;
          do {
            props = Object.getOwnPropertyNames(sourceObj);
            i = props.length;
            while (i-- > 0) {
              prop = props[i];
              if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
              }
            }
            sourceObj = filter !== false && getPrototypeOf(sourceObj);
          } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
          return destObj;
        };

        /**
         * Determines whether a string ends with the characters of a specified string
         *
         * @param {String} str
         * @param {String} searchString
         * @param {Number} [position= 0]
         *
         * @returns {boolean}
         */
        var endsWith = (str, searchString, position) => {
          str = String(str);
          if (position === undefined || position > str.length) {
            position = str.length;
          }
          position -= searchString.length;
          var lastIndex = str.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        };

        /**
         * Returns new array from array like object or null if failed
         *
         * @param {*} [thing]
         *
         * @returns {?Array}
         */
        var toArray = thing => {
          if (!thing) return null;
          if (isArray(thing)) return thing;
          var i = thing.length;
          if (!isNumber(i)) return null;
          var arr = new Array(i);
          while (i-- > 0) {
            arr[i] = thing[i];
          }
          return arr;
        };

        /**
         * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
         * thing passed in is an instance of Uint8Array
         *
         * @param {TypedArray}
         *
         * @returns {Array}
         */
        // eslint-disable-next-line func-names
        var isTypedArray = (TypedArray => {
          // eslint-disable-next-line func-names
          return thing => {
            return TypedArray && thing instanceof TypedArray;
          };
        })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

        /**
         * For each entry in the object, call the function with the key and value.
         *
         * @param {Object<any, any>} obj - The object to iterate over.
         * @param {Function} fn - The function to call for each entry.
         *
         * @returns {void}
         */
        var forEachEntry = (obj, fn) => {
          var generator = obj && obj[Symbol.iterator];
          var iterator = generator.call(obj);
          var result;
          while ((result = iterator.next()) && !result.done) {
            var pair = result.value;
            fn.call(obj, pair[0], pair[1]);
          }
        };

        /**
         * It takes a regular expression and a string, and returns an array of all the matches
         *
         * @param {string} regExp - The regular expression to match against.
         * @param {string} str - The string to search.
         *
         * @returns {Array<boolean>}
         */
        var matchAll = (regExp, str) => {
          var matches;
          var arr = [];
          while ((matches = regExp.exec(str)) !== null) {
            arr.push(matches);
          }
          return arr;
        };

        /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
        var isHTMLForm = kindOfTest('HTMLFormElement');
        var toCamelCase = str => {
          return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
            return p1.toUpperCase() + p2;
          });
        };

        /* Creating a function that will check if an object has a property. */
        var hasOwnProperty = (_ref33 => {
          var hasOwnProperty = _ref33.hasOwnProperty;
          return (obj, prop) => hasOwnProperty.call(obj, prop);
        })(Object.prototype);

        /**
         * Determine if a value is a RegExp object
         *
         * @param {*} val The value to test
         *
         * @returns {boolean} True if value is a RegExp object, otherwise false
         */
        var isRegExp = kindOfTest('RegExp');
        var reduceDescriptors = (obj, reducer) => {
          var descriptors = Object.getOwnPropertyDescriptors(obj);
          var reducedDescriptors = {};
          forEach(descriptors, (descriptor, name) => {
            if (reducer(descriptor, name, obj) !== false) {
              reducedDescriptors[name] = descriptor;
            }
          });
          Object.defineProperties(obj, reducedDescriptors);
        };

        /**
         * Makes all methods read-only
         * @param {Object} obj
         */

        var freezeMethods = obj => {
          reduceDescriptors(obj, (descriptor, name) => {
            // skip restricted props in strict mode
            if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
              return false;
            }
            var value = obj[name];
            if (!isFunction(value)) return;
            descriptor.enumerable = false;
            if ('writable' in descriptor) {
              descriptor.writable = false;
              return;
            }
            if (!descriptor.set) {
              descriptor.set = () => {
                throw Error('Can not rewrite read-only method \'' + name + '\'');
              };
            }
          });
        };
        var toObjectSet = (arrayOrString, delimiter) => {
          var obj = {};
          var define = arr => {
            arr.forEach(value => {
              obj[value] = true;
            });
          };
          isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
          return obj;
        };
        var noop = () => {};
        var toFiniteNumber = (value, defaultValue) => {
          value = +value;
          return Number.isFinite(value) ? value : defaultValue;
        };
        var ALPHA = 'abcdefghijklmnopqrstuvwxyz';
        var DIGIT = '0123456789';
        var ALPHABET = {
          DIGIT,
          ALPHA,
          ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
        };
        var generateString = function generateString() {
          var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
          var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHABET.ALPHA_DIGIT;
          var str = '';
          var length = alphabet.length;
          while (size--) {
            str += alphabet[Math.random() * length | 0];
          }
          return str;
        };

        /**
         * If the thing is a FormData object, return true, otherwise return false.
         *
         * @param {unknown} thing - The thing to check.
         *
         * @returns {boolean}
         */
        function isSpecCompliantForm(thing) {
          return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
        }
        var toJSONObject = obj => {
          var stack = new Array(10);
          var visit = (source, i) => {
            if (isObject(source)) {
              if (stack.indexOf(source) >= 0) {
                return;
              }
              if (!('toJSON' in source)) {
                stack[i] = source;
                var target = isArray(source) ? [] : {};
                forEach(source, (value, key) => {
                  var reducedValue = visit(value, i + 1);
                  !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
              }
            }
            return source;
          };
          return visit(obj, 0);
        };
        var utils = {
          isArray,
          isArrayBuffer,
          isBuffer,
          isFormData,
          isArrayBufferView,
          isString,
          isNumber,
          isBoolean,
          isObject,
          isPlainObject,
          isUndefined,
          isDate,
          isFile,
          isBlob,
          isRegExp,
          isFunction,
          isStream,
          isURLSearchParams,
          isTypedArray,
          isFileList,
          forEach,
          merge,
          extend,
          trim,
          stripBOM,
          inherits,
          toFlatObject,
          kindOf,
          kindOfTest,
          endsWith,
          toArray,
          forEachEntry,
          matchAll,
          isHTMLForm,
          hasOwnProperty,
          hasOwnProp: hasOwnProperty,
          // an alias to avoid ESLint no-prototype-builtins detection
          reduceDescriptors,
          freezeMethods,
          toObjectSet,
          toCamelCase,
          noop,
          toFiniteNumber,
          findKey,
          global: _global,
          isContextDefined,
          ALPHABET,
          generateString,
          isSpecCompliantForm,
          toJSONObject
        };

        /**
         * Create an Error with the specified message, config, error code, request and response.
         *
         * @param {string} message The error message.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [config] The config.
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         *
         * @returns {Error} The created error.
         */
        function AxiosError(message, code, config, request, response) {
          Error.call(this);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error().stack;
          }
          this.message = message;
          this.name = 'AxiosError';
          code && (this.code = code);
          config && (this.config = config);
          request && (this.request = request);
          response && (this.response = response);
        }
        utils.inherits(AxiosError, Error, {
          toJSON: function toJSON() {
            return {
              // Standard
              message: this.message,
              name: this.name,
              // Microsoft
              description: this.description,
              number: this.number,
              // Mozilla
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              // Axios
              config: utils.toJSONObject(this.config),
              code: this.code,
              status: this.response && this.response.status ? this.response.status : null
            };
          }
        });
        var prototype$1 = AxiosError.prototype;
        var descriptors = {};
        ['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
        // eslint-disable-next-line func-names
        ].forEach(code => {
          descriptors[code] = {
            value: code
          };
        });
        Object.defineProperties(AxiosError, descriptors);
        Object.defineProperty(prototype$1, 'isAxiosError', {
          value: true
        });

        // eslint-disable-next-line func-names
        AxiosError.from = (error, code, config, request, response, customProps) => {
          var axiosError = Object.create(prototype$1);
          utils.toFlatObject(error, axiosError, function filter(obj) {
            return obj !== Error.prototype;
          }, prop => {
            return prop !== 'isAxiosError';
          });
          AxiosError.call(axiosError, error.message, code, config, request, response);
          axiosError.cause = error;
          axiosError.name = error.name;
          customProps && Object.assign(axiosError, customProps);
          return axiosError;
        };

        // eslint-disable-next-line strict
        var httpAdapter = null;

        /**
         * Determines if the given thing is a array or js object.
         *
         * @param {string} thing - The object or array to be visited.
         *
         * @returns {boolean}
         */
        function isVisitable(thing) {
          return utils.isPlainObject(thing) || utils.isArray(thing);
        }

        /**
         * It removes the brackets from the end of a string
         *
         * @param {string} key - The key of the parameter.
         *
         * @returns {string} the key without the brackets.
         */
        function removeBrackets(key) {
          return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
        }

        /**
         * It takes a path, a key, and a boolean, and returns a string
         *
         * @param {string} path - The path to the current key.
         * @param {string} key - The key of the current object being iterated over.
         * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
         *
         * @returns {string} The path to the current key.
         */
        function renderKey(path, key, dots) {
          if (!path) return key;
          return path.concat(key).map(function each(token, i) {
            // eslint-disable-next-line no-param-reassign
            token = removeBrackets(token);
            return !dots && i ? '[' + token + ']' : token;
          }).join(dots ? '.' : '');
        }

        /**
         * If the array is an array and none of its elements are visitable, then it's a flat array.
         *
         * @param {Array<any>} arr - The array to check
         *
         * @returns {boolean}
         */
        function isFlatArray(arr) {
          return utils.isArray(arr) && !arr.some(isVisitable);
        }
        var predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
          return /^is[A-Z]/.test(prop);
        });

        /**
         * Convert a data object to FormData
         *
         * @param {Object} obj
         * @param {?Object} [formData]
         * @param {?Object} [options]
         * @param {Function} [options.visitor]
         * @param {Boolean} [options.metaTokens = true]
         * @param {Boolean} [options.dots = false]
         * @param {?Boolean} [options.indexes = false]
         *
         * @returns {Object}
         **/

        /**
         * It converts an object into a FormData object
         *
         * @param {Object<any, any>} obj - The object to convert to form data.
         * @param {string} formData - The FormData object to append to.
         * @param {Object<string, any>} options
         *
         * @returns
         */
        function toFormData(obj, formData, options) {
          if (!utils.isObject(obj)) {
            throw new TypeError('target must be an object');
          }

          // eslint-disable-next-line no-param-reassign
          formData = formData || new FormData();

          // eslint-disable-next-line no-param-reassign
          options = utils.toFlatObject(options, {
            metaTokens: true,
            dots: false,
            indexes: false
          }, false, function defined(option, source) {
            // eslint-disable-next-line no-eq-null,eqeqeq
            return !utils.isUndefined(source[option]);
          });
          var metaTokens = options.metaTokens;
          // eslint-disable-next-line no-use-before-define
          var visitor = options.visitor || defaultVisitor;
          var dots = options.dots;
          var indexes = options.indexes;
          var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
          var useBlob = _Blob && utils.isSpecCompliantForm(formData);
          if (!utils.isFunction(visitor)) {
            throw new TypeError('visitor must be a function');
          }
          function convertValue(value) {
            if (value === null) return '';
            if (utils.isDate(value)) {
              return value.toISOString();
            }
            if (!useBlob && utils.isBlob(value)) {
              throw new AxiosError('Blob is not supported. Use a Buffer instead.');
            }
            if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
              return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
            }
            return value;
          }

          /**
           * Default visitor.
           *
           * @param {*} value
           * @param {String|Number} key
           * @param {Array<String|Number>} path
           * @this {FormData}
           *
           * @returns {boolean} return true to visit the each prop of the value recursively
           */
          function defaultVisitor(value, key, path) {
            var arr = value;
            if (value && !path && typeof value === 'object') {
              if (utils.endsWith(key, '{}')) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
              } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                  !(utils.isUndefined(el) || el === null) && formData.append(
                  // eslint-disable-next-line no-nested-ternary
                  indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
                });
                return false;
              }
            }
            if (isVisitable(value)) {
              return true;
            }
            formData.append(renderKey(path, key, dots), convertValue(value));
            return false;
          }
          var stack = [];
          var exposedHelpers = Object.assign(predicates, {
            defaultVisitor,
            convertValue,
            isVisitable
          });
          function build(value, path) {
            if (utils.isUndefined(value)) return;
            if (stack.indexOf(value) !== -1) {
              throw Error('Circular reference detected in ' + path.join('.'));
            }
            stack.push(value);
            utils.forEach(value, function each(el, key) {
              var result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);
              if (result === true) {
                build(el, path ? path.concat(key) : [key]);
              }
            });
            stack.pop();
          }
          if (!utils.isObject(obj)) {
            throw new TypeError('data must be an object');
          }
          build(obj);
          return formData;
        }

        /**
         * It encodes a string by replacing all characters that are not in the unreserved set with
         * their percent-encoded equivalents
         *
         * @param {string} str - The string to encode.
         *
         * @returns {string} The encoded string.
         */
        function encode$1(str) {
          var charMap = {
            '!': '%21',
            "'": '%27',
            '(': '%28',
            ')': '%29',
            '~': '%7E',
            '%20': '+',
            '%00': '\x00'
          };
          return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
            return charMap[match];
          });
        }

        /**
         * It takes a params object and converts it to a FormData object
         *
         * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
         * @param {Object<string, any>} options - The options object passed to the Axios constructor.
         *
         * @returns {void}
         */
        function AxiosURLSearchParams(params, options) {
          this._pairs = [];
          params && toFormData(params, this, options);
        }
        var prototype = AxiosURLSearchParams.prototype;
        prototype.append = function append(name, value) {
          this._pairs.push([name, value]);
        };
        prototype.toString = function toString(encoder) {
          var _encode = encoder ? function (value) {
            return encoder.call(this, value, encode$1);
          } : encode$1;
          return this._pairs.map(function each(pair) {
            return _encode(pair[0]) + '=' + _encode(pair[1]);
          }, '').join('&');
        };

        /**
         * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
         * URI encoded counterparts
         *
         * @param {string} val The value to be encoded.
         *
         * @returns {string} The encoded value.
         */
        function encode(val) {
          return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
        }

        /**
         * Build a URL by appending params to the end
         *
         * @param {string} url The base of the url (e.g., http://www.google.com)
         * @param {object} [params] The params to be appended
         * @param {?object} options
         *
         * @returns {string} The formatted url
         */
        function buildURL(url, params, options) {
          /*eslint no-param-reassign:0*/
          if (!params) {
            return url;
          }
          var _encode = options && options.encode || encode;
          var serializeFn = options && options.serialize;
          var serializedParams;
          if (serializeFn) {
            serializedParams = serializeFn(params, options);
          } else {
            serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
          }
          if (serializedParams) {
            var hashmarkIndex = url.indexOf("#");
            if (hashmarkIndex !== -1) {
              url = url.slice(0, hashmarkIndex);
            }
            url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
          }
          return url;
        }
        class InterceptorManager {
          constructor() {
            this.handlers = [];
          }

          /**
           * Add a new interceptor to the stack
           *
           * @param {Function} fulfilled The function to handle `then` for a `Promise`
           * @param {Function} rejected The function to handle `reject` for a `Promise`
           *
           * @return {Number} An ID used to remove interceptor later
           */
          use(fulfilled, rejected, options) {
            this.handlers.push({
              fulfilled,
              rejected,
              synchronous: options ? options.synchronous : false,
              runWhen: options ? options.runWhen : null
            });
            return this.handlers.length - 1;
          }

          /**
           * Remove an interceptor from the stack
           *
           * @param {Number} id The ID that was returned by `use`
           *
           * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
           */
          eject(id) {
            if (this.handlers[id]) {
              this.handlers[id] = null;
            }
          }

          /**
           * Clear all interceptors from the stack
           *
           * @returns {void}
           */
          clear() {
            if (this.handlers) {
              this.handlers = [];
            }
          }

          /**
           * Iterate over all the registered interceptors
           *
           * This method is particularly useful for skipping over any
           * interceptors that may have become `null` calling `eject`.
           *
           * @param {Function} fn The function to call for each interceptor
           *
           * @returns {void}
           */
          forEach(fn) {
            utils.forEach(this.handlers, function forEachHandler(h) {
              if (h !== null) {
                fn(h);
              }
            });
          }
        }
        var InterceptorManager$1 = InterceptorManager;
        var transitionalDefaults = {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        };
        var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;
        var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;
        var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

        /**
         * Determine if we're running in a standard browser environment
         *
         * This allows axios to run in a web worker, and react-native.
         * Both environments support XMLHttpRequest, but not fully standard globals.
         *
         * web workers:
         *  typeof window -> undefined
         *  typeof document -> undefined
         *
         * react-native:
         *  navigator.product -> 'ReactNative'
         * nativescript
         *  navigator.product -> 'NativeScript' or 'NS'
         *
         * @returns {boolean}
         */
        var isStandardBrowserEnv = (() => {
          var product;
          if (typeof navigator !== 'undefined' && ((product = navigator.product) === 'ReactNative' || product === 'NativeScript' || product === 'NS')) {
            return false;
          }
          return typeof window !== 'undefined' && typeof document !== 'undefined';
        })();

        /**
         * Determine if we're running in a standard browser webWorker environment
         *
         * Although the `isStandardBrowserEnv` method indicates that
         * `allows axios to run in a web worker`, the WebWorker will still be
         * filtered out due to its judgment standard
         * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
         * This leads to a problem when axios post `FormData` in webWorker
         */
        var isStandardBrowserWebWorkerEnv = (() => {
          return typeof WorkerGlobalScope !== 'undefined' &&
          // eslint-disable-next-line no-undef
          self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
        })();
        var platform = {
          isBrowser: true,
          classes: {
            URLSearchParams: URLSearchParams$1,
            FormData: FormData$1,
            Blob: Blob$1
          },
          isStandardBrowserEnv,
          isStandardBrowserWebWorkerEnv,
          protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
        };
        function toURLEncodedForm(data, options) {
          return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
            visitor: function visitor(value, key, path, helpers) {
              if (platform.isNode && utils.isBuffer(value)) {
                this.append(key, value.toString('base64'));
                return false;
              }
              return helpers.defaultVisitor.apply(this, arguments);
            }
          }, options));
        }

        /**
         * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
         *
         * @param {string} name - The name of the property to get.
         *
         * @returns An array of strings.
         */
        function parsePropPath(name) {
          // foo[x][y][z]
          // foo.x.y.z
          // foo-x-y-z
          // foo x y z
          return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
            return match[0] === '[]' ? '' : match[1] || match[0];
          });
        }

        /**
         * Convert an array to an object.
         *
         * @param {Array<any>} arr - The array to convert to an object.
         *
         * @returns An object with the same keys and values as the array.
         */
        function arrayToObject(arr) {
          var obj = {};
          var keys = Object.keys(arr);
          var i;
          var len = keys.length;
          var key;
          for (i = 0; i < len; i++) {
            key = keys[i];
            obj[key] = arr[key];
          }
          return obj;
        }

        /**
         * It takes a FormData object and returns a JavaScript object
         *
         * @param {string} formData The FormData object to convert to JSON.
         *
         * @returns {Object<string, any> | null} The converted object.
         */
        function formDataToJSON(formData) {
          function buildPath(path, value, target, index) {
            var name = path[index++];
            var isNumericKey = Number.isFinite(+name);
            var isLast = index >= path.length;
            name = !name && utils.isArray(target) ? target.length : name;
            if (isLast) {
              if (utils.hasOwnProp(target, name)) {
                target[name] = [target[name], value];
              } else {
                target[name] = value;
              }
              return !isNumericKey;
            }
            if (!target[name] || !utils.isObject(target[name])) {
              target[name] = [];
            }
            var result = buildPath(path, value, target[name], index);
            if (result && utils.isArray(target[name])) {
              target[name] = arrayToObject(target[name]);
            }
            return !isNumericKey;
          }
          if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
            var obj = {};
            utils.forEachEntry(formData, (name, value) => {
              buildPath(parsePropPath(name), value, obj, 0);
            });
            return obj;
          }
          return null;
        }
        var DEFAULT_CONTENT_TYPE = {
          'Content-Type': undefined
        };

        /**
         * It takes a string, tries to parse it, and if it fails, it returns the stringified version
         * of the input
         *
         * @param {any} rawValue - The value to be stringified.
         * @param {Function} parser - A function that parses a string into a JavaScript object.
         * @param {Function} encoder - A function that takes a value and returns a string.
         *
         * @returns {string} A stringified version of the rawValue.
         */
        function stringifySafely(rawValue, parser, encoder) {
          if (utils.isString(rawValue)) {
            try {
              (parser || JSON.parse)(rawValue);
              return utils.trim(rawValue);
            } catch (e) {
              if (e.name !== 'SyntaxError') {
                throw e;
              }
            }
          }
          return (encoder || JSON.stringify)(rawValue);
        }
        var defaults = {
          transitional: transitionalDefaults,
          adapter: ['xhr', 'http'],
          transformRequest: [function transformRequest(data, headers) {
            var contentType = headers.getContentType() || '';
            var hasJSONContentType = contentType.indexOf('application/json') > -1;
            var isObjectPayload = utils.isObject(data);
            if (isObjectPayload && utils.isHTMLForm(data)) {
              data = new FormData(data);
            }
            var isFormData = utils.isFormData(data);
            if (isFormData) {
              if (!hasJSONContentType) {
                return data;
              }
              return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
            }
            if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
              return data;
            }
            if (utils.isArrayBufferView(data)) {
              return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
              headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
              return data.toString();
            }
            var isFileList;
            if (isObjectPayload) {
              if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
                return toURLEncodedForm(data, this.formSerializer).toString();
              }
              if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
                var _FormData = this.env && this.env.FormData;
                return toFormData(isFileList ? {
                  'files[]': data
                } : data, _FormData && new _FormData(), this.formSerializer);
              }
            }
            if (isObjectPayload || hasJSONContentType) {
              headers.setContentType('application/json', false);
              return stringifySafely(data);
            }
            return data;
          }],
          transformResponse: [function transformResponse(data) {
            var transitional = this.transitional || defaults.transitional;
            var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            var JSONRequested = this.responseType === 'json';
            if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
              var silentJSONParsing = transitional && transitional.silentJSONParsing;
              var strictJSONParsing = !silentJSONParsing && JSONRequested;
              try {
                return JSON.parse(data);
              } catch (e) {
                if (strictJSONParsing) {
                  if (e.name === 'SyntaxError') {
                    throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                  }
                  throw e;
                }
              }
            }
            return data;
          }],
          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */
          timeout: 0,
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          maxContentLength: -1,
          maxBodyLength: -1,
          env: {
            FormData: platform.classes.FormData,
            Blob: platform.classes.Blob
          },
          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },
          headers: {
            common: {
              'Accept': 'application/json, text/plain, */*'
            }
          }
        };
        utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
          defaults.headers[method] = {};
        });
        utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
        });
        var defaults$1 = defaults;

        // RawAxiosHeaders whose duplicates are ignored by node
        // c.f. https://nodejs.org/api/http.html#http_message_headers
        var ignoreDuplicateOf = utils.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

        /**
         * Parse headers into an object
         *
         * ```
         * Date: Wed, 27 Aug 2014 08:58:49 GMT
         * Content-Type: application/json
         * Connection: keep-alive
         * Transfer-Encoding: chunked
         * ```
         *
         * @param {String} rawHeaders Headers needing to be parsed
         *
         * @returns {Object} Headers parsed into an object
         */
        var parseHeaders = rawHeaders => {
          var parsed = {};
          var key;
          var val;
          var i;
          rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
            i = line.indexOf(':');
            key = line.substring(0, i).trim().toLowerCase();
            val = line.substring(i + 1).trim();
            if (!key || parsed[key] && ignoreDuplicateOf[key]) {
              return;
            }
            if (key === 'set-cookie') {
              if (parsed[key]) {
                parsed[key].push(val);
              } else {
                parsed[key] = [val];
              }
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
            }
          });
          return parsed;
        };
        var $internals = Symbol('internals');
        function normalizeHeader(header) {
          return header && String(header).trim().toLowerCase();
        }
        function normalizeValue(value) {
          if (value === false || value == null) {
            return value;
          }
          return utils.isArray(value) ? value.map(normalizeValue) : String(value);
        }
        function parseTokens(str) {
          var tokens = Object.create(null);
          var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
          var match;
          while (match = tokensRE.exec(str)) {
            tokens[match[1]] = match[2];
          }
          return tokens;
        }
        function isValidHeaderName(str) {
          return /^[-_a-zA-Z]+$/.test(str.trim());
        }
        function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
          if (utils.isFunction(filter)) {
            return filter.call(this, value, header);
          }
          if (isHeaderNameFilter) {
            value = header;
          }
          if (!utils.isString(value)) return;
          if (utils.isString(filter)) {
            return value.indexOf(filter) !== -1;
          }
          if (utils.isRegExp(filter)) {
            return filter.test(value);
          }
        }
        function formatHeader(header) {
          return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
            return char.toUpperCase() + str;
          });
        }
        function buildAccessors(obj, header) {
          var accessorName = utils.toCamelCase(' ' + header);
          ['get', 'set', 'has'].forEach(methodName => {
            Object.defineProperty(obj, methodName + accessorName, {
              value: function value(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
              },
              configurable: true
            });
          });
        }
        class AxiosHeaders {
          constructor(headers) {
            headers && this.set(headers);
          }
          set(header, valueOrRewrite, rewrite) {
            var self = this;
            function setHeader(_value, _header, _rewrite) {
              var lHeader = normalizeHeader(_header);
              if (!lHeader) {
                throw new Error('header name must be a non-empty string');
              }
              var key = utils.findKey(self, lHeader);
              if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
                self[key || _header] = normalizeValue(_value);
              }
            }
            var setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
            if (utils.isPlainObject(header) || header instanceof this.constructor) {
              setHeaders(header, valueOrRewrite);
            } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
              setHeaders(parseHeaders(header), valueOrRewrite);
            } else {
              header != null && setHeader(valueOrRewrite, header, rewrite);
            }
            return this;
          }
          get(header, parser) {
            header = normalizeHeader(header);
            if (header) {
              var key = utils.findKey(this, header);
              if (key) {
                var value = this[key];
                if (!parser) {
                  return value;
                }
                if (parser === true) {
                  return parseTokens(value);
                }
                if (utils.isFunction(parser)) {
                  return parser.call(this, value, key);
                }
                if (utils.isRegExp(parser)) {
                  return parser.exec(value);
                }
                throw new TypeError('parser must be boolean|regexp|function');
              }
            }
          }
          has(header, matcher) {
            header = normalizeHeader(header);
            if (header) {
              var key = utils.findKey(this, header);
              return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
            }
            return false;
          }
          delete(header, matcher) {
            var self = this;
            var deleted = false;
            function deleteHeader(_header) {
              _header = normalizeHeader(_header);
              if (_header) {
                var key = utils.findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                  delete self[key];
                  deleted = true;
                }
              }
            }
            if (utils.isArray(header)) {
              header.forEach(deleteHeader);
            } else {
              deleteHeader(header);
            }
            return deleted;
          }
          clear(matcher) {
            var keys = Object.keys(this);
            var i = keys.length;
            var deleted = false;
            while (i--) {
              var key = keys[i];
              if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
              }
            }
            return deleted;
          }
          normalize(format) {
            var self = this;
            var headers = {};
            utils.forEach(this, (value, header) => {
              var key = utils.findKey(headers, header);
              if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
              }
              var normalized = format ? formatHeader(header) : String(header).trim();
              if (normalized !== header) {
                delete self[header];
              }
              self[normalized] = normalizeValue(value);
              headers[normalized] = true;
            });
            return this;
          }
          concat() {
            for (var _len10 = arguments.length, targets = new Array(_len10), _key13 = 0; _key13 < _len10; _key13++) {
              targets[_key13] = arguments[_key13];
            }
            return this.constructor.concat(this, ...targets);
          }
          toJSON(asStrings) {
            var obj = Object.create(null);
            utils.forEach(this, (value, header) => {
              value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
            });
            return obj;
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON()).map(_ref34 => {
              var _ref35 = _slicedToArray(_ref34, 2),
                header = _ref35[0],
                value = _ref35[1];
              return header + ': ' + value;
            }).join('\n');
          }
          get [Symbol.toStringTag]() {
            return 'AxiosHeaders';
          }
          static from(thing) {
            return thing instanceof this ? thing : new this(thing);
          }
          static concat(first) {
            var computed = new this(first);
            for (var _len11 = arguments.length, targets = new Array(_len11 > 1 ? _len11 - 1 : 0), _key14 = 1; _key14 < _len11; _key14++) {
              targets[_key14 - 1] = arguments[_key14];
            }
            targets.forEach(target => computed.set(target));
            return computed;
          }
          static accessor(header) {
            var internals = this[$internals] = this[$internals] = {
              accessors: {}
            };
            var accessors = internals.accessors;
            var prototype = this.prototype;
            function defineAccessor(_header) {
              var lHeader = normalizeHeader(_header);
              if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
              }
            }
            utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
            return this;
          }
        }
        AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);
        utils.freezeMethods(AxiosHeaders.prototype);
        utils.freezeMethods(AxiosHeaders);
        var AxiosHeaders$1 = AxiosHeaders;

        /**
         * Transform the data for a request or a response
         *
         * @param {Array|Function} fns A single function or Array of functions
         * @param {?Object} response The response object
         *
         * @returns {*} The resulting transformed data
         */
        function transformData(fns, response) {
          var config = this || defaults$1;
          var context = response || config;
          var headers = AxiosHeaders$1.from(context.headers);
          var data = context.data;
          utils.forEach(fns, function transform(fn) {
            data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
          });
          headers.normalize();
          return data;
        }
        function isCancel(value) {
          return !!(value && value.__CANCEL__);
        }

        /**
         * A `CanceledError` is an object that is thrown when an operation is canceled.
         *
         * @param {string=} message The message.
         * @param {Object=} config The config.
         * @param {Object=} request The request.
         *
         * @returns {CanceledError} The created error.
         */
        function CanceledError(message, config, request) {
          // eslint-disable-next-line no-eq-null,eqeqeq
          AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
          this.name = 'CanceledError';
        }
        utils.inherits(CanceledError, AxiosError, {
          __CANCEL__: true
        });

        /**
         * Resolve or reject a Promise based on response status.
         *
         * @param {Function} resolve A function that resolves the promise.
         * @param {Function} reject A function that rejects the promise.
         * @param {object} response The response.
         *
         * @returns {object} The response.
         */
        function settle(resolve, reject, response) {
          var validateStatus = response.config.validateStatus;
          if (!response.status || !validateStatus || validateStatus(response.status)) {
            resolve(response);
          } else {
            reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
          }
        }
        var cookies = platform.isStandardBrowserEnv ?
        // Standard browser envs support document.cookie
        function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));
              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }
              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }
              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }
              if (secure === true) {
                cookie.push('secure');
              }
              document.cookie = cookie.join('; ');
            },
            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return match ? decodeURIComponent(match[3]) : null;
            },
            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        }() :
        // Non standard browser env (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() {
              return null;
            },
            remove: function remove() {}
          };
        }();

        /**
         * Determines whether the specified URL is absolute
         *
         * @param {string} url The URL to test
         *
         * @returns {boolean} True if the specified URL is absolute, otherwise false
         */
        function isAbsoluteURL(url) {
          // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
          // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
          // by any combination of letters, digits, plus, period, or hyphen.
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
        }

        /**
         * Creates a new URL by combining the specified URLs
         *
         * @param {string} baseURL The base URL
         * @param {string} relativeURL The relative URL
         *
         * @returns {string} The combined URL
         */
        function combineURLs(baseURL, relativeURL) {
          return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
        }

        /**
         * Creates a new URL by combining the baseURL with the requestedURL,
         * only when the requestedURL is not already an absolute URL.
         * If the requestURL is absolute, this function returns the requestedURL untouched.
         *
         * @param {string} baseURL The base URL
         * @param {string} requestedURL Absolute or relative URL to combine
         *
         * @returns {string} The combined full path
         */
        function buildFullPath(baseURL, requestedURL) {
          if (baseURL && !isAbsoluteURL(requestedURL)) {
            return combineURLs(baseURL, requestedURL);
          }
          return requestedURL;
        }
        var isURLSameOrigin = platform.isStandardBrowserEnv ?
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
          * Parse a URL to discover it's components
          *
          * @param {String} url The URL to be parsed
          * @returns {Object}
          */
          function resolveURL(url) {
            var href = url;
            if (msie) {
              // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);

          /**
          * Determine if a URL shares the same origin as the current location
          *
          * @param {String} requestURL The URL to test
          * @returns {boolean} True if URL shares the same origin, otherwise false
          */
          return function isURLSameOrigin(requestURL) {
            var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }() :
        // Non standard browser envs (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        }();
        function parseProtocol(url) {
          var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
          return match && match[1] || '';
        }

        /**
         * Calculate data maxRate
         * @param {Number} [samplesCount= 10]
         * @param {Number} [min= 1000]
         * @returns {Function}
         */
        function speedometer(samplesCount, min) {
          samplesCount = samplesCount || 10;
          var bytes = new Array(samplesCount);
          var timestamps = new Array(samplesCount);
          var head = 0;
          var tail = 0;
          var firstSampleTS;
          min = min !== undefined ? min : 1000;
          return function push(chunkLength) {
            var now = Date.now();
            var startedAt = timestamps[tail];
            if (!firstSampleTS) {
              firstSampleTS = now;
            }
            bytes[head] = chunkLength;
            timestamps[head] = now;
            var i = tail;
            var bytesCount = 0;
            while (i !== head) {
              bytesCount += bytes[i++];
              i = i % samplesCount;
            }
            head = (head + 1) % samplesCount;
            if (head === tail) {
              tail = (tail + 1) % samplesCount;
            }
            if (now - firstSampleTS < min) {
              return;
            }
            var passed = startedAt && now - startedAt;
            return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
          };
        }
        function progressEventReducer(listener, isDownloadStream) {
          var bytesNotified = 0;
          var _speedometer = speedometer(50, 250);
          return e => {
            var loaded = e.loaded;
            var total = e.lengthComputable ? e.total : undefined;
            var progressBytes = loaded - bytesNotified;
            var rate = _speedometer(progressBytes);
            var inRange = loaded <= total;
            bytesNotified = loaded;
            var data = {
              loaded,
              total,
              progress: total ? loaded / total : undefined,
              bytes: progressBytes,
              rate: rate ? rate : undefined,
              estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
              event: e
            };
            data[isDownloadStream ? 'download' : 'upload'] = true;
            listener(data);
          };
        }
        var isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
        var xhrAdapter = isXHRAdapterSupported && function (config) {
          return new Promise(function dispatchXhrRequest(resolve, reject) {
            var requestData = config.data;
            var requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
            var responseType = config.responseType;
            var onCanceled;
            function done() {
              if (config.cancelToken) {
                config.cancelToken.unsubscribe(onCanceled);
              }
              if (config.signal) {
                config.signal.removeEventListener('abort', onCanceled);
              }
            }
            if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
              requestHeaders.setContentType(false); // Let the browser set it
            }

            var request = new XMLHttpRequest();

            // HTTP basic authentication
            if (config.auth) {
              var username = config.auth.username || '';
              var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
              requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
            }
            var fullPath = buildFullPath(config.baseURL, config.url);
            request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

            // Set the request timeout in MS
            request.timeout = config.timeout;
            function onloadend() {
              if (!request) {
                return;
              }
              // Prepare the response
              var responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
              var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
              var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
              };
              settle(function _resolve(value) {
                resolve(value);
                done();
              }, function _reject(err) {
                reject(err);
                done();
              }, response);

              // Clean up request
              request = null;
            }
            if ('onloadend' in request) {
              // Use onloadend if available
              request.onloadend = onloadend;
            } else {
              // Listen for ready state to emulate onloadend
              request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                  return;
                }

                // The request errored out and we didn't get a response, this will be
                // handled by onerror instead
                // With one exception: request that using file: protocol, most browsers
                // will return status as 0 even though it's a successful request
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                  return;
                }
                // readystate handler is calling before onerror or ontimeout handlers,
                // so we should call onloadend on the next 'tick'
                setTimeout(onloadend);
              };
            }

            // Handle browser request cancellation (as opposed to a manual cancellation)
            request.onabort = function handleAbort() {
              if (!request) {
                return;
              }
              reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

              // Clean up request
              request = null;
            };

            // Handle low level network errors
            request.onerror = function handleError() {
              // Real errors are hidden from us by the browser
              // onerror should only fire if it's a network error
              reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

              // Clean up request
              request = null;
            };

            // Handle timeout
            request.ontimeout = function handleTimeout() {
              var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
              var transitional = config.transitional || transitionalDefaults;
              if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
              }
              reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

              // Clean up request
              request = null;
            };

            // Add xsrf header
            // This is only done if running in a standard browser environment.
            // Specifically not if we're in a web worker, or react-native.
            if (platform.isStandardBrowserEnv) {
              // Add xsrf header
              var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
              if (xsrfValue) {
                requestHeaders.set(config.xsrfHeaderName, xsrfValue);
              }
            }

            // Remove Content-Type if data is undefined
            requestData === undefined && requestHeaders.setContentType(null);

            // Add headers to the request
            if ('setRequestHeader' in request) {
              utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
                request.setRequestHeader(key, val);
              });
            }

            // Add withCredentials to request if needed
            if (!utils.isUndefined(config.withCredentials)) {
              request.withCredentials = !!config.withCredentials;
            }

            // Add responseType to request if needed
            if (responseType && responseType !== 'json') {
              request.responseType = config.responseType;
            }

            // Handle progress if needed
            if (typeof config.onDownloadProgress === 'function') {
              request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
            }

            // Not all browsers support upload events
            if (typeof config.onUploadProgress === 'function' && request.upload) {
              request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
            }
            if (config.cancelToken || config.signal) {
              // Handle cancellation
              // eslint-disable-next-line func-names
              onCanceled = cancel => {
                if (!request) {
                  return;
                }
                reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
                request.abort();
                request = null;
              };
              config.cancelToken && config.cancelToken.subscribe(onCanceled);
              if (config.signal) {
                config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
              }
            }
            var protocol = parseProtocol(fullPath);
            if (protocol && platform.protocols.indexOf(protocol) === -1) {
              reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
              return;
            }

            // Send the request
            request.send(requestData || null);
          });
        };
        var knownAdapters = {
          http: httpAdapter,
          xhr: xhrAdapter
        };
        utils.forEach(knownAdapters, (fn, value) => {
          if (fn) {
            try {
              Object.defineProperty(fn, 'name', {
                value
              });
            } catch (e) {
              // eslint-disable-next-line no-empty
            }
            Object.defineProperty(fn, 'adapterName', {
              value
            });
          }
        });
        var adapters = {
          getAdapter: adapters => {
            adapters = utils.isArray(adapters) ? adapters : [adapters];
            var _adapters = adapters,
              length = _adapters.length;
            var nameOrAdapter;
            var adapter;
            for (var i = 0; i < length; i++) {
              nameOrAdapter = adapters[i];
              if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
                break;
              }
            }
            if (!adapter) {
              if (adapter === false) {
                throw new AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, 'ERR_NOT_SUPPORT');
              }
              throw new Error(utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
            }
            if (!utils.isFunction(adapter)) {
              throw new TypeError('adapter is not a function');
            }
            return adapter;
          },
          adapters: knownAdapters
        };

        /**
         * Throws a `CanceledError` if cancellation has been requested.
         *
         * @param {Object} config The config that is to be used for the request
         *
         * @returns {void}
         */
        function throwIfCancellationRequested(config) {
          if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
          }
          if (config.signal && config.signal.aborted) {
            throw new CanceledError(null, config);
          }
        }

        /**
         * Dispatch a request to the server using the configured adapter.
         *
         * @param {object} config The config that is to be used for the request
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        function dispatchRequest(config) {
          throwIfCancellationRequested(config);
          config.headers = AxiosHeaders$1.from(config.headers);

          // Transform request data
          config.data = transformData.call(config, config.transformRequest);
          if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
            config.headers.setContentType('application/x-www-form-urlencoded', false);
          }
          var adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
          return adapter(config).then(function onAdapterResolution(response) {
            throwIfCancellationRequested(config);

            // Transform response data
            response.data = transformData.call(config, config.transformResponse, response);
            response.headers = AxiosHeaders$1.from(response.headers);
            return response;
          }, function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);

              // Transform response data
              if (reason && reason.response) {
                reason.response.data = transformData.call(config, config.transformResponse, reason.response);
                reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
              }
            }
            return Promise.reject(reason);
          });
        }
        var headersToObject = thing => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

        /**
         * Config-specific merge-function which creates a new config-object
         * by merging two configuration objects together.
         *
         * @param {Object} config1
         * @param {Object} config2
         *
         * @returns {Object} New object resulting from merging config2 to config1
         */
        function mergeConfig(config1, config2) {
          // eslint-disable-next-line no-param-reassign
          config2 = config2 || {};
          var config = {};
          function getMergedValue(target, source, caseless) {
            if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
              return utils.merge.call({
                caseless
              }, target, source);
            } else if (utils.isPlainObject(source)) {
              return utils.merge({}, source);
            } else if (utils.isArray(source)) {
              return source.slice();
            }
            return source;
          }

          // eslint-disable-next-line consistent-return
          function mergeDeepProperties(a, b, caseless) {
            if (!utils.isUndefined(b)) {
              return getMergedValue(a, b, caseless);
            } else if (!utils.isUndefined(a)) {
              return getMergedValue(undefined, a, caseless);
            }
          }

          // eslint-disable-next-line consistent-return
          function valueFromConfig2(a, b) {
            if (!utils.isUndefined(b)) {
              return getMergedValue(undefined, b);
            }
          }

          // eslint-disable-next-line consistent-return
          function defaultToConfig2(a, b) {
            if (!utils.isUndefined(b)) {
              return getMergedValue(undefined, b);
            } else if (!utils.isUndefined(a)) {
              return getMergedValue(undefined, a);
            }
          }

          // eslint-disable-next-line consistent-return
          function mergeDirectKeys(a, b, prop) {
            if (prop in config2) {
              return getMergedValue(a, b);
            } else if (prop in config1) {
              return getMergedValue(undefined, a);
            }
          }
          var mergeMap = {
            url: valueFromConfig2,
            method: valueFromConfig2,
            data: valueFromConfig2,
            baseURL: defaultToConfig2,
            transformRequest: defaultToConfig2,
            transformResponse: defaultToConfig2,
            paramsSerializer: defaultToConfig2,
            timeout: defaultToConfig2,
            timeoutMessage: defaultToConfig2,
            withCredentials: defaultToConfig2,
            adapter: defaultToConfig2,
            responseType: defaultToConfig2,
            xsrfCookieName: defaultToConfig2,
            xsrfHeaderName: defaultToConfig2,
            onUploadProgress: defaultToConfig2,
            onDownloadProgress: defaultToConfig2,
            decompress: defaultToConfig2,
            maxContentLength: defaultToConfig2,
            maxBodyLength: defaultToConfig2,
            beforeRedirect: defaultToConfig2,
            transport: defaultToConfig2,
            httpAgent: defaultToConfig2,
            httpsAgent: defaultToConfig2,
            cancelToken: defaultToConfig2,
            socketPath: defaultToConfig2,
            responseEncoding: defaultToConfig2,
            validateStatus: mergeDirectKeys,
            headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
          };
          utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
            var merge = mergeMap[prop] || mergeDeepProperties;
            var configValue = merge(config1[prop], config2[prop], prop);
            utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
          });
          return config;
        }
        var VERSION = "1.3.4";
        var validators$1 = {};

        // eslint-disable-next-line func-names
        ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
          validators$1[type] = function validator(thing) {
            return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
          };
        });
        var deprecatedWarnings = {};

        /**
         * Transitional option validator
         *
         * @param {function|boolean?} validator - set to false if the transitional option has been removed
         * @param {string?} version - deprecated version / removed since version
         * @param {string?} message - some message with additional info
         *
         * @returns {function}
         */
        validators$1.transitional = function transitional(validator, version, message) {
          function formatMessage(opt, desc) {
            return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
          }

          // eslint-disable-next-line func-names
          return (value, opt, opts) => {
            if (validator === false) {
              throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
            }
            if (version && !deprecatedWarnings[opt]) {
              deprecatedWarnings[opt] = true;
              // eslint-disable-next-line no-console
              console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
            }
            return validator ? validator(value, opt, opts) : true;
          };
        };

        /**
         * Assert object's properties type
         *
         * @param {object} options
         * @param {object} schema
         * @param {boolean?} allowUnknown
         *
         * @returns {object}
         */

        function assertOptions(options, schema, allowUnknown) {
          if (typeof options !== 'object') {
            throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
          }
          var keys = Object.keys(options);
          var i = keys.length;
          while (i-- > 0) {
            var opt = keys[i];
            var _validator = schema[opt];
            if (_validator) {
              var value = options[opt];
              var result = value === undefined || _validator(value, opt, options);
              if (result !== true) {
                throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
              }
              continue;
            }
            if (allowUnknown !== true) {
              throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
            }
          }
        }
        var validator = {
          assertOptions,
          validators: validators$1
        };
        var validators = validator.validators;

        /**
         * Create a new instance of Axios
         *
         * @param {Object} instanceConfig The default config for the instance
         *
         * @return {Axios} A new instance of Axios
         */
        class Axios {
          constructor(instanceConfig) {
            this.defaults = instanceConfig;
            this.interceptors = {
              request: new InterceptorManager$1(),
              response: new InterceptorManager$1()
            };
          }

          /**
           * Dispatch a request
           *
           * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
           * @param {?Object} config
           *
           * @returns {Promise} The Promise to be fulfilled
           */
          request(configOrUrl, config) {
            /*eslint no-param-reassign:0*/
            // Allow for axios('example/url'[, config]) a la fetch API
            if (typeof configOrUrl === 'string') {
              config = config || {};
              config.url = configOrUrl;
            } else {
              config = configOrUrl || {};
            }
            config = mergeConfig(this.defaults, config);
            var _config = config,
              transitional = _config.transitional,
              paramsSerializer = _config.paramsSerializer,
              headers = _config.headers;
            if (transitional !== undefined) {
              validator.assertOptions(transitional, {
                silentJSONParsing: validators.transitional(validators.boolean),
                forcedJSONParsing: validators.transitional(validators.boolean),
                clarifyTimeoutError: validators.transitional(validators.boolean)
              }, false);
            }
            if (paramsSerializer !== undefined) {
              validator.assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
              }, true);
            }

            // Set config.method
            config.method = (config.method || this.defaults.method || 'get').toLowerCase();
            var contextHeaders;

            // Flatten headers
            contextHeaders = headers && utils.merge(headers.common, headers[config.method]);
            contextHeaders && utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
              delete headers[method];
            });
            config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

            // filter out skipped interceptors
            var requestInterceptorChain = [];
            var synchronousRequestInterceptors = true;
            this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
              if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
                return;
              }
              synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
              requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
            });
            var responseInterceptorChain = [];
            this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
              responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
            });
            var promise;
            var i = 0;
            var len;
            if (!synchronousRequestInterceptors) {
              var chain = [dispatchRequest.bind(this), undefined];
              chain.unshift.apply(chain, requestInterceptorChain);
              chain.push.apply(chain, responseInterceptorChain);
              len = chain.length;
              promise = Promise.resolve(config);
              while (i < len) {
                promise = promise.then(chain[i++], chain[i++]);
              }
              return promise;
            }
            len = requestInterceptorChain.length;
            var newConfig = config;
            i = 0;
            while (i < len) {
              var onFulfilled = requestInterceptorChain[i++];
              var onRejected = requestInterceptorChain[i++];
              try {
                newConfig = onFulfilled(newConfig);
              } catch (error) {
                onRejected.call(this, error);
                break;
              }
            }
            try {
              promise = dispatchRequest.call(this, newConfig);
            } catch (error) {
              return Promise.reject(error);
            }
            i = 0;
            len = responseInterceptorChain.length;
            while (i < len) {
              promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
            }
            return promise;
          }
          getUri(config) {
            config = mergeConfig(this.defaults, config);
            var fullPath = buildFullPath(config.baseURL, config.url);
            return buildURL(fullPath, config.params, config.paramsSerializer);
          }
        }

        // Provide aliases for supported request methods
        utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, config) {
            return this.request(mergeConfig(config || {}, {
              method,
              url,
              data: (config || {}).data
            }));
          };
        });
        utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          /*eslint func-names:0*/

          function generateHTTPMethod(isForm) {
            return function httpMethod(url, data, config) {
              return this.request(mergeConfig(config || {}, {
                method,
                headers: isForm ? {
                  'Content-Type': 'multipart/form-data'
                } : {},
                url,
                data
              }));
            };
          }
          Axios.prototype[method] = generateHTTPMethod();
          Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
        });
        var Axios$1 = Axios;

        /**
         * A `CancelToken` is an object that can be used to request cancellation of an operation.
         *
         * @param {Function} executor The executor function.
         *
         * @returns {CancelToken}
         */
        class CancelToken {
          constructor(executor) {
            if (typeof executor !== 'function') {
              throw new TypeError('executor must be a function.');
            }
            var resolvePromise;
            this.promise = new Promise(function promiseExecutor(resolve) {
              resolvePromise = resolve;
            });
            var token = this;

            // eslint-disable-next-line func-names
            this.promise.then(cancel => {
              if (!token._listeners) return;
              var i = token._listeners.length;
              while (i-- > 0) {
                token._listeners[i](cancel);
              }
              token._listeners = null;
            });

            // eslint-disable-next-line func-names
            this.promise.then = onfulfilled => {
              var _resolve;
              // eslint-disable-next-line func-names
              var promise = new Promise(resolve => {
                token.subscribe(resolve);
                _resolve = resolve;
              }).then(onfulfilled);
              promise.cancel = function reject() {
                token.unsubscribe(_resolve);
              };
              return promise;
            };
            executor(function cancel(message, config, request) {
              if (token.reason) {
                // Cancellation has already been requested
                return;
              }
              token.reason = new CanceledError(message, config, request);
              resolvePromise(token.reason);
            });
          }

          /**
           * Throws a `CanceledError` if cancellation has been requested.
           */
          throwIfRequested() {
            if (this.reason) {
              throw this.reason;
            }
          }

          /**
           * Subscribe to the cancel signal
           */

          subscribe(listener) {
            if (this.reason) {
              listener(this.reason);
              return;
            }
            if (this._listeners) {
              this._listeners.push(listener);
            } else {
              this._listeners = [listener];
            }
          }

          /**
           * Unsubscribe from the cancel signal
           */

          unsubscribe(listener) {
            if (!this._listeners) {
              return;
            }
            var index = this._listeners.indexOf(listener);
            if (index !== -1) {
              this._listeners.splice(index, 1);
            }
          }

          /**
           * Returns an object that contains a new `CancelToken` and a function that, when called,
           * cancels the `CancelToken`.
           */
          static source() {
            var cancel;
            var token = new CancelToken(function executor(c) {
              cancel = c;
            });
            return {
              token,
              cancel
            };
          }
        }
        var CancelToken$1 = CancelToken;

        /**
         * Syntactic sugar for invoking a function and expanding an array for arguments.
         *
         * Common use case would be to use `Function.prototype.apply`.
         *
         *  ```js
         *  function f(x, y, z) {}
         *  var args = [1, 2, 3];
         *  f.apply(null, args);
         *  ```
         *
         * With `spread` this example can be re-written.
         *
         *  ```js
         *  spread(function(x, y, z) {})([1, 2, 3]);
         *  ```
         *
         * @param {Function} callback
         *
         * @returns {Function}
         */
        function spread(callback) {
          return function wrap(arr) {
            return callback.apply(null, arr);
          };
        }

        /**
         * Determines whether the payload is an error thrown by Axios
         *
         * @param {*} payload The value to test
         *
         * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
         */
        function isAxiosError(payload) {
          return utils.isObject(payload) && payload.isAxiosError === true;
        }
        var HttpStatusCode = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511
        };
        Object.entries(HttpStatusCode).forEach(_ref36 => {
          var _ref37 = _slicedToArray(_ref36, 2),
            key = _ref37[0],
            value = _ref37[1];
          HttpStatusCode[value] = key;
        });
        var HttpStatusCode$1 = HttpStatusCode;

        /**
         * Create an instance of Axios
         *
         * @param {Object} defaultConfig The default config for the instance
         *
         * @returns {Axios} A new instance of Axios
         */
        function createInstance(defaultConfig) {
          var context = new Axios$1(defaultConfig);
          var instance = bind(Axios$1.prototype.request, context);

          // Copy axios.prototype to instance
          utils.extend(instance, Axios$1.prototype, context, {
            allOwnKeys: true
          });

          // Copy context to instance
          utils.extend(instance, context, null, {
            allOwnKeys: true
          });

          // Factory for creating new instances
          instance.create = function create(instanceConfig) {
            return createInstance(mergeConfig(defaultConfig, instanceConfig));
          };
          return instance;
        }

        // Create the default instance to be exported
        var axios = createInstance(defaults$1);

        // Expose Axios class to allow class inheritance
        axios.Axios = Axios$1;

        // Expose Cancel & CancelToken
        axios.CanceledError = CanceledError;
        axios.CancelToken = CancelToken$1;
        axios.isCancel = isCancel;
        axios.VERSION = VERSION;
        axios.toFormData = toFormData;

        // Expose AxiosError class
        axios.AxiosError = AxiosError;

        // alias for CanceledError for backward compatibility
        axios.Cancel = axios.CanceledError;

        // Expose all/spread
        axios.all = function all(promises) {
          return Promise.all(promises);
        };
        axios.spread = spread;

        // Expose isAxiosError
        axios.isAxiosError = isAxiosError;

        // Expose mergeConfig
        axios.mergeConfig = mergeConfig;
        axios.AxiosHeaders = AxiosHeaders$1;
        axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
        axios.HttpStatusCode = HttpStatusCode$1;
        axios.default = axios;

        // this module should only have a default export
        var axios$1 = axios;
        class AxiosRequester {
          constructor() {
            // static endpoint for POC
            this.AxiosAPI = axios$1.create({
              baseURL: "https://api-entertainment.enlight.diagnal.com/v1b3/content"
            });
          }
          /**
           * Generic funciton used to handle the API request to the server.
           * This function takes one parameter as input and has two returns
           * 
           * @param uri, @type string,  @desc this is the uri from which the data has to be fetched.
           * 
           * @return response, @type AxiosResponse<any> | undefined, @desc This Axiosresponse object, this will return the data fetched if successful.
           * @return error,  @type  AxiosError<any> | undefined, @desc THis error object, this will return error on failure.
           * 
           */
          fetch(uri) {
            var _this4 = this;
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
              var response;
              return _regeneratorRuntime().wrap(function _callee7$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.prev = 0;
                    _context9.next = 3;
                    return _this4.AxiosAPI.get(uri);
                  case 3:
                    response = _context9.sent;
                    return _context9.abrupt("return", [response, void 0]);
                  case 7:
                    _context9.prev = 7;
                    _context9.t0 = _context9["catch"](0);
                    return _context9.abrupt("return", [void 0, _context9.t0]);
                  case 10:
                  case "end":
                    return _context9.stop();
                }
              }, _callee7, null, [[0, 7]]);
            }))();
          }
        }
        class Rail extends lightning.Component {
          constructor() {
            super(...arguments);
            this.index = -1;
            this.dataLength = 0;
            this.railIndex = 0;
            this.axiosRequester = new AxiosRequester();
            this.responseData = {};
            this.data = [];
            this.Wrapper = this.tag("Slider.Wrapper");
          }
          /**
          * This function is responsible for the creation and return of the UI template. This
          * function takes  no parameters and returns the template of the Rail component.
          *
          * @returns Template for the Rail Component.
          *
          */
          static _template() {
            return {
              Header: {
                x: 50,
                y: 20,
                color: theme.colors.white,
                text: {
                  text: "",
                  fontSize: 35
                  // fontFace: "Saira Regular",
                  // fontStyle: "600",
                }
              },

              Slider: {
                w: 1920,
                h: 400,
                y: 105,
                mount: 0,
                rect: true,
                clipping: true,
                color: Colors("transparent").get(),
                Wrapper: {
                  x: 80
                }
              }
            };
          }
          /**
          * This function is responsible for setting up the initial states of the component when
          * attached for the first time. This function takes  no parameters and has no return.
          */
          _init() {
            var rail = [];
            if (this.railIndex < endp.length) {
              this.axiosRequester.fetch(endp[this.railIndex]).then(response => {
                if (response) {
                  var _response$;
                  this.responseData = (_response$ = response[0]) === null || _response$ === void 0 ? void 0 : _response$.data;
                  this.dataLength = this.responseData.totalElements || 0;
                  this.data = this.responseData.content || [];
                  for (var i = 0; i < this.dataLength; i++) {
                    var _this$data$i, _this$data$i$images$f, _this$data$i3, _this$data$i4;
                    var cardSize = cardSizes.regular;
                    var img_src = (_this$data$i = this.data[i]) === null || _this$data$i === void 0 ? void 0 : (_this$data$i$images$f = _this$data$i.images.find(img => img.width === 288)) === null || _this$data$i$images$f === void 0 ? void 0 : _this$data$i$images$f.url;
                    if (this.dataLength === 10 || this.dataLength === 31) {
                      var _this$data$i2, _this$data$i2$images$;
                      cardSize = cardSizes.wide;
                      img_src = (_this$data$i2 = this.data[i]) === null || _this$data$i2 === void 0 ? void 0 : (_this$data$i2$images$ = _this$data$i2.images.find(img => img.width === 526)) === null || _this$data$i2$images$ === void 0 ? void 0 : _this$data$i2$images$.url;
                    }
                    var label = (_this$data$i3 = this.data[i]) === null || _this$data$i3 === void 0 ? void 0 : _this$data$i3.title;
                    console.log((_this$data$i4 = this.data[i]) === null || _this$data$i4 === void 0 ? void 0 : _this$data$i4.images);
                    var cardWidthIncludingMargin = cardSize.w + cardSize.margin;
                    rail.push({
                      type: RailItem,
                      x: i * cardWidthIncludingMargin,
                      item: {
                        label,
                        src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg",
                        data: this.data[i],
                        index: i,
                        totalElements: this.dataLength,
                        cardSize,
                        railIndex: this.railIndex
                      }
                    });
                  }
                }
                this.patch({
                  Header: {
                    text: railName[this.railIndex]
                  }
                });
                this.tag("Wrapper").children = rail;
                this.index = 0;
                this._setState("RowItem");
              });
            } else {
              this.setLongRail();
            }
          }
          setLongRail() {
            var _this5 = this;
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
              var rail, i, _this5$data$i, _this5$data$i2, _this5$data$i2$images, label, img_src;
              return _regeneratorRuntime().wrap(function _callee8$(_context10) {
                while (1) switch (_context10.prev = _context10.next) {
                  case 0:
                    console.log("je");
                    _context10.next = 3;
                    return Storage.get("longData");
                  case 3:
                    _this5.data = _context10.sent;
                    _this5.dataLength = _this5.data.length;
                    console.log(_this5.data.length);
                    rail = [];
                    for (i = 0; i < _this5.dataLength; i++) {
                      label = (_this5$data$i = _this5.data[i]) === null || _this5$data$i === void 0 ? void 0 : _this5$data$i.title;
                      img_src = (_this5$data$i2 = _this5.data[i]) === null || _this5$data$i2 === void 0 ? void 0 : (_this5$data$i2$images = _this5$data$i2.images.find(img => img.width === 288)) === null || _this5$data$i2$images === void 0 ? void 0 : _this5$data$i2$images.url;
                      rail.push({
                        type: RailItem,
                        x: i * (216 + 30),
                        item: {
                          label,
                          src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg",
                          data: _this5.data[i]
                        }
                      });
                    }
                    _this5.patch({
                      Header: {
                        text: railName[_this5.railIndex]
                      }
                    });
                    _this5.tag("Wrapper").children = rail;
                    _this5.index = 0;
                  case 11:
                  case "end":
                    return _context10.stop();
                }
              }, _callee8);
            }))();
          }
          /**
           * To repostion the wrapper on the focused element. Function does not take any parameters
           * nor has any return.
           */
          repositionWrapper() {
            var wrapper = this.tag("Wrapper");
            var currentFocus = wrapper.children[this.index];
            var cardSize = currentFocus.cardSize;
            if (this.index < this.dataLength - (cardSize.minimumCardsInViewport - 1)) {
              wrapper.setSmooth("x", -(cardSize.w + cardSize.margin) * this.index + 80, {
                duration: 0.1
              });
            }
          }
          /**
           * This function overrides the default behaviour of keypress 'Left'.
           * This functions checks the index to see the focused element and decides
           * wheather if it should move to the left or not. And then it will reposition
           * the wrapper.
           */
          _handleLeft() {
            if (this.index > 0) {
              this.index -= 1;
              this.repositionWrapper();
            }
          }
          /**
           * This function overrides the default behaviour of keypress 'Right'.
           * This functions checks the index to see the focused element and decides
           * wheather if it should move to the right or not. And then it will reposition
           * the wrapper.
           */
          _handleRight() {
            if (this.index < this.dataLength - 1) {
              this.index += 1;
              this.repositionWrapper();
            }
          }
          /**
           * This function will override the default behavior of the getFocused() method
           *
           * @returns Return the child Component that this Component wishes to receive focus. Returning null
           * or undefined tells the focus engine to not set focus on this Component at all.By default,
           * this Component's own instance is returned.
           */
          // override _getFocused(): any {
          //     return this.tag('Slider.Wrapper' as any).children[this.index];
          // }
          _getFocused() {
            return this.tag("Slider.Wrapper").children[this.index];
          }
        }
        class NavTextItem extends lightning.Component {
          /**
           * This function is responsible for the creation and return of the UI template. This
           * function takes  no parameters and returns the template of the component.
           *
           * @returns Template for the Component.
           *
           */
          static _template() {
            return {
              NavText: {
                w: 120,
                color: theme.colors.accentGrey.light,
                text: {
                  fontSize: 35
                }
              }
            };
          }
          /**
           * Setter for setting the values for the item property.
           *
           * @Param The value that needs to be setted to the item property.
           *
           */
          set navtext(text) {
            this.patch({
              NavText: {
                text: text === null || text === void 0 ? void 0 : text.toString()
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.patch({
              smooth: {
                scale: 1.1
              },
              NavText: {
                smooth: {
                  color: theme.colors.white
                }
              },
              Rectangle: {
                color: theme.colors.yellow,
                x: 2,
                y: _y2 => _y2 + 50,
                w: 100,
                h: 5,
                rect: true
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.patch({
              smooth: {
                color: theme.colors.primary,
                scale: 1
              },
              NavText: {
                smooth: {
                  color: theme.colors.accentGrey.light
                }
              },
              Rectangle: void 0
            });
          }
        }
        class NavProfileItem extends lightning.Component {
          /**
           * This function is responsible for the creation and return of the UI template. This
           * function takes  no parameters and returns the template of the component.
           *
           * @returns Template for the Component.
           *
           */
          static _template() {
            return {
              w: 50,
              h: 50,
              src: "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/808/289/5qtySjfuJfOLvVrVXuwNo2BIVPH.jpg",
              shader: {
                type: lightning.shaders.RoundedRectangle,
                radius: 10,
                stroke: 5,
                strokeColor: theme.colors.white
              }
            };
          }
          /**
           * Setter for setting the values for the item property.
           *
           * @Param The value that needs to be setted to the item property.
           *
           */
          set navtext(text) {
            this.patch({
              NavText: {
                text: text === null || text === void 0 ? void 0 : text.toString()
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.patch({
              smooth: {
                scale: 1.1
              },
              shader: {
                strokeColor: theme.colors.yellow
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.patch({
              smooth: {
                scale: 1
              },
              shader: {
                strokeColor: theme.colors.white
              }
            });
          }
        }
        class TopNav extends lightning.Component {
          constructor() {
            super(...arguments);
            this.index = 0;
          }
          static _template() {
            return {
              Navbar: {
                w: 1920,
                h: 1080,
                rect: true,
                zIndex: 1,
                shader: {
                  x: 100,
                  y: -100,
                  pivot: 0.5,
                  type: lightning.shaders.RadialGradient,
                  outerColor: theme.colors.primaryLight,
                  innerColor: theme.colors.dark,
                  radius: 800
                },
                NavItems: {
                  x: 10,
                  y: 10,
                  NavMenu: {
                    shader: null
                  }
                }
              }
            };
          }
          /**
          * This function is responsible for setting up the initial states of the component when
          * attached for the first time. This function takes  no parameters and has no return.
          */
          _init() {
            var _this$tag;
            var menus = {
              Home: {
                type: NavTextItem,
                x: 20,
                y: 12,
                navtext: "Home"
              },
              Search: {
                type: NavTextItem,
                x: 140,
                y: 12,
                navtext: "Search"
              },
              Gridlayout: {
                type: NavTextItem,
                x: 280,
                y: 12,
                navtext: "Grids"
              },
              Profile: {
                x: 1840,
                y: 15,
                type: NavProfileItem
              }
              // Exit: {
              //     type: NavTextItem,
              //     x: (x: number) => x - 100, y: 20,
              //     navtext: "Exit"
              // }
            };

            this.tag("Navbar.NavItems.NavMenu").children = menus;
            (_this$tag = this.tag("Navbar")) === null || _this$tag === void 0 ? void 0 : _this$tag.animation({
              duration: 8,
              repeat: -1,
              delay: 2,
              actions: [{
                p: "shader.radius",
                v: {
                  0: {
                    v: 800
                  },
                  0.5: {
                    v: 400
                  },
                  1: {
                    v: 800
                  }
                }
              }]
            }).start();
          }
          /**
           * This function overrides the default behaviour of keypress 'Left'.
           * This functions checks the index to see the focused element and decides
           * wheather if it should move to the left or not. 
           */
          _handleLeft() {
            if (this.index > 0) {
              this.index -= 1;
            }
          }
          /**
           * This function overrides the default behaviour of keypress 'Right'.
           * This functions checks the index to see the focused element and decides
           * wheather if it should move to the right or not.
           */
          _handleRight() {
            if (this.index < 3) {
              this.index += 1;
            }
          }
          /**
          * This function overrides the default behaviour of keypress 'Enter'.
          * This functions checks the index to see the focused element and decides
          * the route to navigate.
          */
          _handleEnter() {
            if (this.index === 0) {
              Router.navigate("home");
            } else if (this.index === 1) {
              Router.navigate("search");
            } else if (this.index === 2) {
              Router.navigate("grid");
            } else {
              Router.navigate("settings");
            }
          }
          _getFocused() {
            return this.tag("Navbar.NavItems.NavMenu").children[this.index];
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {}
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.index = 0;
          }
        }
        class BackButton extends lightning.Component {
          static _template() {
            return {
              Back: {
                w: 80,
                color: theme.colors.accentGrey.light,
                text: {
                  text: "Back",
                  fontSize: 35
                }
              }
            };
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.patch({
              smooth: {
                scale: 1.1
              },
              Back: {
                smooth: {
                  color: theme.colors.white
                }
              },
              Rectangle: {
                color: theme.colors.yellow,
                x: 2,
                y: _y3 => _y3 + 50,
                w: 80,
                h: 5,
                rect: true
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.patch({
              smooth: {
                color: theme.colors.primary,
                scale: 1
              },
              Back: {
                smooth: {
                  color: theme.colors.accentGrey.light
                }
              },
              Rectangle: void 0
            });
          }
        }
        class PlayPauseButton extends lightning.Component {
          constructor() {
            super(...arguments);
            this._isPlaying = false;
          }
          static _template() {
            return {
              mount: 0.5,
              x: 1920 / 2,
              y: 1080 / 2,
              rect: true,
              w: 150,
              h: 150,
              color: 0,
              Background: {
                rect: true,
                w: 150,
                h: 150,
                color: 4289440683,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 75
                }
              },
              Text: {
                mount: 0.5,
                x: 75,
                y: 75,
                text: {
                  textColor: 4294967295,
                  text: "Pause"
                }
              }
            };
          }
          _setup() {
            this._isPlaying = true;
          }
          set isPlaying(isPlaying) {
            this._isPlaying = isPlaying;
            this.tag("Text").patch({
              text: {
                text: isPlaying ? "Pause" : "Play"
              }
            });
          }
          get isPlaying() {
            return this._isPlaying;
          }
        }
        class Button extends lightning.Component {
          static _template() {
            return {
              Button: {
                w: 500,
                h: 100,
                color: 0,
                rect: true,
                shader: {
                  type: lightning.shaders.RadialGradient,
                  innerColor: theme.colors.accentGrey.dark
                },
                Label: {
                  shader: null,
                  h: _h12 => _h12,
                  text: {
                    fontSize: 35,
                    textColor: theme.colors.white,
                    textAlign: "left",
                    textIndent: 20,
                    textBaseline: "hanging"
                  }
                }
              }
            };
          }
          set label(text) {
            this.patch({
              Button: {
                Label: {
                  text
                }
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.patch({
              smooth: {
                scale: 1.1
              },
              Button: {
                shader: {
                  innerColor: 2868042585
                },
                Label: {
                  text: {
                    textColor: theme.colors.white
                  }
                }
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.patch({
              smooth: {
                scale: 1
              },
              Button: {
                shader: {
                  innerColor: theme.colors.accentGrey.dark
                }
              }
            });
          }
        }
        class PreviewComponent extends lightning.Component {
          constructor() {
            super(...arguments);
            this.firstActive = true;
            this.Thumbnail = this.tag("ContentView.Thumbnail");
            this.ContentDetails = this.tag("ContentView.ContentDetails");
          }
          static _template() {
            return {
              ContentView: {
                // alpha: 0,
                Thumbnail: {
                  alpha: 0,
                  x: 1e3,
                  y: 110,
                  scale: 1.5,
                  shader: {
                    type: lightning.shaders.FadeOut,
                    innerColor: theme.colors.black,
                    left: 200,
                    bottom: 200
                  }
                },
                ContentDetails: {
                  ContentData: {
                    // alpha: 0,
                    shader: null,
                    zIndex: 2,
                    Title: {
                      x: 40,
                      y: 165,
                      shader: null,
                      text: {
                        fontSize: 80,
                        fontFace: "Saira Regular",
                        fontStyle: "600"
                      },
                      color: theme.colors.white
                    },
                    Description: {
                      x: 40,
                      y: 270,
                      w: 900,
                      shader: null,
                      text: {
                        wordWrap: true,
                        maxLines: 3,
                        maxLinesSuffix: "...",
                        fontSize: 30
                        // fontFace: "Saira Regular",
                        // fontStyle: "400",
                      },

                      color: theme.colors.accentGrey.light
                    },
                    Genre: {
                      x: 40,
                      y: 380,
                      w: 900,
                      shader: null,
                      text: {
                        fontSize: 24
                        // fontFace: "Saira Regular",
                        // fontStyle: "400",
                      },

                      color: theme.colors.accentGrey.light
                    },
                    Info: {
                      visible: false,
                      Director: {
                        x: 40,
                        y: 440,
                        w: 100,
                        shader: null,
                        text: {
                          text: "Director : ",
                          fontSize: 24
                          // fontFace: "Saira Regular",
                          // fontStyle: "600",
                        },

                        color: theme.colors.accentGrey.light
                      },
                      Starring: {
                        x: 40,
                        y: 470,
                        w: 100,
                        shader: null,
                        text: {
                          text: "Staring  : ",
                          fontSize: 24
                          // fontFace: "Saira Regular",
                          // fontStyle: "600",
                        },

                        color: theme.colors.accentGrey.light
                      },
                      DirectorList: {
                        x: 150,
                        y: 440,
                        w: 800,
                        shader: null,
                        text: {
                          fontSize: 24
                        },
                        color: theme.colors.accentGrey.light
                      },
                      StarringList: {
                        x: 150,
                        y: 470,
                        w: 800,
                        shader: null,
                        text: {
                          fontSize: 24,
                          wordWrap: true,
                          maxLines: 1,
                          maxLinesSuffix: "..."
                        },
                        color: theme.colors.accentGrey.light
                      }
                    },
                    VideoSpec: {
                      visible: false,
                      VideoSpec1: {
                        x: 70,
                        y: 140,
                        shader: null,
                        type: VideoSpecItem,
                        specData: "  16+  "
                      },
                      VideoSpec2: {
                        x: 135,
                        y: 140,
                        shader: null,
                        type: VideoSpecItem,
                        specData: "  4k  "
                      },
                      VideoSpec3: {
                        x: 193,
                        y: 140,
                        shader: null,
                        type: VideoSpecItem,
                        specData: "  cc  "
                      }
                    }
                  }
                }
              }
            };
          }
          set data(eventDetails) {
            console.log(eventDetails);
            var imgSrc = eventDetails.imgSrc,
              title = eventDetails.title,
              description = eventDetails.description,
              genre = eventDetails.genre,
              directorsList = eventDetails.directorsList,
              actorsList = eventDetails.actorsList;
            this.tag("ContentView.Thumbnail").patch({
              smooth: {
                src: imgSrc
              }
            });
            this.tag("ContentView.Thumbnail").transition("src").on("finish", () => {
              this.tag("ContentView.Thumbnail").setSmooth("alpha", 1, {
                duration: 0.5
              });
            });
            this.tag("ContentView.Thumbnail").transition("src").on("finish", () => {
              this.tag("ContentView.Thumbnail").setSmooth("alpha", 1, {
                duration: 0.5
              });
            });
            var contentAnimation = this.tag("ContentView.ContentDetails").animation({
              duration: 0.5,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 0,
                  0.8: 0,
                  1: 1
                }
              }, {
                p: "x",
                v: {
                  0: 10,
                  0.6: -100,
                  0.65: 10
                }
              }, {
                p: "y",
                v: {
                  0: 0,
                  0.6: 0,
                  0.65: -30,
                  1: 0
                }
              }]
            });
            this.patch({
              ContentView: {
                shader: {
                  type: lightning.shaders.RadialGradient,
                  x: 300,
                  y: 300,
                  innerColor: 4278190080,
                  radius: 1500
                },
                ContentDetails: {
                  x: 10,
                  ContentData: {
                    Title: {
                      text: {
                        text: title
                      }
                    },
                    Description: {
                      text: {
                        text: description
                      }
                    },
                    Genre: {
                      text: {
                        text: genre
                      }
                    },
                    Info: {
                      visible: true,
                      DirectorList: {
                        text: {
                          text: directorsList
                        }
                      },
                      StarringList: {
                        text: {
                          text: actorsList
                        }
                      }
                    },
                    VideoSpec: {
                      visible: true
                    }
                  }
                }
              }
            });
            if (this.firstActive) {
              this.firstActive = false;
              this.tag("ContentView.ContentDetails").animation({
                duration: 1,
                delay: 0,
                repeat: 0,
                actions: [{
                  p: "alpha",
                  v: {
                    0: 0,
                    1: 1
                  }
                }, {
                  p: "y",
                  v: {
                    0: -30,
                    1: 0
                  }
                }]
              }).start();
              return;
            }
            contentAnimation.start();
          }
          // Animate on Navigation to details page (invoked from pageTransitionOut of home page )
          animate() {
            this.tag("ContentView.ContentDetails").animation({
              duration: 2,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 1,
                  0.5: 0
                }
              }, {
                p: "y",
                v: {
                  0: 0,
                  0.5: -30,
                  1: 0
                }
              }]
            }).start();
          }
          _init() {
            this.tag("ContentView.Thumbnail").on("txError", () => {
              console.error("texture failed to load: " + this.tag("ContentView.Thumbnail").src);
            });
          }
        }
        class FocusBox extends lightning.Component {
          static _template() {
            return {
              Box: {
                x: 0,
                y: 0,
                w: 216,
                h: 324,
                rect: true,
                color: 0,
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 20
                }
              }
            };
          }
        }
        class Home extends lightning.Component {
          constructor() {
            super(...arguments);
            this.index = 0;
            this.rowLength = endp.length;
            this.hideNav = false;
            this.eventData = {};
            this.Wrapper = this.tag("Background.Slider.Wrapper");
          }
          /**
           * This function is responsible for the creation and return of the UI template. This function
           * takes  no parameters and returns the template.
           *
           * @returns Template for the Application
           *
           */
          static _template() {
            return {
              // Navbar: { type: TopNav },
              Background: {
                w: 1920,
                h: 1080,
                color: theme.colors.black,
                rect: true,
                Version: {
                  x: 50,
                  y: 25,
                  w: 100,
                  h: 100,
                  alpha: 0.3,
                  text: {
                    text: "V: 0.0.1",
                    fontSize: 20
                  }
                },
                Box: {
                  x: 80,
                  y: 665,
                  InnerBox: {
                    zIndex: 3,
                    rect: true,
                    shader: {
                      type: lightning.shaders.RoundedRectangle,
                      radius: 20,
                      stroke: 5,
                      strokeColor: theme.colors.yellow
                    },
                    color: Colors("transparent")
                  }
                },
                ContentDetails: {
                  type: PreviewComponent
                },
                Slider: {
                  zIndex: 2,
                  clipping: true,
                  color: Colors("transparent").get(),
                  w: 1920,
                  h: 540,
                  x: 1920,
                  y: 0,
                  mount: 1,
                  rect: true,
                  Wrapper: {}
                }
              }
            };
          }
          $changeItemOnFocus(data, cardData) {
            var _data$images$find, _this$tag2;
            var imgSrc = (_data$images$find = data.images.find(img => img.width === 828)) === null || _data$images$find === void 0 ? void 0 : _data$images$find.url;
            var title = data.title;
            var description = data.description;
            var genre = data.genre.join(" . ");
            var directorsList = data.director.map(a => a.personName).join(", ");
            var actorsList = data.actor.map(a => a.personName).join(", ");
            var railTotalElements = cardData.railTotalElements,
              cardIndex = cardData.cardIndex,
              cardSize = cardData.cardSize,
              railIndex = cardData.railIndex;
            var minimumCardsInViewport = cardSize.minimumCardsInViewport,
              w = cardSize.w,
              h = cardSize.h,
              margin = cardSize.margin;
            this.tag("Background.ContentDetails").Thumbnail.setSmooth("alpha", 0, {
              duration: 0.5
            });
            this.tag("Background.ContentDetails").ContentDetails.setSmooth("alpha", 0, {
              duration: 0.5
            });
            Registry.setTimeout(() => {
              if (railIndex === this.index && this.Wrapper.children[this.index].Wrapper.children[cardData.cardIndex].focused) {
                var previewItem = {
                  type: PreviewComponent,
                  data: {
                    imgSrc,
                    title,
                    description,
                    genre,
                    directorsList,
                    actorsList
                  }
                };
                this.tag("Background.ContentDetails").patch(previewItem);
              }
            }, 500);
            (_this$tag2 = this.tag("Box")) === null || _this$tag2 === void 0 ? void 0 : _this$tag2.patch({
              InnerBox: {
                w,
                h
                // shader: { w: cardData.cardWidth, h: cardData.cardHeight }
              }
            });

            var focusBox = this.tag("Box");
            if (cardIndex >= railTotalElements - (minimumCardsInViewport - 1)) {
              focusBox.setSmooth("x", (w + margin) * (minimumCardsInViewport - (railTotalElements - cardIndex)) + 80, {
                duration: 0.1
              });
            } else focusBox.setSmooth("x", 80, {
              duration: 0.1
            });
          }
          // initializing the component
          _init() {
            this.backgroundFetchAndSave();
            var rails = [];
            for (var i = 0; i < this.rowLength; i++) {
              rails.push({
                type: Rail,
                x: 0,
                y: i * (500 + 50),
                railIndex: i
              });
            }
            this.tag("Background.Slider.Wrapper").children = rails;
          }
          backgroundFetchAndSave() {
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
              var axiosRequester, longData, _i27, _endp, epoint;
              return _regeneratorRuntime().wrap(function _callee9$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    axiosRequester = new AxiosRequester();
                    longData = [];
                    _i27 = 0, _endp = endp;
                  case 3:
                    if (!(_i27 < _endp.length)) {
                      _context11.next = 10;
                      break;
                    }
                    epoint = _endp[_i27];
                    _context11.next = 7;
                    return axiosRequester.fetch(epoint).then(response => {
                      if (response) {
                        var _response$2;
                        var responseData = (_response$2 = response[0]) === null || _response$2 === void 0 ? void 0 : _response$2.data;
                        var data = (responseData === null || responseData === void 0 ? void 0 : responseData.content) || [];
                        longData = [...longData, ...data];
                      }
                    });
                  case 7:
                    _i27++;
                    _context11.next = 3;
                    break;
                  case 10:
                    _context11.next = 12;
                    return Storage.set("longData", longData);
                  case 12:
                  case "end":
                    return _context11.stop();
                }
              }, _callee9);
            }))();
          }
          repositionWrapper() {
            var wrapper = this.tag("Background.Slider.Wrapper");
            wrapper.setSmooth("y", (-540 - 10) * this.index, {
              duration: 0.1
            });
          }
          // adding animation on entering the page.
          _active() {
            var railInAnimation = this.tag("Background.Slider").animation({
              duration: 1,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                p: "y",
                v: {
                  0: 1400,
                  1: 1100
                }
              }]
            });
            var focusBorderInAnimation = this.tag("Background.Box").animation({
              duration: 1,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                p: "y",
                v: {
                  0: 965,
                  1: 665
                }
              }]
            });
            railInAnimation.start();
            focusBorderInAnimation.start();
          }
          // handling up button click
          _handleUp() {
            if (this.index > 0) {
              this.index -= 1;
              if (this.index >= 0) {
                this.repositionWrapper();
              }
            }
          }
          // handling down button click
          _handleDown() {
            if (this.index < this.rowLength - 1) {
              this.index += 1;
              this.repositionWrapper();
            }
          }
          /**
           * This function will override the default behavior of the getFocused() method
           *
           * @returns Return the child Component that this Component wishes to receive focus. Returning null
           * or undefined tells the focus engine to not set focus on this Component at all.By default,
           * this Component's own instance is returned.
           */
          _getFocused() {
            if (this.index <= 0) {
              this.patch({
                Navbar: {
                  visible: true
                }
              });
            } else {
              this.patch({
                Navbar: {
                  visible: false
                }
              });
            }
            if (this.index >= 0) {
              return this.tag("Background.Slider.Wrapper").children[this.index];
            } else {
              return this.tag("Navbar");
            }
          }
          // Animating the page transition
          pageTransitionOut(page) {
            return new Promise((resolve, reject) => {
              this.tag("Background.Slider").patch({
                smooth: {
                  y: [1300, {
                    duration: 1,
                    delay: 0,
                    timingFunction: "ease"
                  }],
                  alpha: 0
                }
              });
              this.tag("Background.Box").patch({
                smooth: {
                  y: [865, {
                    duration: 1,
                    delay: 0,
                    timingFunction: "ease"
                  }],
                  alpha: 0
                }
              });
              this.tag("Background.ContentDetails").animate();
              this.tag("Background.Slider").transition("y").on("finish", () => {
                resolve();
              });
            });
          }
        }
        class Search extends lightning.Component {
          constructor() {
            super(...arguments);
            this.index = 2;
            this.intervalSub = 0;
          }
          static _template() {
            return {
              w: 1920,
              h: 1080,
              color: theme.colors.primaryLight,
              rect: true,
              shader: {
                x: 100,
                y: -100,
                pivot: 0.5,
                type: lightning.shaders.RadialGradient,
                outerColor: theme.colors.primaryLight,
                innerColor: theme.colors.dark,
                radius: 800
              },
              SearchComponent: {
                x: 40,
                y: 40,
                shader: null,
                SearchBox: {
                  x: 0,
                  y: 60,
                  w: 950,
                  h: 60,
                  rect: true,
                  color: theme.colors.accentGrey.light,
                  shader: {
                    type: lightning.shaders.RoundedRectangle,
                    radius: 30
                  },
                  InputWrapper: {
                    x: 20,
                    color: theme.colors.dark,
                    InputField: {
                      y: 20,
                      type: InputField
                    }
                  }
                },
                BackButton: {
                  type: BackButton
                },
                Keyboard: {
                  x: 0,
                  y: 140,
                  type: Keyboard,
                  config: keyboardConfig,
                  currentLayout: "abc",
                  maxCharacters: 24,
                  signals: {
                    onSearch: true
                  }
                }
              }
            };
          }
          _setup() {
            var inputField = this.tag("SearchComponent.SearchBox.InputWrapper.InputField");
            this.tag("Keyboard").inputField(inputField);
          }
          onSearch(event) {
            console.log("search", event.input);
          }
          _active() {
            super._active();
            this.tag("SearchComponent.SearchBox.InputWrapper.InputField").color = theme.colors.accentGrey.dark;
            var LongRail = {
              type: Rail,
              x: -30,
              y: 380,
              railIndex: 16
            };
            this.tag("SearchComponent").patch({
              LongRail
            });
          }
          _getFocused() {
            return this.tag("Keyboard");
          }
          // overrides the default up button actions
          _handleUp() {
            if (this.index > 1) {
              this.index -= 1;
            }
          }
          // overrides the default down button actions
          _handleDown() {
            if (this.index < 3) {
              this.index += 1;
            }
          }
          // overrides the default behavior when enter button is clicked
          _handleEnter() {
            if (this.index === 1) {
              Router.navigate("home");
            }
          }
          // returns the focused components
          _getFocused() {
            return this.tag("SearchComponent").children[this.index];
          }
        }
        class Key extends Key$1 {
          _firstActive() {
            this.label = {
              mountY: 0.45
            };
            this.labelColors = {
              unfocused: Colors("white").get(),
              focused: theme.colors.dark
            };
            this.backgroundColors = {
              unfocused: Colors("white").alpha(0).get(),
              focused: theme.colors.white
            };
            if (this.hasFocus()) {
              this._focus();
            }
          }
          static get width() {
            return 90;
          }
          static get height() {
            return 40;
          }
        }
        class ActionKey extends Key$1 {
          _active() {
            this.label = {
              mountY: 0.45
            };
            this.labelColors = {
              unfocused: Colors("black").get(),
              focused: Colors("white").get()
            };
            this.backgroundColors = {
              unfocused: Colors("white").get(),
              focused: theme.colors.accentGrey.light
            };
            if (this.hasFocus()) {
              this._focus();
            }
          }
          static get height() {
            return 60;
          }
          static get width() {
            return 160;
          }
        }
        var keyboardConfig = {
          layouts: {
            "abc": [["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"], ["k", "l", "m", "n", "o", "p", "q", "r", "s", "t"], ["u", "v", "w", "x", "y", "z", "_", "-", "@", "."], ["Layout:ABC", "Layout:123", "Space", "Search", "Del"]],
            "ABC": [["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"], ["K", "L", "M", "N", "O", "P", "Q", "R", "S", "T"], ["U", "V", "W", "X", "Y", "Z", "_", "-", "@", "."], ["Layout:abc", "Layout:123", "Space", "Search", "Del"]],
            "123": [["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"], ["Layout:abc", "Space", "Clear", "Del"]]
          },
          styling: {
            align: "center",
            horizontalSpacing: 5,
            verticalSpacing: 20
          },
          buttonTypes: {
            default: {
              type: Key
            },
            Del: {
              type: ActionKey,
              icon: "del"
            },
            Layout: {
              type: ActionKey
            },
            Space: {
              type: ActionKey,
              w: 280,
              label: "space"
            },
            Clear: {
              type: ActionKey,
              label: "clear"
            },
            Search: {
              type: ActionKey,
              label: "search"
            }
          }
        };
        class ContentDetails extends lightning.Component {
          constructor() {
            super(...arguments);
            this.contentId = "";
            this.index = 1;
            this.from = "";
          }
          // readonly contentView = this.getByRef("ContentView")!;
          // readonly spinner = this.contentView.getByRef("Spinner")!;
          // readonly background = this.contentView.getByRef("Background")!;
          // readonly contentDataView = this.contentView.getByRef("ContentData")!;
          // readonly thumbnail = this.contentDataView.getByRef("Thumbnail")!;
          // readonly title = this.contentDataView.getByRef("Title")!;
          // readonly description = this.contentDataView.getByRef("Description")!;
          // readonly genre = this.contentDataView.getByRef("Genre")!;
          // readonly info = this.contentDataView.getByRef("Info")!;
          static _template() {
            return {
              ContentView: {
                w: 1920,
                h: 1080,
                color: theme.colors.black,
                rect: true,
                shader: {
                  x: 100,
                  y: -100,
                  pivot: 0.5,
                  type: lightning.shaders.RadialGradient,
                  outerColor: theme.colors.primaryLight,
                  innerColor: theme.colors.dark,
                  radius: 800
                },
                Thumbnail: {
                  x: 1e3,
                  y: 110,
                  scale: 1.5,
                  shader: {
                    type: lightning.shaders.FadeOut,
                    innerColor: theme.colors.black,
                    left: 200,
                    bottom: 200
                  }
                },
                ContentData: {
                  shader: null,
                  zIndex: 2,
                  Title: {
                    x: 40,
                    y: 165,
                    shader: null,
                    text: {
                      fontSize: 80
                    },
                    color: theme.colors.white
                  },
                  Description: {
                    x: 40,
                    y: 270,
                    w: 900,
                    shader: null,
                    text: {
                      wordWrap: true,
                      maxLines: 3,
                      maxLinesSuffix: "...",
                      fontSize: 30
                    },
                    color: theme.colors.accentGrey.light
                  },
                  Genre: {
                    x: 40,
                    y: 380,
                    w: 900,
                    shader: null,
                    text: {
                      fontSize: 24
                    },
                    color: theme.colors.accentGrey.light
                  },
                  Info: {
                    visible: false,
                    Director: {
                      x: 40,
                      y: 440,
                      w: 100,
                      shader: null,
                      text: {
                        text: "Director : ",
                        fontSize: 24
                      },
                      color: theme.colors.accentGrey.light
                    },
                    Starring: {
                      x: 40,
                      y: 470,
                      w: 100,
                      shader: null,
                      text: {
                        text: "Staring  : ",
                        fontSize: 24
                      },
                      color: theme.colors.accentGrey.light
                    },
                    DirectorList: {
                      x: 150,
                      y: 440,
                      w: 800,
                      shader: null,
                      text: {
                        fontSize: 24
                      },
                      color: theme.colors.accentGrey.light
                    },
                    StarringList: {
                      x: 150,
                      y: 470,
                      w: 800,
                      shader: null,
                      text: {
                        fontSize: 24,
                        wordWrap: true,
                        maxLines: 1,
                        maxLinesSuffix: "..."
                      },
                      color: theme.colors.accentGrey.light
                    }
                  },
                  VideoSpec: {
                    visible: false,
                    VideoSpec1: {
                      x: 70,
                      y: 140,
                      shader: null,
                      type: VideoSpecItem,
                      specData: "  16+  "
                    },
                    VideoSpec2: {
                      x: 135,
                      y: 140,
                      shader: null,
                      type: VideoSpecItem,
                      specData: "  4k  "
                    },
                    VideoSpec3: {
                      x: 193,
                      y: 140,
                      shader: null,
                      type: VideoSpecItem,
                      specData: "  cc  "
                    }
                  }
                },
                ContentActions: {
                  shader: null,
                  BackButton: {
                    x: 40,
                    y: 40,
                    type: BackButton
                  },
                  PlayButton: {
                    x: 40,
                    y: 570,
                    type: Button,
                    label: "Play Video"
                  },
                  PlayTrailer: {
                    x: 40,
                    y: 700,
                    type: Button,
                    label: "Play Trailer"
                  }
                }
              }
            };
          }
          _inactive() {
            console.log("Inactive");
            this.index = 1;
          }
          set params(args) {
            var _data$images$find2;
            var id = args.id,
              from = args.from,
              data = args.data;
            this.from = from;
            var imgSrc = (_data$images$find2 = data.images.find(img => img.width === 828)) === null || _data$images$find2 === void 0 ? void 0 : _data$images$find2.url;
            console.log(args);
            this.patch({
              ContentView: {
                shader: {
                  type: lightning.shaders.RadialGradient,
                  x: 300,
                  y: 300,
                  innerColor: 4278190080,
                  radius: 1500
                },
                Thumbnail: {
                  src: imgSrc
                },
                ContentData: {
                  x: 10,
                  Title: {
                    text: {
                      text: data.title
                    }
                  },
                  Description: {
                    text: {
                      text: data.description
                    }
                  },
                  Genre: {
                    text: {
                      text: data.genre.join(" . ")
                    }
                  },
                  Info: {
                    visible: true,
                    DirectorList: {
                      text: {
                        text: data.director.map(a => a.personName).join(", ")
                      }
                    },
                    StarringList: {
                      text: {
                        text: data.actor.map(a => a.personName).join(", ")
                      }
                    }
                  },
                  VideoSpec: {
                    visible: true
                  }
                }
              }
            });
            this._refocus();
          }
          _init() {}
          // animating elements on netering the page (invoked in the transition)
          animateElements() {
            var contentAnimation = this.tag("ContentView.ContentData").animation({
              duration: 1,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                p: "y",
                v: {
                  0: -60,
                  1: 0
                }
              }]
            });
            var contentActionsAnimation = this.tag("ContentView.ContentActions").animation({
              duration: 1,
              delay: 0,
              actions: [{
                p: "alpha",
                v: {
                  0: 0,
                  1: 1
                }
              }, {
                p: "x",
                v: {
                  0: -100,
                  1: 10
                }
              }]
            });
            contentActionsAnimation.start();
            contentAnimation.start();
          }
          // overrides the default up button actions
          _handleUp() {
            if (this.index > 0) {
              this.index -= 1;
            }
          }
          // overrides the default right button actions
          _handleDown() {
            if (this.index < 2) {
              this.index += 1;
            }
          }
          // overrides the default behavior when enter button is clicked
          _handleEnter() {
            console.log(this.from);
            if (this.index === 0) {
              if (this.from == "gridItem" || this.from == "Grid") {
                Router.navigate("grid");
              } else {
                Router.navigate("home");
              }
            } else {
              Router.navigate(`player/${this.contentId}`);
            }
          }
          // returns the focused components
          _getFocused() {
            return this.tag("ContentView.ContentActions").children[this.index];
          }
          // custom page transition
          pageTransition(pageIn, pageOut) {
            if (!pageOut) return Promise.resolve();
            return new Promise((resolve, reject) => {
              pageOut.pageTransitionOut(pageOut).then(() => {
                pageIn.visible = true;
                pageIn.animateElements();
                resolve();
              });
            });
          }
        }
        var shakaPlayer_compiled = {};

        /*
         @license
         Shaka Player
         Copyright 2016 Google LLC
         SPDX-License-Identifier: Apache-2.0
        */

        (function (exports) {
          (function () {
            var innerGlobal = typeof window != "undefined" ? window : commonjsGlobal;
            var exportTo = {};
            (function (window, global, module) {
              /*
              @license
              Shaka Player
              Copyright 2016 Google LLC
              SPDX-License-Identifier: Apache-2.0
              */
              /*
              	 Copyright The Closure Library Authors.
               SPDX-License-Identifier: Apache-2.0
              */
              var q;
              function aa(a) {
                var b = 0;
                return function () {
                  return b < a.length ? {
                    done: !1,
                    value: a[b++]
                  } : {
                    done: !0
                  };
                };
              }
              var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {
                if (a == Array.prototype || a == Object.prototype) return a;
                a[b] = c.value;
                return a;
              };
              function ca(a) {
                a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
                for (var b = 0; b < a.length; ++b) {
                  var c = a[b];
                  if (c && c.Math == Math) return c;
                }
                throw Error("Cannot find global object");
              }
              var da = ca(this);
              function ea(a, b) {
                if (b) a: {
                  var c = da;
                  a = a.split(".");
                  for (var d = 0; d < a.length - 1; d++) {
                    var e = a[d];
                    if (!(e in c)) break a;
                    c = c[e];
                  }
                  a = a[a.length - 1];
                  d = c[a];
                  b = b(d);
                  b != d && null != b && ba(c, a, {
                    configurable: !0,
                    writable: !0,
                    value: b
                  });
                }
              }
              ea("Symbol", function (a) {
                function b(f) {
                  if (this instanceof b) throw new TypeError("Symbol is not a constructor");
                  return new c(d + (f || "") + "_" + e++, f);
                }
                function c(f, g) {
                  this.g = f;
                  ba(this, "description", {
                    configurable: !0,
                    writable: !0,
                    value: g
                  });
                }
                if (a) return a;
                c.prototype.toString = function () {
                  return this.g;
                };
                var d = "jscomp_symbol_" + (1E9 * Math.random() >>> 0) + "_",
                  e = 0;
                return b;
              });
              ea("Symbol.iterator", function (a) {
                if (a) return a;
                a = Symbol("Symbol.iterator");
                for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
                  var d = da[b[c]];
                  "function" === typeof d && "function" != typeof d.prototype[a] && ba(d.prototype, a, {
                    configurable: !0,
                    writable: !0,
                    value: function value() {
                      return fa(aa(this));
                    }
                  });
                }
                return a;
              });
              function fa(a) {
                a = {
                  next: a
                };
                a[Symbol.iterator] = function () {
                  return this;
                };
                return a;
              }
              function r(a) {
                var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
                return b ? b.call(a) : {
                  next: aa(a)
                };
              }
              function ha(a) {
                if (!(a instanceof Array)) {
                  a = r(a);
                  for (var b, c = []; !(b = a.next()).done;) c.push(b.value);
                  a = c;
                }
                return a;
              }
              var ia = "function" == typeof Object.create ? Object.create : function (a) {
                  function b() {}
                  b.prototype = a;
                  return new b();
                },
                ja;
              if ("function" == typeof Object.setPrototypeOf) ja = Object.setPrototypeOf;else {
                var ka;
                a: {
                  var la = {
                      a: !0
                    },
                    ma = {};
                  try {
                    ma.__proto__ = la;
                    ka = ma.a;
                    break a;
                  } catch (a) {}
                  ka = !1;
                }
                ja = ka ? function (a, b) {
                  a.__proto__ = b;
                  if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
                  return a;
                } : null;
              }
              var na = ja;
              function oa(a, b) {
                a.prototype = ia(b.prototype);
                a.prototype.constructor = a;
                if (na) na(a, b);else for (var c in b) if ("prototype" != c) if (Object.defineProperties) {
                  var d = Object.getOwnPropertyDescriptor(b, c);
                  d && Object.defineProperty(a, c, d);
                } else a[c] = b[c];
                a.xh = b.prototype;
              }
              function pa() {
                this.o = !1;
                this.l = null;
                this.h = void 0;
                this.g = 1;
                this.j = this.m = 0;
                this.u = this.i = null;
              }
              function qa(a) {
                if (a.o) throw new TypeError("Generator is already running");
                a.o = !0;
              }
              pa.prototype.s = function (a) {
                this.h = a;
              };
              function ra(a, b) {
                a.i = {
                  Ee: b,
                  Le: !0
                };
                a.g = a.m || a.j;
              }
              pa.prototype.return = function (a) {
                this.i = {
                  return: a
                };
                this.g = this.j;
              };
              function u(a, b, c) {
                a.g = c;
                return {
                  value: b
                };
              }
              pa.prototype.A = function (a) {
                this.g = a;
              };
              function A(a) {
                a.g = 0;
              }
              function D(a, b, c) {
                a.m = b;
                void 0 != c && (a.j = c);
              }
              function sa(a) {
                a.m = 0;
                a.j = 2;
              }
              function ta(a, b) {
                a.g = b;
                a.m = 0;
              }
              function ua(a) {
                a.m = 0;
                var b = a.i.Ee;
                a.i = null;
                return b;
              }
              function xa(a) {
                a.u = [a.i];
                a.m = 0;
                a.j = 0;
              }
              function ya(a, b) {
                var c = a.u.splice(0)[0];
                (c = a.i = a.i || c) ? c.Le ? a.g = a.m || a.j : void 0 != c.A && a.j < c.A ? (a.g = c.A, a.i = null) : a.g = a.j : a.g = b;
              }
              function za(a) {
                this.g = new pa();
                this.h = a;
              }
              function Aa(a, b) {
                qa(a.g);
                var c = a.g.l;
                if (c) return Ba(a, "return" in c ? c["return"] : function (d) {
                  return {
                    value: d,
                    done: !0
                  };
                }, b, a.g.return);
                a.g.return(b);
                return Ca(a);
              }
              function Ba(a, b, c, d) {
                try {
                  var e = b.call(a.g.l, c);
                  if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object");
                  if (!e.done) return a.g.o = !1, e;
                  var f = e.value;
                } catch (g) {
                  return a.g.l = null, ra(a.g, g), Ca(a);
                }
                a.g.l = null;
                d.call(a.g, f);
                return Ca(a);
              }
              function Ca(a) {
                for (; a.g.g;) try {
                  var b = a.h(a.g);
                  if (b) return a.g.o = !1, {
                    value: b.value,
                    done: !1
                  };
                } catch (c) {
                  a.g.h = void 0, ra(a.g, c);
                }
                a.g.o = !1;
                if (a.g.i) {
                  b = a.g.i;
                  a.g.i = null;
                  if (b.Le) throw b.Ee;
                  return {
                    value: b.return,
                    done: !0
                  };
                }
                return {
                  value: void 0,
                  done: !0
                };
              }
              function Da(a) {
                this.next = function (b) {
                  qa(a.g);
                  a.g.l ? b = Ba(a, a.g.l.next, b, a.g.s) : (a.g.s(b), b = Ca(a));
                  return b;
                };
                this.throw = function (b) {
                  qa(a.g);
                  a.g.l ? b = Ba(a, a.g.l["throw"], b, a.g.s) : (ra(a.g, b), b = Ca(a));
                  return b;
                };
                this.return = function (b) {
                  return Aa(a, b);
                };
                this[Symbol.iterator] = function () {
                  return this;
                };
              }
              function Ea(a) {
                function b(d) {
                  return a.next(d);
                }
                function c(d) {
                  return a.throw(d);
                }
                return new Promise(function (d, e) {
                  function f(g) {
                    g.done ? d(g.value) : Promise.resolve(g.value).then(b, c).then(f, e);
                  }
                  f(a.next());
                });
              }
              function G(a) {
                return Ea(new Da(new za(a)));
              }
              function Fa() {
                for (var a = Number(this), b = [], c = a; c < arguments.length; c++) b[c - a] = arguments[c];
                return b;
              }
              ea("Promise", function (a) {
                function b(g) {
                  this.h = 0;
                  this.i = void 0;
                  this.g = [];
                  this.o = !1;
                  var h = this.j();
                  try {
                    g(h.resolve, h.reject);
                  } catch (k) {
                    h.reject(k);
                  }
                }
                function c() {
                  this.g = null;
                }
                function d(g) {
                  return g instanceof b ? g : new b(function (h) {
                    h(g);
                  });
                }
                if (a) return a;
                c.prototype.h = function (g) {
                  if (null == this.g) {
                    this.g = [];
                    var h = this;
                    this.i(function () {
                      h.l();
                    });
                  }
                  this.g.push(g);
                };
                var e = da.setTimeout;
                c.prototype.i = function (g) {
                  e(g, 0);
                };
                c.prototype.l = function () {
                  for (; this.g && this.g.length;) {
                    var g = this.g;
                    this.g = [];
                    for (var h = 0; h < g.length; ++h) {
                      var k = g[h];
                      g[h] = null;
                      try {
                        k();
                      } catch (l) {
                        this.j(l);
                      }
                    }
                  }
                  this.g = null;
                };
                c.prototype.j = function (g) {
                  this.i(function () {
                    throw g;
                  });
                };
                b.prototype.j = function () {
                  function g(l) {
                    return function (m) {
                      k || (k = !0, l.call(h, m));
                    };
                  }
                  var h = this,
                    k = !1;
                  return {
                    resolve: g(this.F),
                    reject: g(this.l)
                  };
                };
                b.prototype.F = function (g) {
                  if (g === this) this.l(new TypeError("A Promise cannot resolve to itself"));else if (g instanceof b) this.H(g);else {
                    a: switch (typeof g) {
                      case "object":
                        var h = null != g;
                        break a;
                      case "function":
                        h = !0;
                        break a;
                      default:
                        h = !1;
                    }
                    h ? this.D(g) : this.m(g);
                  }
                };
                b.prototype.D = function (g) {
                  var h = void 0;
                  try {
                    h = g.then;
                  } catch (k) {
                    this.l(k);
                    return;
                  }
                  "function" == typeof h ? this.J(h, g) : this.m(g);
                };
                b.prototype.l = function (g) {
                  this.s(2, g);
                };
                b.prototype.m = function (g) {
                  this.s(1, g);
                };
                b.prototype.s = function (g, h) {
                  if (0 != this.h) throw Error("Cannot settle(" + g + ", " + h + "): Promise already settled in state" + this.h);
                  this.h = g;
                  this.i = h;
                  2 === this.h && this.G();
                  this.u();
                };
                b.prototype.G = function () {
                  var g = this;
                  e(function () {
                    if (g.B()) {
                      var h = da.console;
                      "undefined" !== typeof h && h.error(g.i);
                    }
                  }, 1);
                };
                b.prototype.B = function () {
                  if (this.o) return !1;
                  var g = da.CustomEvent,
                    h = da.Event,
                    k = da.dispatchEvent;
                  if ("undefined" === typeof k) return !0;
                  "function" === typeof g ? g = new g("unhandledrejection", {
                    cancelable: !0
                  }) : "function" === typeof h ? g = new h("unhandledrejection", {
                    cancelable: !0
                  }) : (g = da.document.createEvent("CustomEvent"), g.initCustomEvent("unhandledrejection", !1, !0, g));
                  g.promise = this;
                  g.reason = this.i;
                  return k(g);
                };
                b.prototype.u = function () {
                  if (null != this.g) {
                    for (var g = 0; g < this.g.length; ++g) f.h(this.g[g]);
                    this.g = null;
                  }
                };
                var f = new c();
                b.prototype.H = function (g) {
                  var h = this.j();
                  g.Lc(h.resolve, h.reject);
                };
                b.prototype.J = function (g, h) {
                  var k = this.j();
                  try {
                    g.call(h, k.resolve, k.reject);
                  } catch (l) {
                    k.reject(l);
                  }
                };
                b.prototype.then = function (g, h) {
                  function k(p, t) {
                    return "function" == typeof p ? function (v) {
                      try {
                        l(p(v));
                      } catch (y) {
                        m(y);
                      }
                    } : t;
                  }
                  var l,
                    m,
                    n = new b(function (p, t) {
                      l = p;
                      m = t;
                    });
                  this.Lc(k(g, l), k(h, m));
                  return n;
                };
                b.prototype.catch = function (g) {
                  return this.then(void 0, g);
                };
                b.prototype.Lc = function (g, h) {
                  function k() {
                    switch (l.h) {
                      case 1:
                        g(l.i);
                        break;
                      case 2:
                        h(l.i);
                        break;
                      default:
                        throw Error("Unexpected state: " + l.h);
                    }
                  }
                  var l = this;
                  null == this.g ? f.h(k) : this.g.push(k);
                  this.o = !0;
                };
                b.resolve = d;
                b.reject = function (g) {
                  return new b(function (h, k) {
                    k(g);
                  });
                };
                b.race = function (g) {
                  return new b(function (h, k) {
                    for (var l = r(g), m = l.next(); !m.done; m = l.next()) d(m.value).Lc(h, k);
                  });
                };
                b.all = function (g) {
                  var h = r(g),
                    k = h.next();
                  return k.done ? d([]) : new b(function (l, m) {
                    function n(v) {
                      return function (y) {
                        p[v] = y;
                        t--;
                        0 == t && l(p);
                      };
                    }
                    var p = [],
                      t = 0;
                    do p.push(void 0), t++, d(k.value).Lc(n(p.length - 1), m), k = h.next(); while (!k.done);
                  });
                };
                return b;
              });
              function Ha(a, b) {
                return Object.prototype.hasOwnProperty.call(a, b);
              }
              ea("WeakMap", function (a) {
                function b(k) {
                  this.g = (h += Math.random() + 1).toString();
                  if (k) {
                    k = r(k);
                    for (var l; !(l = k.next()).done;) l = l.value, this.set(l[0], l[1]);
                  }
                }
                function c() {}
                function d(k) {
                  var l = typeof k;
                  return "object" === l && null !== k || "function" === l;
                }
                function e(k) {
                  if (!Ha(k, g)) {
                    var l = new c();
                    ba(k, g, {
                      value: l
                    });
                  }
                }
                function f(k) {
                  var l = Object[k];
                  l && (Object[k] = function (m) {
                    if (m instanceof c) return m;
                    Object.isExtensible(m) && e(m);
                    return l(m);
                  });
                }
                if (function () {
                  if (!a || !Object.seal) return !1;
                  try {
                    var k = Object.seal({}),
                      l = Object.seal({}),
                      m = new a([[k, 2], [l, 3]]);
                    if (2 != m.get(k) || 3 != m.get(l)) return !1;
                    m.delete(k);
                    m.set(l, 4);
                    return !m.has(k) && 4 == m.get(l);
                  } catch (n) {
                    return !1;
                  }
                }()) return a;
                var g = "$jscomp_hidden_" + Math.random();
                f("freeze");
                f("preventExtensions");
                f("seal");
                var h = 0;
                b.prototype.set = function (k, l) {
                  if (!d(k)) throw Error("Invalid WeakMap key");
                  e(k);
                  if (!Ha(k, g)) throw Error("WeakMap key fail: " + k);
                  k[g][this.g] = l;
                  return this;
                };
                b.prototype.get = function (k) {
                  return d(k) && Ha(k, g) ? k[g][this.g] : void 0;
                };
                b.prototype.has = function (k) {
                  return d(k) && Ha(k, g) && Ha(k[g], this.g);
                };
                b.prototype.delete = function (k) {
                  return d(k) && Ha(k, g) && Ha(k[g], this.g) ? delete k[g][this.g] : !1;
                };
                return b;
              });
              ea("Map", function (a) {
                function b() {
                  var h = {};
                  return h.Qa = h.next = h.head = h;
                }
                function c(h, k) {
                  var l = h.g;
                  return fa(function () {
                    if (l) {
                      for (; l.head != h.g;) l = l.Qa;
                      for (; l.next != l.head;) return l = l.next, {
                        done: !1,
                        value: k(l)
                      };
                      l = null;
                    }
                    return {
                      done: !0,
                      value: void 0
                    };
                  });
                }
                function d(h, k) {
                  var l = k && typeof k;
                  "object" == l || "function" == l ? f.has(k) ? l = f.get(k) : (l = "" + ++g, f.set(k, l)) : l = "p_" + k;
                  var m = h.h[l];
                  if (m && Ha(h.h, l)) for (h = 0; h < m.length; h++) {
                    var n = m[h];
                    if (k !== k && n.key !== n.key || k === n.key) return {
                      id: l,
                      list: m,
                      index: h,
                      ga: n
                    };
                  }
                  return {
                    id: l,
                    list: m,
                    index: -1,
                    ga: void 0
                  };
                }
                function e(h) {
                  this.h = {};
                  this.g = b();
                  this.size = 0;
                  if (h) {
                    h = r(h);
                    for (var k; !(k = h.next()).done;) k = k.value, this.set(k[0], k[1]);
                  }
                }
                if (function () {
                  if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal) return !1;
                  try {
                    var h = Object.seal({
                        x: 4
                      }),
                      k = new a(r([[h, "s"]]));
                    if ("s" != k.get(h) || 1 != k.size || k.get({
                      x: 4
                    }) || k.set({
                      x: 4
                    }, "t") != k || 2 != k.size) return !1;
                    var l = k.entries(),
                      m = l.next();
                    if (m.done || m.value[0] != h || "s" != m.value[1]) return !1;
                    m = l.next();
                    return m.done || 4 != m.value[0].x || "t" != m.value[1] || !l.next().done ? !1 : !0;
                  } catch (n) {
                    return !1;
                  }
                }()) return a;
                var f = new WeakMap();
                e.prototype.set = function (h, k) {
                  h = 0 === h ? 0 : h;
                  var l = d(this, h);
                  l.list || (l.list = this.h[l.id] = []);
                  l.ga ? l.ga.value = k : (l.ga = {
                    next: this.g,
                    Qa: this.g.Qa,
                    head: this.g,
                    key: h,
                    value: k
                  }, l.list.push(l.ga), this.g.Qa.next = l.ga, this.g.Qa = l.ga, this.size++);
                  return this;
                };
                e.prototype.delete = function (h) {
                  h = d(this, h);
                  return h.ga && h.list ? (h.list.splice(h.index, 1), h.list.length || delete this.h[h.id], h.ga.Qa.next = h.ga.next, h.ga.next.Qa = h.ga.Qa, h.ga.head = null, this.size--, !0) : !1;
                };
                e.prototype.clear = function () {
                  this.h = {};
                  this.g = this.g.Qa = b();
                  this.size = 0;
                };
                e.prototype.has = function (h) {
                  return !!d(this, h).ga;
                };
                e.prototype.get = function (h) {
                  return (h = d(this, h).ga) && h.value;
                };
                e.prototype.entries = function () {
                  return c(this, function (h) {
                    return [h.key, h.value];
                  });
                };
                e.prototype.keys = function () {
                  return c(this, function (h) {
                    return h.key;
                  });
                };
                e.prototype.values = function () {
                  return c(this, function (h) {
                    return h.value;
                  });
                };
                e.prototype.forEach = function (h, k) {
                  for (var l = this.entries(), m; !(m = l.next()).done;) m = m.value, h.call(k, m[1], m[0], this);
                };
                e.prototype[Symbol.iterator] = e.prototype.entries;
                var g = 0;
                return e;
              });
              ea("Set", function (a) {
                function b(c) {
                  this.g = new Map();
                  if (c) {
                    c = r(c);
                    for (var d; !(d = c.next()).done;) this.add(d.value);
                  }
                  this.size = this.g.size;
                }
                if (function () {
                  if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal) return !1;
                  try {
                    var c = Object.seal({
                        x: 4
                      }),
                      d = new a(r([c]));
                    if (!d.has(c) || 1 != d.size || d.add(c) != d || 1 != d.size || d.add({
                      x: 4
                    }) != d || 2 != d.size) return !1;
                    var e = d.entries(),
                      f = e.next();
                    if (f.done || f.value[0] != c || f.value[1] != c) return !1;
                    f = e.next();
                    return f.done || f.value[0] == c || 4 != f.value[0].x || f.value[1] != f.value[0] ? !1 : e.next().done;
                  } catch (g) {
                    return !1;
                  }
                }()) return a;
                b.prototype.add = function (c) {
                  c = 0 === c ? 0 : c;
                  this.g.set(c, c);
                  this.size = this.g.size;
                  return this;
                };
                b.prototype.delete = function (c) {
                  c = this.g.delete(c);
                  this.size = this.g.size;
                  return c;
                };
                b.prototype.clear = function () {
                  this.g.clear();
                  this.size = 0;
                };
                b.prototype.has = function (c) {
                  return this.g.has(c);
                };
                b.prototype.entries = function () {
                  return this.g.entries();
                };
                b.prototype.values = function () {
                  return this.g.values();
                };
                b.prototype.keys = b.prototype.values;
                b.prototype[Symbol.iterator] = b.prototype.values;
                b.prototype.forEach = function (c, d) {
                  var e = this;
                  this.g.forEach(function (f) {
                    return c.call(d, f, f, e);
                  });
                };
                return b;
              });
              function Ia(a, b, c) {
                a instanceof String && (a = String(a));
                for (var d = a.length, e = 0; e < d; e++) {
                  var f = a[e];
                  if (b.call(c, f, e, a)) return {
                    Je: e,
                    v: f
                  };
                }
                return {
                  Je: -1,
                  v: void 0
                };
              }
              ea("Array.prototype.findIndex", function (a) {
                return a ? a : function (b, c) {
                  return Ia(this, b, c).Je;
                };
              });
              ea("Object.is", function (a) {
                return a ? a : function (b, c) {
                  return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c;
                };
              });
              ea("Array.prototype.includes", function (a) {
                return a ? a : function (b, c) {
                  var d = this;
                  d instanceof String && (d = String(d));
                  var e = d.length;
                  c = c || 0;
                  for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
                    var f = d[c];
                    if (f === b || Object.is(f, b)) return !0;
                  }
                  return !1;
                };
              });
              function Ka(a, b, c) {
                if (null == a) throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
                if (b instanceof RegExp) throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
                return a + "";
              }
              ea("String.prototype.includes", function (a) {
                return a ? a : function (b, c) {
                  return -1 !== Ka(this, b, "includes").indexOf(b, c || 0);
                };
              });
              ea("Array.prototype.find", function (a) {
                return a ? a : function (b, c) {
                  return Ia(this, b, c).v;
                };
              });
              ea("String.prototype.startsWith", function (a) {
                return a ? a : function (b, c) {
                  var d = Ka(this, b, "startsWith"),
                    e = d.length,
                    f = b.length;
                  c = Math.max(0, Math.min(c | 0, d.length));
                  for (var g = 0; g < f && c < e;) if (d[c++] != b[g++]) return !1;
                  return g >= f;
                };
              });
              function La(a, b) {
                a instanceof String && (a += "");
                var c = 0,
                  d = !1,
                  e = {
                    next: function next() {
                      if (!d && c < a.length) {
                        var f = c++;
                        return {
                          value: b(f, a[f]),
                          done: !1
                        };
                      }
                      d = !0;
                      return {
                        done: !0,
                        value: void 0
                      };
                    }
                  };
                e[Symbol.iterator] = function () {
                  return e;
                };
                return e;
              }
              ea("Array.prototype.keys", function (a) {
                return a ? a : function () {
                  return La(this, function (b) {
                    return b;
                  });
                };
              });
              var Na = "function" == typeof Object.assign ? Object.assign : function (a, b) {
                for (var c = 1; c < arguments.length; c++) {
                  var d = arguments[c];
                  if (d) for (var e in d) Ha(d, e) && (a[e] = d[e]);
                }
                return a;
              };
              ea("Object.assign", function (a) {
                return a || Na;
              });
              ea("Array.from", function (a) {
                return a ? a : function (b, c, d) {
                  c = null != c ? c : function (h) {
                    return h;
                  };
                  var e = [],
                    f = "undefined" != typeof Symbol && Symbol.iterator && b[Symbol.iterator];
                  if ("function" == typeof f) {
                    b = f.call(b);
                    for (var g = 0; !(f = b.next()).done;) e.push(c.call(d, f.value, g++));
                  } else for (f = b.length, g = 0; g < f; g++) e.push(c.call(d, b[g], g));
                  return e;
                };
              });
              ea("Array.prototype.values", function (a) {
                return a ? a : function () {
                  return La(this, function (b, c) {
                    return c;
                  });
                };
              });
              ea("Promise.prototype.finally", function (a) {
                return a ? a : function (b) {
                  return this.then(function (c) {
                    return Promise.resolve(b()).then(function () {
                      return c;
                    });
                  }, function (c) {
                    return Promise.resolve(b()).then(function () {
                      throw c;
                    });
                  });
                };
              });
              ea("Array.prototype.entries", function (a) {
                return a ? a : function () {
                  return La(this, function (b, c) {
                    return [b, c];
                  });
                };
              });
              ea("String.prototype.repeat", function (a) {
                return a ? a : function (b) {
                  var c = Ka(this, null, "repeat");
                  if (0 > b || 1342177279 < b) throw new RangeError("Invalid count value");
                  b |= 0;
                  for (var d = ""; b;) if (b & 1 && (d += c), b >>>= 1) c += c;
                  return d;
                };
              });
              ea("Number.isNaN", function (a) {
                return a ? a : function (b) {
                  return "number" === typeof b && isNaN(b);
                };
              });
              ea("Object.values", function (a) {
                return a ? a : function (b) {
                  var c = [],
                    d;
                  for (d in b) Ha(b, d) && c.push(b[d]);
                  return c;
                };
              });
              ea("Math.log2", function (a) {
                return a ? a : function (b) {
                  return Math.log(b) / Math.LN2;
                };
              });
              ea("Math.trunc", function (a) {
                return a ? a : function (b) {
                  b = Number(b);
                  if (isNaN(b) || Infinity === b || -Infinity === b || 0 === b) return b;
                  var c = Math.floor(Math.abs(b));
                  return 0 > b ? -c : c;
                };
              });
              ea("Object.entries", function (a) {
                return a ? a : function (b) {
                  var c = [],
                    d;
                  for (d in b) Ha(b, d) && c.push([d, b[d]]);
                  return c;
                };
              });
              var Oa = this || self;
              function K(a, b) {
                a = a.split(".");
                var c = Oa;
                a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
                for (var d; a.length && (d = a.shift());) a.length || void 0 === b ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
              }
              function Pa(a) {
                this.g = Math.exp(Math.log(.5) / a);
                this.i = this.h = 0;
              }
              Pa.prototype.sample = function (a, b) {
                var c = Math.pow(this.g, a);
                b = b * (1 - c) + c * this.h;
                isNaN(b) || (this.h = b, this.i += a);
              };
              function Qa(a) {
                return a.h / (1 - Math.pow(a.g, a.i));
              }
              function Ra() {
                this.h = new Pa(2);
                this.j = new Pa(5);
                this.g = 0;
                this.i = 128E3;
                this.l = 16E3;
              }
              Ra.prototype.configure = function (a) {
                this.i = a.minTotalBytes;
                this.l = a.minBytes;
                this.h.g = Math.exp(Math.log(.5) / a.fastHalfLife);
                this.j.g = Math.exp(Math.log(.5) / a.slowHalfLife);
              };
              Ra.prototype.sample = function (a, b) {
                if (!(b < this.l)) {
                  var c = 8E3 * b / a;
                  a /= 1E3;
                  this.g += b;
                  this.h.sample(a, c);
                  this.j.sample(a, c);
                }
              };
              Ra.prototype.getBandwidthEstimate = function (a) {
                return this.g < this.i ? a : Math.min(Qa(this.h), Qa(this.j));
              };
              function Ta() {}
              function Va() {}
              function Wa() {}
              function Xa(a) {
                var b = Fa.apply(1, arguments);
                Ya.has(a) || (Ya.add(a), Wa.apply(Ta, ha(b)));
              }
              function Za() {}
              function $a() {}
              function ab() {}
              function bb() {}
              var Ya = new Set();
              if (window.console && window.console.log.bind) {
                var cb = {},
                  db = (cb[1] = console.error.bind(console), cb[2] = console.warn.bind(console), cb[3] = console.info.bind(console), cb[4] = console.log.bind(console), cb[5] = console.debug.bind(console), cb[6] = console.debug.bind(console), cb);
                Wa = db[2];
                Va = db[1];
              }
              function eb(a) {
                if (fb.has(a)) return fb.get(a);
                var b = MediaSource.isTypeSupported(a);
                fb.set(a, b);
                return b;
              }
              var fb = new Map();
              function gb(a, b) {
                return "number" === typeof a && "number" === typeof b && isNaN(a) && isNaN(b) ? !0 : a === b;
              }
              function hb(a, b) {
                b = a.indexOf(b);
                -1 < b && a.splice(b, 1);
              }
              function ib(a, b, c) {
                c || (c = gb);
                if (a.length != b.length) return !1;
                b = b.slice();
                var d = {};
                a = r(a);
                for (var e = a.next(); !e.done; d = {
                  md: d.md
                }, e = a.next()) {
                  d.md = e.value;
                  e = b.findIndex(function (f) {
                    return function (g) {
                      return c(f.md, g);
                    };
                  }(d));
                  if (-1 == e) return !1;
                  b[e] = b[b.length - 1];
                  b.pop();
                }
                return 0 == b.length;
              }
              function jb(a, b, c) {
                c || (c = gb);
                if (a.length != b.length) return !1;
                for (var d = 0; d < a.length; d++) if (!c(a[d], b[d])) return !1;
                return !0;
              }
              function kb(a, b, c) {
                this.startTime = a;
                this.direction = lb;
                this.endTime = b;
                this.payload = c;
                this.region = new mb();
                this.position = null;
                this.positionAlign = nb;
                this.size = 0;
                this.textAlign = ob;
                this.writingMode = qb;
                this.lineInterpretation = rb;
                this.line = null;
                this.lineHeight = "";
                this.lineAlign = sb;
                this.displayAlign = tb;
                this.fontSize = this.textStrokeWidth = this.textStrokeColor = this.textShadow = this.border = this.backgroundImage = this.backgroundColor = this.color = "";
                this.fontWeight = ub;
                this.fontStyle = vb;
                this.linePadding = this.letterSpacing = this.fontFamily = "";
                this.opacity = 1;
                this.textDecoration = [];
                this.wrapLine = !0;
                this.id = "";
                this.nestedCues = [];
                this.lineBreak = this.isContainer = !1;
                this.cellResolution = {
                  columns: 32,
                  rows: 15
                };
              }
              kb.prototype.clone = function () {
                var a = new kb(0, 0, ""),
                  b;
                for (b in this) a[b] = this[b], a[b] && a[b].constructor == Array && (a[b] = a[b].slice());
                return a;
              };
              function wb(a, b) {
                if (a.startTime != b.startTime || a.endTime != b.endTime || a.payload != b.payload) return !1;
                for (var c in a) if ("startTime" != c && "endTime" != c && "payload" != c) if ("nestedCues" == c) {
                  if (!jb(a.nestedCues, b.nestedCues, wb)) return !1;
                } else if ("region" == c || "cellResolution" == c) for (var d in a[c]) {
                  if (a[c][d] != b[c][d]) return !1;
                } else if (Array.isArray(a[c])) {
                  if (!jb(a[c], b[c])) return !1;
                } else if (a[c] != b[c]) return !1;
                return !0;
              }
              K("shaka.text.Cue", kb);
              var nb = "auto";
              kb.positionAlign = {
                LEFT: "line-left",
                RIGHT: "line-right",
                CENTER: "center",
                AUTO: nb
              };
              var ob = "center",
                xb = {
                  LEFT: "left",
                  RIGHT: "right",
                  CENTER: ob,
                  START: "start",
                  END: "end"
                };
              kb.textAlign = xb;
              var tb = "after",
                yb = {
                  BEFORE: "before",
                  CENTER: "center",
                  AFTER: tb
                };
              kb.displayAlign = yb;
              var lb = "ltr";
              kb.direction = {
                HORIZONTAL_LEFT_TO_RIGHT: lb,
                HORIZONTAL_RIGHT_TO_LEFT: "rtl"
              };
              var qb = "horizontal-tb";
              kb.writingMode = {
                HORIZONTAL_TOP_TO_BOTTOM: qb,
                VERTICAL_LEFT_TO_RIGHT: "vertical-lr",
                VERTICAL_RIGHT_TO_LEFT: "vertical-rl"
              };
              var rb = 0;
              kb.lineInterpretation = {
                LINE_NUMBER: rb,
                PERCENTAGE: 1
              };
              var sb = "start",
                zb = {
                  CENTER: "center",
                  START: sb,
                  END: "end"
                };
              kb.lineAlign = zb;
              var Ab = {
                white: "#FFF",
                lime: "#0F0",
                cyan: "#0FF",
                red: "#F00",
                yellow: "#FF0",
                magenta: "#F0F",
                blue: "#00F",
                black: "#000"
              };
              kb.defaultTextColor = Ab;
              var Bb = {
                bg_white: "#FFF",
                bg_lime: "#0F0",
                bg_cyan: "#0FF",
                bg_red: "#F00",
                bg_yellow: "#FF0",
                bg_magenta: "#F0F",
                bg_blue: "#00F",
                bg_black: "#000"
              };
              kb.defaultTextBackgroundColor = Bb;
              var ub = 400;
              kb.fontWeight = {
                NORMAL: ub,
                BOLD: 700
              };
              var vb = "normal",
                Cb = {
                  NORMAL: vb,
                  ITALIC: "italic",
                  OBLIQUE: "oblique"
                };
              kb.fontStyle = Cb;
              kb.textDecoration = {
                UNDERLINE: "underline",
                LINE_THROUGH: "lineThrough",
                OVERLINE: "overline"
              };
              function mb() {
                this.id = "";
                this.regionAnchorY = this.regionAnchorX = this.viewportAnchorY = this.viewportAnchorX = 0;
                this.height = this.width = 100;
                this.viewportAnchorUnits = this.widthUnits = this.heightUnits = Db;
                this.scroll = Eb;
              }
              K("shaka.text.CueRegion", mb);
              var Db = 1;
              mb.units = {
                PX: 0,
                PERCENTAGE: Db,
                LINES: 2
              };
              var Eb = "";
              mb.scrollMode = {
                NONE: Eb,
                UP: "up"
              };
              function Fb() {}
              function Gb(a, b) {
                if (!a && !b) return !0;
                if (!a || !b || a.byteLength != b.byteLength) return !1;
                if (Hb(a) == Hb(b) && (a.byteOffset || 0) == (b.byteOffset || 0)) return !0;
                var c = M(a);
                b = M(b);
                for (var d = 0; d < a.byteLength; d++) if (c[d] != b[d]) return !1;
                return !0;
              }
              function Hb(a) {
                return a instanceof ArrayBuffer ? a : a.buffer;
              }
              function Ib(a) {
                return a instanceof ArrayBuffer ? a : 0 == a.byteOffset && a.byteLength == a.buffer.byteLength ? a.buffer : new Uint8Array(a).buffer;
              }
              function M(a, b, c) {
                c = void 0 === c ? Infinity : c;
                return Jb(a, void 0 === b ? 0 : b, c, Uint8Array);
              }
              function Lb(a, b, c) {
                c = void 0 === c ? Infinity : c;
                return Jb(a, void 0 === b ? 0 : b, c, DataView);
              }
              function Jb(a, b, c, d) {
                var e = (a.byteOffset || 0) + a.byteLength;
                b = Math.max(0, Math.min((a.byteOffset || 0) + b, e));
                return new d(Hb(a), b, Math.min(b + Math.max(c, 0), e) - b);
              }
              K("shaka.util.BufferUtils", Fb);
              Fb.toDataView = Lb;
              Fb.toUint8 = M;
              Fb.toArrayBuffer = Ib;
              Fb.equal = Gb;
              function O(a, b, c) {
                var d = Fa.apply(3, arguments);
                this.severity = a;
                this.category = b;
                this.code = c;
                this.data = d;
                this.handled = !1;
              }
              O.prototype.toString = function () {
                return "shaka.util.Error " + JSON.stringify(this, null, "  ");
              };
              K("shaka.util.Error", O);
              O.Severity = {
                RECOVERABLE: 1,
                CRITICAL: 2
              };
              O.Category = {
                NETWORK: 1,
                TEXT: 2,
                MEDIA: 3,
                MANIFEST: 4,
                STREAMING: 5,
                DRM: 6,
                PLAYER: 7,
                CAST: 8,
                STORAGE: 9,
                ADS: 10
              };
              O.Code = {
                UNSUPPORTED_SCHEME: 1E3,
                BAD_HTTP_STATUS: 1001,
                HTTP_ERROR: 1002,
                TIMEOUT: 1003,
                MALFORMED_DATA_URI: 1004,
                REQUEST_FILTER_ERROR: 1006,
                RESPONSE_FILTER_ERROR: 1007,
                MALFORMED_TEST_URI: 1008,
                UNEXPECTED_TEST_REQUEST: 1009,
                ATTEMPTS_EXHAUSTED: 1010,
                SEGMENT_MISSING: 1011,
                INVALID_TEXT_HEADER: 2E3,
                INVALID_TEXT_CUE: 2001,
                UNABLE_TO_DETECT_ENCODING: 2003,
                BAD_ENCODING: 2004,
                INVALID_XML: 2005,
                INVALID_MP4_TTML: 2007,
                INVALID_MP4_VTT: 2008,
                UNABLE_TO_EXTRACT_CUE_START_TIME: 2009,
                INVALID_MP4_CEA: 2010,
                TEXT_COULD_NOT_GUESS_MIME_TYPE: 2011,
                CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS: 2012,
                TEXT_ONLY_WEBVTT_SRC_EQUALS: 2013,
                MISSING_TEXT_PLUGIN: 2014,
                CHAPTERS_TRACK_FAILED: 2015,
                CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS: 2016,
                UNSUPPORTED_EXTERNAL_THUMBNAILS_URI: 2017,
                BUFFER_READ_OUT_OF_BOUNDS: 3E3,
                JS_INTEGER_OVERFLOW: 3001,
                EBML_OVERFLOW: 3002,
                EBML_BAD_FLOATING_POINT_SIZE: 3003,
                MP4_SIDX_WRONG_BOX_TYPE: 3004,
                MP4_SIDX_INVALID_TIMESCALE: 3005,
                MP4_SIDX_TYPE_NOT_SUPPORTED: 3006,
                WEBM_CUES_ELEMENT_MISSING: 3007,
                WEBM_EBML_HEADER_ELEMENT_MISSING: 3008,
                WEBM_SEGMENT_ELEMENT_MISSING: 3009,
                WEBM_INFO_ELEMENT_MISSING: 3010,
                WEBM_DURATION_ELEMENT_MISSING: 3011,
                WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING: 3012,
                WEBM_CUE_TIME_ELEMENT_MISSING: 3013,
                MEDIA_SOURCE_OPERATION_FAILED: 3014,
                MEDIA_SOURCE_OPERATION_THREW: 3015,
                VIDEO_ERROR: 3016,
                QUOTA_EXCEEDED_ERROR: 3017,
                TRANSMUXING_FAILED: 3018,
                CONTENT_TRANSFORMATION_FAILED: 3019,
                UNABLE_TO_GUESS_MANIFEST_TYPE: 4E3,
                DASH_INVALID_XML: 4001,
                DASH_NO_SEGMENT_INFO: 4002,
                DASH_EMPTY_ADAPTATION_SET: 4003,
                DASH_EMPTY_PERIOD: 4004,
                DASH_WEBM_MISSING_INIT: 4005,
                DASH_UNSUPPORTED_CONTAINER: 4006,
                DASH_PSSH_BAD_ENCODING: 4007,
                DASH_NO_COMMON_KEY_SYSTEM: 4008,
                DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED: 4009,
                DASH_CONFLICTING_KEY_IDS: 4010,
                RESTRICTIONS_CANNOT_BE_MET: 4012,
                HLS_PLAYLIST_HEADER_MISSING: 4015,
                INVALID_HLS_TAG: 4016,
                HLS_INVALID_PLAYLIST_HIERARCHY: 4017,
                DASH_DUPLICATE_REPRESENTATION_ID: 4018,
                HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND: 4020,
                HLS_REQUIRED_ATTRIBUTE_MISSING: 4023,
                HLS_REQUIRED_TAG_MISSING: 4024,
                HLS_COULD_NOT_GUESS_CODECS: 4025,
                HLS_KEYFORMATS_NOT_SUPPORTED: 4026,
                DASH_UNSUPPORTED_XLINK_ACTUATE: 4027,
                DASH_XLINK_DEPTH_LIMIT: 4028,
                CONTENT_UNSUPPORTED_BY_BROWSER: 4032,
                CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM: 4033,
                NO_VARIANTS: 4036,
                PERIOD_FLATTENING_FAILED: 4037,
                INCONSISTENT_DRM_ACROSS_PERIODS: 4038,
                HLS_VARIABLE_NOT_FOUND: 4039,
                HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED: 4040,
                HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED: 4041,
                NO_WEB_CRYPTO_API: 4042,
                HLS_AES_128_INVALID_IV_LENGTH: 4043,
                HLS_AES_128_INVALID_KEY_LENGTH: 4044,
                CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM: 4045,
                STREAMING_ENGINE_STARTUP_INVALID_STATE: 5006,
                NO_RECOGNIZED_KEY_SYSTEMS: 6E3,
                REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE: 6001,
                FAILED_TO_CREATE_CDM: 6002,
                FAILED_TO_ATTACH_TO_VIDEO: 6003,
                INVALID_SERVER_CERTIFICATE: 6004,
                FAILED_TO_CREATE_SESSION: 6005,
                FAILED_TO_GENERATE_LICENSE_REQUEST: 6006,
                LICENSE_REQUEST_FAILED: 6007,
                LICENSE_RESPONSE_REJECTED: 6008,
                ENCRYPTED_CONTENT_WITHOUT_DRM_INFO: 6010,
                NO_LICENSE_SERVER_GIVEN: 6012,
                OFFLINE_SESSION_REMOVED: 6013,
                EXPIRED: 6014,
                SERVER_CERTIFICATE_REQUIRED: 6015,
                INIT_DATA_TRANSFORM_ERROR: 6016,
                SERVER_CERTIFICATE_REQUEST_FAILED: 6017,
                LOAD_INTERRUPTED: 7E3,
                OPERATION_ABORTED: 7001,
                NO_VIDEO_ELEMENT: 7002,
                OBJECT_DESTROYED: 7003,
                CONTENT_NOT_LOADED: 7004,
                CAST_API_UNAVAILABLE: 8E3,
                NO_CAST_RECEIVERS: 8001,
                ALREADY_CASTING: 8002,
                UNEXPECTED_CAST_ERROR: 8003,
                CAST_CANCELED_BY_USER: 8004,
                CAST_CONNECTION_TIMED_OUT: 8005,
                CAST_RECEIVER_APP_UNAVAILABLE: 8006,
                STORAGE_NOT_SUPPORTED: 9E3,
                INDEXED_DB_ERROR: 9001,
                DEPRECATED_OPERATION_ABORTED: 9002,
                REQUESTED_ITEM_NOT_FOUND: 9003,
                MALFORMED_OFFLINE_URI: 9004,
                CANNOT_STORE_LIVE_OFFLINE: 9005,
                NO_INIT_DATA_FOR_OFFLINE: 9007,
                LOCAL_PLAYER_INSTANCE_REQUIRED: 9008,
                NEW_KEY_OPERATION_NOT_SUPPORTED: 9011,
                KEY_NOT_FOUND: 9012,
                MISSING_STORAGE_CELL: 9013,
                STORAGE_LIMIT_REACHED: 9014,
                DOWNLOAD_SIZE_CALLBACK_ERROR: 9015,
                MODIFY_OPERATION_NOT_SUPPORTED: 9016,
                INDEXED_DB_INIT_TIMED_OUT: 9017,
                CS_IMA_SDK_MISSING: 1E4,
                CS_AD_MANAGER_NOT_INITIALIZED: 10001,
                SS_IMA_SDK_MISSING: 10002,
                SS_AD_MANAGER_NOT_INITIALIZED: 10003,
                CURRENT_DAI_REQUEST_NOT_FINISHED: 10004
              }; /*
                 @license
                 Copyright 2008 The Closure Library Authors
                 SPDX-License-Identifier: Apache-2.0
                 */
              var Mb = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$"); /*
                                                                                                                                                 @license
                                                                                                                                                 Copyright 2006 The Closure Library Authors
                                                                                                                                                 SPDX-License-Identifier: Apache-2.0
                                                                                                                                                 */
              function Nb(a) {
                var b;
                a instanceof Nb ? (Ob(this, a.Ea), this.pb = a.pb, this.Ha = a.Ha, Pb(this, a.Kb), this.qa = a.qa, Qb(this, a.g.clone()), this.fb = a.fb) : a && (b = String(a).match(Mb)) ? (Ob(this, b[1] || "", !0), this.pb = Rb(b[2] || ""), this.Ha = Rb(b[3] || "", !0), Pb(this, b[4]), this.qa = Rb(b[5] || "", !0), Qb(this, b[6] || "", !0), this.fb = Rb(b[7] || "")) : this.g = new Sb(null);
              }
              q = Nb.prototype;
              q.Ea = "";
              q.pb = "";
              q.Ha = "";
              q.Kb = null;
              q.qa = "";
              q.fb = "";
              q.toString = function () {
                var a = [],
                  b = this.Ea;
                b && a.push(Tb(b, Ub, !0), ":");
                if (b = this.Ha) {
                  a.push("//");
                  var c = this.pb;
                  c && a.push(Tb(c, Ub, !0), "@");
                  a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g, "%$1"));
                  b = this.Kb;
                  null != b && a.push(":", String(b));
                }
                if (b = this.qa) this.Ha && "/" != b.charAt(0) && a.push("/"), a.push(Tb(b, "/" == b.charAt(0) ? Vb : Wb, !0));
                (b = this.g.toString()) && a.push("?", b);
                (b = this.fb) && a.push("#", Tb(b, Xb));
                return a.join("");
              };
              q.resolve = function (a) {
                var b = this.clone();
                "data" === b.Ea && (b = new Nb());
                var c = !!a.Ea;
                c ? Ob(b, a.Ea) : c = !!a.pb;
                c ? b.pb = a.pb : c = !!a.Ha;
                c ? b.Ha = a.Ha : c = null != a.Kb;
                var d = a.qa;
                if (c) Pb(b, a.Kb);else if (c = !!a.qa) {
                  if ("/" != d.charAt(0)) if (this.Ha && !this.qa) d = "/" + d;else {
                    var e = b.qa.lastIndexOf("/");
                    -1 != e && (d = b.qa.substr(0, e + 1) + d);
                  }
                  if (".." == d || "." == d) d = "";else if (-1 != d.indexOf("./") || -1 != d.indexOf("/.")) {
                    e = 0 == d.lastIndexOf("/", 0);
                    d = d.split("/");
                    for (var f = [], g = 0; g < d.length;) {
                      var h = d[g++];
                      "." == h ? e && g == d.length && f.push("") : ".." == h ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), e && g == d.length && f.push("")) : (f.push(h), e = !0);
                    }
                    d = f.join("/");
                  }
                }
                c ? b.qa = d : c = "" !== a.g.toString();
                c ? Qb(b, a.g.clone()) : c = !!a.fb;
                c && (b.fb = a.fb);
                return b;
              };
              q.clone = function () {
                return new Nb(this);
              };
              function Ob(a, b, c) {
                a.Ea = c ? Rb(b, !0) : b;
                a.Ea && (a.Ea = a.Ea.replace(/:$/, ""));
              }
              function Pb(a, b) {
                if (b) {
                  b = Number(b);
                  if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);
                  a.Kb = b;
                } else a.Kb = null;
              }
              function Qb(a, b, c) {
                b instanceof Sb ? a.g = b : (c || (b = Tb(b, Yb)), a.g = new Sb(b));
              }
              function Rb(a, b) {
                return a ? b ? decodeURI(a) : decodeURIComponent(a) : "";
              }
              function Tb(a, b, c) {
                return null != a ? (a = encodeURI(a).replace(b, $b), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
              }
              function $b(a) {
                a = a.charCodeAt(0);
                return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
              }
              var Ub = /[#\/\?@]/g,
                Wb = /[#\?:]/g,
                Vb = /[#\?]/g,
                Yb = /[#\?@]/g,
                Xb = /#/g;
              function Sb(a) {
                this.g = a || null;
              }
              function ac(a) {
                if (!a.la && (a.la = {}, a.Oc = 0, a.g)) for (var b = a.g.split("&"), c = 0; c < b.length; c++) {
                  var d = b[c].indexOf("="),
                    e = null;
                  if (0 <= d) {
                    var f = b[c].substring(0, d);
                    e = b[c].substring(d + 1);
                  } else f = b[c];
                  f = decodeURIComponent(f.replace(/\+/g, " "));
                  e = e || "";
                  a.add(f, decodeURIComponent(e.replace(/\+/g, " ")));
                }
              }
              q = Sb.prototype;
              q.la = null;
              q.Oc = null;
              q.add = function (a, b) {
                ac(this);
                this.g = null;
                var c = this.la.hasOwnProperty(a) ? this.la[a] : null;
                c || (this.la[a] = c = []);
                c.push(b);
                this.Oc++;
                return this;
              };
              q.set = function (a, b) {
                ac(this);
                this.g = null;
                this.la.hasOwnProperty(a) ? this.la[a] = [b] : this.add(a, b);
                return this;
              };
              q.toString = function () {
                if (this.g) return this.g;
                if (!this.la) return "";
                var a = [],
                  b;
                for (b in this.la) for (var c = encodeURIComponent(b), d = this.la[b], e = 0; e < d.length; e++) {
                  var f = c;
                  "" !== d[e] && (f += "=" + encodeURIComponent(d[e]));
                  a.push(f);
                }
                return this.g = a.join("&");
              };
              q.clone = function () {
                var a = new Sb();
                a.g = this.g;
                if (this.la) {
                  var b = {},
                    c;
                  for (c in this.la) b[c] = this.la[c].concat();
                  a.la = b;
                  a.Oc = this.Oc;
                }
                return a;
              };
              function bc(a, b) {
                return a.concat(b);
              }
              function cc() {}
              function dc(a) {
                return null != a;
              }
              function ec(a, b) {
                if (0 == b.length) return a;
                var c = b.map(function (d) {
                  return new Nb(d);
                });
                return a.map(function (d) {
                  return new Nb(d);
                }).map(function (d) {
                  return c.map(function (e) {
                    return d.resolve(e);
                  });
                }).reduce(bc, []).map(function (d) {
                  return d.toString();
                });
              }
              function fc(a, b) {
                return {
                  keySystem: a,
                  licenseServerUri: "",
                  distinctiveIdentifierRequired: !1,
                  persistentStateRequired: !1,
                  audioRobustness: "",
                  videoRobustness: "",
                  serverCertificate: null,
                  serverCertificateUri: "",
                  sessionType: "",
                  initData: b || [],
                  keyIds: new Set()
                };
              }
              function gc(a, b) {
                if (1 == b.length) return b[0];
                a = hc(a, b);
                if (null != a) return a;
                throw new O(2, 4, 4025, b);
              }
              function hc(a, b) {
                for (var c = r(ic[a]), d = c.next(); !d.done; d = c.next()) {
                  d = d.value;
                  for (var e = r(b), f = e.next(); !f.done; f = e.next()) if (f = f.value, d.test(f.trim())) return f.trim();
                }
                return a == jc ? "" : null;
              }
              var jc = "text",
                kc = {
                  va: "video",
                  Hc: "audio",
                  X: jc,
                  Wb: "image",
                  Gg: "application"
                },
                ic = {
                  audio: [/^vorbis$/, /^opus$/, /^flac$/, /^mp4a/, /^[ae]c-3$/, /^ac-4$/, /^dts[cx]$/, /^[du]dts$/],
                  video: [/^avc/, /^hev/, /^hvc/, /^vp0?[89]/, /^av01/, /^dvhe/],
                  text: [/^vtt$/, /^wvtt/, /^stpp/]
                };
              function lc() {
                var a,
                  b,
                  c = new Promise(function (d, e) {
                    a = d;
                    b = e;
                  });
                c.resolve = a;
                c.reject = b;
                return c;
              }
              lc.prototype.resolve = function () {};
              lc.prototype.reject = function () {};
              function mc(a) {
                this.h = a;
                this.g = void 0;
              }
              mc.prototype.value = function () {
                void 0 == this.g && (this.g = this.h());
                return this.g;
              };
              function nc(a) {
                this.h = a;
                this.g = null;
              }
              nc.prototype.N = function (a) {
                var b = this;
                this.stop();
                var c = !0,
                  d = null;
                this.g = function () {
                  window.clearTimeout(d);
                  c = !1;
                };
                d = window.setTimeout(function () {
                  c && b.h();
                }, 1E3 * a);
                return this;
              };
              nc.prototype.stop = function () {
                this.g && (this.g(), this.g = null);
              };
              function P(a) {
                this.h = a;
                this.g = null;
              }
              P.prototype.Mb = function () {
                this.stop();
                this.h();
                return this;
              };
              P.prototype.N = function (a) {
                var b = this;
                this.stop();
                this.g = new nc(function () {
                  b.h();
                }).N(a);
                return this;
              };
              P.prototype.Ca = function (a) {
                var b = this;
                this.stop();
                this.g = new nc(function () {
                  b.g.N(a);
                  b.h();
                }).N(a);
                return this;
              };
              P.prototype.stop = function () {
                this.g && (this.g.stop(), this.g = null);
              };
              K("shaka.util.Timer", P);
              P.prototype.stop = P.prototype.stop;
              P.prototype.tickEvery = P.prototype.Ca;
              P.prototype.tickAfter = P.prototype.N;
              P.prototype.tickNow = P.prototype.Mb;
              function oc() {
                return window.MediaSource && MediaSource.isTypeSupported ? !0 : !1;
              }
              function pc(a) {
                return "" != qc().canPlayType(a);
              }
              function rc() {
                return navigator.userAgent.match(/Edge?\//) ? !0 : !1;
              }
              function sc() {
                return tc("Xbox One");
              }
              function uc() {
                return tc("Tizen");
              }
              function vc() {
                return tc("Web0S") && tc("Chrome/38.0.2125.122 Safari/537.36");
              }
              function wc() {
                return !!navigator.vendor && navigator.vendor.includes("Apple") && !uc() && !tc("PC=EOS") && !tc("VirginMedia") && !xc() && !tc("AFT");
              }
              function xc() {
                return tc("PlayStation 4");
              }
              function yc() {
                if (!wc()) return null;
                var a = navigator.userAgent.match(/Version\/(\d+)/);
                return a ? parseInt(a[1], 10) : (a = navigator.userAgent.match(/OS (\d+)(?:_\d+)?/)) ? parseInt(a[1], 10) : null;
              }
              function tc(a) {
                return (navigator.userAgent || "").includes(a);
              }
              function qc() {
                if (zc) return zc;
                Ac || (Ac = new P(function () {
                  zc = null;
                }));
                (zc = document.getElementsByTagName("video")[0] || document.getElementsByTagName("audio")[0]) || (zc = document.createElement("video"));
                Ac.N(1);
                return zc;
              }
              var Ac = null,
                zc = null;
              function Bc() {}
              function Cc(a) {
                if (!a) return "";
                a = M(a);
                239 == a[0] && 187 == a[1] && 191 == a[2] && (a = a.subarray(3));
                if (window.TextDecoder && !xc()) return a = new TextDecoder().decode(a), a.includes("\ufffd") && Va('Decoded string contains an "unknown character" codepoint.  That probably means the UTF8 encoding was incorrect!'), a;
                for (var b = "", c = 0; c < a.length; ++c) {
                  var d = 65533;
                  0 == (a[c] & 128) ? d = a[c] : a.length >= c + 2 && 192 == (a[c] & 224) && 128 == (a[c + 1] & 192) ? (d = (a[c] & 31) << 6 | a[c + 1] & 63, c += 1) : a.length >= c + 3 && 224 == (a[c] & 240) && 128 == (a[c + 1] & 192) && 128 == (a[c + 2] & 192) ? (d = (a[c] & 15) << 12 | (a[c + 1] & 63) << 6 | a[c + 2] & 63, c += 2) : a.length >= c + 4 && 240 == (a[c] & 241) && 128 == (a[c + 1] & 192) && 128 == (a[c + 2] & 192) && 128 == (a[c + 3] & 192) && (d = (a[c] & 7) << 18 | (a[c + 1] & 63) << 12 | (a[c + 2] & 63) << 6 | a[c + 3] & 63, c += 3);
                  if (65535 >= d) b += String.fromCharCode(d);else {
                    d -= 65536;
                    var e = d & 1023;
                    b += String.fromCharCode(55296 + (d >> 10));
                    b += String.fromCharCode(56320 + e);
                  }
                }
                return b;
              }
              function Dc(a, b, c) {
                if (!a) return "";
                if (!c && 0 != a.byteLength % 2) throw new O(2, 2, 2004);
                c = Math.floor(a.byteLength / 2);
                var d = new Uint16Array(c);
                a = Lb(a);
                for (var e = 0; e < c; e++) d[e] = a.getUint16(2 * e, b);
                return Ec.value()(d);
              }
              function Fc(a) {
                function b(d) {
                  return c.byteLength <= d || 32 <= c[d] && 126 >= c[d];
                }
                if (!a) return "";
                var c = M(a);
                if (239 == c[0] && 187 == c[1] && 191 == c[2]) return Cc(c);
                if (254 == c[0] && 255 == c[1]) return Dc(c.subarray(2), !1);
                if (255 == c[0] && 254 == c[1]) return Dc(c.subarray(2), !0);
                if (0 == c[0] && 0 == c[2]) return Dc(a, !1);
                if (0 == c[1] && 0 == c[3]) return Dc(a, !0);
                if (b(0) && b(1) && b(2) && b(3)) return Cc(a);
                throw new O(2, 2, 2003);
              }
              function Gc(a) {
                if (window.TextEncoder && !xc()) {
                  var b = new TextEncoder();
                  return Ib(b.encode(a));
                }
                a = encodeURIComponent(a);
                a = unescape(a);
                b = new Uint8Array(a.length);
                for (var c = 0; c < a.length; c++) b[c] = a[c].charCodeAt(0);
                return Ib(b);
              }
              function Hc(a, b) {
                for (var c = new ArrayBuffer(2 * a.length), d = new DataView(c), e = 0; e < a.length; ++e) d.setUint16(2 * e, a.charCodeAt(e), b);
                return c;
              }
              K("shaka.util.StringUtils", Bc);
              Bc.resetFromCharCode = function () {
                Ec.g = void 0;
              };
              Bc.toUTF16 = Hc;
              Bc.toUTF8 = Gc;
              Bc.fromBytesAutoDetect = Fc;
              Bc.fromUTF16 = Dc;
              Bc.fromUTF8 = Cc;
              var Ec = new mc(function () {
                function a(c) {
                  try {
                    var d = new Uint8Array(c);
                    return 0 < String.fromCharCode.apply(null, d).length;
                  } catch (e) {
                    return !1;
                  }
                }
                for (var b = {
                  Ua: 65536
                }; 0 < b.Ua; b = {
                  Ua: b.Ua
                }, b.Ua /= 2) if (a(b.Ua)) return function (c) {
                  return function (d) {
                    for (var e = "", f = 0; f < d.length; f += c.Ua) e += String.fromCharCode.apply(null, d.subarray(f, f + c.Ua));
                    return e;
                  };
                }(b);
                return null;
              });
              function Ic() {}
              function Jc(a) {
                a = M(a);
                a = Ec.value()(a);
                return btoa(a);
              }
              function Kc(a, b) {
                b = void 0 == b ? !0 : b;
                a = Jc(a).replace(/\+/g, "-").replace(/\//g, "_");
                return b ? a : a.replace(/[=]*$/, "");
              }
              function Lc(a) {
                a = window.atob(a.replace(/-/g, "+").replace(/_/g, "/"));
                for (var b = new Uint8Array(a.length), c = 0; c < a.length; ++c) b[c] = a.charCodeAt(c);
                return b;
              }
              function Mc(a) {
                for (var b = a.length / 2, c = new Uint8Array(b), d = 0; d < b; d++) c[d] = window.parseInt(a.substr(2 * d, 2), 16);
                return c;
              }
              function Nc(a) {
                var b = M(a);
                a = "";
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) c = c.value, c = c.toString(16), 1 == c.length && (c = "0" + c), a += c;
                return a;
              }
              function Oc() {
                for (var a = Fa.apply(0, arguments), b = 0, c = r(a), d = c.next(); !d.done; d = c.next()) b += d.value.byteLength;
                b = new Uint8Array(b);
                c = 0;
                a = r(a);
                for (d = a.next(); !d.done; d = a.next()) d = d.value, b.set(M(d), c), c += d.byteLength;
                return b;
              }
              K("shaka.util.Uint8ArrayUtils", Ic);
              Ic.concat = Oc;
              Ic.toHex = Nc;
              Ic.fromHex = Mc;
              Ic.fromBase64 = Lc;
              Ic.toBase64 = Kc;
              Ic.toStandardBase64 = Jc;
              function Pc() {}
              K("shaka.dependencies", Pc);
              Pc.has = function (a) {
                return Qc.has(a);
              };
              Pc.add = function (a, b) {
                if (!Rc[a]) throw Error(a + " is not supported");
                Qc.set(a, function () {
                  return b;
                });
              };
              var Rc = {
                muxjs: "muxjs"
              };
              Pc.Allowed = Rc;
              var Qc = new Map([["muxjs", function () {
                return window.muxjs;
              }]]);
              function Sc(a) {
                var b = this;
                this.o = a;
                this.m = Qc.get("muxjs")();
                this.h = this.g = null;
                this.l = [];
                this.i = [];
                this.j = !1;
                this.m && (this.g = new this.m.mp4.Transmuxer({
                  keepOriginalTimestamps: !0
                }), this.g.on("data", function (c) {
                  b.i = c.captions;
                  b.l.push(Oc(c.initSegment, c.data));
                }), this.g.on("done", function () {
                  var c = {
                    data: Oc.apply(Ic, ha(b.l)),
                    captions: b.i
                  };
                  b.h.resolve(c);
                  b.j = !1;
                }));
              }
              Sc.prototype.destroy = function () {
                this.g && this.g.dispose();
                this.g = null;
                return Promise.resolve();
              };
              function Tc(a, b) {
                var c = Uc(a),
                  d = "audio/aac" == a.toLowerCase().split(";")[0];
                if (!Qc.get("muxjs")() || !c && !d) return !1;
                if (d) return eb('audio/mp4; codecs="mp4a.40.2"');
                if (b) return eb(Vc(b, a));
                b = Vc("audio", a);
                a = Vc("video", a);
                return eb(b) || eb(a);
              }
              function Uc(a) {
                return "mp2t" == a.toLowerCase().split(";")[0].split("/")[1];
              }
              function Wc(a, b) {
                return "audio/aac" == b.toLowerCase().split(";")[0] ? 'audio/mp4; codecs="mp4a.40.2"' : Uc(b) ? Vc(a, b) : b;
              }
              function Vc(a, b) {
                b = b.replace(/mp2t/i, "mp4");
                "audio" == a && (b = b.replace("video", "audio"));
                if (a = /avc1\.(66|77|100)\.(\d+)/.exec(b)) {
                  var c = "avc1.",
                    d = a[1],
                    e = Number(a[2]);
                  c = ("66" == d ? c + "4200" : "77" == d ? c + "4d00" : c + "6400") + (e >> 4).toString(16);
                  c += (e & 15).toString(16);
                  b = b.replace(a[0], c);
                }
                return b;
              }
              function Xc(a, b) {
                a.j = !0;
                a.h = new lc();
                a.l = [];
                a.i = [];
                b = M(b);
                a.g.push(b);
                a.g.flush();
                a.j && a.h.reject(new O(2, 3, 3018));
                return a.h;
              }
              function Yc() {}
              function Zc(a, b) {
                b && (a += '; codecs="' + b + '"');
                return a;
              }
              function $c(a, b, c) {
                b = Zc(a, b);
                return Tc(b, c) ? Wc(c, b) : "video/mp2t" != a && "audio" == c ? b.replace("video", "audio") : b;
              }
              function ad(a) {
                var b = bd(a);
                a = b[0];
                b = b[1].toLowerCase();
                switch (!0) {
                  case "mp4a" === a && "69" === b:
                  case "mp4a" === a && "6b" === b:
                    return "mp3";
                  case "mp4a" === a && "66" === b:
                  case "mp4a" === a && "67" === b:
                  case "mp4a" === a && "68" === b:
                  case "mp4a" === a && "40.2" === b:
                  case "mp4a" === a && "40.02" === b:
                  case "mp4a" === a && "40.5" === b:
                  case "mp4a" === a && "40.05" === b:
                  case "mp4a" === a && "40.29" === b:
                  case "mp4a" === a && "40.42" === b:
                    return "aac";
                  case "mp4a" === a && "a5" === b:
                    return "ac-3";
                  case "mp4a" === a && "a6" === b:
                    return "ec-3";
                  case "mp4a" === a && "b2" === b:
                    return "dtsx";
                  case "mp4a" === a && "a9" === b:
                    return "dtsc";
                  case "avc1" === a:
                  case "avc3" === a:
                    return "avc";
                  case "hvc1" === a:
                  case "hev1" === a:
                    return "hevc";
                  case "dvh1" === a:
                  case "dvhe" === a:
                    return "dovi";
                }
                return a;
              }
              function cd(a) {
                a = a.split(/ *; */);
                a.shift();
                return (a = a.find(function (b) {
                  return b.startsWith("codecs=");
                })) ? a.split("=")[1].replace(/^"|"$/g, "") : "";
              }
              function bd(a) {
                a = a.split(".");
                var b = a[0];
                a.shift();
                return [b, a.join(".")];
              }
              K("shaka.util.MimeUtils", Yc);
              Yc.getFullType = Zc;
              new Map().set("codecs", "codecs").set("frameRate", "framerate").set("bandwidth", "bitrate").set("width", "width").set("height", "height").set("channelsCount", "channels");
              function dd(a) {
                this.j = null;
                this.i = a;
                this.u = !1;
                this.l = this.s = 0;
                this.m = Infinity;
                this.h = this.g = null;
                this.B = "";
                this.o = new Map();
              }
              function ed(a) {
                return fd[a] || "application/cea-608" == a || "application/cea-708" == a ? !0 : !1;
              }
              dd.prototype.destroy = function () {
                this.i = this.j = null;
                this.o.clear();
                return Promise.resolve();
              };
              function gd(a, b, c, d) {
                var e, f, g, h;
                return G(function (k) {
                  if (1 == k.g) return u(k, Promise.resolve(), 2);
                  if (!a.j || !a.i) return k.return();
                  if (null == c || null == d) return a.j.parseInit(M(b)), k.return();
                  e = a.u ? c : a.s;
                  f = {
                    periodStart: a.s,
                    segmentStart: c,
                    segmentEnd: d,
                    vttOffset: e
                  };
                  g = a.j.parseMedia(M(b), f);
                  h = g.filter(function (l) {
                    return l.startTime >= a.l && l.startTime < a.m;
                  });
                  a.i.append(h);
                  null == a.g && (a.g = Math.max(c, a.l));
                  a.h = Math.min(d, a.m);
                  A(k);
                });
              }
              dd.prototype.remove = function (a, b) {
                var c = this;
                return G(function (d) {
                  if (1 == d.g) return u(d, Promise.resolve(), 2);
                  !c.i || !c.i.remove(a, b) || null == c.g || b <= c.g || a >= c.h || (a <= c.g && b >= c.h ? c.g = c.h = null : a <= c.g && b < c.h ? c.g = b : a > c.g && b >= c.h && (c.h = a));
                  A(d);
                });
              };
              function hd(a, b, c) {
                a.l = b;
                a.m = c;
              }
              function id(a, b, c) {
                a.B = b;
                if (b = a.o.get(b)) for (var d = r(b.keys()), e = d.next(); !e.done; e = d.next()) (e = b.get(e.value).filter(function (f) {
                  return f.endTime <= c;
                })) && a.i.append(e);
              }
              function jd(a) {
                var b = [];
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) c = c.value, b.push({
                  stream: c.stream,
                  cue: new kb(c.startTime, c.endTime, c.text)
                });
                return b;
              }
              function kd(a, b, c) {
                b.startTime += c;
                b.endTime += c;
                b = r(b.nestedCues);
                for (var d = b.next(); !d.done; d = b.next()) kd(a, d.value, c);
              }
              function ld(a, b, c, d, e) {
                var f = c + " " + d,
                  g = new Map();
                b = r(b);
                for (var h = b.next(); !h.done; h = b.next()) {
                  var k = h.value;
                  h = k.stream;
                  k = k.cue;
                  g.has(h) || g.set(h, new Map());
                  g.get(h).has(f) || g.get(h).set(f, []);
                  kd(a, k, e);
                  k.startTime >= a.l && k.startTime < a.m && (g.get(h).get(f).push(k), h == a.B && a.i.append([k]));
                }
                e = r(g.keys());
                for (f = e.next(); !f.done; f = e.next()) for (f = f.value, a.o.has(f) || a.o.set(f, new Map()), b = r(g.get(f).keys()), h = b.next(); !h.done; h = b.next()) h = h.value, k = g.get(f).get(h), a.o.get(f).set(h, k);
                a.g = null == a.g ? Math.max(c, a.l) : Math.min(a.g, Math.max(c, a.l));
                a.h = Math.max(a.h, Math.min(d, a.m));
              }
              K("shaka.text.TextEngine", dd);
              dd.prototype.destroy = dd.prototype.destroy;
              dd.findParser = function (a) {
                return fd[a];
              };
              dd.unregisterParser = function (a) {
                delete fd[a];
              };
              dd.registerParser = function (a, b) {
                fd[a] = b;
              };
              var fd = {};
              function md() {}
              function nd(a, b) {
                a = od(a);
                b = od(b);
                return a.split("-")[0] == b.split("-")[0];
              }
              function pd(a, b) {
                a = od(a);
                b = od(b);
                a = a.split("-");
                b = b.split("-");
                return a[0] == b[0] && 1 == a.length && 2 == b.length;
              }
              function qd(a, b) {
                a = od(a);
                b = od(b);
                a = a.split("-");
                b = b.split("-");
                return 2 == a.length && 2 == b.length && a[0] == b[0];
              }
              function od(a) {
                var b = a.split("-");
                a = b[0] || "";
                b = b[1] || "";
                a = a.toLowerCase();
                a = rd.get(a) || a;
                return (b = b.toUpperCase()) ? a + "-" + b : a;
              }
              function sd(a, b) {
                a = od(a);
                b = od(b);
                return b == a ? 4 : pd(b, a) ? 3 : qd(b, a) ? 2 : pd(a, b) ? 1 : 0;
              }
              function td(a) {
                var b = a.indexOf("-");
                a = 0 <= b ? a.substring(0, b) : a;
                a = a.toLowerCase();
                return a = rd.get(a) || a;
              }
              function ud(a) {
                return a.language ? od(a.language) : a.audio && a.audio.language ? od(a.audio.language) : a.video && a.video.language ? od(a.video.language) : "und";
              }
              function vd(a, b) {
                a = od(a);
                var c = new Set(),
                  d = r(b);
                for (b = d.next(); !b.done; b = d.next()) c.add(od(b.value));
                d = r(c);
                for (b = d.next(); !b.done; b = d.next()) if (b = b.value, b == a) return b;
                d = r(c);
                for (b = d.next(); !b.done; b = d.next()) if (b = b.value, pd(b, a)) return b;
                d = r(c);
                for (b = d.next(); !b.done; b = d.next()) if (b = b.value, qd(b, a)) return b;
                c = r(c);
                for (b = c.next(); !b.done; b = c.next()) if (b = b.value, pd(a, b)) return b;
                return null;
              }
              K("shaka.util.LanguageUtils", md);
              md.findClosestLocale = vd;
              md.getLocaleForVariant = ud;
              md.getLocaleForText = function (a) {
                return od(a.language || "und");
              };
              md.getBase = td;
              md.relatedness = sd;
              md.areSiblings = function (a, b) {
                var c = td(a),
                  d = td(b);
                return a != c && b != d && c == d;
              };
              md.normalize = od;
              md.isSiblingOf = qd;
              md.isParentOf = pd;
              md.areLanguageCompatible = nd;
              md.areLocaleCompatible = function (a, b) {
                a = od(a);
                b = od(b);
                return a == b;
              };
              var rd = new Map([["aar", "aa"], ["abk", "ab"], ["afr", "af"], ["aka", "ak"], ["alb", "sq"], ["amh", "am"], ["ara", "ar"], ["arg", "an"], ["arm", "hy"], ["asm", "as"], ["ava", "av"], ["ave", "ae"], ["aym", "ay"], ["aze", "az"], ["bak", "ba"], ["bam", "bm"], ["baq", "eu"], ["bel", "be"], ["ben", "bn"], ["bih", "bh"], ["bis", "bi"], ["bod", "bo"], ["bos", "bs"], ["bre", "br"], ["bul", "bg"], ["bur", "my"], ["cat", "ca"], ["ces", "cs"], ["cha", "ch"], ["che", "ce"], ["chi", "zh"], ["chu", "cu"], ["chv", "cv"], ["cor", "kw"], ["cos", "co"], ["cre", "cr"], ["cym", "cy"], ["cze", "cs"], ["dan", "da"], ["deu", "de"], ["div", "dv"], ["dut", "nl"], ["dzo", "dz"], ["ell", "el"], ["eng", "en"], ["epo", "eo"], ["est", "et"], ["eus", "eu"], ["ewe", "ee"], ["fao", "fo"], ["fas", "fa"], ["fij", "fj"], ["fin", "fi"], ["fra", "fr"], ["fre", "fr"], ["fry", "fy"], ["ful", "ff"], ["geo", "ka"], ["ger", "de"], ["gla", "gd"], ["gle", "ga"], ["glg", "gl"], ["glv", "gv"], ["gre", "el"], ["grn", "gn"], ["guj", "gu"], ["hat", "ht"], ["hau", "ha"], ["heb", "he"], ["her", "hz"], ["hin", "hi"], ["hmo", "ho"], ["hrv", "hr"], ["hun", "hu"], ["hye", "hy"], ["ibo", "ig"], ["ice", "is"], ["ido", "io"], ["iii", "ii"], ["iku", "iu"], ["ile", "ie"], ["ina", "ia"], ["ind", "id"], ["ipk", "ik"], ["isl", "is"], ["ita", "it"], ["jav", "jv"], ["jpn", "ja"], ["kal", "kl"], ["kan", "kn"], ["kas", "ks"], ["kat", "ka"], ["kau", "kr"], ["kaz", "kk"], ["khm", "km"], ["kik", "ki"], ["kin", "rw"], ["kir", "ky"], ["kom", "kv"], ["kon", "kg"], ["kor", "ko"], ["kua", "kj"], ["kur", "ku"], ["lao", "lo"], ["lat", "la"], ["lav", "lv"], ["lim", "li"], ["lin", "ln"], ["lit", "lt"], ["ltz", "lb"], ["lub", "lu"], ["lug", "lg"], ["mac", "mk"], ["mah", "mh"], ["mal", "ml"], ["mao", "mi"], ["mar", "mr"], ["may", "ms"], ["mkd", "mk"], ["mlg", "mg"], ["mlt", "mt"], ["mon", "mn"], ["mri", "mi"], ["msa", "ms"], ["mya", "my"], ["nau", "na"], ["nav", "nv"], ["nbl", "nr"], ["nde", "nd"], ["ndo", "ng"], ["nep", "ne"], ["nld", "nl"], ["nno", "nn"], ["nob", "nb"], ["nor", "no"], ["nya", "ny"], ["oci", "oc"], ["oji", "oj"], ["ori", "or"], ["orm", "om"], ["oss", "os"], ["pan", "pa"], ["per", "fa"], ["pli", "pi"], ["pol", "pl"], ["por", "pt"], ["pus", "ps"], ["que", "qu"], ["roh", "rm"], ["ron", "ro"], ["rum", "ro"], ["run", "rn"], ["rus", "ru"], ["sag", "sg"], ["san", "sa"], ["sin", "si"], ["slk", "sk"], ["slo", "sk"], ["slv", "sl"], ["sme", "se"], ["smo", "sm"], ["sna", "sn"], ["snd", "sd"], ["som", "so"], ["sot", "st"], ["spa", "es"], ["sqi", "sq"], ["srd", "sc"], ["srp", "sr"], ["ssw", "ss"], ["sun", "su"], ["swa", "sw"], ["swe", "sv"], ["tah", "ty"], ["tam", "ta"], ["tat", "tt"], ["tel", "te"], ["tgk", "tg"], ["tgl", "tl"], ["tha", "th"], ["tib", "bo"], ["tir", "ti"], ["ton", "to"], ["tsn", "tn"], ["tso", "ts"], ["tuk", "tk"], ["tur", "tr"], ["twi", "tw"], ["uig", "ug"], ["ukr", "uk"], ["urd", "ur"], ["uzb", "uz"], ["ven", "ve"], ["vie", "vi"], ["vol", "vo"], ["wel", "cy"], ["wln", "wa"], ["wol", "wo"], ["xho", "xh"], ["yid", "yi"], ["yor", "yo"], ["zha", "za"], ["zho", "zh"], ["zul", "zu"]]);
              function wd() {
                this.g = {};
              }
              q = wd.prototype;
              q.push = function (a, b) {
                this.g.hasOwnProperty(a) ? this.g[a].push(b) : this.g[a] = [b];
              };
              q.get = function (a) {
                return (a = this.g[a]) ? a.slice() : null;
              };
              q.remove = function (a, b) {
                a in this.g && (this.g[a] = this.g[a].filter(function (c) {
                  return c != b;
                }), 0 == this.g[a].length && delete this.g[a]);
              };
              q.forEach = function (a) {
                for (var b in this.g) a(b, this.g[b]);
              };
              q.size = function () {
                return Object.keys(this.g).length;
              };
              q.keys = function () {
                return Object.keys(this.g);
              };
              function xd(a, b, c, d, e) {
                var f = a.variants;
                if (b.length || c.length) f = yd(f, b, c);
                f = zd(f, d);
                b = Ad(f);
                b = Bd(b);
                var g = Cd(b, e);
                a.variants = a.variants.filter(function (h) {
                  return Dd(h) == g ? !0 : !1;
                });
              }
              function Ad(a) {
                var b = new wd();
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) {
                  c = c.value;
                  var d = Dd(c);
                  b.push(d, c);
                }
                return b;
              }
              function Bd(a) {
                var b = 0,
                  c = new Map(),
                  d = a.size();
                a.forEach(function (e, f) {
                  f = r(f);
                  for (var g = f.next(); !g.done; g = f.next()) {
                    g = g.value;
                    var h = g.video;
                    if (h && h.width && h.height) {
                      h = h.width * h.height * (h.frameRate || 1);
                      c.has(h) || c.set(h, new wd());
                      var k = c.get(h);
                      k.push(e, g);
                      k.size() === d && (b = Math.max(b, h));
                    }
                  }
                });
                return b ? c.get(b) : a;
              }
              function yd(a, b, c) {
                var d = {};
                b = r(b);
                for (var e = b.next(); !e.done; d = {
                  xd: d.xd
                }, e = b.next()) if (d.xd = e.value, e = a.filter(function (f) {
                  return function (g) {
                    return g.video && g.video.codecs.startsWith(f.xd);
                  };
                }(d)), e.length) {
                  a = e;
                  break;
                }
                d = {};
                c = r(c);
                for (b = c.next(); !b.done; d = {
                  jd: d.jd
                }, b = c.next()) if (d.jd = b.value, b = a.filter(function (f) {
                  return function (g) {
                    return g.audio && g.audio.codecs.startsWith(f.jd);
                  };
                }(d)), b.length) {
                  a = b;
                  break;
                }
                return a;
              }
              function Cd(a, b) {
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) if (c = c.value, c == Ed || c == Fd) {
                  if (a = Gd(a, c), 1 == a.size()) return a.keys()[0];
                } else if (c == Hd) break;
                return Id(a);
              }
              function Gd(a, b) {
                var c = 0,
                  d = new wd();
                a.forEach(function (e, f) {
                  for (var g = 0, h = 0, k = r(f), l = k.next(); !l.done; l = k.next()) l = l.value, l.decodingInfos.length && (g += l.decodingInfos[0][b] ? 1 : 0, h++);
                  g /= h;
                  g > c ? (d.g = {}, d.push(e, f), c = g) : g == c && d.push(e, f);
                });
                return d;
              }
              function Id(a) {
                var b = "",
                  c = Infinity;
                a.forEach(function (d, e) {
                  var f = 0,
                    g = 0;
                  e = r(e);
                  for (var h = e.next(); !h.done; h = e.next()) f += h.value.bandwidth || 0, ++g;
                  f /= g;
                  f < c && (b = d, c = f);
                });
                return b;
              }
              function Dd(a) {
                var b = "";
                a.video && (b = ad(a.video.codecs));
                var c = "";
                a.audio && (c = ad(a.audio.codecs));
                return b + "-" + c;
              }
              function Jd(a, b, c) {
                a.variants = a.variants.filter(function (d) {
                  return Kd(d, b, c);
                });
              }
              function Kd(a, b, c) {
                function d(f, g, h) {
                  return f >= g && f <= h;
                }
                var e = a.video;
                if (0 != a.disabledUntilTime) {
                  if (a.disabledUntilTime > Date.now() / 1E3) return !1;
                  a.disabledUntilTime = 0;
                }
                return e && e.width && e.height && (!d(e.width, b.minWidth, Math.min(b.maxWidth, c.width)) || !d(e.height, b.minHeight, Math.min(b.maxHeight, c.height)) || !d(e.width * e.height, b.minPixels, b.maxPixels)) || a && a.video && a.video.frameRate && !d(a.video.frameRate, b.minFrameRate, b.maxFrameRate) || !d(a.bandwidth, b.minBandwidth, b.maxBandwidth) ? !1 : !0;
              }
              function Ld(a, b, c) {
                var d = !1;
                a = r(a);
                for (var e = a.next(); !e.done; e = a.next()) {
                  e = e.value;
                  var f = e.allowedByApplication;
                  e.allowedByApplication = Kd(e, b, c);
                  f != e.allowedByApplication && (d = !0);
                }
                return d;
              }
              function Md(a, b) {
                return G(function (c) {
                  if (1 == c.g) return u(c, Nd(b, 0 < b.offlineSessionIds.length), 2);
                  Od(a, b);
                  Pd(b);
                  return u(c, Qd(b), 0);
                });
              }
              function Nd(a, b) {
                return G(function (c) {
                  if (1 == c.g) return u(c, Rd(a.variants, b, !1), 2);
                  a.variants = a.variants.filter(function (d) {
                    var e = d.video;
                    if (e) {
                      var f = Sd(e.codecs);
                      if (e.codecs.includes(",")) {
                        var g = e.codecs.split(",");
                        f = gc("video", g);
                        f = Sd(f);
                        g = gc("audio", g);
                        g = Td(g);
                        var h = $c(e.mimeType, g, "audio");
                        if (!eb(h)) return !1;
                        f = [f, g].join();
                      }
                      g = $c(e.mimeType, f, "video");
                      if (!eb(g)) return !1;
                      e.codecs = f;
                    }
                    if (f = d.audio) {
                      g = Td(f.codecs);
                      h = $c(f.mimeType, g, "audio");
                      if (!eb(h)) return !1;
                      f.codecs = g;
                    }
                    if (sc() && e && (e.width && 1920 < e.width || e.height && 1080 < e.height) && (e.codecs.includes("avc1.") || e.codecs.includes("avc3."))) return $a(Ud(d)), !1;
                    (e = d.decodingInfos.some(function (k) {
                      return k.supported;
                    })) || $a(Ud(d));
                    return e;
                  });
                  A(c);
                });
              }
              function Rd(a, b, c) {
                var e, f, g, h, k, l, m, n, p, t;
                return G(function (v) {
                  if (a.some(function (y) {
                    return y.decodingInfos.length;
                  })) return v.return();
                  e = navigator.mediaCapabilities;
                  f = [];
                  g = function g(y, w) {
                    var x;
                    return G(function (C) {
                      if (1 == C.g) return D(C, 2), u(C, e.decodingInfo(w), 4);
                      if (2 != C.g) return x = C.h, y.decodingInfos.push(x), ta(C, 0);
                      ua(C);
                      JSON.stringify(w);
                      A(C);
                    });
                  };
                  h = r(a);
                  for (k = h.next(); !k.done; k = h.next()) for (l = k.value, m = Vd(l, b, c), n = r(m), p = n.next(); !p.done; p = n.next()) t = p.value, f.push(g(l, t));
                  return u(v, Promise.all(f), 0);
                });
              }
              function Vd(a, b, c) {
                var d = a.audio,
                  e = a.video;
                c = {
                  type: c ? "file" : "media-source"
                };
                if (e) {
                  var f = e.codecs;
                  if (e.codecs.includes(",")) {
                    var g = e.codecs.split(",");
                    f = gc("video", g);
                    f = Sd(f);
                    g = gc("audio", g);
                    g = $c(e.mimeType, g, "audio");
                    c.audio = {
                      contentType: g,
                      channels: 2,
                      bitrate: a.bandwidth || 1,
                      samplerate: 1,
                      spatialRendering: !1
                    };
                  }
                  f = Sd(f);
                  f = $c(e.mimeType, f, "video");
                  c.video = {
                    contentType: f,
                    width: e.width || 64,
                    height: e.height || 64,
                    bitrate: e.bandwidth || a.bandwidth || 1,
                    framerate: e.frameRate || 1
                  };
                  if (e.hdr) switch (e.hdr) {
                    case "SDR":
                      c.video.transferFunction = "srgb";
                      break;
                    case "PQ":
                      c.video.transferFunction = "pq";
                      break;
                    case "HLG":
                      c.video.transferFunction = "hlg";
                  }
                }
                d && (f = Td(d.codecs), f = $c(d.mimeType, f, "audio"), c.audio = {
                  contentType: f,
                  channels: d.channelsCount || 2,
                  bitrate: d.bandwidth || a.bandwidth || 1,
                  samplerate: d.audioSamplingRate || 1,
                  spatialRendering: d.spatialAudio
                });
                g = (a.video ? a.video.drmInfos : []).concat(a.audio ? a.audio.drmInfos : []);
                if (!g.length) return [c];
                a = [];
                f = new Map();
                g = r(g);
                for (var h = g.next(); !h.done; h = g.next()) {
                  var k = h.value;
                  f.get(k.keySystem) || f.set(k.keySystem, []);
                  f.get(k.keySystem).push(k);
                }
                g = b ? "required" : "optional";
                b = b ? ["persistent-license"] : ["temporary"];
                k = r(f.keys());
                for (var l = k.next(); !l.done; l = k.next()) {
                  var m = l.value;
                  l = Object.assign({}, c);
                  var n = f.get(m);
                  m = {
                    keySystem: m,
                    initDataType: "cenc",
                    persistentState: g,
                    distinctiveIdentifier: "optional",
                    sessionTypes: b
                  };
                  n = r(n);
                  for (h = n.next(); !h.done; h = n.next()) {
                    h = h.value;
                    if (h.initData && h.initData.length) {
                      for (var p = new Set(), t = r(h.initData), v = t.next(); !v.done; v = t.next()) p.add(v.value.initDataType);
                      m.initDataType = h.initData[0].initDataType;
                    }
                    h.distinctiveIdentifierRequired && (m.distinctiveIdentifier = "required");
                    h.persistentStateRequired && (m.persistentState = "required");
                    h.sessionType && (m.sessionTypes = [h.sessionType]);
                    d && ("" != h.audioRobustness ? m.audio ? m.audio.robustness = m.audio.robustness || h.audioRobustness : m.audio = {
                      robustness: h.audioRobustness
                    } : m.audio || (m.audio = {}));
                    e && ("" != h.videoRobustness ? m.video ? m.video.robustness = m.video.robustness || h.videoRobustness : m.video = {
                      robustness: h.videoRobustness
                    } : m.video || (m.video = {}));
                  }
                  l.keySystemConfiguration = m;
                  a.push(l);
                }
                return a;
              }
              function Td(a) {
                return uc() ? "ac-3" == a.toLowerCase() ? "ec-3" : a : a;
              }
              function Sd(a) {
                if (a.includes("avc1")) {
                  var b = a.split(".");
                  if (3 == b.length) return a = b.shift() + ".", a += parseInt(b.shift(), 10).toString(16), a += ("000" + parseInt(b.shift(), 10).toString(16)).slice(-4);
                } else if ("vp9" == a) return "vp09.00.41.08";
                return a;
              }
              function Od(a, b) {
                b.variants = b.variants.filter(function (c) {
                  var d = c.audio;
                  c = c.video;
                  return d && a && a.audio && !Wd(d, a.audio) || c && a && a.video && !Wd(c, a.video) ? !1 : !0;
                });
              }
              function Pd(a) {
                a.textStreams = a.textStreams.filter(function (b) {
                  return ed(Zc(b.mimeType, b.codecs));
                });
              }
              function Qd(a) {
                var b, c, d, e, f, g, h;
                return G(function (l) {
                  switch (l.g) {
                    case 1:
                      b = [], c = r(a.imageStreams), d = c.next();
                    case 2:
                      if (d.done) {
                        l.A(4);
                        break;
                      }
                      e = d.value;
                      f = e.mimeType;
                      if (Xd.has(f)) {
                        l.A(5);
                        break;
                      }
                      g = Yd.get(f);
                      if (!g) {
                        Xd.set(f, !1);
                        l.A(5);
                        break;
                      }
                      return u(l, Zd(g), 7);
                    case 7:
                      h = l.h, Xd.set(f, h);
                    case 5:
                      Xd.get(f) && b.push(e);
                      d = c.next();
                      l.A(2);
                      break;
                    case 4:
                      a.imageStreams = b, A(l);
                  }
                });
              }
              function Zd(a) {
                return new Promise(function (b) {
                  var c = new Image();
                  c.src = a;
                  "decode" in c ? c.decode().then(function () {
                    b(!0);
                  }).catch(function () {
                    b(!1);
                  }) : c.onload = c.onerror = function () {
                    b(2 === c.height);
                  };
                });
              }
              function Wd(a, b) {
                return a.mimeType != b.mimeType || a.codecs.split(".")[0] != b.codecs.split(".")[0] ? !1 : !0;
              }
              function $d(a) {
                var b = a.audio,
                  c = a.video,
                  d = b ? b.mimeType : null,
                  e = c ? c.mimeType : null,
                  f = b ? b.codecs : null,
                  g = c ? c.codecs : null,
                  h = [];
                g && h.push(g);
                f && h.push(f);
                var k = [];
                c && k.push(c.mimeType);
                b && k.push(b.mimeType);
                k = k[0] || null;
                var l = [];
                b && l.push(b.kind);
                c && l.push(c.kind);
                l = l[0] || null;
                var m = new Set();
                if (b) for (var n = r(b.roles), p = n.next(); !p.done; p = n.next()) m.add(p.value);
                if (c) for (n = r(c.roles), p = n.next(); !p.done; p = n.next()) m.add(p.value);
                a = {
                  id: a.id,
                  active: !1,
                  type: "variant",
                  bandwidth: a.bandwidth,
                  language: a.language,
                  label: null,
                  kind: l,
                  width: null,
                  height: null,
                  frameRate: null,
                  pixelAspectRatio: null,
                  hdr: null,
                  mimeType: k,
                  audioMimeType: d,
                  videoMimeType: e,
                  codecs: h.join(", "),
                  audioCodec: f,
                  videoCodec: g,
                  primary: a.primary,
                  roles: Array.from(m),
                  audioRoles: null,
                  forced: !1,
                  videoId: null,
                  audioId: null,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  tilesLayout: null,
                  audioBandwidth: null,
                  videoBandwidth: null,
                  originalVideoId: null,
                  originalAudioId: null,
                  originalTextId: null,
                  originalImageId: null
                };
                c && (a.videoId = c.id, a.originalVideoId = c.originalId, a.width = c.width || null, a.height = c.height || null, a.frameRate = c.frameRate || null, a.pixelAspectRatio = c.pixelAspectRatio || null, a.videoBandwidth = c.bandwidth || null);
                b && (a.audioId = b.id, a.originalAudioId = b.originalId, a.channelsCount = b.channelsCount, a.audioSamplingRate = b.audioSamplingRate, a.audioBandwidth = b.bandwidth || null, a.spatialAudio = b.spatialAudio, a.label = b.label, a.audioRoles = b.roles);
                return a;
              }
              function ae(a) {
                return {
                  id: a.id,
                  active: !1,
                  type: jc,
                  bandwidth: 0,
                  language: a.language,
                  label: a.label,
                  kind: a.kind || null,
                  width: null,
                  height: null,
                  frameRate: null,
                  pixelAspectRatio: null,
                  hdr: null,
                  mimeType: a.mimeType,
                  audioMimeType: null,
                  videoMimeType: null,
                  codecs: a.codecs || null,
                  audioCodec: null,
                  videoCodec: null,
                  primary: a.primary,
                  roles: a.roles,
                  audioRoles: null,
                  forced: a.forced,
                  videoId: null,
                  audioId: null,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  tilesLayout: null,
                  audioBandwidth: null,
                  videoBandwidth: null,
                  originalVideoId: null,
                  originalAudioId: null,
                  originalTextId: a.originalId,
                  originalImageId: null
                };
              }
              function be(a) {
                var b = a.width || null,
                  c = a.height || null,
                  d = null;
                a.segmentIndex && (d = a.segmentIndex.get(0));
                var e = a.tilesLayout;
                d && (e = d.tilesLayout || e);
                e && null != b && (b /= Number(e.split("x")[0]));
                e && null != c && (c /= Number(e.split("x")[1]));
                return {
                  id: a.id,
                  active: !1,
                  type: "image",
                  bandwidth: a.bandwidth || 0,
                  language: "",
                  label: null,
                  kind: null,
                  width: b,
                  height: c,
                  frameRate: null,
                  pixelAspectRatio: null,
                  hdr: null,
                  mimeType: a.mimeType,
                  audioMimeType: null,
                  videoMimeType: null,
                  codecs: null,
                  audioCodec: null,
                  videoCodec: null,
                  primary: !1,
                  roles: [],
                  audioRoles: null,
                  forced: !1,
                  videoId: null,
                  audioId: null,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  tilesLayout: e || null,
                  audioBandwidth: null,
                  videoBandwidth: null,
                  originalVideoId: null,
                  originalAudioId: null,
                  originalTextId: null,
                  originalImageId: a.originalId
                };
              }
              function ce(a) {
                a.__shaka_id || (a.__shaka_id = de++);
                return a.__shaka_id;
              }
              function ee(a) {
                var b = fe(a);
                b.active = "disabled" != a.mode;
                b.type = "text";
                b.originalTextId = a.id;
                "captions" == a.kind && (b.mimeType = "application/cea-608");
                a.kind && (b.roles = [a.kind]);
                "forced" == a.kind && (b.forced = !0);
                return b;
              }
              function ge(a) {
                var b = fe(a);
                b.active = a.enabled;
                b.type = "variant";
                b.originalAudioId = a.id;
                "main" == a.kind && (b.primary = !0);
                a.kind && (b.roles = [a.kind], b.audioRoles = [a.kind], b.label = a.label);
                return b;
              }
              function fe(a) {
                return {
                  id: ce(a),
                  active: !1,
                  type: "",
                  bandwidth: 0,
                  language: od(a.language),
                  label: a.label,
                  kind: a.kind,
                  width: null,
                  height: null,
                  frameRate: null,
                  pixelAspectRatio: null,
                  hdr: null,
                  mimeType: null,
                  audioMimeType: null,
                  videoMimeType: null,
                  codecs: null,
                  audioCodec: null,
                  videoCodec: null,
                  primary: !1,
                  roles: [],
                  forced: !1,
                  audioRoles: null,
                  videoId: null,
                  audioId: null,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  tilesLayout: null,
                  audioBandwidth: null,
                  videoBandwidth: null,
                  originalVideoId: null,
                  originalAudioId: null,
                  originalTextId: null,
                  originalImageId: null
                };
              }
              function he(a) {
                return a.allowedByApplication && a.allowedByKeySystem;
              }
              function ie(a) {
                return a.filter(function (b) {
                  return he(b);
                });
              }
              function zd(a, b) {
                var c = a.filter(function (g) {
                    return g.audio && g.audio.channelsCount;
                  }),
                  d = new Map();
                c = r(c);
                for (var e = c.next(); !e.done; e = c.next()) {
                  e = e.value;
                  var f = e.audio.channelsCount;
                  d.has(f) || d.set(f, []);
                  d.get(f).push(e);
                }
                c = Array.from(d.keys());
                if (0 == c.length) return a;
                a = c.filter(function (g) {
                  return g <= b;
                });
                return a.length ? d.get(Math.max.apply(Math, ha(a))) : d.get(Math.min.apply(Math, ha(c)));
              }
              function je(a, b, c, d) {
                var e = a,
                  f = a.filter(function (k) {
                    return k.primary;
                  });
                f.length && (e = f);
                var g = e.length ? e[0].language : "";
                e = e.filter(function (k) {
                  return k.language == g;
                });
                if (b) {
                  var h = vd(od(b), a.map(function (k) {
                    return k.language;
                  }));
                  h && (e = a.filter(function (k) {
                    return od(k.language) == h;
                  }));
                }
                e = e.filter(function (k) {
                  return k.forced == d;
                });
                if (c) {
                  if (a = ke(e, c), a.length) return a;
                } else if (a = e.filter(function (k) {
                  return 0 == k.roles.length;
                }), a.length) return a;
                a = e.map(function (k) {
                  return k.roles;
                }).reduce(bc, []);
                return a.length ? ke(e, a[0]) : e;
              }
              function ke(a, b) {
                return a.filter(function (c) {
                  return c.roles.includes(b);
                });
              }
              function Ud(a) {
                var b = [];
                a.audio && b.push(le(a.audio));
                a.video && b.push(le(a.video));
                return b.join(", ");
              }
              function le(a) {
                return "audio" == a.type ? "type=audio codecs=" + a.codecs + " bandwidth=" + a.bandwidth + " channelsCount=" + a.channelsCount + " audioSamplingRate=" + a.audioSamplingRate : "video" == a.type ? "type=video codecs=" + a.codecs + " bandwidth=" + a.bandwidth + " frameRate=" + a.frameRate + " width=" + a.width + " height=" + a.height : "unexpected stream type";
              }
              var de = 0,
                Ed = "smooth",
                Fd = "powerEfficient",
                Hd = "bandwidth",
                Xd = new Map().set("image/svg+xml", !0).set("image/png", !0).set("image/jpeg", !0).set("image/jpg", !0),
                Yd = new Map().set("image/webp", "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA").set("image/avif", "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=");
              function me() {
                var a = this;
                this.l = null;
                this.o = !1;
                this.i = new Ra();
                navigator.connection && navigator.connection.addEventListener("change", function () {
                  if (a.g.useNetworkInformation && a.o) {
                    a.i = new Ra();
                    a.g && a.i.configure(a.g.advanced);
                    var b = a.chooseVariant();
                    b && a.l(b);
                  }
                });
                this.m = [];
                this.u = 1;
                this.B = !1;
                this.h = this.j = this.g = this.s = null;
                this.D = new P(function () {
                  if (a.g.restrictToElementSize) {
                    var b = a.chooseVariant();
                    b && a.l(b);
                  }
                });
              }
              q = me.prototype;
              q.stop = function () {
                this.l = null;
                this.o = !1;
                this.m = [];
                this.u = 1;
                this.j = this.s = null;
                this.h && (this.h.disconnect(), this.h = null);
                this.D.stop();
              };
              q.init = function (a) {
                this.l = a;
              };
              q.chooseVariant = function () {
                var a = Infinity,
                  b = Infinity;
                this.g.restrictToScreenSize && (b = this.g.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio, a = window.screen.height * b, b *= window.screen.width);
                this.h && this.g.restrictToElementSize && (b = this.g.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio, a = this.j.clientWidth * b, b *= this.j.clientHeight);
                a = ne(this.g.restrictions, this.m, a, b);
                b = this.i.getBandwidthEstimate(oe(this));
                this.m.length && !a.length && (a = ne(null, this.m, Infinity, Infinity), a = [a[0]]);
                for (var c = a[0] || null, d = 0; d < a.length; d++) {
                  for (var e = a[d], f = isNaN(this.u) ? 1 : Math.abs(this.u), g = f * e.bandwidth / this.g.bandwidthDowngradeTarget, h = {
                      bandwidth: Infinity
                    }, k = d + 1; k < a.length; k++) if (e.bandwidth != a[k].bandwidth) {
                    h = a[k];
                    break;
                  }
                  f = f * h.bandwidth / this.g.bandwidthUpgradeTarget;
                  b >= g && b <= f && c.bandwidth != e.bandwidth && (c = e);
                }
                this.s = Date.now();
                return c;
              };
              q.enable = function () {
                this.o = !0;
              };
              q.disable = function () {
                this.o = !1;
              };
              q.segmentDownloaded = function (a, b) {
                this.i.sample(a, b);
                if (null != this.s && this.o) a: {
                  if (!this.B) {
                    a = this.i;
                    if (!(a.g >= a.i)) break a;
                    this.B = !0;
                  } else if (Date.now() - this.s < 1E3 * this.g.switchInterval) break a;
                  a = this.chooseVariant();
                  this.i.getBandwidthEstimate(oe(this));
                  a && this.l(a);
                }
              };
              q.getBandwidthEstimate = function () {
                return this.i.getBandwidthEstimate(oe(this));
              };
              q.setVariants = function (a) {
                this.m = a;
              };
              q.playbackRateChanged = function (a) {
                this.u = a;
              };
              q.setMediaElement = function (a) {
                var b = this;
                this.j = a;
                this.h && (this.h.disconnect(), this.h = null);
                this.j && "ResizeObserver" in window && (this.h = new ResizeObserver(function () {
                  b.D.N(pe);
                }), this.h.observe(this.j));
              };
              q.configure = function (a) {
                this.g = a;
                this.i && this.g && this.i.configure(this.g.advanced);
              };
              function oe(a) {
                var b = a.g.defaultBandwidthEstimate;
                navigator.connection && navigator.connection.downlink && a.g.useNetworkInformation && (b = 1E6 * navigator.connection.downlink);
                return b;
              }
              function ne(a, b, c, d) {
                a && (b = b.filter(function (e) {
                  return Kd(e, a, {
                    width: d,
                    height: c
                  });
                }));
                return b.sort(function (e, f) {
                  return e.bandwidth - f.bandwidth;
                });
              }
              K("shaka.abr.SimpleAbrManager", me);
              me.prototype.configure = me.prototype.configure;
              me.prototype.setMediaElement = me.prototype.setMediaElement;
              me.prototype.playbackRateChanged = me.prototype.playbackRateChanged;
              me.prototype.setVariants = me.prototype.setVariants;
              me.prototype.getBandwidthEstimate = me.prototype.getBandwidthEstimate;
              me.prototype.segmentDownloaded = me.prototype.segmentDownloaded;
              me.prototype.disable = me.prototype.disable;
              me.prototype.enable = me.prototype.enable;
              me.prototype.chooseVariant = me.prototype.chooseVariant;
              me.prototype.init = me.prototype.init;
              me.prototype.stop = me.prototype.stop;
              var pe = 1;
              function qe(a, b) {
                this.g = a;
                this.h = b;
              }
              qe.prototype.toString = function () {
                return "v" + this.g + "." + this.h;
              };
              function re(a, b) {
                var c = new qe(5, 0),
                  d = se,
                  e = d.g,
                  f = c.h - e.h;
                (0 < (c.g - e.g || f) ? d.i : d.h)(d.g, c, a, b);
              }
              function te(a, b, c, d) {
                Wa([c, "has been deprecated and will be removed in", b, ". We are currently at version", a, ". Additional information:", d].join(" "));
              }
              function ue(a, b, c, d) {
                Va([c, "has been deprecated and has been removed in", b, ". We are now at version", a, ". Additional information:", d].join(""));
              }
              var se = null;
              K("shaka.config.AutoShowText", {
                NEVER: 0,
                ALWAYS: 1,
                IF_PREFERRED_TEXT_LANGUAGE: 2,
                IF_SUBTITLES_MAY_BE_NEEDED: 3
              });
              function ve(a, b) {
                this.h = a;
                this.g = new Set([a]);
                b = b || [];
                a = r(b);
                for (b = a.next(); !b.done; b = a.next()) this.add(b.value);
              }
              ve.prototype.add = function (a) {
                return we(this.h, a) ? (this.g.add(a), !0) : !1;
              };
              function we(a, b) {
                var c;
                if (!(c = !!a.audio != !!b.audio || !!a.video != !!b.video || a.language != b.language) && (c = a.audio && b.audio)) {
                  c = a.audio;
                  var d = b.audio;
                  c = !((!(!c.channelsCount || !d.channelsCount || 2 < c.channelsCount || 2 < d.channelsCount) || c.channelsCount == d.channelsCount) && xe(c, d) && ye(c.roles, d.roles));
                }
                !c && (c = a.video && b.video) && (a = a.video, b = b.video, c = !(xe(a, b) && ye(a.roles, b.roles)));
                return c ? !1 : !0;
              }
              ve.prototype.values = function () {
                return this.g.values();
              };
              function xe(a, b) {
                if (a.mimeType != b.mimeType) return !1;
                a = a.codecs.split(",").map(function (d) {
                  return bd(d)[0];
                });
                b = b.codecs.split(",").map(function (d) {
                  return bd(d)[0];
                });
                if (a.length != b.length) return !1;
                a.sort();
                b.sort();
                for (var c = 0; c < a.length; c++) if (a[c] != b[c]) return !1;
                return !0;
              }
              function ye(a, b) {
                a = new Set(a);
                b = new Set(b);
                a.delete("main");
                b.delete("main");
                if (a.size != b.size) return !1;
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) if (!b.has(c.value)) return !1;
                return !0;
              }
              function ze(a) {
                this.g = a;
                this.h = new Ae(a.language, "", a.audio && a.audio.channelsCount ? a.audio.channelsCount : 0, "");
              }
              ze.prototype.create = function (a) {
                var b = this,
                  c = a.filter(function (d) {
                    return we(b.g, d);
                  });
                return c.length ? new ve(c[0], c) : this.h.create(a);
              };
              function Ae(a, b, c, d) {
                this.i = a;
                this.j = b;
                this.g = c;
                this.h = void 0 === d ? "" : d;
              }
              Ae.prototype.create = function (a) {
                var b = [];
                b = Be(a, this.i);
                var c = a.filter(function (d) {
                  return d.primary;
                });
                b = b.length ? b : c.length ? c : a;
                a = Ce(b, this.j);
                a.length && (b = a);
                this.g && (a = zd(b, this.g), a.length && (b = a));
                this.h && (a = De(b, this.h), a.length && (b = a));
                a = new ve(b[0]);
                b = r(b);
                for (c = b.next(); !c.done; c = b.next()) c = c.value, we(a.h, c) && a.add(c);
                return a;
              };
              function Be(a, b) {
                b = od(b);
                var c = vd(b, a.map(function (d) {
                  return ud(d);
                }));
                return c ? a.filter(function (d) {
                  return c == ud(d);
                }) : [];
              }
              function Ce(a, b) {
                return a.filter(function (c) {
                  return c.audio ? b ? c.audio.roles.includes(b) : 0 == c.audio.roles.length : !1;
                });
              }
              function De(a, b) {
                return a.filter(function (c) {
                  return c.audio ? c.audio.label.toLowerCase() == b.toLowerCase() : !1;
                });
              }
              function Ee() {
                this.g = Fe;
                this.h = new Map().set(Fe, 2).set(Ge, 1);
              }
              function He(a, b, c) {
                a.h.set(Fe, c).set(Ge, b);
              }
              var Ge = 0,
                Fe = 1;
              function Ie(a, b) {
                var c = Je();
                this.l = null == a.maxAttempts ? c.maxAttempts : a.maxAttempts;
                this.j = null == a.baseDelay ? c.baseDelay : a.baseDelay;
                this.o = null == a.fuzzFactor ? c.fuzzFactor : a.fuzzFactor;
                this.m = null == a.backoffFactor ? c.backoffFactor : a.backoffFactor;
                this.g = 0;
                this.h = this.j;
                if (this.i = void 0 === b ? !1 : b) this.g = 1;
              }
              function Ke(a) {
                var b, c;
                return G(function (d) {
                  if (1 == d.g) {
                    if (a.g >= a.l) if (a.i) a.g = 1, a.h = a.j;else throw new O(2, 7, 1010);
                    b = a.g;
                    a.g++;
                    if (0 == b) return d.return();
                    c = a.h * (1 + (2 * Math.random() - 1) * a.o);
                    return u(d, new Promise(function (e) {
                      new P(e).N(c / 1E3);
                    }), 2);
                  }
                  a.h *= a.m;
                  A(d);
                });
              }
              function Je() {
                return {
                  maxAttempts: 2,
                  baseDelay: 1E3,
                  backoffFactor: 2,
                  fuzzFactor: .5,
                  timeout: 3E4,
                  stallTimeout: 5E3,
                  connectionTimeout: 1E4
                };
              }
              function Le(a, b) {
                this.promise = a;
                this.i = b;
                this.g = !1;
              }
              function Me(a) {
                return new Le(Promise.reject(a), function () {
                  return Promise.resolve();
                });
              }
              function Ne() {
                var a = Promise.reject(new O(2, 7, 7001));
                a.catch(function () {});
                return new Le(a, function () {
                  return Promise.resolve();
                });
              }
              function Oe(a) {
                return new Le(Promise.resolve(a), function () {
                  return Promise.resolve();
                });
              }
              function Pe(a) {
                return new Le(a, function () {
                  return a.catch(function () {});
                });
              }
              Le.prototype.abort = function () {
                this.g = !0;
                return this.i();
              };
              function Qe(a) {
                return new Le(Promise.all(a.map(function (b) {
                  return b.promise;
                })), function () {
                  return Promise.all(a.map(function (b) {
                    return b.abort();
                  }));
                });
              }
              Le.prototype.finally = function (a) {
                this.promise.then(function () {
                  return a(!0);
                }, function () {
                  return a(!1);
                });
                return this;
              };
              Le.prototype.Y = function (a, b) {
                function c(h) {
                  return function (k) {
                    if (e.g && h) f.reject(g);else {
                      var l = h ? a : b;
                      l ? d = Re(l, k, f) : (h ? f.resolve : f.reject)(k);
                    }
                  };
                }
                function d() {
                  f.reject(g);
                  return e.abort();
                }
                var e = this,
                  f = new lc(),
                  g = new O(2, 7, 7001);
                this.promise.then(c(!0), c(!1));
                return new Le(f, function () {
                  return d();
                });
              };
              function Re(a, b, c) {
                try {
                  var d = a(b);
                  if (d && d.promise && d.abort) return c.resolve(d.promise), function () {
                    return d.abort();
                  };
                  c.resolve(d);
                  return function () {
                    return Promise.resolve(d).then(function () {}, function () {});
                  };
                } catch (e) {
                  return c.reject(e), function () {
                    return Promise.resolve();
                  };
                }
              }
              K("shaka.util.AbortableOperation", Le);
              Le.prototype.chain = Le.prototype.Y;
              Le.prototype["finally"] = Le.prototype.finally;
              Le.all = Qe;
              Le.prototype.abort = Le.prototype.abort;
              Le.notAbortable = Pe;
              Le.completed = Oe;
              Le.aborted = Ne;
              Le.failed = Me;
              function S(a, b) {
                if (b) if (b instanceof Map) for (var c = r(b.keys()), d = c.next(); !d.done; d = c.next()) d = d.value, Object.defineProperty(this, d, {
                  value: b.get(d),
                  writable: !0,
                  enumerable: !0
                });else for (c in b) Object.defineProperty(this, c, {
                  value: b[c],
                  writable: !0,
                  enumerable: !0
                });
                this.defaultPrevented = this.cancelable = this.bubbles = !1;
                this.timeStamp = window.performance && window.performance.now ? window.performance.now() : Date.now();
                this.type = a;
                this.isTrusted = !1;
                this.target = this.currentTarget = null;
                this.g = !1;
              }
              function Se(a) {
                var b = new S(a.type),
                  c;
                for (c in a) Object.defineProperty(b, c, {
                  value: a[c],
                  writable: !0,
                  enumerable: !0
                });
                return b;
              }
              S.prototype.preventDefault = function () {
                this.cancelable && (this.defaultPrevented = !0);
              };
              S.prototype.stopImmediatePropagation = function () {
                this.g = !0;
              };
              S.prototype.stopPropagation = function () {};
              K("shaka.util.FakeEvent", S);
              var Te = {
                Ig: "abrstatuschanged",
                Jg: "adaptation",
                Kg: "buffering",
                Lg: "downloadfailed",
                Mg: "downloadheadersreceived",
                Ng: "drmsessionupdate",
                Pg: "emsg",
                ah: "prft",
                Error: "error",
                Qg: "expirationupdated",
                Rg: "gapjumped",
                Tg: "loaded",
                Ug: "loading",
                Wg: "manifestparsed",
                Xg: "mediaqualitychanged",
                Metadata: "metadata",
                Zg: "onstatechange",
                $g: "onstateidle",
                bh: "ratechange",
                eh: "segmentappended",
                fh: "sessiondata",
                gh: "stalldetected",
                hh: "streaming",
                ih: "textchanged",
                jh: "texttrackvisibility",
                kh: "timelineregionadded",
                lh: "timelineregionenter",
                mh: "timelineregionexit",
                nh: "trackschanged",
                ph: "unloading",
                qh: "variantchanged"
              };
              function Ue() {
                this.da = new wd();
                this.Wc = this;
              }
              Ue.prototype.addEventListener = function (a, b) {
                this.da && this.da.push(a, b);
              };
              Ue.prototype.removeEventListener = function (a, b) {
                this.da && this.da.remove(a, b);
              };
              Ue.prototype.dispatchEvent = function (a) {
                if (!this.da) return !0;
                var b = this.da.get(a.type) || [],
                  c = this.da.get("All");
                c && (b = b.concat(c));
                b = r(b);
                for (c = b.next(); !c.done; c = b.next()) {
                  c = c.value;
                  a.target = this.Wc;
                  a.currentTarget = this.Wc;
                  try {
                    c.handleEvent ? c.handleEvent(a) : c.call(this, a);
                  } catch (d) {}
                  if (a.g) break;
                }
                return a.defaultPrevented;
              };
              Ue.prototype.release = function () {
                this.da = null;
              };
              function Ve(a) {
                function b(d) {
                  switch (typeof d) {
                    case "undefined":
                    case "boolean":
                    case "number":
                    case "string":
                    case "symbol":
                    case "function":
                      return d;
                    default:
                      if (!d || d.buffer && d.buffer.constructor == ArrayBuffer) return d;
                      if (c.has(d)) return null;
                      var e = d.constructor == Array;
                      if (d.constructor != Object && !e) return null;
                      c.add(d);
                      var f = e ? [] : {},
                        g;
                      for (g in d) f[g] = b(d[g]);
                      e && (f.length = d.length);
                      return f;
                  }
                }
                var c = new Set();
                return b(a);
              }
              function We(a) {
                var b = {},
                  c;
                for (c in a) b[c] = a[c];
                return b;
              }
              function Xe() {
                this.g = [];
              }
              function Ye(a, b) {
                a.g.push(b.finally(function () {
                  hb(a.g, b);
                }));
              }
              Xe.prototype.destroy = function () {
                for (var a = [], b = r(this.g), c = b.next(); !c.done; c = b.next()) c = c.value, c.promise.catch(function () {}), a.push(c.abort());
                this.g = [];
                return Promise.all(a);
              };
              function Ze(a, b, c) {
                Ue.call(this);
                this.i = !1;
                this.m = new Xe();
                this.g = new Set();
                this.h = new Set();
                this.l = a || null;
                this.j = b || null;
                this.s = c || null;
                this.o = !1;
              }
              oa(Ze, Ue);
              q = Ze.prototype;
              q.je = function (a) {
                this.o = a;
              };
              function $e(a, b, c, d) {
                c = c || af;
                var e = bf[a];
                if (!e || c >= e.priority) bf[a] = {
                  priority: c,
                  jg: b,
                  kg: void 0 === d ? !1 : d
                };
              }
              q.lg = function (a) {
                this.g.add(a);
              };
              q.Bg = function (a) {
                this.g.delete(a);
              };
              q.rf = function () {
                this.g.clear();
              };
              q.mg = function (a) {
                this.h.add(a);
              };
              q.Cg = function (a) {
                this.h.delete(a);
              };
              q.tf = function () {
                this.h.clear();
              };
              function cf(a, b, c) {
                return {
                  uris: a,
                  method: "GET",
                  body: null,
                  headers: {},
                  allowCrossSiteCredentials: !1,
                  retryParameters: b,
                  licenseRequestType: null,
                  sessionId: null,
                  drmInfo: null,
                  initData: null,
                  initDataType: null,
                  streamDataCallback: void 0 === c ? null : c
                };
              }
              q.destroy = function () {
                this.i = !0;
                this.g.clear();
                this.h.clear();
                Ue.prototype.release.call(this);
                return this.m.destroy();
              };
              q.request = function (a, b) {
                var c = this,
                  d = new df();
                if (this.i) {
                  var e = Promise.reject(new O(2, 7, 7001));
                  e.catch(function () {});
                  return new ef(e, function () {
                    return Promise.resolve();
                  }, d);
                }
                b.method = b.method || "GET";
                b.headers = b.headers || {};
                b.retryParameters = b.retryParameters ? Ve(b.retryParameters) : Je();
                b.uris = Ve(b.uris);
                e = ff(this, a, b);
                var f = e.Y(function () {
                    return gf(c, a, b, new Ie(b.retryParameters, !1), 0, null, d);
                  }),
                  g = f.Y(function (n) {
                    return hf(c, a, n);
                  }),
                  h = Date.now(),
                  k = 0;
                e.promise.then(function () {
                  k = Date.now() - h;
                }, function () {});
                var l = 0;
                f.promise.then(function () {
                  l = Date.now();
                }, function () {});
                var m = g.Y(function (n) {
                  var p = Date.now() - l,
                    t = n.response;
                  t.timeMs += k;
                  t.timeMs += p;
                  n.Yf || !c.l || t.fromCache || a != jf || c.l(t.timeMs, t.data.byteLength);
                  return t;
                }, function (n) {
                  n && (n.severity = 2);
                  throw n;
                });
                e = new ef(m.promise, function () {
                  return m.abort();
                }, d);
                Ye(this.m, e);
                return e;
              };
              function ff(a, b, c) {
                var d = Oe(void 0),
                  e = {};
                a = r(a.g);
                for (var f = a.next(); !f.done; e = {
                  sd: e.sd
                }, f = a.next()) e.sd = f.value, d = d.Y(function (g) {
                  return function () {
                    c.body && (c.body = Ib(c.body));
                    return g.sd(b, c);
                  };
                }(e));
                return d.Y(void 0, function (g) {
                  if (g instanceof O && 7001 == g.code) throw g;
                  throw new O(2, 1, 1006, g);
                });
              }
              function gf(a, b, c, d, e, f, g) {
                a.o && (c.uris[e] = c.uris[e].replace("http://", "https://"));
                var h = new Nb(c.uris[e]),
                  k = h.Ea,
                  l = !1;
                k || (k = location.protocol, k = k.slice(0, -1), Ob(h, k), c.uris[e] = h.toString());
                k = k.toLowerCase();
                var m = (k = bf[k]) ? k.jg : null;
                if (!m) return Me(new O(2, 1, 1E3, h));
                var n = k.kg,
                  p = null,
                  t = null,
                  v = !1,
                  y = !1,
                  w;
                return Pe(Ke(d)).Y(function () {
                  if (a.i) return Ne();
                  w = Date.now();
                  var x = m(c.uris[e], c, b, function (B, E, F) {
                    p && p.stop();
                    t && t.N(z / 1E3);
                    a.l && b == jf && (a.l(B, E), l = !0, g.g = F);
                  }, function (B) {
                    a.j && a.j(B, c, b);
                    y = !0;
                  });
                  if (!n) return x;
                  var C = c.retryParameters.connectionTimeout;
                  C && (p = new P(function () {
                    v = !0;
                    x.abort();
                  }), p.N(C / 1E3));
                  var z = c.retryParameters.stallTimeout;
                  z && (t = new P(function () {
                    v = !0;
                    x.abort();
                  }));
                  return x;
                }).Y(function (x) {
                  p && p.stop();
                  t && t.stop();
                  void 0 == x.timeMs && (x.timeMs = Date.now() - w);
                  var C = {
                    response: x,
                    Yf: l
                  };
                  !y && a.j && a.j(x.headers, c, b);
                  return C;
                }, function (x) {
                  p && p.stop();
                  t && t.stop();
                  if (a.s) {
                    var C = null,
                      z = 0;
                    x instanceof O && (C = x, 1001 == x.code && (z = x.data[1]));
                    a.s(c, C, z, v);
                  }
                  if (a.i) return Ne();
                  v && (x = new O(1, 1, 1003, c.uris[e], b));
                  if (x instanceof O) {
                    if (7001 == x.code) throw x;
                    if (1010 == x.code) throw f;
                    if (1 == x.severity) return C = new Map().set("error", x), C = new S("retry", C), a.dispatchEvent(C), e = (e + 1) % c.uris.length, gf(a, b, c, d, e, x, g);
                  }
                  throw x;
                });
              }
              function hf(a, b, c) {
                var d = Oe(void 0),
                  e = {};
                a = r(a.h);
                for (var f = a.next(); !f.done; e = {
                  td: e.td
                }, f = a.next()) e.td = f.value, d = d.Y(function (g) {
                  return function () {
                    var h = c.response;
                    h.data && (h.data = Ib(h.data));
                    return g.td(b, h);
                  };
                }(e));
                return d.Y(function () {
                  return c;
                }, function (g) {
                  var h = 2;
                  if (g instanceof O) {
                    if (7001 == g.code) throw g;
                    h = g.severity;
                  }
                  throw new O(h, 1, 1007, g);
                });
              }
              K("shaka.net.NetworkingEngine", Ze);
              Ze.prototype.request = Ze.prototype.request;
              Ze.prototype.destroy = Ze.prototype.destroy;
              Ze.makeRequest = cf;
              Ze.defaultRetryParameters = function () {
                return Je();
              };
              Ze.prototype.clearAllResponseFilters = Ze.prototype.tf;
              Ze.prototype.unregisterResponseFilter = Ze.prototype.Cg;
              Ze.prototype.registerResponseFilter = Ze.prototype.mg;
              Ze.prototype.clearAllRequestFilters = Ze.prototype.rf;
              Ze.prototype.unregisterRequestFilter = Ze.prototype.Bg;
              Ze.prototype.registerRequestFilter = Ze.prototype.lg;
              Ze.unregisterScheme = function (a) {
                delete bf[a];
              };
              Ze.registerScheme = $e;
              Ze.prototype.setForceHTTPS = Ze.prototype.je;
              function df() {
                this.g = 0;
              }
              Ze.NumBytesRemainingClass = df;
              function ef(a, b, c) {
                Le.call(this, a, b);
                this.h = c;
              }
              oa(ef, Le);
              Ze.PendingRequest = ef;
              var jf = 1;
              Ze.RequestType = {
                MANIFEST: 0,
                SEGMENT: jf,
                LICENSE: 2,
                APP: 3,
                TIMING: 4,
                SERVER_CERTIFICATE: 5,
                KEY: 6
              };
              var af = 3;
              Ze.PluginPriority = {
                FALLBACK: 1,
                PREFERRED: 2,
                APPLICATION: af
              };
              var bf = {};
              function kf(a) {
                this.g = !1;
                this.h = new lc();
                this.i = a;
              }
              kf.prototype.destroy = function () {
                var a = this;
                if (this.g) return this.h;
                this.g = !0;
                return this.i().then(function () {
                  a.h.resolve();
                }, function () {
                  a.h.resolve();
                });
              };
              function lf(a, b) {
                if (a.g) {
                  if (b instanceof O && 7003 == b.code) throw b;
                  throw new O(2, 7, 7003, b);
                }
              }
              function mf() {
                this.g = new wd();
              }
              q = mf.prototype;
              q.release = function () {
                this.nb();
                this.g = null;
              };
              q.C = function (a, b, c, d) {
                this.g && (a = new nf(a, b, c, d), this.g.push(b, a));
              };
              q.ma = function (a, b, c, d) {
                function e(g) {
                  f.zc(a, b, e);
                  c(g);
                }
                var f = this;
                this.C(a, b, e, d);
              };
              q.zc = function (a, b, c) {
                if (this.g) {
                  var d = this.g.get(b) || [];
                  d = r(d);
                  for (var e = d.next(); !e.done; e = d.next()) e = e.value, e.target != a || c != e.listener && c || (e.zc(), this.g.remove(b, e));
                }
              };
              q.nb = function () {
                if (this.g) {
                  var a = this.g,
                    b = [],
                    c;
                  for (c in a.g) b.push.apply(b, ha(a.g[c]));
                  a = r(b);
                  for (b = a.next(); !b.done; b = a.next()) b.value.zc();
                  this.g.g = {};
                }
              };
              K("shaka.util.EventManager", mf);
              mf.prototype.removeAll = mf.prototype.nb;
              mf.prototype.unlisten = mf.prototype.zc;
              mf.prototype.listenOnce = mf.prototype.ma;
              mf.prototype.listen = mf.prototype.C;
              mf.prototype.release = mf.prototype.release;
              function nf(a, b, c, d) {
                this.target = a;
                this.type = b;
                this.listener = c;
                this.g = of(a, d);
                this.target.addEventListener(b, c, this.g);
              }
              nf.prototype.zc = function () {
                this.target.removeEventListener(this.type, this.listener, this.g);
                this.listener = this.target = null;
                this.g = !1;
              };
              function of(a, b) {
                if (void 0 == b) return !1;
                if ("boolean" == typeof b) return b;
                var c = new Set(["passive", "capture"]);
                Object.keys(b).filter(function (d) {
                  return !c.has(d);
                });
                return pf(a) ? b : b.capture || !1;
              }
              function pf(a) {
                var b = qf;
                if (void 0 == b) {
                  b = !1;
                  try {
                    var c = {},
                      d = {
                        get: function get() {
                          b = !0;
                          return !1;
                        }
                      };
                    Object.defineProperty(c, "passive", d);
                    Object.defineProperty(c, "capture", d);
                    d = function d() {};
                    a.addEventListener("test", d, c);
                    a.removeEventListener("test", d, c);
                  } catch (e) {
                    b = !1;
                  }
                  qf = b;
                }
                return b || !1;
              }
              var qf = void 0;
              function rf(a, b) {
                var c = [];
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) c.push(b(d.value));
                return c;
              }
              function sf(a, b) {
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) if (!b(c.value)) return !1;
                return !0;
              }
              function tf(a) {
                for (var b = new Map(), c = r(Object.keys(a)), d = c.next(); !d.done; d = c.next()) d = d.value, b.set(d, a[d]);
                return b;
              }
              function uf(a) {
                var b = {};
                a.forEach(function (c, d) {
                  b[d] = c;
                });
                return b;
              }
              function vf(a, b) {
                if (a || b) {
                  if (a && !b || b && !a) return !1;
                } else return !0;
                if (a.size != b.size) return !1;
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) {
                  var d = r(c.value);
                  c = d.next().value;
                  d = d.next().value;
                  if (!b.has(c)) return !1;
                  c = b.get(c);
                  if (c != d || void 0 == c) return !1;
                }
                return !0;
              }
              function wf(a, b) {
                this.S = Lb(a);
                this.h = b == xf;
                this.g = 0;
              }
              q = wf.prototype;
              q.ha = function () {
                return this.g < this.S.byteLength;
              };
              q.Z = function () {
                return this.g;
              };
              q.Gf = function () {
                return this.S.byteLength;
              };
              q.Ra = function () {
                try {
                  var a = this.S.getUint8(this.g);
                  this.g += 1;
                  return a;
                } catch (b) {
                  throw yf();
                }
              };
              q.$d = function () {
                try {
                  var a = this.S.getUint16(this.g, this.h);
                  this.g += 2;
                  return a;
                } catch (b) {
                  throw yf();
                }
              };
              q.K = function () {
                try {
                  var a = this.S.getUint32(this.g, this.h);
                  this.g += 4;
                  return a;
                } catch (b) {
                  throw yf();
                }
              };
              q.Pe = function () {
                try {
                  var a = this.S.getInt32(this.g, this.h);
                  this.g += 4;
                  return a;
                } catch (b) {
                  throw yf();
                }
              };
              q.$a = function () {
                try {
                  if (this.h) {
                    var a = this.S.getUint32(this.g, !0);
                    var b = this.S.getUint32(this.g + 4, !0);
                  } else b = this.S.getUint32(this.g, !1), a = this.S.getUint32(this.g + 4, !1);
                } catch (c) {
                  throw yf();
                }
                if (2097151 < b) throw new O(2, 3, 3001);
                this.g += 8;
                return b * Math.pow(2, 32) + a;
              };
              q.Za = function (a) {
                if (this.g + a > this.S.byteLength) throw yf();
                var b = M(this.S, this.g, a);
                this.g += a;
                return b;
              };
              q.skip = function (a) {
                if (this.g + a > this.S.byteLength) throw yf();
                this.g += a;
              };
              q.sg = function (a) {
                if (this.g < a) throw yf();
                this.g -= a;
              };
              q.seek = function (a) {
                if (0 > a || a > this.S.byteLength) throw yf();
                this.g = a;
              };
              q.sc = function () {
                for (var a = this.g; this.ha() && 0 != this.S.getUint8(this.g);) this.g += 1;
                a = M(this.S, a, this.g - a);
                this.g += 1;
                return Cc(a);
              };
              function yf() {
                return new O(2, 3, 3E3);
              }
              K("shaka.util.DataViewReader", wf);
              wf.prototype.readTerminatedString = wf.prototype.sc;
              wf.prototype.seek = wf.prototype.seek;
              wf.prototype.rewind = wf.prototype.sg;
              wf.prototype.skip = wf.prototype.skip;
              wf.prototype.readBytes = wf.prototype.Za;
              wf.prototype.readUint64 = wf.prototype.$a;
              wf.prototype.readInt32 = wf.prototype.Pe;
              wf.prototype.readUint32 = wf.prototype.K;
              wf.prototype.readUint16 = wf.prototype.$d;
              wf.prototype.readUint8 = wf.prototype.Ra;
              wf.prototype.getLength = wf.prototype.Gf;
              wf.prototype.getPosition = wf.prototype.Z;
              wf.prototype.hasMoreData = wf.prototype.ha;
              var xf = 1;
              wf.Endianness = {
                BIG_ENDIAN: 0,
                LITTLE_ENDIAN: xf
              };
              function zf() {
                this.i = [];
                this.h = [];
                this.g = !1;
              }
              q = zf.prototype;
              q.box = function (a, b) {
                a = Af(a);
                this.i[a] = Bf;
                this.h[a] = b;
                return this;
              };
              q.P = function (a, b) {
                a = Af(a);
                this.i[a] = Cf;
                this.h[a] = b;
                return this;
              };
              q.stop = function () {
                this.g = !0;
              };
              q.parse = function (a, b, c) {
                a = new wf(a, 0);
                for (this.g = !1; a.ha() && !this.g;) this.qc(0, a, b, c);
              };
              q.qc = function (a, b, c, d) {
                var e = b.Z();
                if (d && e + 8 > b.S.byteLength) this.g = !0;else {
                  var f = b.K(),
                    g = b.K(),
                    h = Df(g),
                    k = !1;
                  switch (f) {
                    case 0:
                      f = b.S.byteLength - e;
                      break;
                    case 1:
                      if (d && b.Z() + 8 > b.S.byteLength) {
                        this.g = !0;
                        return;
                      }
                      f = b.$a();
                      k = !0;
                  }
                  var l = this.h[g];
                  if (l) {
                    var m = null,
                      n = null;
                    if (this.i[g] == Cf) {
                      if (d && b.Z() + 4 > b.S.byteLength) {
                        this.g = !0;
                        return;
                      }
                      n = b.K();
                      m = n >>> 24;
                      n &= 16777215;
                    }
                    g = e + f;
                    c && g > b.S.byteLength && (g = b.S.byteLength);
                    d && g > b.S.byteLength ? this.g = !0 : (d = g - b.Z(), b = 0 < d ? b.Za(d) : new Uint8Array(0), b = new wf(b, 0), l({
                      name: h,
                      parser: this,
                      partialOkay: c || !1,
                      version: m,
                      flags: n,
                      reader: b,
                      size: f,
                      start: e + a,
                      has64BitSize: k
                    }));
                  } else b.skip(Math.min(e + f - b.Z(), b.S.byteLength - b.Z()));
                }
              };
              function Ef(a) {
                for (var b = Ff(a); a.reader.ha() && !a.parser.g;) a.parser.qc(a.start + b, a.reader, a.partialOkay);
              }
              function Gf(a) {
                for (var b = Ff(a), c = a.reader.K(), d = 0; d < c && (a.parser.qc(a.start + b, a.reader, a.partialOkay), !a.parser.g); d++);
              }
              function Hf(a) {
                var b = Ff(a);
                for (a.reader.skip(78); a.reader.ha() && !a.parser.g;) a.parser.qc(a.start + b, a.reader, a.partialOkay);
              }
              function If(a) {
                return function (b) {
                  a(b.reader.Za(b.reader.S.byteLength - b.reader.Z()));
                };
              }
              function Af(a) {
                var b = 0;
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) b = b << 8 | c.value.charCodeAt(0);
                return b;
              }
              function Df(a) {
                return String.fromCharCode(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255);
              }
              function Ff(a) {
                return 8 + (a.has64BitSize ? 8 : 0) + (null != a.flags ? 4 : 0);
              }
              K("shaka.util.Mp4Parser", zf);
              zf.headerSize = Ff;
              zf.typeToString = Df;
              zf.allData = If;
              zf.visualSampleEntry = Hf;
              zf.sampleDescription = Gf;
              zf.children = Ef;
              zf.prototype.parseNext = zf.prototype.qc;
              zf.prototype.parse = zf.prototype.parse;
              zf.prototype.stop = zf.prototype.stop;
              zf.prototype.fullBox = zf.prototype.P;
              zf.prototype.box = zf.prototype.box;
              var Bf = 0,
                Cf = 1;
              function Jf(a) {
                var b = this;
                this.g = [];
                this.h = [];
                this.data = [];
                new zf().box("moov", Ef).box("moof", Ef).P("pssh", function (c) {
                  if (!(1 < c.version)) {
                    var d = M(c.reader.S, -12, c.size);
                    b.data.push(d);
                    b.g.push(Nc(c.reader.Za(16)));
                    if (0 < c.version) {
                      d = c.reader.K();
                      for (var e = 0; e < d; e++) {
                        var f = Nc(c.reader.Za(16));
                        b.h.push(f);
                      }
                    }
                  }
                }).parse(a);
              }
              function Kf(a, b, c, d) {
                var e = a.length,
                  f = b.length + 16 + e;
                0 < d && (f += 4 + 16 * c.size);
                var g = new Uint8Array(f),
                  h = Lb(g),
                  k = 0;
                h.setUint32(k, f);
                k += 4;
                h.setUint32(k, 1886614376);
                k += 4;
                1 > d ? h.setUint32(k, 0) : h.setUint32(k, 16777216);
                k += 4;
                g.set(b, k);
                k += b.length;
                if (0 < d) for (h.setUint32(k, c.size), k += 4, b = r(c), c = b.next(); !c.done; c = b.next()) c = Mc(c.value), g.set(c, k), k += c.length;
                h.setUint32(k, e);
                g.set(a, k + 4);
                return g;
              }
              function Lf(a, b) {
                a = Mf(a, b);
                return 1 != a.length ? null : a[0];
              }
              function Nf(a, b, c) {
                a = Of(a, b, c);
                return 1 != a.length ? null : a[0];
              }
              function Mf(a, b) {
                var c = [];
                a = r(a.childNodes);
                for (var d = a.next(); !d.done; d = a.next()) d = d.value, d instanceof Element && d.tagName == b && c.push(d);
                return c;
              }
              function Pf(a) {
                return Array.from(a.childNodes).filter(function (b) {
                  return b instanceof Element;
                });
              }
              function Of(a, b, c) {
                var d = [];
                a = r(a.childNodes);
                for (var e = a.next(); !e.done; e = a.next()) e = e.value, e instanceof Element && e.localName == c && e.namespaceURI == b && d.push(e);
                return d;
              }
              function Qf(a, b, c) {
                return a.hasAttributeNS(b, c) ? a.getAttributeNS(b, c) : null;
              }
              function Rf(a, b, c) {
                b = r(b);
                for (var d = b.next(); !d.done; d = b.next()) if (d = d.value, a.hasAttributeNS(d, c)) return a.getAttributeNS(d, c);
                return null;
              }
              function Sf(a) {
                return Array.from(a.childNodes).every(Tf) ? a.textContent.trim() : null;
              }
              function Tf(a) {
                return a.nodeType == Node.TEXT_NODE || a.nodeType == Node.CDATA_SECTION_NODE;
              }
              function Uf(a, b, c, d) {
                d = void 0 === d ? null : d;
                var e = null;
                a = a.getAttribute(b);
                null != a && (e = c(a));
                return null == e ? d : e;
              }
              function Vf(a) {
                if (!a) return null;
                /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(a) && (a += "Z");
                a = Date.parse(a);
                return isNaN(a) ? null : a / 1E3;
              }
              function Wf(a) {
                if (!a) return null;
                a = RegExp("^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$").exec(a);
                if (!a) return null;
                a = 31536E3 * Number(a[1] || null) + 2592E3 * Number(a[2] || null) + 86400 * Number(a[3] || null) + 3600 * Number(a[4] || null) + 60 * Number(a[5] || null) + Number(a[6] || null);
                return isFinite(a) ? a : null;
              }
              function Xf(a) {
                var b = /([0-9]+)-([0-9]+)/.exec(a);
                if (!b) return null;
                a = Number(b[1]);
                if (!isFinite(a)) return null;
                b = Number(b[2]);
                return isFinite(b) ? {
                  start: a,
                  end: b
                } : null;
              }
              function Yf(a) {
                a = Number(a);
                return 0 === a % 1 ? a : null;
              }
              function Zf(a) {
                a = Number(a);
                return 0 === a % 1 && 0 < a ? a : null;
              }
              function $f(a) {
                a = Number(a);
                return 0 === a % 1 && 0 <= a ? a : null;
              }
              function ag(a) {
                a = Number(a);
                return isNaN(a) ? null : a;
              }
              function bg(a) {
                var b;
                var c = (b = a.match(/^(\d+)\/(\d+)$/)) ? Number(b[1]) / Number(b[2]) : Number(a);
                return isNaN(c) ? null : c;
              }
              function cg(a, b) {
                var c = new DOMParser(),
                  d = dg.value()(a);
                a = null;
                try {
                  a = c.parseFromString(d, "text/xml");
                } catch (e) {
                  return null;
                }
                c = a.documentElement;
                if (!c || c.getElementsByTagName("parsererror").length || c.tagName != b) return null;
                for (b = document.createNodeIterator(a, NodeFilter.SHOW_ALL); a = b.nextNode();) if (a instanceof HTMLElement || a instanceof SVGElement) return null;
                return c;
              }
              function eg(a, b) {
                try {
                  var c = Cc(a);
                  return cg(c, b);
                } catch (d) {
                  return null;
                }
              }
              var dg = new mc(function () {
                if ("undefined" !== typeof trustedTypes) {
                  var a = trustedTypes.createPolicy("shaka-player#xml", {
                    createHTML: function createHTML(b) {
                      return b;
                    }
                  });
                  return function (b) {
                    return a.createHTML(b);
                  };
                }
                return function (b) {
                  return b;
                };
              });
              function fg(a, b) {
                var c = this;
                b = void 0 === b ? 1 : b;
                this.D = a;
                this.G = new Set();
                this.l = this.u = null;
                this.da = this.W = !1;
                this.H = 0;
                this.g = null;
                this.s = new mf();
                this.i = new Map();
                this.B = [];
                this.o = new lc();
                this.h = null;
                this.m = function (d) {
                  c.o.reject(d);
                  a.onError(d);
                };
                this.ea = new Map();
                this.ba = new Map();
                this.O = new P(function () {
                  return gg(c);
                });
                this.L = !1;
                this.J = [];
                this.M = !1;
                this.ca = new P(function () {
                  hg(c);
                }).Ca(b);
                this.o.catch(function () {});
                this.j = new kf(function () {
                  return ig(c);
                });
                this.V = !1;
                this.F = null;
              }
              q = fg.prototype;
              q.destroy = function () {
                return this.j.destroy();
              };
              function ig(a) {
                return G(function (b) {
                  switch (b.g) {
                    case 1:
                      return a.s.release(), a.s = null, a.o.reject(), a.ca.stop(), a.ca = null, a.O.stop(), a.O = null, u(b, jg(a), 2);
                    case 2:
                      if (!a.l) {
                        b.A(3);
                        break;
                      }
                      D(b, 4);
                      return u(b, a.l.setMediaKeys(null), 6);
                    case 6:
                      ta(b, 5);
                      break;
                    case 4:
                      ua(b);
                    case 5:
                      a.l = null;
                    case 3:
                      a.g = null, a.G.clear(), a.u = null, a.B = [], a.h = null, a.m = function () {}, a.D = null, a.V = !1, a.F = null, A(b);
                  }
                });
              }
              q.configure = function (a) {
                this.h = a;
              };
              function kg(a, b, c) {
                a.da = !0;
                a.B = [];
                a.L = c;
                return lg(a, b);
              }
              function mg(a, b, c) {
                a.B = c;
                a.L = 0 < c.length;
                return lg(a, b);
              }
              function ng(a, b, c, d, e, f) {
                var g = new Map();
                e = {
                  audioCapabilities: e,
                  videoCapabilities: f,
                  distinctiveIdentifier: "optional",
                  persistentState: "required",
                  sessionTypes: ["persistent-license"],
                  label: b
                };
                e.drmInfos = [{
                  keySystem: b,
                  licenseServerUri: c,
                  distinctiveIdentifierRequired: !1,
                  persistentStateRequired: !0,
                  audioRobustness: "",
                  videoRobustness: "",
                  serverCertificate: d,
                  serverCertificateUri: "",
                  initData: null,
                  keyIds: null
                }];
                g.set(b, e);
                return og(a, g, []);
              }
              function lg(a, b) {
                var c, d, e, f, g, h, k, l, m, n, p, t, v, y;
                return G(function (w) {
                  if (1 == w.g) {
                    if (c = pg(a)) for (d = r(b), e = d.next(); !e.done; e = d.next()) f = e.value, f.video && (f.video.drmInfos = [c]), f.audio && (f.audio.drmInfos = [c]);
                    g = b.some(function (x) {
                      return x.video && x.video.drmInfos.length || x.audio && x.audio.drmInfos.length ? !0 : !1;
                    });
                    g || (h = tf(a.h.servers), qg(b, h));
                    k = r(b);
                    for (e = k.next(); !e.done; e = k.next()) for (l = e.value, m = rg(l), n = r(m), p = n.next(); !p.done; p = n.next()) t = p.value, sg(t, tf(a.h.servers), tf(a.h.advanced || {}), a.h.keySystemsMapping);
                    return u(w, Rd(b, a.L, a.V), 2);
                  }
                  v = g || Object.keys(a.h.servers).length;
                  if (!v) return a.W = !0, w.return(Promise.resolve());
                  y = og(a, void 0, b);
                  return w.return(g ? y : y.catch(function () {}));
                });
              }
              function tg(a) {
                var b;
                return G(function (c) {
                  switch (c.g) {
                    case 1:
                      if (a.l.mediaKeys) return c.return();
                      if (!a.F) {
                        c.A(2);
                        break;
                      }
                      return u(c, a.F, 3);
                    case 3:
                      return lf(a.j), c.return();
                    case 2:
                      return D(c, 4), a.F = a.l.setMediaKeys(a.u), u(c, a.F, 6);
                    case 6:
                      ta(c, 5);
                      break;
                    case 4:
                      b = ua(c), a.m(new O(2, 6, 6003, b.message));
                    case 5:
                      lf(a.j), A(c);
                  }
                });
              }
              function ug(a, b) {
                return G(function (c) {
                  if (1 == c.g) return u(c, tg(a), 2);
                  vg(a, b.initDataType, M(b.initData));
                  A(c);
                });
              }
              q.Yb = function (a) {
                var b = this,
                  c;
                return G(function (d) {
                  if (1 == d.g) {
                    if (!b.u) return b.s.ma(a, "encrypted", function () {
                      b.m(new O(2, 6, 6010));
                    }), d.return();
                    b.l = a;
                    b.s.ma(b.l, "play", function () {
                      for (var e = r(b.J), f = e.next(); !f.done; f = e.next()) wg(b, f.value);
                      b.M = !0;
                      b.J = [];
                    });
                    "webkitCurrentPlaybackTargetIsWireless" in b.l && b.s.C(b.l, "webkitcurrentplaybacktargetiswirelesschanged", function () {
                      return jg(b);
                    });
                    return (c = b.g ? b.g.initData.find(function (e) {
                      return 0 < e.initData.length;
                    }) : null) || "com.apple.fps" !== b.g.keySystem || b.B.length ? u(d, tg(b), 2) : d.A(2);
                  }
                  xg(b);
                  c || b.B.length || b.h.parseInbandPsshEnabled || b.s.C(b.l, "encrypted", function (e) {
                    return ug(b, e);
                  });
                  A(d);
                });
              };
              function yg(a) {
                var b, c, d, e, f;
                return G(function (g) {
                  switch (g.g) {
                    case 1:
                      if (!a.u || !a.g) return g.return();
                      if (!a.g.serverCertificateUri || a.g.serverCertificate && a.g.serverCertificate.length) {
                        g.A(2);
                        break;
                      }
                      b = cf([a.g.serverCertificateUri], a.h.retryParameters);
                      D(g, 3);
                      c = a.D.kb.request(5, b);
                      return u(g, c.promise, 5);
                    case 5:
                      d = g.h;
                      a.g.serverCertificate = M(d.data);
                      ta(g, 4);
                      break;
                    case 3:
                      throw e = ua(g), new O(2, 6, 6017, e);
                    case 4:
                      if (a.j.g) return g.return();
                    case 2:
                      if (!a.g.serverCertificate || !a.g.serverCertificate.length) return g.return();
                      D(g, 6);
                      return u(g, a.u.setServerCertificate(a.g.serverCertificate), 8);
                    case 8:
                      ta(g, 0);
                      break;
                    case 6:
                      throw f = ua(g), new O(2, 6, 6004, f.message);
                  }
                });
              }
              function zg(a, b) {
                var c, d, e;
                return G(function (f) {
                  if (1 == f.g) return u(f, Ag(a, b), 2);
                  if (3 != f.g) {
                    c = f.h;
                    if (!c) return f.return();
                    d = [];
                    if (e = a.i.get(c)) e.Ja = new lc(), d.push(e.Ja);
                    d.push(c.remove());
                    return u(f, Promise.all(d), 3);
                  }
                  a.i.delete(c);
                  A(f);
                });
              }
              function xg(a) {
                for (var b = (a.g ? a.g.initData : []) || [], c = r(b), d = c.next(); !d.done; d = c.next()) d = d.value, vg(a, d.initDataType, d.initData);
                c = r(a.B);
                for (d = c.next(); !d.done; d = c.next()) Ag(a, d.value);
                b.length || a.B.length || a.o.resolve();
                return a.o;
              }
              function vg(a, b, c) {
                if (c.length) {
                  var d = a.i.values();
                  d = r(d);
                  for (var e = d.next(); !e.done; e = d.next()) if (Gb(c, e.value.initData) && !tc("Tizen 2")) return;
                  0 < a.i.size && Bg(a) && (a.o.resolve(), a.o = new lc(), a.o.catch(function () {}));
                  Cg(a, b, c, a.g.sessionType);
                }
              }
              function Dg(a) {
                return a ? !!a.match(/^com\.(microsoft|chromecast)\.playready/) : !1;
              }
              function Eg(a) {
                a = a.i.keys();
                a = rf(a, function (b) {
                  return b.sessionId;
                });
                return Array.from(a);
              }
              q.ic = function () {
                var a = Infinity,
                  b = this.i.keys();
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) c = c.value, isNaN(c.expiration) || (a = Math.min(a, c.expiration));
                return a;
              };
              q.Qc = function () {
                return uf(this.ba);
              };
              function og(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p, t, v, y;
                return G(function (w) {
                  switch (w.g) {
                    case 1:
                      d = new Map();
                      if (c.length) {
                        e = Fg(a, c, d);
                        w.A(2);
                        break;
                      }
                      return u(w, Gg(a, b), 3);
                    case 3:
                      e = w.h;
                    case 2:
                      f = e;
                      if (!f) throw new O(2, 6, 6001);
                      lf(a.j);
                      D(w, 4);
                      a.G.clear();
                      g = f.getConfiguration();
                      h = g.audioCapabilities || [];
                      k = g.videoCapabilities || [];
                      l = r(h);
                      for (m = l.next(); !m.done; m = l.next()) n = m.value, a.G.add(n.contentType.toLowerCase());
                      p = r(k);
                      for (m = p.next(); !m.done; m = p.next()) t = m.value, a.G.add(t.contentType.toLowerCase());
                      if (c.length) {
                        var x = f.keySystem;
                        var C = d.get(f.keySystem);
                        var z = [],
                          B = [],
                          E = [],
                          F = [],
                          H = new Set();
                        Hg(C, z, E, B, F, H);
                        var I = a.L ? "persistent-license" : "temporary";
                        x = {
                          keySystem: x,
                          licenseServerUri: z[0],
                          distinctiveIdentifierRequired: C[0].distinctiveIdentifierRequired,
                          persistentStateRequired: C[0].persistentStateRequired,
                          sessionType: C[0].sessionType || I,
                          audioRobustness: C[0].audioRobustness || "",
                          videoRobustness: C[0].videoRobustness || "",
                          serverCertificate: E[0],
                          serverCertificateUri: B[0],
                          initData: F,
                          keyIds: H
                        };
                        C = r(C);
                        for (z = C.next(); !z.done; z = C.next()) z = z.value, z.distinctiveIdentifierRequired && (x.distinctiveIdentifierRequired = z.distinctiveIdentifierRequired), z.persistentStateRequired && (x.persistentStateRequired = z.persistentStateRequired);
                        C = x;
                      } else C = f.keySystem, x = b.get(f.keySystem), z = [], B = [], E = [], F = [], H = new Set(), Hg(x.drmInfos, z, E, B, F, H), C = {
                        keySystem: C,
                        licenseServerUri: z[0],
                        distinctiveIdentifierRequired: "required" == x.distinctiveIdentifier,
                        persistentStateRequired: "required" == x.persistentState,
                        sessionType: x.sessionTypes[0] || "temporary",
                        audioRobustness: (x.audioCapabilities ? x.audioCapabilities[0].robustness : "") || "",
                        videoRobustness: (x.videoCapabilities ? x.videoCapabilities[0].robustness : "") || "",
                        serverCertificate: E[0],
                        serverCertificateUri: B[0],
                        initData: F,
                        keyIds: H
                      };
                      a.g = C;
                      if (!a.g.licenseServerUri) throw new O(2, 6, 6012, a.g.keySystem);
                      return u(w, f.createMediaKeys(), 6);
                    case 6:
                      return v = w.h, lf(a.j), a.u = v, a.W = !0, u(w, yg(a), 7);
                    case 7:
                      lf(a.j);
                      ta(w, 0);
                      break;
                    case 4:
                      y = ua(w);
                      lf(a.j, y);
                      a.g = null;
                      a.G.clear();
                      if (y instanceof O) throw y;
                      throw new O(2, 6, 6002, y.message);
                  }
                });
              }
              function Fg(a, b, c) {
                for (var d = r(b), e = d.next(); !e.done; e = d.next()) {
                  var f = r(rg(e.value));
                  for (e = f.next(); !e.done; e = f.next()) e = e.value, c.has(e.keySystem) || c.set(e.keySystem, []), c.get(e.keySystem).push(e);
                }
                if (1 == c.size && c.has("")) throw new O(2, 6, 6E3);
                d = {};
                a = r(a.h.preferredKeySystems);
                for (e = a.next(); !e.done; d = {
                  qd: d.qd
                }, e = a.next()) for (d.qd = e.value, f = r(b), e = f.next(); !e.done; e = f.next()) if (e = e.value.decodingInfos.find(function (l) {
                  return function (m) {
                    return m.supported && null != m.keySystemAccess && m.keySystemAccess.keySystem == l.qd;
                  };
                }(d))) return e.keySystemAccess;
                a = r([!0, !1]);
                for (e = a.next(); !e.done; e = a.next()) for (d = e.value, f = r(b), e = f.next(); !e.done; e = f.next()) {
                  var g = r(e.value.decodingInfos);
                  for (e = g.next(); !e.done; e = g.next()) {
                    var h = e.value;
                    if (h.supported && h.keySystemAccess) {
                      e = c.get(h.keySystemAccess.keySystem);
                      var k = r(e);
                      for (e = k.next(); !e.done; e = k.next()) if (!!e.value.licenseServerUri == d) return h.keySystemAccess;
                    }
                  }
                }
                return null;
              }
              function Gg(a, b) {
                var c, d, e, f, g, h, k, l, m, n, p, t, v, y, w;
                return G(function (x) {
                  switch (x.g) {
                    case 1:
                      if (1 == b.size && b.has("")) throw new O(2, 6, 6E3);
                      d = r(b.values());
                      for (e = d.next(); !e.done; e = d.next()) f = e.value, 0 == f.audioCapabilities.length && delete f.audioCapabilities, 0 == f.videoCapabilities.length && delete f.videoCapabilities;
                      g = r(a.h.preferredKeySystems);
                      h = g.next();
                    case 2:
                      if (h.done) {
                        x.A(4);
                        break;
                      }
                      k = h.value;
                      if (!b.has(k)) {
                        x.A(3);
                        break;
                      }
                      l = b.get(k);
                      D(x, 6);
                      return u(x, navigator.requestMediaKeySystemAccess(k, [l]), 8);
                    case 8:
                      return c = x.h, x.return(c);
                    case 6:
                      ua(x);
                    case 7:
                      lf(a.j);
                    case 3:
                      h = g.next();
                      x.A(2);
                      break;
                    case 4:
                      m = r([!0, !1]), n = m.next();
                    case 9:
                      if (n.done) {
                        x.A(11);
                        break;
                      }
                      p = n.value;
                      t = r(b.keys());
                      h = t.next();
                    case 12:
                      if (h.done) {
                        n = m.next();
                        x.A(9);
                        break;
                      }
                      v = h.value;
                      y = b.get(v);
                      w = y.drmInfos.some(function (C) {
                        return !!C.licenseServerUri;
                      });
                      if (w != p) {
                        x.A(13);
                        break;
                      }
                      D(x, 15);
                      return u(x, navigator.requestMediaKeySystemAccess(v, [y]), 17);
                    case 17:
                      return c = x.h, x.return(c);
                    case 15:
                      ua(x);
                    case 16:
                      lf(a.j);
                    case 13:
                      h = t.next();
                      x.A(12);
                      break;
                    case 11:
                      return x.return(c);
                  }
                });
              }
              function pg(a) {
                a = tf(a.h.clearKeys);
                if (0 == a.size) return null;
                var b = [],
                  c = [];
                a.forEach(function (e, f) {
                  var g = f;
                  22 != g.length && (g = Kc(Mc(f), !1));
                  f = e;
                  22 != f.length && (f = Kc(Mc(e), !1));
                  e = {
                    kty: "oct",
                    kid: g,
                    k: f
                  };
                  b.push(e);
                  c.push(e.kid);
                });
                a = JSON.stringify({
                  keys: b
                });
                var d = JSON.stringify({
                  kids: c
                });
                d = [{
                  initData: M(Gc(d)),
                  initDataType: "keyids"
                }];
                return {
                  keySystem: "org.w3.clearkey",
                  licenseServerUri: "data:application/json;base64," + window.btoa(a),
                  distinctiveIdentifierRequired: !1,
                  persistentStateRequired: !1,
                  audioRobustness: "",
                  videoRobustness: "",
                  serverCertificate: null,
                  serverCertificateUri: "",
                  sessionType: "",
                  initData: d,
                  keyIds: new Set(c)
                };
              }
              function Ag(a, b) {
                var c, d, e, f, g;
                return G(function (h) {
                  switch (h.g) {
                    case 1:
                      try {
                        c = a.u.createSession("persistent-license");
                      } catch (k) {
                        return d = new O(2, 6, 6005, k.message), a.m(d), h.return(Promise.reject(d));
                      }
                      a.s.C(c, "message", function (k) {
                        a.l && a.h.delayLicenseRequestUntilPlayed && a.l.paused && !a.M ? a.J.push(k) : wg(a, k);
                      });
                      a.s.C(c, "keystatuseschange", function (k) {
                        return Ig(a, k);
                      });
                      e = {
                        initData: null,
                        initDataType: null,
                        loaded: !1,
                        Vd: Infinity,
                        Ja: null,
                        type: "persistent-license"
                      };
                      a.i.set(c, e);
                      D(h, 2);
                      return u(h, c.load(b), 4);
                    case 4:
                      f = h.h;
                      lf(a.j);
                      if (!f) return a.i.delete(c), a.m(new O(2, 6, 6013)), h.return(Promise.resolve());
                      e.loaded = !0;
                      Bg(a) && a.o.resolve();
                      return h.return(c);
                    case 2:
                      g = ua(h), lf(a.j, g), a.i.delete(c), a.m(new O(2, 6, 6005, g.message));
                    case 3:
                      return h.return(Promise.resolve());
                  }
                });
              }
              function Cg(a, b, c, d) {
                try {
                  var e = a.u.createSession(d);
                } catch (f) {
                  a.m(new O(2, 6, 6005, f.message));
                  return;
                }
                a.s.C(e, "message", function (f) {
                  a.l && a.h.delayLicenseRequestUntilPlayed && a.l.paused && !a.M ? a.J.push(f) : wg(a, f);
                });
                a.s.C(e, "keystatuseschange", function (f) {
                  return Ig(a, f);
                });
                a.i.set(e, {
                  initData: c,
                  initDataType: b,
                  loaded: !1,
                  Vd: Infinity,
                  Ja: null,
                  type: d
                });
                try {
                  c = a.h.initDataTransform(c, b, a.g);
                } catch (f) {
                  b = f;
                  f instanceof O || (b = new O(2, 6, 6016, f));
                  a.m(b);
                  return;
                }
                a.h.logLicenseExchange && Kc(c);
                e.generateRequest(b, c).catch(function (f) {
                  if (!a.j.g) {
                    a.i.delete(e);
                    var g = f.errorCode;
                    if (g && g.systemCode) {
                      var h = g.systemCode;
                      0 > h && (h += Math.pow(2, 32));
                      h = "0x" + h.toString(16);
                    }
                    a.m(new O(2, 6, 6006, f.message, f, h));
                  }
                });
              }
              function wg(a, b) {
                var c, d, e, f, g, h, k, l, m, n, p, t, v, y;
                G(function (w) {
                  switch (w.g) {
                    case 1:
                      return c = b.target, a.h.logLicenseExchange && Kc(b.message), d = a.i.get(c), e = a.g.licenseServerUri, f = a.h.advanced[a.g.keySystem], "individualization-request" == b.messageType && f && f.individualizationServer && (e = f.individualizationServer), g = cf([e], a.h.retryParameters), g.body = b.message, g.method = "POST", g.licenseRequestType = b.messageType, g.sessionId = c.sessionId, g.drmInfo = a.g, d && (g.initData = d.initData, g.initDataType = d.initDataType), Dg(a.g.keySystem) && Jg(g), h = Date.now(), D(w, 2), l = a.D.kb.request(2, g), u(w, l.promise, 4);
                    case 4:
                      k = w.h;
                      ta(w, 3);
                      break;
                    case 2:
                      return m = ua(w), n = new O(2, 6, 6007, m), a.m(n), d && d.Ja && d.Ja.reject(n), w.return();
                    case 3:
                      if (a.j.g) return w.return();
                      a.H += (Date.now() - h) / 1E3;
                      a.h.logLicenseExchange && Kc(k.data);
                      D(w, 5);
                      return u(w, c.update(k.data), 7);
                    case 7:
                      ta(w, 6);
                      break;
                    case 5:
                      return p = ua(w), t = new O(2, 6, 6008, p.message), a.m(t), d && d.Ja && d.Ja.reject(t), w.return();
                    case 6:
                      if (a.j.g) return w.return();
                      v = new S("drmsessionupdate");
                      a.D.onEvent(v);
                      d && (d.Ja && d.Ja.resolve(), y = new P(function () {
                        d.loaded = !0;
                        Bg(a) && a.o.resolve();
                      }), y.N(Kg));
                      A(w);
                  }
                });
              }
              function Jg(a) {
                var b = Dc(a.body, !0, !0);
                if (b.includes("PlayReadyKeyMessage")) {
                  b = cg(b, "PlayReadyKeyMessage");
                  for (var c = r(b.getElementsByTagName("HttpHeader")), d = c.next(); !d.done; d = c.next()) d = d.value, a.headers[d.getElementsByTagName("name")[0].textContent] = d.getElementsByTagName("value")[0].textContent;
                  a.body = Lc(b.getElementsByTagName("Challenge")[0].textContent);
                } else a.headers["Content-Type"] = "text/xml; charset=utf-8";
              }
              function Ig(a, b) {
                b = b.target;
                var c = a.i.get(b),
                  d = !1;
                b.keyStatuses.forEach(function (f, g) {
                  if ("string" == typeof g) {
                    var h = g;
                    g = f;
                    f = h;
                  }
                  if (Dg(a.g.keySystem) && 16 == g.byteLength && (rc() || xc())) {
                    h = Lb(g);
                    var k = h.getUint32(0, !0),
                      l = h.getUint16(4, !0),
                      m = h.getUint16(6, !0);
                    h.setUint32(0, k, !1);
                    h.setUint16(4, l, !1);
                    h.setUint16(6, m, !1);
                  }
                  "status-pending" != f && (c.loaded = !0);
                  "expired" == f && (d = !0);
                  g = Nc(g).slice(0, 32);
                  a.ea.set(g, f);
                });
                var e = b.expiration - Date.now();
                (0 > e || d && 1E3 > e) && c && !c.Ja && (a.i.delete(b), b.close().catch(function () {}));
                Bg(a) && (a.o.resolve(), a.O.N(Lg));
              }
              function gg(a) {
                var b = a.ea,
                  c = a.ba;
                c.clear();
                b.forEach(function (d, e) {
                  return c.set(e, d);
                });
                b = Array.from(c.values());
                b.length && b.every(function (d) {
                  return "expired" == d;
                }) && a.m(new O(2, 6, 6014));
                a.D.cd(uf(c));
              }
              function Mg() {
                var a, b, c, d, e, f, g, h;
                return G(function (k) {
                  return 1 == k.g ? (a = "org.w3.clearkey com.widevine.alpha com.microsoft.playready com.microsoft.playready.recommendation com.apple.fps.1_0 com.apple.fps com.adobe.primetime".split(" "), b = [{
                    contentType: 'video/mp4; codecs="avc1.42E01E"'
                  }, {
                    contentType: 'video/webm; codecs="vp8"'
                  }], c = {
                    initDataTypes: ["cenc"],
                    videoCapabilities: b
                  }, d = {
                    videoCapabilities: b,
                    persistentState: "required",
                    sessionTypes: ["persistent-license"]
                  }, e = [d, c], f = new Map(), g = function g(l) {
                    var m, n, p;
                    return G(function (t) {
                      switch (t.g) {
                        case 1:
                          D(t, 2);
                          if ("org.w3.clearkey" === l && yc()) throw Error("Unsupported keySystem");
                          return u(t, navigator.requestMediaKeySystemAccess(l, e), 4);
                        case 4:
                          return m = t.h, p = (n = m.getConfiguration().sessionTypes) ? n.includes("persistent-license") : !1, tc("Tizen 3") && (p = !1), f.set(l, {
                            persistentState: p
                          }), u(t, m.createMediaKeys(), 5);
                        case 5:
                          ta(t, 0);
                          break;
                        case 2:
                          ua(t), f.set(l, null), A(t);
                      }
                    });
                  }, h = a.map(function (l) {
                    return g(l);
                  }), u(k, Promise.all(h), 2)) : k.return(uf(f));
                });
              }
              function Ng(a) {
                var b;
                return G(function (c) {
                  if (1 == c.g) return b = new Promise(function (d, e) {
                    new P(e).N(Og);
                  }), D(c, 2), u(c, Promise.race([Promise.all([a.close(), a.closed]), b]), 4);
                  if (2 != c.g) return ta(c, 0);
                  ua(c);
                  A(c);
                });
              }
              function jg(a) {
                var b;
                return G(function (c) {
                  b = Array.from(a.i.entries());
                  a.i.clear();
                  return u(c, Promise.all(b.map(function (d) {
                    d = r(d);
                    var e = d.next().value,
                      f = d.next().value;
                    return G(function (g) {
                      if (1 == g.g) return D(g, 2), a.da || a.B.includes(e.sessionId) || "persistent-license" !== f.type ? u(g, Ng(e), 5) : u(g, e.remove(), 5);
                      if (2 != g.g) return ta(g, 0);
                      ua(g);
                      A(g);
                    });
                  })), 0);
                });
              }
              function Pg(a, b) {
                if (!a.length) return b;
                if (!b.length) return a;
                var c = [];
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) {
                  d = d.value;
                  for (var e = {}, f = r(b), g = f.next(); !g.done; e = {
                    Da: e.Da
                  }, g = f.next()) if (g = g.value, d.keySystem == g.keySystem) {
                    e.Da = [];
                    e.Da = e.Da.concat(d.initData || []);
                    e.Da = e.Da.concat(g.initData || []);
                    e.Da = e.Da.filter(function (h) {
                      return function (k, l) {
                        return void 0 === k.keyId || l === h.Da.findIndex(function (m) {
                          return m.keyId === k.keyId;
                        });
                      };
                    }(e));
                    f = d.keyIds && g.keyIds ? new Set([].concat(ha(d.keyIds), ha(g.keyIds))) : d.keyIds || g.keyIds;
                    c.push({
                      keySystem: d.keySystem,
                      licenseServerUri: d.licenseServerUri || g.licenseServerUri,
                      distinctiveIdentifierRequired: d.distinctiveIdentifierRequired || g.distinctiveIdentifierRequired,
                      persistentStateRequired: d.persistentStateRequired || g.persistentStateRequired,
                      videoRobustness: d.videoRobustness || g.videoRobustness,
                      audioRobustness: d.audioRobustness || g.audioRobustness,
                      serverCertificate: d.serverCertificate || g.serverCertificate,
                      serverCertificateUri: d.serverCertificateUri || g.serverCertificateUri,
                      initData: e.Da,
                      keyIds: f
                    });
                    break;
                  }
                }
                return c;
              }
              function rg(a) {
                return (a.video ? a.video.drmInfos : []).concat(a.audio ? a.audio.drmInfos : []);
              }
              function hg(a) {
                a.i.forEach(function (b, c) {
                  var d = b.Vd,
                    e = c.expiration;
                  isNaN(e) && (e = Infinity);
                  e != d && (a.D.onExpirationUpdated(c.sessionId, e), b.Vd = e);
                });
              }
              function Bg(a) {
                a = a.i.values();
                return sf(a, function (b) {
                  return b.loaded;
                });
              }
              function qg(a, b) {
                var c = [];
                b.forEach(function (d, e) {
                  c.push({
                    keySystem: e,
                    licenseServerUri: d,
                    distinctiveIdentifierRequired: !1,
                    persistentStateRequired: !1,
                    audioRobustness: "",
                    videoRobustness: "",
                    serverCertificate: null,
                    serverCertificateUri: "",
                    initData: [],
                    keyIds: new Set()
                  });
                });
                a = r(a);
                for (b = a.next(); !b.done; b = a.next()) b = b.value, b.video && (b.video.drmInfos = c), b.audio && (b.audio.drmInfos = c);
              }
              function Hg(a, b, c, d, e, f) {
                var g = {};
                a = r(a);
                for (var h = a.next(); !h.done; g = {
                  oa: g.oa
                }, h = a.next()) {
                  g.oa = h.value;
                  b.includes(g.oa.licenseServerUri) || b.push(g.oa.licenseServerUri);
                  d.includes(g.oa.serverCertificateUri) || d.push(g.oa.serverCertificateUri);
                  g.oa.serverCertificate && (c.some(function (m) {
                    return function (n) {
                      return Gb(n, m.oa.serverCertificate);
                    };
                  }(g)) || c.push(g.oa.serverCertificate));
                  if (g.oa.initData) {
                    h = {};
                    for (var k = r(g.oa.initData), l = k.next(); !l.done; h = {
                      Dc: h.Dc
                    }, l = k.next()) h.Dc = l.value, e.some(function (m) {
                      return function (n) {
                        var p = m.Dc;
                        return n.keyId && n.keyId == p.keyId ? !0 : n.initDataType == p.initDataType && Gb(n.initData, p.initData);
                      };
                    }(h)) || e.push(h.Dc);
                  }
                  if (g.oa.keyIds) for (h = r(g.oa.keyIds), k = h.next(); !k.done; k = h.next()) f.add(k.value);
                }
              }
              function sg(a, b, c, d) {
                var e = a.keySystem;
                if (e && ("org.w3.clearkey" != e || !a.licenseServerUri)) {
                  b.size && (b = b.get(e) || "", a.licenseServerUri = b);
                  a.keyIds || (a.keyIds = new Set());
                  if (c = c.get(e)) a.distinctiveIdentifierRequired || (a.distinctiveIdentifierRequired = c.distinctiveIdentifierRequired), a.persistentStateRequired || (a.persistentStateRequired = c.persistentStateRequired), a.videoRobustness || (a.videoRobustness = c.videoRobustness), a.audioRobustness || (a.audioRobustness = c.audioRobustness), a.serverCertificate || (a.serverCertificate = c.serverCertificate), c.sessionType && (a.sessionType = c.sessionType), a.serverCertificateUri || (a.serverCertificateUri = c.serverCertificateUri);
                  d[e] && (a.keySystem = d[e]);
                  window.cast && window.cast.__platform__ && "com.microsoft.playready" == e && (a.keySystem = "com.chromecast.playready");
                }
              }
              var Og = 1,
                Kg = 5,
                Lg = .5,
                Qg = new mc(function () {
                  return Ib(new Uint8Array([0]));
                });
              function Rg() {}
              function Sg(a, b, c, d) {
                var e, f, g, h;
                return G(function (k) {
                  if (1 == k.g) {
                    if (d && (e = Tg[d.toLowerCase()])) return k.return(e);
                    if (f = Ug(a)) if (g = Vg[f]) return k.return(g);
                    return d ? k.A(2) : u(k, Wg(a, b, c), 3);
                  }
                  if (2 != k.g && (d = k.h) && (h = Tg[d])) return k.return(h);
                  throw new O(2, 4, 4E3, a);
                });
              }
              function Wg(a, b, c) {
                var d, e, f;
                return G(function (g) {
                  if (1 == g.g) return d = cf([a], c), d.method = "HEAD", u(g, b.request(0, d).promise, 2);
                  e = g.h;
                  f = e.headers["content-type"];
                  return g.return(f ? f.toLowerCase().split(";").shift() : "");
                });
              }
              function Ug(a) {
                a = new Nb(a).qa.split("/").pop().split(".");
                return 1 == a.length ? "" : a.pop().toLowerCase();
              }
              K("shaka.media.ManifestParser", Rg);
              Rg.unregisterParserByMime = function (a) {
                delete Tg[a];
              };
              Rg.registerParserByMime = function (a, b) {
                Tg[a] = b;
              };
              Rg.registerParserByExtension = function (a, b) {
                Vg[a] = b;
              };
              var Tg = {},
                Vg = {};
              function Xg(a) {
                function b() {
                  d = !0;
                }
                function c(l) {
                  f.push(l);
                  Ef(l);
                }
                a = M(a);
                var d = !1,
                  e,
                  f = [],
                  g = [];
                new zf().box("moov", c).box("trak", c).box("mdia", c).box("minf", c).box("stbl", c).P("stsd", function (l) {
                  e = l;
                  f.push(l);
                  Gf(l);
                }).P("encv", b).P("enca", b).P("hev1", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733238
                  });
                }).P("hvc1", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733238
                  });
                }).P("avc1", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733238
                  });
                }).P("avc3", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733238
                  });
                }).P("ac-3", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733217
                  });
                }).P("ec-3", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733217
                  });
                }).P("mp4a", function (l) {
                  g.push({
                    box: l,
                    lb: 1701733217
                  });
                }).parse(a);
                if (d) return a;
                if (0 == g.length || !e) throw bb(Nc(a)), new O(2, 3, 3019);
                g.reverse();
                for (var h = r(g), k = h.next(); !k.done; k = h.next()) k = k.value, a = Yg(a, e, k.box, f, k.lb);
                return a;
              }
              function Yg(a, b, c, d, e) {
                var f = Zg.value(),
                  g = a.subarray(c.start, c.start + c.size),
                  h = Lb(g),
                  k = new Uint8Array(c.size + f.byteLength);
                k.set(g, 0);
                g = Lb(k);
                g.setUint32(4, e);
                k.set(f, c.size);
                e = h.getUint32(4);
                g.setUint32(c.size + 16, e);
                $g(k, 0, k.byteLength);
                e = new Uint8Array(a.byteLength + k.byteLength);
                c = sc() ? c.start : c.start + c.size;
                f = a.subarray(c);
                e.set(a.subarray(0, c));
                e.set(k, c);
                e.set(f, c + k.byteLength);
                a = r(d);
                for (d = a.next(); !d.done; d = a.next()) d = d.value, $g(e, d.start, d.size + k.byteLength);
                k = Lb(e, b.start);
                b = Ff(b);
                a = k.getUint32(b);
                k.setUint32(b, a + 1);
                return e;
              }
              function $g(a, b, c) {
                a = Lb(a, b);
                b = a.getUint32(0);
                0 != b && (1 == b ? (a.setUint32(8, c >> 32), a.setUint32(12, c & 4294967295)) : a.setUint32(0, c));
              }
              var Zg = new mc(function () {
                return new Uint8Array([0, 0, 0, 80, 115, 105, 110, 102, 0, 0, 0, 12, 102, 114, 109, 97, 0, 0, 0, 0, 0, 0, 0, 20, 115, 99, 104, 109, 0, 0, 0, 0, 99, 101, 110, 99, 0, 1, 0, 0, 0, 0, 0, 40, 115, 99, 104, 105, 0, 0, 0, 32, 116, 101, 110, 99, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
              });
              function ah(a, b, c, d, e) {
                if (d >= e) return null;
                for (var f = -1, g = -1, h = 0; h < c.length; h++) if (c[h].some(function (B) {
                  return null != B && "" != B.g.trim();
                })) {
                  f = h;
                  break;
                }
                for (h = c.length - 1; 0 <= h; h--) if (c[h].some(function (B) {
                  return null != B && "" != B.g.trim();
                })) {
                  g = h;
                  break;
                }
                if (-1 === f || -1 === g) return null;
                for (var k = h = !1, l = "white", m = "black", n = bh(d, e, h, k, l, m); f <= g; f++) {
                  for (var p = c[f], t = -1, v = -1, y = 0; y < p.length; y++) if (null != p[y] && "" !== p[y].g.trim()) {
                    t = y;
                    break;
                  }
                  for (y = p.length - 1; 0 <= y; y--) if (null != p[y] && "" !== p[y].g.trim()) {
                    v = y;
                    break;
                  }
                  if (-1 === t || -1 === v) p = ch(d, e), a.nestedCues.push(p);else {
                    for (; t <= v; t++) if (y = p[t]) {
                      var w = y.l,
                        x = y.i,
                        C = y.j,
                        z = y.h;
                      if (w != h || x != k || C != l || z != m) n.payload && a.nestedCues.push(n), n = bh(d, e, w, x, C, z), h = w, k = x, l = C, m = z;
                      n.payload += y.g;
                    } else n.payload += " ";
                    n.payload && a.nestedCues.push(n);
                    f !== g && (n = ch(d, e), a.nestedCues.push(n));
                    n = bh(d, e, h, k, l, m);
                  }
                }
                return a.nestedCues.length ? {
                  cue: a,
                  stream: b
                } : null;
              }
              function bh(a, b, c, d, e, f) {
                a = new kb(a, b, "");
                c && a.textDecoration.push("underline");
                d && (a.fontStyle = "italic");
                a.color = e;
                a.backgroundColor = f;
                return a;
              }
              function ch(a, b) {
                a = new kb(a, b, "");
                a.lineBreak = !0;
                return a;
              }
              function dh(a, b, c, d, e) {
                this.g = a;
                this.l = b;
                this.i = c;
                this.h = d;
                this.j = e;
              }
              function eh(a, b) {
                this.i = [];
                this.g = 1;
                this.h = 0;
                this.u = a;
                this.s = b;
                this.j = this.m = !1;
                this.l = "white";
                this.o = "black";
                fh(this);
              }
              function gh(a, b, c) {
                return ah(new kb(b, c, ""), "CC" + (a.u << 1 | a.s + 1), a.i, b, c);
              }
              function fh(a) {
                hh(a, 0, 15);
                a.g = 1;
              }
              function ih(a, b, c) {
                if (!(32 > c || 127 < c)) {
                  var d = "";
                  switch (b) {
                    case jh:
                      d = kh.has(c) ? kh.get(c) : String.fromCharCode(c);
                      break;
                    case lh:
                      d = mh.get(c);
                      break;
                    case nh:
                      a.i[a.g].pop();
                      d = oh.get(c);
                      break;
                    case ph:
                      a.i[a.g].pop(), d = qh.get(c);
                  }
                  d && a.i[a.g].push(new dh(d, a.m, a.j, a.o, a.l));
                }
              }
              function rh(a, b, c, d) {
                if (!(0 > c || 0 > b)) if (b >= c) for (--d; 0 <= d; d--) a.i[b + d] = a.i[c + d].map(function (f) {
                  return f;
                });else for (var e = 0; e < d; e++) a.i[b + e] = a.i[c + e].map(function (f) {
                  return f;
                });
              }
              function hh(a, b, c) {
                for (var d = 0; d <= c; d++) a.i[b + d] = [];
              }
              var jh = 0,
                lh = 1,
                nh = 2,
                ph = 3,
                kh = new Map([[39, "\u2019"], [42, "\u00e1"], [92, "\u00e9"], [92, "\u00e9"], [94, "\u00ed"], [95, "\u00f3"], [96, "\u00fa"], [123, "\u00e7"], [124, "\u00f7"], [125, "\u00d1"], [126, "\u00f1"], [127, "\u2588"]]),
                mh = new Map([[48, "\u00ae"], [49, "\u00b0"], [50, "\u00bd"], [51, "\u00bf"], [52, "\u2122"], [53, "\u00a2"], [54, "\u00a3"], [55, "\u266a"], [56, "\u00e0"], [57, "\u2800"], [58, "\u00e8"], [59, "\u00e2"], [60, "\u00ea"], [61, "\u00ee"], [62, "\u00f4"], [63, "\u00fb"]]),
                oh = new Map([[32, "\u00c1"], [33, "\u00c9"], [34, "\u00d3"], [35, "\u00da"], [36, "\u00dc"], [37, "\u00fc"], [38, "\u2018"], [39, "\u00a1"], [40, "*"], [41, "'"], [42, "\u2500"], [43, "\u00a9"], [44, "\u2120"], [45, "\u00b7"], [46, "\u201c"], [47, "\u201d"], [48, "\u00c0"], [49, "\u00c2"], [50, "\u00c7"], [51, "\u00c8"], [52, "\u00ca"], [53, "\u00cb"], [54, "\u00eb"], [55, "\u00ce"], [56, "\u00cf"], [57, "\u00ef"], [58, "\u00d4"], [59, "\u00d9"], [60, "\u00f9"], [61, "\u00db"], [62, "\u00ab"], [63, "\u00bb"]]),
                qh = new Map([[32, "\u00c3"], [33, "\u00e3"], [34, "\u00cd"], [35, "\u00cc"], [36, "\u00ec"], [37, "\u00d2"], [38, "\u00f2"], [39, "\u00d5"], [40, "\u00f5"], [41, "{"], [42, "}"], [43, "\\"], [44, "^"], [45, "_"], [46, "|"], [47, "~"], [48, "\u00c4"], [49, "\u00e4"], [50, "\u00d6"], [51, "\u00f6"], [52, "\u00df"], [53, "\u00a5"], [54, "\u00a4"], [55, "\u2502"], [56, "\u00c5"], [57, "\u00e5"], [58, "\u00d8"], [59, "\u00f8"], [60, "\u250c"], [61, "\u2510"], [62, "\u2514"], [63, "\u2518"]]);
              function sh(a, b) {
                this.h = th;
                this.o = new eh(a, b);
                this.i = new eh(a, b);
                this.l = new eh(a, b);
                this.g = this.i;
                this.j = 0;
                this.m = null;
              }
              function uh(a, b, c) {
                a.g = a.i;
                var d = a.g,
                  e = null;
                a.h !== vh && a.h !== wh && (e = gh(d, a.j, c), c = a.i, c.g = 0 < c.h ? c.h : 0, hh(c, 0, 15), c = a.l, c.g = 0 < c.h ? c.h : 0, hh(c, 0, 15), d.g = 15);
                a.h = vh;
                d.h = b;
                return e;
              }
              function xh(a) {
                a.h = yh;
                a.g = a.l;
                a.g.h = 0;
              }
              function zh(a) {
                Xa("Cea608DataChannel", "CEA-608 text mode entered, but is unsupported");
                a.g = a.o;
                a.h = wh;
              }
              var th = 0,
                yh = 1,
                vh = 3,
                wh = 4,
                Ah = "black green blue cyan red yellow magenta black".split(" "),
                Bh = "white green blue cyan red yellow magenta white_italics".split(" ");
              function Ch() {
                this.l = !1;
                this.B = this.F = 0;
                this.D = Dh;
                this.i = [];
                this.g = this.h = this.j = 0;
                this.u = this.o = !1;
                this.s = "white";
                this.m = "black";
                Eh(this);
              }
              function Eh(a) {
                a.i = [];
                for (var b = 0; 16 > b; b++) a.i.push(Fh());
              }
              function Fh() {
                for (var a = [], b = 0; 42 > b; b++) a.push(null);
                return a;
              }
              function Gh(a, b) {
                Hh(a) && (a.i[a.h][a.g] = new dh(b, a.u, a.o, a.m, a.s), a.g++);
              }
              function Hh(a) {
                var b = a.g < a.B && 0 <= a.g;
                return a.h < a.F && 0 <= a.h && b;
              }
              Ch.prototype.isVisible = function () {
                return this.l;
              };
              function Ih(a, b, c) {
                var d = new kb(a.j, b, "");
                d.textAlign = a.D === Jh ? "left" : a.D === Kh ? "right" : ob;
                if (c = ah(d, "svc" + c, a.i, a.j, b)) a.j = b;
                return c;
              }
              var Jh = 0,
                Kh = 1,
                Dh = 2;
              function Lh() {
                this.i = [];
                this.h = null;
                this.g = 0;
              }
              function Mh(a, b) {
                3 === b.type ? (a.g = 2 * (b.value & 63) - 1, a.h = []) : a.h && (0 < a.g && (a.h.push(b), a.g--), 0 === a.g && (a.i.push(new Nh(a.h)), a.h = null, a.g = 0));
              }
              function Nh(a) {
                this.g = 0;
                this.h = a;
              }
              Nh.prototype.ha = function () {
                return this.g < this.h.length;
              };
              Nh.prototype.Z = function () {
                return this.g;
              };
              function Oh(a) {
                if (!a.ha()) throw new O(2, 2, 3E3);
                return a.h[a.g++];
              }
              Nh.prototype.skip = function (a) {
                if (this.g + a > this.h.length) throw new O(2, 2, 3E3);
                this.g += a;
              };
              function Ph(a) {
                this.i = a;
                this.h = [null, null, null, null, null, null, null, null];
                this.g = null;
              }
              function Qh(a, b, c, d) {
                if (128 <= c && 135 >= c) d = c & 7, a.h[d] && (a.g = a.h[d]);else {
                  if (136 === c) {
                    c = Oh(b).value;
                    b = null;
                    c = r(Rh(a, c));
                    for (var e = c.next(); !e.done; e = c.next()) e = a.h[e.value], e.isVisible() && (b = Ih(e, d, a.i)), Eh(e);
                    return b;
                  }
                  if (137 === c) for (b = Oh(b).value, b = r(Rh(a, b)), c = b.next(); !c.done; c = b.next()) c = a.h[c.value], c.isVisible() || (c.j = d), c.l = !0;else {
                    if (138 === c) {
                      c = Oh(b).value;
                      b = null;
                      c = r(Rh(a, c));
                      for (e = c.next(); !e.done; e = c.next()) e = a.h[e.value], e.isVisible() && (b = Ih(e, d, a.i)), e.l = !1;
                      return b;
                    }
                    if (139 === c) {
                      c = Oh(b).value;
                      b = null;
                      c = r(Rh(a, c));
                      for (e = c.next(); !e.done; e = c.next()) e = a.h[e.value], e.isVisible() ? b = Ih(e, d, a.i) : e.j = d, e.l = !e.l;
                      return b;
                    }
                    if (140 === c) return b = Oh(b).value, Sh(a, b, d);
                    if (143 === c) return d = Sh(a, 255, d), Th(a), d;
                    if (144 === c) b.skip(1), d = Oh(b).value, a.g && (a.g.o = 0 < (d & 128), a.g.u = 0 < (d & 64));else if (145 === c) d = Oh(b).value, c = Oh(b).value, b.skip(1), a.g && (b = Uh((c & 48) >> 4, (c & 12) >> 2, c & 3), a.g.s = Uh((d & 48) >> 4, (d & 12) >> 2, d & 3), a.g.m = b);else if (146 === c) d = Oh(b).value, b = Oh(b).value, a.g && (a = a.g, a.h = d & 15, a.g = b & 63);else if (151 === c) b.skip(1), b.skip(1), d = Oh(b).value, b.skip(1), a.g && (a.g.D = d & 3);else if (152 <= c && 159 >= c) {
                      c = (c & 15) - 8;
                      e = null !== a.h[c];
                      if (!e) {
                        var f = new Ch();
                        f.j = d;
                        a.h[c] = f;
                      }
                      d = Oh(b).value;
                      Oh(b);
                      Oh(b);
                      f = Oh(b).value;
                      var g = Oh(b).value;
                      b = Oh(b).value;
                      e && 0 === (b & 7) || (b = a.h[c], b.h = 0, b.g = 0, b.u = !1, b.o = !1, b.s = "white", b.m = "black");
                      b = a.h[c];
                      b.l = 0 < (d & 32);
                      b.F = (f & 15) + 1;
                      b.B = (g & 63) + 1;
                      a.g = a.h[c];
                    }
                  }
                }
                return null;
              }
              function Rh(a, b) {
                for (var c = [], d = 0; 8 > d; d++) 1 === (b & 1) && a.h[d] && c.push(d), b >>= 1;
                return c;
              }
              function Sh(a, b, c) {
                var d = null;
                b = r(Rh(a, b));
                for (var e = b.next(); !e.done; e = b.next()) {
                  e = e.value;
                  var f = a.h[e];
                  f.isVisible() && (d = Ih(f, c, a.i));
                  a.h[e] = null;
                }
                return d;
              }
              function Th(a) {
                a.g = null;
                a.h = [null, null, null, null, null, null, null, null];
              }
              function Uh(a, b, c) {
                var d = {
                  0: 0,
                  1: 0,
                  2: 1,
                  3: 1
                };
                a = d[a];
                b = d[b];
                c = d[c];
                return Vh[a << 2 | b << 1 | c];
              }
              var Wh = new Map([[32, " "], [33, "\u00a0"], [37, "\u2026"], [42, "\u0160"], [44, "\u0152"], [48, "\u2588"], [49, "\u2018"], [50, "\u2019"], [51, "\u201c"], [52, "\u201d"], [53, "\u2022"], [57, "\u2122"], [58, "\u0161"], [60, "\u0153"], [61, "\u2120"], [63, "\u0178"], [118, "\u215b"], [119, "\u215c"], [120, "\u215d"], [121, "\u215e"], [122, "\u2502"], [123, "\u2510"], [124, "\u2514"], [125, "\u2500"], [126, "\u2518"], [127, "\u250c"]]),
                Vh = "black blue green cyan red magenta yellow white".split(" ");
              function Xh() {
                this.h = [];
                this.g = [];
                this.i = new Lh();
                this.l = 0;
                this.s = new Map([["CC1", new sh(0, 0)], ["CC2", new sh(0, 1)], ["CC3", new sh(1, 0)], ["CC4", new sh(1, 1)]]);
                this.o = this.m = 0;
                this.j = new Map();
                Yh(this);
              }
              function Yh(a) {
                a.m = 0;
                a.o = 0;
                a = r(a.s.values());
                for (var b = a.next(); !b.done; b = a.next()) b = b.value, b.h = 2, b.g = b.i, b.m = null, fh(b.i), fh(b.l), fh(b.o);
              }
              function Zh(a) {
                function b(f, g) {
                  return f.pts - g.pts || f.order - g.order;
                }
                var c = [];
                a.h.sort(b);
                a.g.sort(b);
                for (var d = r(a.h), e = d.next(); !e.done; e = d.next()) (e = $h(a, e.value)) && c.push(e);
                d = r(a.g);
                for (e = d.next(); !e.done; e = d.next()) Mh(a.i, e.value);
                d = r(a.i.i);
                for (e = d.next(); !e.done; e = d.next()) e = ai(a, e.value), c.push.apply(c, ha(e));
                a.i.i = [];
                a.h = [];
                a.g = [];
                return c;
              }
              function $h(a, b) {
                var c = b.type;
                if (16 === (b.xa & 112)) {
                  var d = b.xa >> 3 & 1;
                  0 === c ? a.m = d : a.o = d;
                }
                c = a.s.get("CC" + (c << 1 | (c ? a.o : a.m) + 1));
                if (255 === b.xa && 255 === b.La || !b.xa && !b.La || !bi(b.xa) || !bi(b.La)) return 45 <= ++a.l && Yh(a), null;
                a.l = 0;
                b.xa &= 127;
                b.La &= 127;
                if (!b.xa && !b.La) return null;
                a = null;
                if (16 === (b.xa & 112)) a: {
                  d = b.xa;
                  a = b.La;
                  if (c.m === (d << 8 | a)) c.m = null;else if (c.m = d << 8 | a, 16 === (d & 240) && 64 === (a & 192)) {
                    b = [11, 11, 1, 2, 3, 4, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10][(d & 7) << 1 | a >> 5 & 1];
                    var e = (a & 30) >> 1;
                    d = "white";
                    var f = !1;
                    7 > e ? d = Bh[e] : 7 === e && (f = !0);
                    a = 1 === (a & 1);
                    if (c.h !== wh) {
                      e = c.g;
                      if (c.h === vh && b !== e.g) {
                        var g = 1 + b - e.h;
                        rh(e, g, 1 + e.g - e.h, e.h);
                        hh(e, 0, g - 1);
                        hh(e, b + 1, 15 - b);
                      }
                      e.g = b;
                      c.g.m = a;
                      c.g.j = f;
                      c.g.l = d;
                      c.g.o = "black";
                    }
                  } else if (17 === (d & 247) && 32 === (a & 240)) c.g.m = !1, c.g.j = !1, c.g.l = "white", ih(c.g, jh, 32), d = !1, b = Bh[(a & 14) >> 1], "white_italics" === b && (b = "white", d = !0), c.g.m = 1 === (a & 1), c.g.j = d, c.g.l = b;else if (16 === (d & 247) && 32 === (a & 240) || 23 === (d & 247) && 45 === (a & 255)) b = "black", 0 === (d & 7) && (b = Ah[(a & 14) >> 1]), c.g.o = b;else if (17 === (d & 247) && 48 === (a & 240)) ih(c.g, lh, a);else if (18 === (d & 246) && 32 === (a & 224)) ih(c.g, d & 1 ? ph : nh, a);else if (20 === (d & 246) && 32 === (a & 240)) {
                    a = b.pts;
                    d = null;
                    switch (b.La) {
                      case 32:
                        xh(c);
                        break;
                      case 33:
                        c = c.g;
                        c.i[c.g].pop();
                        break;
                      case 37:
                        d = uh(c, 2, a);
                        break;
                      case 38:
                        d = uh(c, 3, a);
                        break;
                      case 39:
                        d = uh(c, 4, a);
                        break;
                      case 40:
                        ih(c.g, jh, 32);
                        break;
                      case 41:
                        c.h = 2;
                        c.g = c.i;
                        c.g.h = 0;
                        c.j = a;
                        break;
                      case 42:
                        fh(c.o);
                        zh(c);
                        break;
                      case 43:
                        zh(c);
                        break;
                      case 44:
                        b = c.i;
                        d = null;
                        c.h !== wh && (d = gh(b, c.j, a));
                        hh(b, 0, 15);
                        break;
                      case 45:
                        b = c.g;
                        c.h !== vh ? d = null : (d = gh(b, c.j, a), f = b.g - b.h + 1, rh(b, f - 1, f, b.h), hh(b, 0, f - 1), hh(b, b.g, 15 - b.g), c.j = a);
                        break;
                      case 46:
                        hh(c.l, 0, 15);
                        break;
                      case 47:
                        b = null, c.h !== wh && (b = gh(c.i, c.j, a)), d = c.l, c.l = c.i, c.i = d, xh(c), c.j = a, d = b;
                    }
                    a = d;
                    break a;
                  }
                  a = null;
                } else d = b.La, ih(c.g, jh, b.xa), ih(c.g, jh, d);
                return a;
              }
              function ai(a, b) {
                var c = [];
                try {
                  for (; b.ha();) {
                    var d = Oh(b).value,
                      e = (d & 224) >> 5,
                      f = d & 31;
                    7 === e && 0 != f && (e = Oh(b).value & 63);
                    if (0 != e) {
                      a.j.has(e) || a.j.set(e, new Ph(e));
                      for (var g = a.j.get(e), h = b.Z(); b.Z() - h < f;) {
                        e = b;
                        var k = Oh(e),
                          l = k.value,
                          m = k.pts;
                        if (16 === l) {
                          var n = Oh(e);
                          l = l << 16 | n.value;
                        }
                        if (0 <= l && 31 >= l) {
                          var p = m;
                          if (g.g) {
                            var t = g.g;
                            e = null;
                            switch (l) {
                              case 8:
                                !Hh(t) || 0 >= t.g && 0 >= t.h || (0 >= t.g ? (t.g = t.B - 1, t.h--) : t.g--, t.i[t.h][t.g] = null);
                                break;
                              case 13:
                                t.isVisible() && (e = Ih(t, p, g.i));
                                if (t.h + 1 >= t.F) {
                                  p = t;
                                  for (var v = 0, y = 1; 16 > y; y++, v++) p.i[v] = p.i[y];
                                  for (y = 0; 1 > y; y++, v++) p.i[v] = Fh();
                                } else t.h++;
                                t.g = 0;
                                break;
                              case 14:
                                t.isVisible() && (e = Ih(t, p, g.i));
                                t.i[t.h] = Fh();
                                t.g = 0;
                                break;
                              case 12:
                                t.isVisible() && (e = Ih(t, p, g.i)), Eh(t), p = t, p.h = 0, p.g = 0;
                            }
                            var w = e;
                          } else w = null;
                        } else if (128 <= l && 159 >= l) w = Qh(g, e, l, m);else {
                          if (4096 <= l && 4127 >= l) p = l & 255, 8 <= p && 15 >= p ? e.skip(1) : 16 <= p && 23 >= p ? e.skip(2) : 24 <= p && 31 >= p && e.skip(3);else if (4224 <= l && 4255 >= l) p = l & 255, 128 <= p && 135 >= p ? e.skip(4) : 136 <= p && 143 >= p && e.skip(5);else if (32 <= l && 127 >= l) e = l, g.g && (127 === e ? Gh(g.g, "\u266a") : Gh(g.g, String.fromCharCode(e)));else if (160 <= l && 255 >= l) g.g && Gh(g.g, String.fromCharCode(l));else if (4128 <= l && 4223 >= l) {
                            if (e = l & 255, g.g) if (Wh.has(e)) {
                              var x = Wh.get(e);
                              Gh(g.g, x);
                            } else Gh(g.g, "_");
                          } else 4256 <= l && 4351 >= l && g.g && (160 != (l & 255) ? Gh(g.g, "_") : Gh(g.g, "[CC]"));
                          w = null;
                        }
                        (e = w) && c.push(e);
                      }
                    }
                  }
                } catch (C) {
                  if (C instanceof O && 3E3 === C.code) Xa("CEA708_INVALID_DATA", "Buffer read out of bounds / invalid CEA-708 Data.");else throw C;
                }
                return c;
              }
              function bi(a) {
                for (var b = 0; a;) b ^= a & 1, a >>= 1;
                return 1 === b;
              }
              function ci() {}
              ci.prototype.init = function () {};
              ci.prototype.parse = function () {
                return [];
              };
              function di(a, b) {
                var c = null,
                  d = null,
                  e = null,
                  f = a.K();
                b & 1 && (e = a.$a());
                b & 2 && a.skip(4);
                b & 8 && (c = a.K());
                b & 16 && (d = a.K());
                return {
                  trackId: f,
                  Ce: c,
                  xf: d,
                  rh: e
                };
              }
              function ei(a, b) {
                return {
                  we: 1 == b ? a.$a() : a.K()
                };
              }
              function fi(a, b) {
                1 == b ? (a.skip(8), a.skip(8)) : (a.skip(4), a.skip(4));
                return {
                  timescale: a.K()
                };
              }
              function gi(a, b, c) {
                var d = a.K(),
                  e = [],
                  f = null;
                c & 1 && (f = a.K());
                c & 4 && a.skip(4);
                for (var g = 0; g < d; g++) {
                  var h = {
                    ee: null,
                    sampleSize: null,
                    ed: null
                  };
                  c & 256 && (h.ee = a.K());
                  c & 512 && (h.sampleSize = a.K());
                  c & 1024 && a.skip(4);
                  c & 2048 && (h.ed = 0 == b ? a.K() : a.Pe());
                  e.push(h);
                }
                return {
                  wh: d,
                  Re: e,
                  wf: f
                };
              }
              function hi() {
                this.j = new Map();
                this.i = this.h = 0;
                this.g = ii;
              }
              hi.prototype.init = function (a) {
                function b(f) {
                  f = f.name;
                  f in ji && (c.g = ji[f]);
                }
                var c = this,
                  d = [],
                  e = [];
                new zf().box("moov", Ef).box("mvex", Ef).P("trex", function (f) {
                  var g = f.reader;
                  g.skip(4);
                  g.skip(4);
                  f = g.K();
                  g = g.K();
                  c.h = f;
                  c.i = g;
                }).box("trak", Ef).P("tkhd", function (f) {
                  var g = f.reader;
                  1 == f.version ? (g.skip(8), g.skip(8)) : (g.skip(4), g.skip(4));
                  f = g.K();
                  d.push(f);
                }).box("mdia", Ef).P("mdhd", function (f) {
                  f = fi(f.reader, f.version);
                  e.push(f.timescale);
                }).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("avc1", b).box("avc3", b).box("hev1", b).box("hvc1", b).box("dvh1", b).box("dvhe", b).box("encv", Hf).box("sinf", Ef).box("frma", function (f) {
                  f = f.reader.K();
                  f = Df(f);
                  f in ji && (c.g = ji[f]);
                }).parse(a, !0);
                if (!d.length || !e.length || d.length != e.length) throw new O(2, 2, 2010);
                this.g == ii && Wa("Unable to determine bitstream format for CEA parsing!");
                d.forEach(function (f, g) {
                  c.j.set(f, e[g]);
                });
              };
              hi.prototype.parse = function (a) {
                var b = this;
                if (this.g == ii) return [];
                var c = [],
                  d = this.h,
                  e = this.i,
                  f = [],
                  g = null,
                  h = null,
                  k = null,
                  l = 9E4;
                new zf().box("moof", function (m) {
                  g = m.start;
                  Ef(m);
                }).box("traf", Ef).P("trun", function (m) {
                  m = gi(m.reader, m.version, m.flags);
                  f = m.Re;
                  h = m.wf;
                }).P("tfhd", function (m) {
                  m = di(m.reader, m.flags);
                  d = m.Ce || b.h;
                  e = m.xf || b.i;
                  m = m.trackId;
                  b.j.has(m) && (l = b.j.get(m));
                }).P("tfdt", function (m) {
                  k = ei(m.reader, m.version).we;
                }).box("mdat", function (m) {
                  if (null === k) throw new O(2, 2, 2010);
                  a: {
                    var n = m.reader,
                      p = k,
                      t = l,
                      v = d,
                      y = e,
                      w = f,
                      x = 0,
                      C = y;
                    w.length && (C = w[0].sampleSize || y);
                    for (n.skip((g || 0) + (h || 0) - m.start - 8); n.ha();) {
                      m = n.K();
                      var z = n.Ra();
                      switch (b.g) {
                        case ki:
                          z &= 31;
                          z = 6 == z;
                          break;
                        case li:
                          z = z >> 1 & 63;
                          z = 39 == z || 40 == z;
                          break;
                        default:
                          break a;
                      }
                      if (z) {
                        z = 0;
                        w.length > x && (z = w[x].ed || 0);
                        z = (p + z) / t;
                        for (var B = [], E, F = n.Za(m - 1), H = E = 0; H < F.length;) 2 == E && 3 == F[H] ? (E = 0, F = [].concat(ha(F)), F.splice(H, 1), F = new Uint8Array(F)) : 0 == F[H] ? E++ : E = 0, H++;
                        E = F;
                        for (H = 0; H < E.length;) {
                          for (F = 0; 255 == E[H];) F += 255, H++;
                          F += E[H++];
                          for (var I = 0; 255 == E[H];) I += 255, H++;
                          I += E[H++];
                          4 == F && B.push(E.subarray(H, H + I));
                          H += I;
                        }
                        B = r(B);
                        for (E = B.next(); !E.done; E = B.next()) c.push({
                          ig: E.value,
                          pts: z
                        });
                      } else try {
                        n.skip(m - 1);
                      } catch (J) {
                        break;
                      }
                      C -= m + 4;
                      0 == C && (p = w.length > x ? p + (w[x].ee || v) : p + v, x++, C = w.length > x ? w[x].sampleSize || y : y);
                    }
                  }
                }).parse(a, !1);
                return c;
              };
              var ii = 0,
                ki = 1,
                li = 2,
                ji = {
                  avc1: ki,
                  avc3: ki,
                  hev1: li,
                  hvc1: li,
                  dvh1: li,
                  dvhe: li
                };
              function mi(a) {
                this.h = new ci();
                a.includes("video/mp4") && (this.h = new hi());
                this.g = new Xh();
              }
              mi.prototype.init = function (a) {
                this.h.init(a);
              };
              function ni(a, b) {
                b = a.h.parse(b);
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) {
                  var d = c.value,
                    e = M(d.ig);
                  if (0 < e.length && (c = a.g, d = d.pts, e = new wf(e, 0), 181 === e.Ra() && 49 === e.$d() && 1195456820 === e.K() && 3 === e.Ra())) {
                    var f = e.Ra();
                    if (0 !== (f & 64)) {
                      f &= 31;
                      e.skip(1);
                      for (var g = 0; g < f; g++) {
                        var h = e.Ra(),
                          k = (h & 4) >> 2,
                          l = e.Ra(),
                          m = e.Ra();
                        k && (h &= 3, 0 === h || 1 === h ? c.h.push({
                          pts: d,
                          type: h,
                          xa: l,
                          La: m,
                          order: c.h.length
                        }) : (c.g.push({
                          pts: d,
                          type: h,
                          value: l,
                          order: c.g.length
                        }), c.g.push({
                          pts: d,
                          type: 2,
                          value: m,
                          order: c.g.length
                        })));
                      }
                    }
                  }
                }
                return Zh(a.g);
              }
              function oi(a, b, c, d, e) {
                this.ya = a;
                this.Ba = b;
                this.ka = c;
                this.Od = void 0 === d ? null : d;
                this.timescale = e;
              }
              oi.prototype.lc = function () {
                return this.Ba;
              };
              oi.prototype.hc = function () {
                return this.ka;
              };
              function pi(a, b) {
                return a && b ? a.lc() == b.lc() && a.hc() == b.hc() && jb(a.ya(), b.ya()) : a == b;
              }
              K("shaka.media.InitSegmentReference", oi);
              oi.prototype.getEndByte = oi.prototype.hc;
              oi.prototype.getStartByte = oi.prototype.lc;
              function qi(a, b, c, d, e, f, g, h, k, l, m, n, p, t, v) {
                l = void 0 === l ? [] : l;
                t = void 0 === t ? ri : t;
                this.startTime = a;
                this.j = this.endTime = b;
                this.u = c;
                this.Ba = d;
                this.ka = e;
                this.h = f;
                this.timestampOffset = g;
                this.appendWindowStart = h;
                this.appendWindowEnd = k;
                this.i = l;
                this.tilesLayout = void 0 === m ? "" : m;
                this.s = void 0 === n ? null : n;
                this.g = void 0 === p ? null : p;
                this.status = t;
                this.l = void 0 === v ? null : v;
                this.o = null;
                this.m = 0;
              }
              q = qi.prototype;
              q.ya = function () {
                return this.u();
              };
              q.getStartTime = function () {
                return this.startTime;
              };
              q.Ef = function () {
                return this.endTime;
              };
              q.lc = function () {
                return this.Ba;
              };
              q.hc = function () {
                return this.ka;
              };
              q.Vf = function () {
                return this.tilesLayout;
              };
              q.Uf = function () {
                return this.s;
              };
              q.Eb = function () {
                return this.status;
              };
              q.bg = function () {
                this.status = si;
              };
              q.Ye = function (a) {
                this.o = a;
              };
              q.Sf = function () {
                return this.o;
              };
              q.offset = function (a) {
                this.startTime += a;
                this.endTime += a;
                this.j += a;
                for (var b = r(this.i), c = b.next(); !c.done; c = b.next()) c = c.value, c.startTime += a, c.endTime += a, c.j += a;
              };
              q.oe = function (a) {
                null == this.g ? Va("Sync attempted without sync time!") : (a = this.g - a - this.startTime, .001 <= Math.abs(a) && this.offset(a));
              };
              K("shaka.media.SegmentReference", qi);
              qi.prototype.syncAgainst = qi.prototype.oe;
              qi.prototype.offset = qi.prototype.offset;
              qi.prototype.getThumbnailSprite = qi.prototype.Sf;
              qi.prototype.setThumbnailSprite = qi.prototype.Ye;
              qi.prototype.markAsUnavailable = qi.prototype.bg;
              qi.prototype.getStatus = qi.prototype.Eb;
              qi.prototype.getTileDuration = qi.prototype.Uf;
              qi.prototype.getTilesLayout = qi.prototype.Vf;
              qi.prototype.getEndByte = qi.prototype.hc;
              qi.prototype.getStartByte = qi.prototype.lc;
              qi.prototype.getEndTime = qi.prototype.Ef;
              qi.prototype.getStartTime = qi.prototype.getStartTime;
              qi.prototype.getUris = qi.prototype.ya;
              var ri = 0,
                si = 1;
              qi.Status = {
                Hg: ri,
                oh: si,
                Vg: 2
              };
              function ti(a) {
                return !a || 1 == a.length && 1E-6 > a.end(0) - a.start(0) ? null : 1 == a.length && 0 > a.start(0) ? 0 : a.length ? a.start(0) : null;
              }
              function ui(a) {
                return !a || 1 == a.length && 1E-6 > a.end(0) - a.start(0) ? null : a.length ? a.end(a.length - 1) : null;
              }
              function vi(a, b) {
                return !a || !a.length || 1 == a.length && 1E-6 > a.end(0) - a.start(0) || b > a.end(a.length - 1) ? !1 : b >= a.start(0);
              }
              function wi(a, b) {
                if (!a || !a.length || 1 == a.length && 1E-6 > a.end(0) - a.start(0)) return 0;
                var c = 0;
                a = r(xi(a));
                for (var d = a.next(); !d.done; d = a.next()) {
                  var e = d.value;
                  d = e.start;
                  e = e.end;
                  e > b && (c += e - Math.max(d, b));
                }
                return c;
              }
              function yi(a, b, c) {
                if (!a || !a.length || 1 == a.length && 1E-6 > a.end(0) - a.start(0)) return null;
                a = xi(a).findIndex(function (d, e, f) {
                  return d.start > b && (0 == e || f[e - 1].end - b <= c);
                });
                return 0 <= a ? a : null;
              }
              function xi(a) {
                if (!a) return [];
                for (var b = [], c = 0; c < a.length; c++) b.push({
                  start: a.start(c),
                  end: a.end(c)
                });
                return b;
              }
              function zi() {}
              function Ai(a, b) {
                var c = (a[b] & 127) << 21;
                c |= (a[b + 1] & 127) << 14;
                c |= (a[b + 2] & 127) << 7;
                return c |= a[b + 3] & 127;
              }
              function Bi(a) {
                var b = {
                  key: a.type,
                  description: "",
                  data: ""
                };
                if ("TXXX" === a.type) {
                  if (2 > a.size || 3 !== a.data[0]) return null;
                  var c = a.data.subarray(1).indexOf(0);
                  if (-1 === c) return null;
                  var d = Cc(M(a.data, 1, c));
                  a = Cc(M(a.data, 2 + c)).replace(/\0*$/, "");
                  b.description = d;
                  b.data = a;
                  return b;
                }
                if ("WXXX" === a.type) {
                  if (2 > a.size || 3 !== a.data[0]) return null;
                  c = a.data.subarray(1).indexOf(0);
                  if (-1 === c) return null;
                  d = Cc(M(a.data, 1, c));
                  a = Cc(M(a.data, 2 + c)).replace(/\0*$/, "");
                  b.description = d;
                  b.data = a;
                  return b;
                }
                if ("PRIV" === a.type) {
                  if (2 > a.size) return null;
                  d = a.data.indexOf(0);
                  if (-1 === d) return null;
                  d = Cc(M(a.data, 0, d));
                  a = Ib(a.data.subarray(d.length + 1));
                  b.description = d;
                  b.data = a;
                  return b;
                }
                if ("T" === a.type[0]) {
                  if (2 > a.size || 3 !== a.data[0]) return null;
                  a = Cc(a.data.subarray(1)).replace(/\0*$/, "");
                  b.data = a;
                  return b;
                }
                return "W" === a.type[0] ? (a = Cc(a.data).replace(/\0*$/, ""), b.data = a, b) : a.data ? (b.data = Ib(a.data), b) : null;
              }
              function Ci(a) {
                for (var b = 0, c = []; b + 10 <= a.length && 73 === a[b] && 68 === a[b + 1] && 51 === a[b + 2] && 255 > a[b + 3] && 255 > a[b + 4] && 128 > a[b + 6] && 128 > a[b + 7] && 128 > a[b + 8] && 128 > a[b + 9];) {
                  var d = Ai(a, b + 6);
                  a[b + 5] >> 6 & 1 && (b += 10);
                  b += 10;
                  for (d = b + d; b + 10 < d;) {
                    var e = a.subarray(b),
                      f = Ai(e, 4);
                    e = {
                      type: String.fromCharCode(e[0], e[1], e[2], e[3]),
                      size: f,
                      data: e.subarray(10, 10 + f)
                    };
                    (f = Bi(e)) && c.push(f);
                    b += e.size + 10;
                  }
                  b + 10 <= a.length && 51 === a[b] && 68 === a[b + 1] && 73 === a[b + 2] && 255 > a[b + 3] && 255 > a[b + 4] && 128 > a[b + 6] && 128 > a[b + 7] && 128 > a[b + 8] && 128 > a[b + 9] && (b += 10);
                }
                return c;
              }
              K("shaka.util.Id3Utils", zi);
              zi.getID3Frames = Ci;
              function Di() {
                this.o = null;
                this.s = !1;
                this.l = this.m = null;
                this.B = [];
                this.g = this.h = null;
                this.u = [];
                this.j = null;
                this.i = [];
              }
              Di.prototype.parse = function (a) {
                if (564 > a.length) return this;
                for (var b = Math.max(0, Ei(a)), c = a.length - (a.length + b) % 188, d = !1, e = b; e < c; e += 188) if (71 === a[e]) {
                  var f = !!(a[e + 1] & 64),
                    g = ((a[e + 1] & 31) << 8) + a[e + 2];
                  if (1 < (a[e + 3] & 48) >> 4) {
                    var h = e + 5 + a[e + 4];
                    if (h === e + 188) continue;
                  } else h = e + 4;
                  switch (g) {
                    case 0:
                      f && (h += a[h] + 1);
                      this.o = (a[h + 10] & 31) << 8 | a[h + 11];
                      break;
                    case 17:
                    case 8191:
                      break;
                    case this.o:
                      f && (h += a[h] + 1);
                      f = a;
                      g = {
                        audio: -1,
                        video: -1,
                        Ed: -1,
                        audioCodec: "",
                        videoCodec: ""
                      };
                      var k = h + 3 + ((f[h + 1] & 15) << 8 | f[h + 2]) - 4;
                      for (h += 12 + ((f[h + 10] & 15) << 8 | f[h + 11]); h < k;) {
                        var l = (f[h + 1] & 31) << 8 | f[h + 2];
                        switch (f[h]) {
                          case 15:
                            -1 === g.audio && (g.audio = l, g.audioCodec = "aac");
                            break;
                          case 21:
                            -1 === g.Ed && (g.Ed = l);
                            break;
                          case 27:
                            -1 === g.video && (g.video = l, g.videoCodec = "avc");
                            break;
                          case 3:
                          case 4:
                            -1 === g.audio && (g.audio = l, g.audioCodec = "mp3");
                            break;
                          case 36:
                            -1 === g.video && (g.video = l, g.videoCodec = "hvc");
                        }
                        h += ((f[h + 3] & 15) << 8 | f[h + 4]) + 5;
                      }
                      f = g;
                      null == this.l && (this.l = f.video);
                      null == this.g && (this.g = f.audio);
                      null == this.j && (this.j = f.Ed);
                      d && !this.s && (d = !1, e = b - 188);
                      this.s = !0;
                      break;
                    case this.l:
                      f = a.subarray(h, e + 188);
                      null == this.m && (h = Fi(f)) && null != h.pts && (this.m = h.pts / 9E4);
                      this.B.push(f);
                      break;
                    case this.g:
                      f = a.subarray(h, e + 188);
                      null == this.h && (h = Fi(f)) && null != h.pts && (this.h = h.pts / 9E4);
                      this.u.push(f);
                      break;
                    case this.j:
                      this.i.push(a.subarray(h, e + 188));
                      break;
                    default:
                      d = !0;
                  }
                }
                return this;
              };
              function Fi(a) {
                if (1 !== (a[0] << 16 | a[1] << 8 | a[2])) return null;
                var b = {
                    data: new Uint8Array(0),
                    vh: 6 + (a[4] << 8 | a[5]),
                    pts: null,
                    dts: null
                  },
                  c = a[7];
                c & 192 && (b.pts = 536870912 * (a[9] & 14) + 4194304 * (a[10] & 255) + 16384 * (a[11] & 254) + 128 * (a[12] & 255) + (a[13] & 254) / 2, b.dts = b.pts, c & 64 && (b.dts = 536870912 * (a[14] & 14) + 4194304 * (a[15] & 255) + 16384 * (a[16] & 254) + 128 * (a[17] & 255) + (a[18] & 254) / 2));
                b.data = a.subarray(9 + a[8]);
                return b;
              }
              function Gi(a) {
                for (var b = [], c = new Uint8Array(0), d = a.i.length - 1; 0 <= d; d--) {
                  c = Oc(a.i[d], c);
                  var e = Fi(c);
                  e && (b.unshift({
                    cueTime: e.pts ? e.pts / 9E4 : null,
                    data: e.data,
                    frames: Ci(e.data),
                    dts: e.dts,
                    pts: e.pts
                  }), c = new Uint8Array(0));
                }
                return b;
              }
              Di.prototype.getStartTime = function () {
                return {
                  audio: this.h,
                  video: this.m
                };
              };
              function Ei(a) {
                for (var b = Math.min(1E3, a.length - 564), c = 0; c < b;) {
                  if (71 === a[c] && 71 === a[c + 188] && 71 === a[c + 376]) return c;
                  c++;
                }
                return -1;
              }
              K("shaka.util.TsParser", Di);
              function Hi(a, b, c) {
                this.g = null;
                this.i = -1;
                this.j = a;
                this.h = b;
                this.l = c;
                "undefined" === typeof libDPIModule && Wa("Could not Find LCEVC Library dependencies on this page");
                "undefined" === typeof LcevcDil ? Wa("Could not Find LCEVC Library on this page") : LcevcDil.SupportObject.SupportStatus || Wa(LcevcDil.SupportObject.SupportError);
                "undefined" !== typeof LcevcDil && "undefined" !== typeof libDPIModule && this.h instanceof HTMLCanvasElement && LcevcDil.SupportObject.SupportStatus && !this.g && LcevcDil.SupportObject.webGLSupport(this.h) && (this.h.classList.remove("shaka-hidden"), this.g = new LcevcDil.LcevcDil(this.j, this.h, this.l));
              }
              Hi.prototype.release = function () {
                this.g && (this.g.close(), this.g = null);
              };
              function Ii(a, b) {
                var c = Ji;
                switch (b.mimeType) {
                  case "video/webm":
                    c = Ki;
                    break;
                  case "video/mp4":
                    c = Li;
                }
                a.g && (a.i = b.id, a.g.setLevelSwitching(b.id, !0), a.g.setContainerFormat(c));
              }
              K("shaka.lcevc.Dil", Hi);
              Hi.prototype.release = Hi.prototype.release;
              var Ji = 0,
                Ki = 1,
                Li = 2;
              function Mi(a, b, c, d) {
                var e = this;
                this.j = a;
                this.F = null;
                this.m = b;
                this.h = {};
                this.L = {};
                this.O = {};
                this.g = null;
                this.H = !1;
                this.V = c || function () {};
                this.D = d || null;
                this.i = {};
                this.u = new mf();
                this.o = {};
                this.s = null;
                this.J = new lc();
                this.l = Ni(this, this.J);
                this.G = new kf(function () {
                  return Oi(e);
                });
                this.M = "";
                this.B = !1;
                this.W = new lc();
              }
              function Ni(a, b) {
                var c = new MediaSource();
                a.u.ma(c, "sourceopen", function () {
                  URL.revokeObjectURL(a.M);
                  b.resolve();
                });
                a.M = Pi(c);
                a.j.src = a.M;
                return c;
              }
              q = Mi.prototype;
              q.destroy = function () {
                return this.G.destroy();
              };
              function Oi(a) {
                var b, c, d, e, f, g, h, k;
                return G(function (l) {
                  if (1 == l.g) {
                    b = [];
                    for (c in a.i) for (d = a.i[c], e = d[0], a.i[c] = d.slice(0, 1), e && b.push(e.p.catch(cc)), f = r(d.slice(1)), g = f.next(); !g.done; g = f.next()) h = g.value, h.p.reject(new O(2, 7, 7003, void 0));
                    a.g && b.push(a.g.destroy());
                    a.m && b.push(a.m.destroy());
                    for (k in a.o) b.push(a.o[k].destroy());
                    return u(l, Promise.all(b), 2);
                  }
                  a.u && (a.u.release(), a.u = null);
                  a.j && (a.j.removeAttribute("src"), a.j.load(), a.j = null);
                  a.F = null;
                  a.l = null;
                  a.g = null;
                  a.m = null;
                  a.h = {};
                  a.o = {};
                  a.s = null;
                  a.i = {};
                  a.D = null;
                  A(l);
                });
              }
              q.init = function (a, b, c) {
                c = void 0 === c ? !1 : c;
                var d = this,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l,
                  m,
                  n;
                return G(function (p) {
                  if (1 == p.g) return e = kc, u(p, d.J, 2);
                  d.B = c;
                  f = {};
                  g = r(a.keys());
                  for (h = g.next(); !h.done; f = {
                    na: f.na
                  }, h = g.next()) f.na = h.value, k = a.get(f.na), l = Zc(k.mimeType, k.codecs), f.na == e.X ? Qi(d, l, c) : (!b && eb(l) || !Tc(l, f.na) || (d.o[f.na] = new Sc(l), l = Wc(f.na, l)), m = l + d.F.sourceBufferExtraFeatures, n = d.l.addSourceBuffer(m), d.u.C(n, "error", function (t) {
                    return function () {
                      d.i[t.na][0].p.reject(new O(2, 3, 3014, d.j.error ? d.j.error.code : 0));
                    };
                  }(f)), d.u.C(n, "updateend", function (t) {
                    return function () {
                      return Ri(d, t.na);
                    };
                  }(f)), d.h[f.na] = n, d.L[f.na] = l, d.i[f.na] = [], d.O[f.na] = !!k.drmInfos.length);
                  A(p);
                });
              };
              q.configure = function (a) {
                this.F = a;
              };
              function Qi(a, b, c) {
                a.g || (a.g = new dd(a.m));
                var d = a.g;
                a = a.H;
                "application/cea-608" != b && "application/cea-708" != b && (d.j = (0, fd[b])(), d.j.setSequenceMode ? d.j.setSequenceMode(c) : Wa('Text parsers should have a "setSequenceMode" method!'), d.u = a);
              }
              function Si(a) {
                return a.l ? "ended" == a.l.readyState : !0;
              }
              function Ti(a, b) {
                return b == jc ? a.g.g : ti(Ui(a, b));
              }
              function Vi(a, b) {
                return b == jc ? a.g.h : ui(Ui(a, b));
              }
              function Wi(a, b, c) {
                if (b == jc) return a = a.g, null == a.h || a.h < c ? 0 : a.h - Math.max(c, a.g);
                a = Ui(a, b);
                return wi(a, c);
              }
              q.Na = function () {
                var a = {
                  total: xi(this.j.buffered),
                  audio: xi(Ui(this, "audio")),
                  video: xi(Ui(this, "video")),
                  text: []
                };
                if (this.g) {
                  var b = this.g.g,
                    c = this.g.h;
                  null != b && null != c && a.text.push({
                    start: b,
                    end: c
                  });
                }
                return a;
              };
              function Ui(a, b) {
                try {
                  return a.h[b].buffered;
                } catch (c) {
                  return null;
                }
              }
              function Xi(a, b, c, d, e, f, g) {
                f = void 0 === f ? !1 : f;
                g = void 0 === g ? !1 : g;
                var h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U;
                return G(function (N) {
                  switch (N.g) {
                    case 1:
                      h = kc;
                      if (b != h.X) {
                        N.A(2);
                        break;
                      }
                      if (!a.B) {
                        N.A(3);
                        break;
                      }
                      return u(N, a.W, 4);
                    case 4:
                      k = N.h, a.g.s = k;
                    case 3:
                      return u(N, gd(a.g, c, d ? d.startTime : null, d ? d.endTime : null), 5);
                    case 5:
                      return N.return();
                    case 2:
                      l = M(c);
                      m = a.L[b];
                      a.o[b] && (m = a.o[b].o);
                      0 > Ei(l) ? Yi.includes(m) && (v = Ci(l), v.length && d && (y = {
                        cueTime: d.startTime,
                        data: l,
                        frames: v,
                        dts: d.startTime,
                        pts: d.startTime
                      }, a.V([y], 0, d.endTime))) : (n = new Di().parse(l), p = d.startTime - (n.getStartTime()[b] || 0), t = Gi(n), t.length && a.V(t, p, d ? d.endTime : null));
                      if (!a.o[b]) {
                        e && b == h.va && (a.g || Qi(a, "text/vtt", a.B), a.s || (a.s = new mi(m)), d ? (w = ni(a.s, c), w.length && (x = a.h[h.va].timestampOffset, ld(a.g, w, d.startTime, d.endTime, x))) : a.s.init(c));
                        N.A(6);
                        break;
                      }
                      f && a.o[b].g.resetCaptions();
                      return u(N, Xc(a.o[b], c), 7);
                    case 7:
                      C = N.h, a.g || Qi(a, "text/vtt", a.B), C.captions && C.captions.length && (z = a.h[h.va].timestampOffset, B = jd(C.captions), ld(a.g, B, d ? d.startTime : null, d ? d.endTime : null, z)), c = C.data;
                    case 6:
                      c = Zi(a, c, d ? d.startTime : null, b);
                      E = a.h[b];
                      F = $i;
                      if (!a.B || E.mode == F || !d) {
                        N.A(8);
                        break;
                      }
                      H = a.l.duration;
                      I = b == h.va || !(h.va in a.h);
                      if (!I) {
                        N.A(9);
                        break;
                      }
                      J = [E.appendWindowStart, E.appendWindowEnd];
                      E.appendWindowStart = 0;
                      E.appendWindowEnd = Infinity;
                      L = E.timestampOffset;
                      E.timestampOffset = 0;
                      return u(N, aj(a, b, function () {
                        return bj(a, b, c);
                      }), 10);
                    case 10:
                      return u(N, aj(a, b, function () {
                        return cj(a, b);
                      }), 11);
                    case 11:
                      return E.timestampOffset = L, E.appendWindowStart = J[0], E.appendWindowEnd = J[1], R = ti(Ui(a, b)), Q = (d.startTime || 0) - (R || 0), a.W.resolve(Q), u(N, aj(a, b, function () {
                        return dj(a, b, 0, H);
                      }), 12);
                    case 12:
                      if (b != h.va) {
                        N.A(9);
                        break;
                      }
                      return u(N, aj(a, b, function () {
                        a.j.currentTime -= .001;
                        Ri(a, b);
                      }), 9);
                    case 9:
                      return E.mode = F, u(N, a.Aa(H), 8);
                    case 8:
                      return d && a.B && b != h.X && (f || g) && (U = d.startTime, aj(a, b, function () {
                        return cj(a, b);
                      }), aj(a, b, function () {
                        return ej(a, b, U);
                      })), u(N, aj(a, b, function () {
                        bj(a, b, c);
                      }), 16);
                    case 16:
                      A(N);
                  }
                });
              }
              function fj(a, b) {
                var c = Vi(a, "video") || 0;
                id(a.g, b, c);
              }
              function gj(a) {
                a.g && id(a.g, "", 0);
              }
              q.remove = function (a, b, c) {
                var d = this,
                  e;
                return G(function (f) {
                  e = kc;
                  return a == e.X ? u(f, d.g.remove(b, c), 0) : u(f, aj(d, a, function () {
                    return dj(d, a, b, c);
                  }), 0);
                });
              };
              function hj(a, b) {
                var c;
                return G(function (d) {
                  c = kc;
                  return b == c.X ? a.g ? u(d, a.g.remove(0, Infinity), 0) : d.return() : u(d, aj(a, b, function () {
                    return dj(a, b, 0, a.l.duration);
                  }), 0);
                });
              }
              q.flush = function (a) {
                var b = this,
                  c;
                return G(function (d) {
                  c = kc;
                  return a == c.X ? d.return() : u(d, aj(b, a, function () {
                    b.j.currentTime -= .001;
                    Ri(b, a);
                  }), 0);
                });
              };
              function ij(a, b, c, d, e, f) {
                var g;
                return G(function (h) {
                  g = kc;
                  return b == g.X ? (f || (a.g.s = c), hd(a.g, d, e), h.return()) : u(h, Promise.all([aj(a, b, function () {
                    return cj(a, b);
                  }), f ? Promise.resolve() : aj(a, b, function () {
                    return ej(a, b, c);
                  }), aj(a, b, function () {
                    a.h[b].appendWindowStart = 0;
                    a.h[b].appendWindowEnd = e;
                    a.h[b].appendWindowStart = d;
                    Ri(a, b);
                  })]), 0);
                });
              }
              function jj(a, b, c) {
                var d;
                return G(function (e) {
                  d = kc;
                  if (b == d.X) return e.return();
                  aj(a, b, function () {
                    return cj(a, b);
                  });
                  return u(e, aj(a, b, function () {
                    return ej(a, b, c);
                  }), 0);
                });
              }
              q.endOfStream = function (a) {
                var b = this;
                return G(function (c) {
                  return u(c, kj(b, function () {
                    Si(b) || (a ? b.l.endOfStream(a) : b.l.endOfStream());
                  }), 0);
                });
              };
              q.Aa = function (a) {
                var b = this;
                return G(function (c) {
                  return u(c, kj(b, function () {
                    if (a < b.l.duration) for (var d in b.h) {
                      var e = {
                        start: function start() {},
                        p: new lc()
                      };
                      b.i[d].unshift(e);
                    }
                    b.l.duration = a;
                  }), 0);
                });
              };
              q.getDuration = function () {
                return this.l.duration;
              };
              function bj(a, b, c) {
                if ("video" == b && a.D) {
                  var d = a.D;
                  d.g && d.g.appendBuffer(c, "video", d.i);
                }
                a.h[b].appendBuffer(c);
              }
              function dj(a, b, c, d) {
                d <= c ? Ri(a, b) : a.h[b].remove(c, d);
              }
              function cj(a, b) {
                var c = a.h[b].appendWindowStart,
                  d = a.h[b].appendWindowEnd;
                a.h[b].abort();
                a.h[b].appendWindowStart = c;
                a.h[b].appendWindowEnd = d;
                Ri(a, b);
              }
              function ej(a, b, c) {
                0 > c && (c += .001);
                a.h[b].timestampOffset = c;
                Ri(a, b);
              }
              function Ri(a, b) {
                var c = a.i[b][0];
                c && (c.p.resolve(), lj(a, b));
              }
              function aj(a, b, c) {
                lf(a.G);
                c = {
                  start: c,
                  p: new lc()
                };
                a.i[b].push(c);
                1 == a.i[b].length && mj(a, b);
                return c.p;
              }
              function kj(a, b) {
                var c, d, e, f, g, h;
                return G(function (k) {
                  switch (k.g) {
                    case 1:
                      lf(a.G);
                      c = [];
                      d = {};
                      for (e in a.h) d.Ub = new lc(), f = {
                        start: function (l) {
                          return function () {
                            return l.Ub.resolve();
                          };
                        }(d),
                        p: d.Ub
                      }, a.i[e].push(f), c.push(d.Ub), 1 == a.i[e].length && f.start(), d = {
                        Ub: d.Ub
                      };
                      D(k, 2);
                      return u(k, Promise.all(c), 4);
                    case 4:
                      ta(k, 3);
                      break;
                    case 2:
                      throw g = ua(k), g;
                    case 3:
                      try {
                        b();
                      } catch (l) {
                        throw new O(2, 3, 3015, l);
                      } finally {
                        for (h in a.h) lj(a, h);
                      }
                      A(k);
                  }
                });
              }
              function lj(a, b) {
                a.i[b].shift();
                mj(a, b);
              }
              function mj(a, b) {
                var c = a.i[b][0];
                if (c) try {
                  c.start();
                } catch (d) {
                  "QuotaExceededError" == d.name ? c.p.reject(new O(2, 3, 3017, b)) : c.p.reject(new O(2, 3, 3015, d)), lj(a, b);
                }
              }
              function Zi(a, b, c, d) {
                var e = a.O[d];
                null == c && e && (uc() || sc()) && "mp4" == a.L[d].split(";")[0].split("/")[1] && (b = Xg(b));
                return b;
              }
              var Pi = window.URL.createObjectURL,
                $i = "sequence",
                Yi = ["audio/aac", "audio/ac3", "audio/ec3", "audio/mpeg"];
              function T(a, b, c) {
                this.i = a;
                this.m = b;
                this.o = this.j = Infinity;
                this.g = 1;
                this.h = this.l = null;
                this.s = 0;
                this.u = !0;
                this.B = 0;
                this.D = void 0 === c ? !0 : c;
                this.F = 0;
                this.G = !1;
              }
              q = T.prototype;
              q.getDuration = function () {
                return this.j;
              };
              q.Kf = function () {
                return this.g;
              };
              q.Xe = function (a) {
                this.i = a;
              };
              q.Aa = function (a) {
                this.j = a;
              };
              q.Pf = function () {
                return this.i;
              };
              q.Ve = function (a) {
                this.s = a;
              };
              q.yc = function (a) {
                this.u = a;
              };
              q.me = function (a) {
                this.o = a;
              };
              q.We = function (a) {
                this.m = a;
              };
              q.Df = function () {
                return this.m;
              };
              q.Ib = function (a) {
                if (0 != a.length) {
                  var b = a[0].startTime,
                    c = a[0].endTime;
                  a = r(a);
                  for (var d = a.next(); !d.done; d = a.next()) d = d.value, b = Math.min(b, d.startTime), c = Math.max(c, d.endTime), this.g = Math.max(this.g, d.endTime - d.startTime);
                  this.Td(b);
                  this.h = Math.max(this.h, c);
                  null != this.i && this.D && !this.G && (this.i = (Date.now() + this.s) / 1E3 - this.h - this.g);
                }
              };
              q.Md = function () {
                this.G = !0;
              };
              q.Td = function (a) {
                this.l = null == this.l ? a : Math.min(this.l, a);
              };
              q.Sd = function (a) {
                this.g = Math.max(this.g, a);
              };
              q.offset = function (a) {
                null != this.l && (this.l += a);
                null != this.h && (this.h += a);
              };
              q.U = function () {
                return Infinity == this.j && !this.u;
              };
              q.jb = function () {
                return Infinity != this.j && !this.u;
              };
              q.Pa = function () {
                return Math.max(this.B, this.gb() - this.o);
              };
              q.Ze = function (a) {
                this.B = a;
              };
              q.gb = function () {
                return this.U() || this.jb() ? Math.min(Math.max(0, (Date.now() + this.s) / 1E3 - this.g - this.i) + this.F, this.j) : this.h ? Math.min(this.h, this.j) : this.j;
              };
              q.kc = function (a) {
                var b = Math.max(this.l, this.B);
                return Infinity == this.o ? Math.ceil(1E3 * b) / 1E3 : Math.max(b, Math.min(this.gb() - this.o + a, this.Oa()));
              };
              q.Db = function () {
                return this.kc(0);
              };
              q.Oa = function () {
                return Math.max(0, this.gb() - (this.U() || this.jb() ? this.m : 0));
              };
              q.df = function () {
                return null == this.i || null != this.h && this.D ? !1 : !0;
              };
              q.Ue = function (a) {
                this.F = a;
              };
              K("shaka.media.PresentationTimeline", T);
              T.prototype.setAvailabilityTimeOffset = T.prototype.Ue;
              T.prototype.usingPresentationStartTime = T.prototype.df;
              T.prototype.getSeekRangeEnd = T.prototype.Oa;
              T.prototype.getSeekRangeStart = T.prototype.Db;
              T.prototype.getSafeSeekRangeStart = T.prototype.kc;
              T.prototype.getSegmentAvailabilityEnd = T.prototype.gb;
              T.prototype.setUserSeekStart = T.prototype.Ze;
              T.prototype.getSegmentAvailabilityStart = T.prototype.Pa;
              T.prototype.isInProgress = T.prototype.jb;
              T.prototype.isLive = T.prototype.U;
              T.prototype.offset = T.prototype.offset;
              T.prototype.notifyMaxSegmentDuration = T.prototype.Sd;
              T.prototype.notifyMinSegmentStartTime = T.prototype.Td;
              T.prototype.lockStartTime = T.prototype.Md;
              T.prototype.notifySegments = T.prototype.Ib;
              T.prototype.getDelay = T.prototype.Df;
              T.prototype.setDelay = T.prototype.We;
              T.prototype.setSegmentAvailabilityDuration = T.prototype.me;
              T.prototype.setStatic = T.prototype.yc;
              T.prototype.setClockOffset = T.prototype.Ve;
              T.prototype.getPresentationStartTime = T.prototype.Pf;
              T.prototype.setDuration = T.prototype.Aa;
              T.prototype.setPresentationStartTime = T.prototype.Xe;
              T.prototype.getMaxSegmentDuration = T.prototype.Kf;
              T.prototype.getDuration = T.prototype.getDuration;
              function nj(a, b, c) {
                this.l = c;
                this.j = a;
                this.s = oj(a);
                this.g = a.g.currentTime;
                this.m = Date.now() / 1E3;
                this.h = !1;
                this.o = 0;
                this.u = b;
                this.i = function () {};
              }
              nj.prototype.release = function () {
                this.l = this.j = null;
                this.i = function () {};
              };
              function pj(a, b) {
                a.i = b;
              }
              function qj(a) {
                this.g = a;
              }
              function oj(a) {
                if (a.g.paused || 0 == a.g.playbackRate || 0 == a.g.buffered.length) var b = !1;else a: {
                  b = a.g.currentTime;
                  a = r(xi(a.g.buffered));
                  for (var c = a.next(); !c.done; c = a.next()) if (c = c.value, !(b < c.start - .1 || b > c.end - .5)) {
                    b = !0;
                    break a;
                  }
                  b = !1;
                }
                return b;
              }
              function rj(a, b, c, d, e) {
                var f = this;
                this.o = e;
                this.g = a;
                this.s = b;
                this.D = c;
                this.i = new mf();
                this.m = !1;
                this.B = a.readyState;
                this.u = 0;
                this.h = d;
                this.l = !1;
                this.i.C(a, "waiting", function () {
                  return sj(f);
                });
                this.j = new P(function () {
                  sj(f);
                }).Ca(.25);
              }
              rj.prototype.release = function () {
                this.i && (this.i.release(), this.i = null);
                null != this.j && (this.j.stop(), this.j = null);
                this.h && (this.h.release(), this.h = null);
                this.g = this.s = this.o = null;
              };
              rj.prototype.Wd = function () {
                this.l = !0;
                sj(this);
              };
              function sj(a) {
                if (0 != a.g.readyState) {
                  if (a.g.seeking) {
                    if (!a.m) return;
                  } else a.m = !1;
                  if (!a.g.paused || 0 == a.g.currentTime && (a.g.autoplay || 0 != a.g.currentTime)) {
                    a.g.readyState != a.B && (a.B = a.g.readyState);
                    var b;
                    if (!(b = !a.h)) {
                      b = a.h;
                      var c = b.j,
                        d = oj(c),
                        e = c.g.currentTime,
                        f = Date.now() / 1E3;
                      if (b.g != e || b.s != d) b.m = f, b.g = e, b.s = d, b.h = !1;
                      e = f - b.m;
                      if (d = e >= b.u && d && !b.h) b.i(b.g, e), b.h = !0, b.g = c.g.currentTime, b.o++, b.l(new S("stalldetected"));
                      b = !d;
                    }
                    b && (b = a.g.currentTime, c = a.g.buffered, d = yi(c, b, a.D.gapDetectionThreshold), null == d || 0 == d && !a.l || (e = c.start(d), e >= a.s.Oa() || .001 > e - b || (0 != d && c.end(d - 1), a.g.currentTime = e, a.u++, a.o(new S("gapjumped")))));
                  }
                }
              }
              function tj(a, b, c, d) {
                b == HTMLMediaElement.HAVE_NOTHING || a.readyState >= b ? d() : (b = uj.value().get(b), c.ma(a, b, d));
              }
              var uj = new mc(function () {
                return new Map([[HTMLMediaElement.HAVE_METADATA, "loadedmetadata"], [HTMLMediaElement.HAVE_CURRENT_DATA, "loadeddata"], [HTMLMediaElement.HAVE_FUTURE_DATA, "canplay"], [HTMLMediaElement.HAVE_ENOUGH_DATA, "canplaythrough"]]);
              });
              function vj(a, b, c) {
                var d = this;
                this.g = a;
                this.l = b;
                this.j = c;
                this.m = !1;
                this.h = new mf();
                this.i = new wj(a);
                tj(this.g, HTMLMediaElement.HAVE_METADATA, this.h, function () {
                  xj(d, d.j);
                });
              }
              vj.prototype.release = function () {
                this.h && (this.h.release(), this.h = null);
                null != this.i && (this.i.release(), this.i = null);
                this.l = function () {};
                this.g = null;
              };
              function yj(a) {
                return a.m ? a.g.currentTime : a.j;
              }
              function zj(a, b) {
                0 < a.g.readyState ? Aj(a.i, b) : tj(a.g, HTMLMediaElement.HAVE_METADATA, a.h, function () {
                  xj(a, a.j);
                });
              }
              function xj(a, b) {
                .001 > Math.abs(a.g.currentTime - b) ? Bj(a) : (a.h.ma(a.g, "seeking", function () {
                  Bj(a);
                }), Aj(a.i, a.g.currentTime && 0 != a.g.currentTime ? a.g.currentTime : b));
              }
              function Bj(a) {
                a.m = !0;
                a.h.C(a.g, "seeking", function () {
                  return a.l();
                });
              }
              function wj(a) {
                var b = this;
                this.h = a;
                this.m = 10;
                this.l = this.j = this.i = 0;
                this.g = new P(function () {
                  0 >= b.i ? b.g.stop() : b.h.currentTime != b.j ? b.g.stop() : (b.h.currentTime = b.l, b.i--);
                });
              }
              wj.prototype.release = function () {
                this.g && (this.g.stop(), this.g = null);
                this.h = null;
              };
              function Aj(a, b) {
                a.j = a.h.currentTime;
                a.l = b;
                a.i = a.m;
                a.h.currentTime = b;
                a.g.Ca(.1);
              }
              function Cj(a) {
                this.g = a;
                this.j = !1;
                this.h = null;
                this.i = new mf();
              }
              q = Cj.prototype;
              q.yd = function () {
                function a() {
                  null == b.h || 0 == b.h ? b.j = !0 : (b.i.ma(b.g, "seeking", function () {
                    b.j = !0;
                  }), b.g.currentTime = Math.max(0, b.g.currentTime + b.h));
                }
                var b = this;
                tj(this.g, HTMLMediaElement.HAVE_CURRENT_DATA, this.i, function () {
                  a();
                });
              };
              q.release = function () {
                this.i && (this.i.release(), this.i = null);
                this.g = null;
              };
              q.zd = function (a) {
                this.h = this.j ? this.h : a;
              };
              q.Ic = function () {
                return (this.j ? this.g.currentTime : this.h) || 0;
              };
              q.ue = function () {
                return 0;
              };
              q.te = function () {
                return 0;
              };
              q.Ne = function () {};
              function Dj(a, b, c, d, e, f) {
                var g = this;
                this.i = a;
                this.g = b.presentationTimeline;
                this.B = b.minBufferTime || 0;
                this.l = c;
                this.u = e;
                this.s = null;
                this.o = Ej(a, c, f);
                this.j = new rj(a, b.presentationTimeline, c, this.o, f);
                this.h = new vj(a, function () {
                  a: {
                    var h = g.j;
                    h.m = !0;
                    h.l = !1;
                    var k = yj(g.h);
                    h = Fj(g, k);
                    if (.001 < Math.abs(h - k) && (k = Date.now() / 1E3, !g.s || g.s < k - 1)) {
                      g.s = k;
                      zj(g.h, h);
                      h = void 0;
                      break a;
                    }
                    g.u();
                    h = void 0;
                  }
                  return h;
                }, Gj(this, d));
                this.m = new P(function () {
                  if (0 != g.i.readyState && !g.i.paused) {
                    var h = yj(g.h),
                      k = g.g.Db(),
                      l = g.g.Oa();
                    3 > l - k && (k = l - 3);
                    h < k && (h = Fj(g, h), g.i.currentTime = h);
                  }
                });
              }
              q = Dj.prototype;
              q.yd = function () {
                this.m.Ca(.25);
              };
              q.release = function () {
                this.h && (this.h.release(), this.h = null);
                this.j && (this.j.release(), this.j = null);
                this.m && (this.m.stop(), this.m = null);
                this.i = this.h = this.g = this.l = null;
                this.u = function () {};
              };
              q.zd = function (a) {
                zj(this.h, a);
              };
              q.Ic = function () {
                var a = yj(this.h);
                return 0 < this.i.readyState && !this.i.paused ? Hj(this, a) : a;
              };
              q.ue = function () {
                return this.o ? this.o.o : 0;
              };
              q.te = function () {
                return this.j.u;
              };
              function Gj(a, b) {
                null == b ? b = Infinity > a.g.getDuration() ? a.g.Db() : a.g.Oa() : 0 > b && (b = a.g.Oa() + b);
                return Ij(a, Hj(a, b));
              }
              q.Ne = function () {
                this.j.Wd();
              };
              function Ij(a, b) {
                var c = a.g.getDuration();
                return b >= c ? c - a.l.durationBackoff : b;
              }
              function Fj(a, b) {
                var c = Math.max(a.B, a.l.rebufferingGoal),
                  d = a.l.safeSeekOffset,
                  e = a.g.Db(),
                  f = a.g.Oa(),
                  g = a.g.getDuration();
                3 > f - e && (e = f - 3);
                var h = a.g.kc(c),
                  k = a.g.kc(d);
                c = a.g.kc(c + d);
                return b >= g ? Ij(a, b) : b > f ? f : b < e ? vi(a.i.buffered, k) ? k : c : b >= h || vi(a.i.buffered, b) ? b : c;
              }
              function Hj(a, b) {
                var c = a.g.Db();
                if (b < c) return c;
                a = a.g.Oa();
                return b > a ? a : b;
              }
              function Ej(a, b, c) {
                if (!b.stallEnabled) return null;
                var d = b.stallSkip;
                b = new nj(new qj(a), b.stallThreshold, c);
                pj(b, function () {
                  d ? a.currentTime += d : (a.pause(), a.play());
                });
                return b;
              }
              function Jj(a) {
                this.g = a;
                this.h = null;
                this.i = 0;
                this.j = !1;
              }
              q = Jj.prototype;
              q.release = function () {
                this.j || (this.g = [], this.h && this.h.stop(), this.h = null);
              };
              q.cg = function () {
                this.j = !0;
              };
              function Kj(a, b) {
                a = r(a.g);
                for (var c = a.next(); !c.done; c = a.next()) b(c.value);
              }
              q.find = function (a) {
                for (var b = this.g.length - 1, c = b; 0 <= c; --c) {
                  var d = this.g[c],
                    e = c < b ? this.g[c + 1].startTime : d.endTime;
                  if (a >= d.startTime && a < e) return c + this.i;
                }
                return this.g.length && a < this.g[0].startTime ? this.i : null;
              };
              q.get = function (a) {
                if (0 == this.g.length) return null;
                a -= this.i;
                return 0 > a || a >= this.g.length ? null : this.g[a];
              };
              q.offset = function (a) {
                if (!this.j) for (var b = r(this.g), c = b.next(); !c.done; c = b.next()) c.value.offset(a);
              };
              q.pc = function (a) {
                if (!this.j && a.length) {
                  var b = Math.round(1E3 * a[0].startTime) / 1E3;
                  this.g = this.g.filter(function (c) {
                    return Math.round(1E3 * c.startTime) / 1E3 < b;
                  });
                  this.g.push.apply(this.g, ha(a));
                }
              };
              q.Hb = function (a, b) {
                var c = this;
                a = a.filter(function (d) {
                  return d.endTime > b && (0 == c.g.length || d.endTime > c.g[0].startTime);
                });
                this.pc(a);
                this.eb(b);
              };
              q.eb = function (a) {
                if (!this.j) {
                  var b = this.g.length;
                  this.g = this.g.filter(function (c) {
                    return c.endTime > a;
                  });
                  this.i += b - this.g.length;
                }
              };
              q.Wa = function (a, b, c) {
                c = void 0 === c ? !1 : c;
                if (!this.j) {
                  for (; this.g.length;) if (this.g[this.g.length - 1].startTime >= b) this.g.pop();else break;
                  for (; this.g.length;) if (this.g[0].endTime <= a) this.g.shift(), c || this.i++;else break;
                  0 != this.g.length && (a = this.g[this.g.length - 1], this.g[this.g.length - 1] = new qi(a.startTime, b, a.u, a.Ba, a.ka, a.h, a.timestampOffset, a.appendWindowStart, a.appendWindowEnd, a.i, a.tilesLayout, a.s, a.g, a.status, a.l));
                }
              };
              q.fd = function (a, b) {
                var c = this;
                this.j || (this.h && this.h.stop(), this.h = new P(function () {
                  var d = b();
                  d ? c.g.push.apply(c.g, ha(d)) : (c.h.stop(), c.h = null);
                }), this.h.Ca(a));
              };
              Jj.prototype[Symbol.iterator] = function () {
                return this.Cb(0);
              };
              Jj.prototype.Cb = function (a) {
                var b = this.find(a);
                if (null == b) return null;
                b--;
                var c = this.get(b + 1),
                  d = -1;
                if (c && 0 < c.i.length) for (var e = c.i.length - 1; 0 <= e; --e) {
                  var f = c.i[e];
                  if (a >= f.startTime && a < f.endTime) {
                    b++;
                    d = e - 1;
                    break;
                  }
                }
                return new Lj(this, b, d);
              };
              function Mj(a, b, c) {
                return new Jj([new qi(a, a + b, function () {
                  return c;
                }, 0, null, null, a, a, a + b)]);
              }
              K("shaka.media.SegmentIndex", Jj);
              Jj.forSingleSegment = Mj;
              Jj.prototype.getIteratorForTime = Jj.prototype.Cb;
              Jj.prototype.updateEvery = Jj.prototype.fd;
              Jj.prototype.fit = Jj.prototype.Wa;
              Jj.prototype.evict = Jj.prototype.eb;
              Jj.prototype.mergeAndEvict = Jj.prototype.Hb;
              Jj.prototype.offset = Jj.prototype.offset;
              Jj.prototype.get = Jj.prototype.get;
              Jj.prototype.find = Jj.prototype.find;
              Jj.prototype.markImmutable = Jj.prototype.cg;
              Jj.prototype.release = Jj.prototype.release;
              function Lj(a, b, c) {
                this.i = a;
                this.g = b;
                this.h = c;
              }
              Lj.prototype.vf = function () {
                return this.g;
              };
              Lj.prototype.current = function () {
                var a = this.i.get(this.g);
                a && 0 < a.i.length && a.ya().length && this.h >= a.i.length && (this.g++, this.h = 0, a = this.i.get(this.g));
                return a && 0 < a.i.length ? a.i[this.h] : a;
              };
              Lj.prototype.next = function () {
                var a = this.i.get(this.g);
                a && 0 < a.i.length ? (this.h++, a.ya().length && this.h == a.i.length && (this.g++, this.h = 0)) : (this.g++, this.h = 0);
                a = this.current();
                return {
                  value: a,
                  done: !a
                };
              };
              K("shaka.media.SegmentIterator", Lj);
              Lj.prototype.next = Lj.prototype.next;
              Lj.prototype.current = Lj.prototype.current;
              Lj.prototype.currentPosition = Lj.prototype.vf;
              function Nj() {
                Jj.call(this, []);
                this.l = [];
              }
              oa(Nj, Jj);
              q = Nj.prototype;
              q.clone = function () {
                var a = new Nj();
                a.l = this.l.slice();
                return a;
              };
              q.release = function () {
                for (var a = r(this.l), b = a.next(); !b.done; b = a.next()) b.value.release();
                this.l = [];
              };
              q.find = function (a) {
                for (var b = 0, c = r(this.l), d = c.next(); !d.done; d = c.next()) {
                  d = d.value;
                  var e = d.find(a);
                  if (null != e) return e + b;
                  b += d.i + d.g.length;
                }
                return null;
              };
              q.get = function (a) {
                for (var b = 0, c = r(this.l), d = c.next(); !d.done; d = c.next()) {
                  d = d.value;
                  var e = d.get(a - b);
                  if (e) return e;
                  b += d.i + d.g.length;
                }
                return null;
              };
              q.offset = function () {};
              q.pc = function () {};
              q.eb = function () {};
              q.Hb = function () {};
              q.Wa = function () {};
              q.fd = function () {};
              K("shaka.media.MetaSegmentIndex", Nj);
              Nj.prototype.updateEvery = Nj.prototype.fd;
              Nj.prototype.fit = Nj.prototype.Wa;
              Nj.prototype.mergeAndEvict = Nj.prototype.Hb;
              Nj.prototype.evict = Nj.prototype.eb;
              Nj.prototype.merge = Nj.prototype.pc;
              Nj.prototype.offset = Nj.prototype.offset;
              Nj.prototype.get = Nj.prototype.get;
              Nj.prototype.find = Nj.prototype.find;
              Nj.prototype.release = Nj.prototype.release;
              function Oj(a) {
                var b = this;
                this.g = a;
                this.j = !1;
                this.i = this.g.Tc();
                this.h = new P(function () {
                  b.g.Me(.25 * b.i);
                });
              }
              Oj.prototype.release = function () {
                this.h && (this.h.stop(), this.h = null);
                this.g = null;
              };
              Oj.prototype.set = function (a) {
                this.i = a;
                Pj(this);
              };
              Oj.prototype.Pc = function () {
                return this.g.Pc();
              };
              function Pj(a) {
                a.h.stop();
                var b = a.j ? 0 : a.i;
                if (0 <= b) try {
                  a.g.Tc() != b && a.g.le(b);
                  return;
                } catch (c) {}
                a.h.Ca(.25);
                0 != a.g.Tc() && a.g.le(0);
              }
              function Qj(a) {
                var b = this;
                this.h = a;
                this.g = new Set();
                this.i = new P(function () {
                  Rj(b, !1);
                }).Ca(.25);
              }
              Qj.prototype.release = function () {
                this.i.stop();
                for (var a = r(this.g), b = a.next(); !b.done; b = a.next()) b.value.release();
                this.g.clear();
              };
              function Rj(a, b) {
                for (var c = r(a.g), d = c.next(); !d.done; d = c.next()) d.value.j(a.h.currentTime, b);
              }
              function Sj(a) {
                Ue.call(this);
                this.g = new Map();
                this.h = a;
              }
              oa(Sj, Ue);
              Sj.prototype.release = function () {
                this.g.clear();
                Ue.prototype.release.call(this);
              };
              function Tj(a, b) {
                var c = a.g.get(b);
                c || (c = {
                  rc: [],
                  Ae: null,
                  contentType: b
                }, a.g.set(b, c));
                return c;
              }
              function Uj(a, b, c) {
                var d = Tj(a, b.contentType);
                Vj(a, d);
                a = {
                  Od: b,
                  position: c
                };
                d = d.rc;
                b = d.findIndex(function (e) {
                  return e.position >= c;
                });
                0 <= b ? d.splice(b, d[b].position == c ? 1 : 0, a) : d.push(a);
              }
              Sj.prototype.j = function (a) {
                for (var b = r(this.g.values()), c = b.next(); !c.done; c = b.next()) {
                  c = c.value;
                  a: {
                    var d = c.rc;
                    for (var e = d.length - 1; 0 <= e; e--) {
                      var f = d[e];
                      if (f.position <= a) {
                        d = f.Od;
                        break a;
                      }
                    }
                    d = null;
                  }
                  if (e = d) e = c.Ae, e = !(e === d || e && d && e.bandwidth == d.bandwidth && e.audioSamplingRate == d.audioSamplingRate && e.codecs == d.codecs && e.contentType == d.contentType && e.frameRate == d.frameRate && e.height == d.height && e.mimeType == d.mimeType && e.channelsCount == d.channelsCount && e.pixelAspectRatio == d.pixelAspectRatio && e.width == d.width);
                  if (e) a: {
                    e = a;
                    f = d.contentType;
                    if ((f = this.h()[f]) && 0 < f.length) {
                      var g = f[f.length - 1].end;
                      if (e >= f[0].start && e < g) {
                        e = !0;
                        break a;
                      }
                    }
                    e = !1;
                  }
                  e && (c.Ae = d, JSON.stringify(d), c = new S("qualitychange", new Map([["quality", d], ["position", a]])), this.dispatchEvent(c));
                }
              };
              function Vj(a, b) {
                if ((a = a.h()[b.contentType]) && 0 < a.length) {
                  var c = a[0].start,
                    d = a[a.length - 1].end,
                    e = b.rc;
                  b.rc = e.filter(function (f, g) {
                    return f.position <= c && g + 1 < e.length && e[g + 1].position <= c || f.position >= d ? !1 : !0;
                  });
                } else b.rc = [];
              }
              function Wj(a) {
                Ue.call(this);
                var b = this;
                this.g = new Set();
                this.i = a;
                this.h = new P(function () {
                  for (var c = b.i(), d = r(b.g), e = d.next(); !e.done; e = d.next()) e = e.value, e.endTime < c.start && (b.g.delete(e), e = new S("regionremove", new Map([["region", e]])), b.dispatchEvent(e));
                }).Ca(2);
              }
              oa(Wj, Ue);
              Wj.prototype.release = function () {
                this.g.clear();
                this.h.stop();
                Ue.prototype.release.call(this);
              };
              function Xj(a) {
                Ue.call(this);
                var b = this;
                this.i = a;
                this.g = new Map();
                this.l = [{
                  rb: null,
                  qb: Yj,
                  ib: function ib(c, d) {
                    return Zj(b, "enter", c, d);
                  }
                }, {
                  rb: ak,
                  qb: Yj,
                  ib: function ib(c, d) {
                    return Zj(b, "enter", c, d);
                  }
                }, {
                  rb: bk,
                  qb: Yj,
                  ib: function ib(c, d) {
                    return Zj(b, "enter", c, d);
                  }
                }, {
                  rb: Yj,
                  qb: ak,
                  ib: function ib(c, d) {
                    return Zj(b, "exit", c, d);
                  }
                }, {
                  rb: Yj,
                  qb: bk,
                  ib: function ib(c, d) {
                    return Zj(b, "exit", c, d);
                  }
                }, {
                  rb: ak,
                  qb: bk,
                  ib: function ib(c, d) {
                    return Zj(b, "skip", c, d);
                  }
                }, {
                  rb: bk,
                  qb: ak,
                  ib: function ib(c, d) {
                    return Zj(b, "skip", c, d);
                  }
                }];
                this.h = new mf();
                this.h.C(this.i, "regionremove", function (c) {
                  b.g.delete(c.region);
                });
              }
              oa(Xj, Ue);
              Xj.prototype.release = function () {
                this.i = null;
                this.g.clear();
                this.h.release();
                this.h = null;
                Ue.prototype.release.call(this);
              };
              Xj.prototype.j = function (a, b) {
                for (var c = r(this.i.g), d = c.next(); !d.done; d = c.next()) {
                  d = d.value;
                  var e = this.g.get(d),
                    f = a < d.startTime ? ak : a > d.endTime ? bk : Yj;
                  this.g.set(d, f);
                  for (var g = r(this.l), h = g.next(); !h.done; h = g.next()) h = h.value, h.rb == e && h.qb == f && h.ib(d, b);
                }
              };
              function Zj(a, b, c, d) {
                b = new S(b, new Map([["region", c], ["seeking", d]]));
                a.dispatchEvent(b);
              }
              var ak = 1,
                Yj = 2,
                bk = 3;
              function ck(a, b, c, d, e) {
                a = cf(a, d, e);
                if (0 != b || null != c) a.headers.Range = c ? "bytes=" + b + "-" + c : "bytes=" + b + "-";
                return a;
              }
              function dk(a, b) {
                var c = this;
                this.g = b;
                this.m = a;
                this.i = null;
                this.u = 1;
                this.o = this.l = null;
                this.D = !1;
                this.j = new Map();
                this.B = !1;
                this.F = null;
                this.s = !1;
                this.h = new kf(function () {
                  return ek(c);
                });
              }
              q = dk.prototype;
              q.destroy = function () {
                return this.h.destroy();
              };
              function ek(a) {
                var b, c, d, e;
                return G(function (f) {
                  if (1 == f.g) {
                    b = [];
                    c = r(a.j.values());
                    for (d = c.next(); !d.done; d = c.next()) e = d.value, fk(e), b.push(gk(e));
                    return u(f, Promise.all(b), 2);
                  }
                  a.j.clear();
                  a.g = null;
                  a.m = null;
                  a.i = null;
                  A(f);
                });
              }
              q.configure = function (a) {
                this.i = a;
                this.F = new Ie({
                  maxAttempts: Math.max(a.retryParameters.maxAttempts, 2),
                  baseDelay: a.retryParameters.baseDelay,
                  backoffFactor: a.retryParameters.backoffFactor,
                  fuzzFactor: a.retryParameters.fuzzFactor,
                  timeout: 0,
                  stallTimeout: 0,
                  connectionTimeout: 0
                }, !0);
              };
              q.start = function () {
                var a = this;
                return G(function (b) {
                  if (1 == b.g) return u(b, hk(a), 2);
                  lf(a.h);
                  a.B = !0;
                  A(b);
                });
              };
              function ik(a, b) {
                var c, d, e, f, h;
                G(function (k) {
                  switch (k.g) {
                    case 1:
                      return c = kc, D(k, 2), u(k, hj(a.g.R, c.X), 4);
                    case 4:
                      ta(k, 3);
                      break;
                    case 2:
                      if (d = ua(k), a.g) a.g.onError(d);
                    case 3:
                      e = Zc(b.mimeType, b.codecs);
                      Qi(a.g.R, e, a.m.sequenceMode);
                      f = a.g.R.m;
                      if (f.isTextVisible() || a.i.alwaysStreamText) h = jk(b), a.j.set(c.X, h), kk(a, h, 0);
                      A(k);
                  }
                });
              }
              function lk(a) {
                var b = a.j.get(jc);
                b && (fk(b), gk(b).catch(function () {}), a.j.delete(jc));
                a.o = null;
              }
              function mk(a, b) {
                var c = a.j.get("video");
                if (c) {
                  var d = c.stream;
                  if (d) if (b) (b = d.trickModeVideo) && !c.ob && (nk(a, b, !1, 0, !1), c.ob = d);else if (d = c.ob) c.ob = null, nk(a, d, !0, 0, !1);
                }
              }
              function ok(a, b, c, d, e, f) {
                c = void 0 === c ? !1 : c;
                d = void 0 === d ? 0 : d;
                e = void 0 === e ? !1 : e;
                f = void 0 === f ? !1 : f;
                a.l = b;
                a.B && (b.video && nk(a, b.video, c, d, e, f), b.audio && nk(a, b.audio, c, d, e, f));
              }
              function pk(a, b) {
                a.o = b;
                a.B && nk(a, b, !0, 0, !1);
              }
              function nk(a, b, c, d, e, f) {
                var g = a.j.get(b.type);
                g || b.type != jc ? g && (g.ob && (b.trickModeVideo ? (g.ob = b, b = b.trickModeVideo) : g.ob = null), g.stream != b || e) && (b.type == jc && Qi(a.g.R, Zc(b.mimeType, b.codecs), a.m.sequenceMode), g.stream.closeSegmentIndex && g.stream.closeSegmentIndex(), g.stream = b, g.aa = null, g.ve = !!f, c && (g.ac ? g.hd = !0 : g.ra ? (g.bb = !0, g.Nc = d, g.hd = !0) : (fk(g), qk(a, g, !0, d).catch(function (h) {
                  if (a.g) a.g.onError(h);
                }))), rk(a, g).catch(function (h) {
                  if (a.g) a.g.onError(h);
                })) : ik(a, b);
              }
              function rk(a, b) {
                var c, d;
                return G(function (e) {
                  if (1 == e.g) {
                    if (!b.ta) return e.return();
                    c = b.stream;
                    d = b.ta;
                    return c.segmentIndex ? e.A(2) : u(e, c.createSegmentIndex(), 2);
                  }
                  if (b.ta != d || b.stream != c) return e.return();
                  var f = a.g.Sc();
                  var g = Vi(a.g.R, b.type),
                    h = b.stream.segmentIndex.find(b.pa ? b.pa.endTime : f),
                    k = null == h ? null : b.stream.segmentIndex.get(h);
                  h = k ? k.ka ? k.ka - k.Ba : null : null;
                  k && !h && (h = (k.endTime - k.getStartTime()) * (b.stream.bandwidth || 0) / 8);
                  h ? ((k = k.h) && (h += (k.ka ? k.ka - k.Ba : null) || 0), k = a.g.getBandwidthEstimate(), f = 8 * h / k < (g || 0) - f - Math.max(a.m.minBufferTime || 0, a.i.rebufferingGoal) || b.ta.h.g > h ? !0 : !1) : f = !1;
                  f && b.ta.abort();
                  A(e);
                });
              }
              q.vc = function () {
                if (this.g) for (var a = this.g.Sc(), b = r(this.j.keys()), c = b.next(); !c.done; c = b.next()) {
                  var d = c.value;
                  c = this.j.get(d);
                  c.aa = null;
                  var e = this.g.R;
                  d == jc ? (e = e.g, e = null == e.g || null == e.h ? !1 : a >= e.g && a < e.h) : (e = Ui(e, d), e = vi(e, a));
                  if (!e) {
                    (null != Vi(this.g.R, d) || c.ra) && sk(this, c);
                    c.ta && (c.ta.abort(), c.ta = null);
                    if (d === jc && (d = this.g.R, d.s)) for (d = d.s.g, d.l = 0, d.h = [], d.g = [], e = d.i, e.i = [], e.h = [], e.g = 0, Yh(d), d = r(d.j.values()), e = d.next(); !e.done; e = d.next()) Th(e.value);
                    c.vc = !0;
                  }
                }
              };
              function sk(a, b) {
                b.ac || b.bb || (b.ra ? (b.bb = !0, b.Nc = 0) : null == Ti(a.g.R, b.type) ? null == b.Ka && kk(a, b, 0) : (fk(b), qk(a, b, !1, 0).catch(function (c) {
                  if (a.g) a.g.onError(c);
                })));
              }
              function hk(a) {
                var b, c, d, e, f, g, h, k, l, m;
                return G(function (n) {
                  if (1 == n.g) {
                    b = kc;
                    if (!a.l) throw new O(2, 5, 5006);
                    c = new Map();
                    d = new Set();
                    a.l.audio && (c.set(b.Hc, a.l.audio), d.add(a.l.audio));
                    a.l.video && (c.set(b.va, a.l.video), d.add(a.l.video));
                    a.o && (c.set(b.X, a.o), d.add(a.o));
                    e = a.g.R;
                    f = a.i.forceTransmux;
                    return u(n, e.init(c, f, a.m.sequenceMode), 2);
                  }
                  lf(a.h);
                  a.updateDuration();
                  g = r(c.keys());
                  for (h = g.next(); !h.done; h = g.next()) k = h.value, l = c.get(k), a.j.has(k) || (m = jk(l), a.j.set(k, m), kk(a, m, 0));
                  A(n);
                });
              }
              function jk(a) {
                return {
                  stream: a,
                  type: a.type,
                  aa: null,
                  pa: null,
                  Zc: null,
                  Kd: null,
                  Jd: null,
                  Id: null,
                  ob: null,
                  endOfStream: !1,
                  ra: !1,
                  Ka: null,
                  bb: !1,
                  Nc: 0,
                  hd: !1,
                  ac: !1,
                  vc: !0,
                  Rd: !1,
                  be: !1,
                  nc: !1,
                  ta: null
                };
              }
              q.updateDuration = function () {
                var a = this.m.presentationTimeline.getDuration();
                Infinity > a ? this.g.R.Aa(a) : this.g.R.Aa(Math.pow(2, 32));
              };
              function tk(a, b) {
                var c, d, e, f, g;
                return G(function (h) {
                  switch (h.g) {
                    case 1:
                      lf(a.h);
                      if (b.ra || null == b.Ka || b.ac) return h.return();
                      b.Ka = null;
                      if (!b.bb) {
                        h.A(2);
                        break;
                      }
                      return u(h, qk(a, b, b.hd, b.Nc), 3);
                    case 3:
                      return h.return();
                    case 2:
                      if (b.stream.segmentIndex) {
                        h.A(4);
                        break;
                      }
                      c = b.stream;
                      return u(h, b.stream.createSegmentIndex(), 5);
                    case 5:
                      if (c != b.stream) return c.closeSegmentIndex && c.closeSegmentIndex(), b.ra || b.Ka || kk(a, b, 0), h.return();
                    case 4:
                      D(h, 6);
                      d = uk(a, b);
                      null != d && (kk(a, b, d), b.nc = !1);
                      ta(h, 7);
                      break;
                    case 6:
                      return e = ua(h), u(h, vk(a, e), 8);
                    case 8:
                      return h.return();
                    case 7:
                      f = Array.from(a.j.values());
                      if (!a.B || !f.every(function (k) {
                        return k.endOfStream;
                      })) {
                        h.A(0);
                        break;
                      }
                      return u(h, a.g.R.endOfStream(), 10);
                    case 10:
                      lf(a.h), g = a.g.R.getDuration(), 0 != g && g < a.m.presentationTimeline.getDuration() && a.m.presentationTimeline.Aa(g), A(h);
                  }
                });
              }
              function uk(a, b) {
                if (wk(b)) return fj(a.g.R, b.stream.originalId || ""), null;
                b.type == jc && gj(a.g.R);
                var c = a.g.Sc(),
                  d = b.pa ? b.pa.endTime : c,
                  e = Wi(a.g.R, b.type, c),
                  f = Math.max(a.m.minBufferTime || 0, a.i.rebufferingGoal, a.i.bufferingGoal) * a.u,
                  g = a.m.presentationTimeline.getDuration() - d,
                  h = Vi(a.g.R, b.type);
                if (1E-6 > g && h) return b.endOfStream = !0, "video" == b.type && (a = a.j.get(jc)) && wk(a) && (a.endOfStream = !0), null;
                b.endOfStream = !1;
                if (e >= f) return a.i.updateIntervalSeconds / 2;
                e = xk(a, b, c, h);
                if (!e) return a.i.updateIntervalSeconds;
                f = Infinity;
                g = Array.from(a.j.values());
                g = r(g);
                for (h = g.next(); !h.done; h = g.next()) h = h.value, wk(h) || h.aa && !h.aa.current() || (f = Math.min(f, h.pa ? h.pa.endTime : c));
                if (d >= f + a.m.presentationTimeline.g) return a.i.updateIntervalSeconds;
                yk(a, b, c, e).catch(function () {});
                return null;
              }
              function xk(a, b, c, d) {
                if (b.aa) return b.aa.current();
                if (b.pa || d) return c = b.pa ? b.pa.endTime : d, b.Rd = !0, b.aa = b.stream.segmentIndex.Cb(c), b.aa && b.aa.next().value;
                a = a.i.inaccurateManifestTolerance;
                d = Math.max(c - a, 0);
                var e = null;
                a && (b.aa = b.stream.segmentIndex.Cb(d), e = b.aa && b.aa.next().value);
                e || (b.aa = b.stream.segmentIndex.Cb(c), e = b.aa && b.aa.next().value);
                return e;
              }
              function yk(a, b, c, d) {
                var e, f, g, h, k, l, m, n, p, t, v, y, w, x, C;
                return G(function (z) {
                  switch (z.g) {
                    case 1:
                      e = kc;
                      f = b.stream;
                      g = b.aa;
                      b.ra = !0;
                      D(z, 2);
                      if (2 == d.Eb()) throw new O(1, 1, 1011);
                      return u(z, zk(a, b, d), 4);
                    case 4:
                      lf(a.h);
                      if (a.s) return z.return();
                      h = "video/mp4" == f.mimeType || "audio/mp4" == f.mimeType;
                      k = window.ReadableStream;
                      if (a.i.lowLatencyMode && k && h && !d.l) return n = new Uint8Array(0), t = p = !1, v = function v(B) {
                        var E, F, H;
                        return G(function (I) {
                          if (p) return I.return();
                          t = !0;
                          lf(a.h);
                          if (a.s) return I.return();
                          n = Ak(n, B);
                          E = !1;
                          F = 0;
                          new zf().box("mdat", function (J) {
                            F = J.size + J.start;
                            E = !0;
                          }).parse(n, !1, !0);
                          if (!E) return I.A(0);
                          H = n.subarray(0, F);
                          n = n.subarray(F);
                          return u(I, Bk(a, b, c, f, d, H), 0);
                        });
                      }, u(z, Ck(a, b, d, v), 11);
                      l = Ck(a, b, d);
                      return u(z, l, 7);
                    case 7:
                      m = z.h;
                      lf(a.h);
                      if (a.s) return z.return();
                      if (!d.l) {
                        z.A(8);
                        break;
                      }
                      return u(z, Dk(m, d, g), 9);
                    case 9:
                      m = z.h;
                    case 8:
                      return lf(a.h), b.bb ? (b.ra = !1, kk(a, b, 0), z.return()) : u(z, Bk(a, b, c, f, d, m), 6);
                    case 11:
                      y = z.h;
                      if (t) {
                        z.A(6);
                        break;
                      }
                      p = !0;
                      lf(a.h);
                      return a.s ? z.return() : b.bb ? (b.ra = !1, kk(a, b, 0), z.return()) : u(z, Bk(a, b, c, f, d, y), 6);
                    case 6:
                      lf(a.h);
                      if (a.s) return z.return();
                      b.pa = d;
                      g.next();
                      b.ra = !1;
                      b.be = !1;
                      w = a.g.R.Na();
                      x = w[b.type];
                      ab(JSON.stringify(x));
                      b.bb || a.g.Wd(d.startTime, d.endTime, b.type);
                      kk(a, b, 0);
                      ta(z, 0);
                      break;
                    case 2:
                      C = ua(z);
                      lf(a.h, C);
                      if (a.s) return z.return();
                      b.ra = !1;
                      if (7001 == C.code) b.ra = !1, fk(b), kk(a, b, 0), z.A(0);else if (b.type == e.X && a.i.ignoreTextStreamFailures) a.j.delete(e.X), z.A(0);else if (3017 == C.code) Ek(a, b, C), z.A(0);else return b.nc = !0, C.severity = 2, u(z, vk(a, C), 0);
                  }
                });
              }
              function Dk(a, b, c) {
                var d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) return d = b.l, d.cryptoKey ? h.A(2) : u(h, d.fetchKey(), 3);
                  e = d.iv;
                  if (!e) for (e = M(new ArrayBuffer(16)), f = d.firstMediaSequenceNumber + c.g, g = e.byteLength - 1; 0 <= g; g--) e[g] = f & 255, f >>= 8;
                  return h.return(window.crypto.subtle.decrypt({
                    name: "AES-CBC",
                    iv: e
                  }, d.cryptoKey, a));
                });
              }
              function Ak(a, b) {
                var c = new Uint8Array(a.length + b.length);
                c.set(a);
                c.set(b, a.length);
                return c;
              }
              function Ek(a, b, c) {
                if (!Array.from(a.j.values()).some(function (e) {
                  return e != b && e.be;
                })) {
                  var d = Math.round(100 * a.u);
                  if (20 < d) a.u -= .2;else if (4 < d) a.u -= .04;else {
                    b.nc = !0;
                    a.s = !0;
                    a.g.onError(c);
                    return;
                  }
                  b.be = !0;
                }
                kk(a, b, 4);
              }
              function zk(a, b, c) {
                var d, e, f, g, h, k, l, m;
                return G(function (n) {
                  d = [];
                  e = Math.max(0, c.appendWindowStart - .1);
                  f = c.appendWindowEnd + .01;
                  g = c.timestampOffset;
                  if (g != b.Kd || e != b.Jd || f != b.Id) h = function h() {
                    var p;
                    return G(function (t) {
                      if (1 == t.g) return D(t, 2), b.Jd = e, b.Id = f, b.Kd = g, u(t, ij(a.g.R, b.type, g, e, f, a.m.sequenceMode), 4);
                      if (2 != t.g) return ta(t, 0);
                      p = ua(t);
                      b.Jd = null;
                      b.Id = null;
                      b.Kd = null;
                      throw p;
                    });
                  }, d.push(h());
                  !pi(c.h, b.Zc) && (b.Zc = c.h) && (k = Ck(a, b, c.h), l = function l() {
                    var p, t, v, y;
                    return G(function (w) {
                      switch (w.g) {
                        case 1:
                          return D(w, 2), u(w, k, 4);
                        case 4:
                          return p = w.h, lf(a.h), t = new zf(), t.box("moov", Ef).box("trak", Ef).box("mdia", Ef).P("mdhd", function (x) {
                            x = fi(x.reader || 0, x.version || 0);
                            c.h.timescale = x.timescale;
                          }).parse(p), v = b.stream.closedCaptions && 0 < b.stream.closedCaptions.size, u(w, a.g.xe(b.type, p), 5);
                        case 5:
                          return u(w, Xi(a.g.R, b.type, p, null, v), 6);
                        case 6:
                          ta(w, 0);
                          break;
                        case 2:
                          throw y = ua(w), b.Zc = null, y;
                      }
                    });
                  }, a.g.fg(c.startTime, c.h), d.push(l()));
                  a.m.sequenceMode && (m = b.pa ? b.pa.m : null, c.m != m || b.Rd) && (b.Rd = !1, d.push(jj(a.g.R, b.type, c.startTime)));
                  return u(n, Promise.all(d), 0);
                });
              }
              function Bk(a, b, c, d, e, f) {
                var g, h, k, l, m, n;
                return G(function (p) {
                  switch (p.g) {
                    case 1:
                      g = d.closedCaptions && 0 < d.closedCaptions.size;
                      k = null != d.emsgSchemeIdUris && 0 < d.emsgSchemeIdUris.length || a.i.dispatchAllEmsgBoxes;
                      l = a.i.parsePrftBox && !a.D;
                      if (k || l) h = new zf();
                      k && h.P("emsg", function (t) {
                        var v = d.emsgSchemeIdUris;
                        if (0 === t.version) {
                          var y = t.reader.sc();
                          var w = t.reader.sc();
                          var x = t.reader.K();
                          var C = t.reader.K();
                          var z = t.reader.K();
                          var B = t.reader.K();
                          var E = e.startTime + C / x;
                        } else x = t.reader.K(), E = t.reader.$a() / x + e.timestampOffset, C = E - e.startTime, z = t.reader.K(), B = t.reader.K(), y = t.reader.sc(), w = t.reader.sc();
                        t = t.reader.Za(t.reader.S.byteLength - t.reader.Z());
                        if (v && v.includes(y) || a.i.dispatchAllEmsgBoxes) "urn:mpeg:dash:event:2012" == y ? a.g.gg() : "https://aomedia.org/emsg/ID3" == y ? (v = Ci(t), v.length && e && a.g.hg([{
                          cueTime: e.startTime,
                          data: t,
                          frames: v,
                          dts: e.startTime,
                          pts: e.startTime
                        }], 0, e.endTime)) : (v = new Map().set("detail", {
                          startTime: E,
                          endTime: E + z / x,
                          schemeIdUri: y,
                          value: w,
                          timescale: x,
                          presentationTimeDelta: C,
                          eventDuration: z,
                          id: B,
                          messageData: t
                        }), v = new S("emsg", v), a.g.onEvent(v));
                      });
                      l && h.P("prft", function (t) {
                        a: {
                          if (!a.D && e.h.timescale) {
                            t.reader.K();
                            var v = t.reader.K(),
                              y = t.reader.K();
                            v = 1E3 * v + y / Math.pow(2, 32) * 1E3;
                            if (0 === t.version) var w = t.reader.K();else try {
                              w = t.reader.$a();
                            } catch (x) {
                              a.D = !0;
                              w = void 0;
                              break a;
                            }
                            t = new Date(new Date(Date.UTC(1900, 0, 1, 0, 0, 0)).getTime() + v).getTime();
                            w = new Map().set("detail", {
                              wallClockTime: t,
                              programStartDate: new Date(t - w / e.h.timescale * 1E3)
                            });
                            w = new S("prft", w);
                            a.g.onEvent(w);
                            a.D = !0;
                          }
                          w = void 0;
                        }
                        return w;
                      });
                      (k || l) && h.parse(f);
                      return u(p, Fk(a, b, c), 2);
                    case 2:
                      return lf(a.h), m = b.vc, b.vc = !1, n = b.ve, b.ve = !1, u(p, a.g.xe(b.type, f), 3);
                    case 3:
                      return u(p, Xi(a.g.R, b.type, f, e, g, m, n), 4);
                    case 4:
                      lf(a.h), A(p);
                  }
                });
              }
              function Fk(a, b, c) {
                var d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) {
                    d = Math.max(a.i.bufferBehind, a.m.presentationTimeline.g);
                    e = Ti(a.g.R, b.type);
                    if (null == e) return h.return();
                    f = c - e;
                    g = f - d;
                    return .01 >= g ? h.return() : u(h, a.g.R.remove(b.type, e, e + g), 2);
                  }
                  lf(a.h);
                  A(h);
                });
              }
              function wk(a) {
                return a && a.type == jc && ("application/cea-608" == a.stream.mimeType || "application/cea-708" == a.stream.mimeType);
              }
              function Ck(a, b, c, d) {
                var e, f, g, h, k;
                return G(function (l) {
                  if (1 == l.g) return e = jf, f = ck(c.ya(), c.Ba, c.ka, a.i.retryParameters, d), g = b.stream, a.g.modifySegmentRequest(f, {
                    type: g.type,
                    init: c instanceof oi,
                    duration: c.endTime - c.startTime,
                    mimeType: g.mimeType,
                    codecs: g.codecs,
                    bandwidth: g.bandwidth
                  }), h = a.g.kb.request(e, f), b.ta = h, u(l, h.promise, 2);
                  k = l.h;
                  b.ta = null;
                  return l.return(k.data);
                });
              }
              function qk(a, b, c, d) {
                var e, f;
                return G(function (g) {
                  if (1 == g.g) return b.bb = !1, b.hd = !1, b.Nc = 0, b.ac = !0, b.pa = null, b.Zc = null, b.aa = null, d ? (e = a.g.Sc(), f = a.g.R.getDuration(), u(g, a.g.R.remove(b.type, e + d, f), 3)) : u(g, hj(a.g.R, b.type), 4);
                  if (3 != g.g) return lf(a.h), c ? u(g, a.g.R.flush(b.type), 3) : g.A(3);
                  lf(a.h);
                  b.ac = !1;
                  b.endOfStream = !1;
                  b.ra || b.Ka || kk(a, b, 0);
                  A(g);
                });
              }
              function kk(a, b, c) {
                var d = b.type;
                if (d != jc || a.j.has(d)) b.Ka = new nc(function () {
                  var e;
                  return G(function (f) {
                    if (1 == f.g) return D(f, 2), u(f, tk(a, b), 4);
                    if (2 != f.g) return ta(f, 0);
                    e = ua(f);
                    if (a.g) a.g.onError(e);
                    A(f);
                  });
                }).N(c);
              }
              function fk(a) {
                null != a.Ka && (a.Ka.stop(), a.Ka = null);
              }
              function gk(a) {
                return G(function (b) {
                  return a.ta ? u(b, a.ta.abort(), 0) : b.A(0);
                });
              }
              function vk(a, b) {
                return G(function (c) {
                  if (1 == c.g) return u(c, Ke(a.F), 2);
                  lf(a.h);
                  a.g.onError(b);
                  b.handled || a.i.failureCallback(b);
                  A(c);
                });
              }
              function Gk(a, b) {
                var c = Hk(),
                  d = this;
                this.j = b;
                this.i = a;
                this.l = c;
                this.o = null;
                this.m = [];
                this.h = this.g = null;
                this.u = Promise.resolve().then(function () {
                  return Ik(d);
                });
                this.s = new kf(function () {
                  return Jk(d);
                });
              }
              Gk.prototype.destroy = function () {
                return this.s.destroy();
              };
              function Jk(a) {
                var b, c, d;
                return G(function (e) {
                  if (1 == e.g) return a.h && a.h.abort(), Kk(a), u(e, a.u, 2);
                  a.g && a.g.Ia.mb();
                  b = r(a.m);
                  for (c = b.next(); !c.done; c = b.next()) d = c.value, d.Ia.mb();
                  a.g = null;
                  a.m = [];
                  a.j = null;
                  A(e);
                });
              }
              function Lk(a, b) {
                var c = {
                  Jb: function Jb() {},
                  bd: function bd() {},
                  mb: function mb() {},
                  onError: function onError() {},
                  dd: function dd() {},
                  uh: function uh() {}
                };
                a.m.push({
                  create: b,
                  Ia: c
                });
                a.h && a.h.abort();
                Kk(a);
                return c;
              }
              function Ik(a) {
                return G(function (b) {
                  if (a.s.g) b = b.A(0);else {
                    if (0 == a.m.length || a.g && !a.g.hb) var c = !1;else {
                      a.g && (a.g.Ia.mb(), a.g = null);
                      c = a.m.shift();
                      var d = c.create(a.l);
                      d ? (c.Ia.Jb(), a.g = {
                        node: d.node,
                        payload: d.payload,
                        hb: d.hb,
                        Ia: c.Ia
                      }) : c.Ia.dd();
                      c = !0;
                    }
                    c ? c = Promise.resolve() : a.g ? c = Mk(a) : (a.j.eg(a.i), a.o = new lc(), c = a.o);
                    b = u(b, c, 1);
                  }
                  return b;
                });
              }
              function Mk(a) {
                var b, c;
                return G(function (d) {
                  switch (d.g) {
                    case 1:
                      return a.i = a.j.Mf(a.i, a.l, a.g.node, a.g.payload), D(d, 2), a.h = a.j.yf(a.i, a.l, a.g.payload), u(d, a.h.promise, 4);
                    case 4:
                      a.h = null;
                      a.i == a.g.node && (a.g.Ia.bd(), a.g = null);
                      ta(d, 0);
                      break;
                    case 2:
                      b = ua(d);
                      if (7001 == b.code) a.g.Ia.mb();else a.g.Ia.onError(b);
                      a.g = null;
                      a.h = null;
                      c = a;
                      return u(d, a.j.handleError(a.l, b), 5);
                    case 5:
                      c.i = d.h, A(d);
                  }
                });
              }
              function Kk(a) {
                a.o && (a.o.resolve(), a.o = null);
              }
              function Nk(a) {
                var b = [],
                  c = 700 <= a.fontWeight,
                  d = "italic" == a.fontStyle,
                  e = a.textDecoration.includes("underline");
                c && b.push("b");
                d && b.push("i");
                e && b.push("u");
                c = b.reduce(function (f, g) {
                  return f + "<" + g + ">";
                }, "");
                b = b.reduceRight(function (f, g) {
                  return f + "</" + g + ">";
                }, "");
                return a.lineBreak ? "\n" : a.nestedCues.length ? a.nestedCues.map(Nk).join("") : c + a.payload + b;
              }
              function Ok(a, b) {
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) if (c = c.value, c.isContainer) Ok(c.nestedCues, b);else {
                  var d = c.clone();
                  d.nestedCues = [];
                  d.payload = Nk(c);
                  b.push(d);
                }
                return b;
              }
              function Pk(a) {
                this.g = null;
                for (var b = r(Array.from(a.textTracks)), c = b.next(); !c.done; c = b.next()) c = c.value, c.mode = "disabled", "Shaka Player TextTrack" == c.label && (this.g = c);
                this.g || (this.g = a.addTextTrack("subtitles", "Shaka Player TextTrack"));
                this.g.mode = "hidden";
              }
              q = Pk.prototype;
              q.remove = function (a, b) {
                if (!this.g) return !1;
                Qk(this.g, function (c) {
                  return c.startTime < b && c.endTime > a;
                });
                return !0;
              };
              q.append = function (a) {
                var b = Ok(a, []),
                  c = [];
                a = this.g.cues ? Array.from(this.g.cues) : [];
                var d = {};
                b = r(b);
                for (var e = b.next(); !e.done; d = {
                  sb: d.sb
                }, e = b.next()) d.sb = e.value, a.some(function (f) {
                  return function (g) {
                    return g.startTime == f.sb.startTime && g.endTime == f.sb.endTime && g.text == f.sb.payload ? !0 : !1;
                  };
                }(d)) || (e = Rk(d.sb)) && c.push(e);
                a = c.slice().sort(function (f, g) {
                  return f.startTime != g.startTime ? f.startTime - g.startTime : f.endTime != g.endTime ? f.endTime - g.startTime : "line" in VTTCue.prototype ? c.indexOf(g) - c.indexOf(f) : c.indexOf(f) - c.indexOf(g);
                });
                a = r(a);
                for (d = a.next(); !d.done; d = a.next()) this.g.addCue(d.value);
              };
              q.destroy = function () {
                this.g && (Qk(this.g, function () {
                  return !0;
                }), this.g.mode = "disabled");
                this.g = null;
                return Promise.resolve();
              };
              q.isTextVisible = function () {
                return "showing" == this.g.mode;
              };
              q.setTextVisibility = function (a) {
                this.g.mode = a ? "showing" : "hidden";
              };
              function Rk(a) {
                if (a.startTime >= a.endTime) return null;
                var b = new VTTCue(a.startTime, a.endTime, a.payload);
                b.lineAlign = a.lineAlign;
                b.positionAlign = a.positionAlign;
                a.size && (b.size = a.size);
                try {
                  b.align = a.textAlign;
                } catch (c) {}
                "center" == a.textAlign && "center" != b.align && (b.align = "middle");
                "vertical-lr" == a.writingMode ? b.vertical = "lr" : "vertical-rl" == a.writingMode && (b.vertical = "rl");
                1 == a.lineInterpretation && (b.snapToLines = !1);
                null != a.line && (b.line = a.line);
                null != a.position && (b.position = a.position);
                return b;
              }
              function Qk(a, b) {
                var c = a.mode;
                a.mode = "showing" == c ? "showing" : "hidden";
                for (var d = r(Array.from(a.cues)), e = d.next(); !e.done; e = d.next()) (e = e.value) && b(e) && a.removeCue(e);
                a.mode = c;
              }
              K("shaka.text.SimpleTextDisplayer", Pk);
              Pk.prototype.setTextVisibility = Pk.prototype.setTextVisibility;
              Pk.prototype.isTextVisible = Pk.prototype.isTextVisible;
              Pk.prototype.destroy = Pk.prototype.destroy;
              Pk.prototype.append = Pk.prototype.append;
              Pk.prototype.remove = Pk.prototype.remove;
              function Sk() {}
              function Tk(a) {
                for (; a.firstChild;) a.removeChild(a.firstChild);
              }
              K("shaka.util.Dom", Sk);
              Sk.removeAllChildren = Tk;
              function Uk(a, b) {
                var c = this;
                this.j = !1;
                this.i = [];
                this.B = a;
                this.m = b;
                this.g = document.createElement("div");
                this.g.classList.add("shaka-text-container");
                this.g.style.textAlign = "center";
                this.g.style.display = "flex";
                this.g.style.flexDirection = "column";
                this.g.style.alignItems = "center";
                this.g.style.justifyContent = "flex-end";
                this.m.appendChild(this.g);
                this.u = new P(function () {
                  Vk(c);
                }).Ca(.25);
                this.h = new Map();
                this.s = new mf();
                this.s.C(document, "fullscreenchange", function () {
                  Vk(c, !0);
                });
                this.l = null;
                "ResizeObserver" in window && (this.l = new ResizeObserver(function () {
                  Vk(c, !0);
                }), this.l.observe(this.g));
                this.o = new Map();
              }
              q = Uk.prototype;
              q.append = function (a) {
                var b = [].concat(ha(this.i)),
                  c = {};
                a = r(a);
                for (var d = a.next(); !d.done; c = {
                  Cc: c.Cc
                }, d = a.next()) c.Cc = d.value, b.some(function (e) {
                  return function (f) {
                    return wb(f, e.Cc);
                  };
                }(c)) || this.i.push(c.Cc);
                Vk(this);
              };
              q.destroy = function () {
                this.m.removeChild(this.g);
                this.g = null;
                this.j = !1;
                this.i = [];
                this.u && this.u.stop();
                this.h.clear();
                this.s && (this.s.release(), this.s = null);
                this.l && (this.l.disconnect(), this.l = null);
              };
              q.remove = function (a, b) {
                if (!this.g) return !1;
                var c = this.i.length;
                this.i = this.i.filter(function (d) {
                  return d.startTime < a || d.endTime >= b;
                });
                Vk(this, c > this.i.length);
                return !0;
              };
              q.isTextVisible = function () {
                return this.j;
              };
              q.setTextVisibility = function (a) {
                this.j = a;
              };
              function Wk(a, b) {
                for (; null != b;) {
                  if (b == a.g) return !0;
                  b = b.parentElement;
                }
                return !1;
              }
              function Xk(a, b, c, d, e) {
                var f = !1,
                  g = [],
                  h = [];
                b = r(b);
                for (var k = b.next(); !k.done; k = b.next()) {
                  k = k.value;
                  e.push(k);
                  var l = a.h.get(k),
                    m = k.startTime <= d && k.endTime > d,
                    n = l ? l.ef : null;
                  l && (g.push(l.Bd), l.tc && g.push(l.tc), m || (f = !0, a.h.delete(k), l = null));
                  m && (h.push(k), l ? Wk(a, n) || (f = !0) : (Yk(a, k, e), l = a.h.get(k), n = l.ef, f = !0));
                  0 < k.nestedCues.length && n && Xk(a, k.nestedCues, n, d, e);
                  e.pop();
                }
                if (f) {
                  d = r(g);
                  for (e = d.next(); !e.done; e = d.next()) e = e.value, e.parentElement && e.parentElement.removeChild(e);
                  h.sort(function (p, t) {
                    return p.startTime != t.startTime ? p.startTime - t.startTime : p.endTime - t.endTime;
                  });
                  h = r(h);
                  for (k = h.next(); !k.done; k = h.next()) d = a.h.get(k.value), d.tc ? (c.appendChild(d.tc), d.tc.appendChild(d.Bd)) : c.appendChild(d.Bd);
                }
              }
              function Vk(a, b) {
                if (a.g) {
                  var c = a.B.currentTime;
                  if (!a.j || (void 0 === b ? 0 : b)) {
                    b = r(a.o.values());
                    for (var d = b.next(); !d.done; d = b.next()) Tk(d.value);
                    Tk(a.g);
                    a.h.clear();
                    a.o.clear();
                  }
                  if (a.j) {
                    b = new Map();
                    d = r(a.h.keys());
                    for (var e = d.next(); !e.done; e = d.next()) e = e.value, b.set(e, a.h.get(e));
                    Xk(a, a.i, a.g, c, []);
                  }
                }
              }
              function Yk(a, b, c) {
                var d = 1 < c.length,
                  e = d ? "span" : "div";
                b.lineBreak && (e = "br");
                d = !d && 0 < b.nestedCues.length;
                var f = document.createElement(e);
                "br" != e && Zk(a, f, b, c, d);
                c = null;
                if (b.region && b.region.id) if (c = b.region, e = c.id + "_" + c.width + "x" + c.height + (c.heightUnits == Db ? "%" : "px") + "-" + c.viewportAnchorX + "x" + c.viewportAnchorY + (c.viewportAnchorUnits == Db ? "%" : "px"), a.o.has(e)) c = a.o.get(e);else {
                  var g = document.createElement("span"),
                    h = c.heightUnits == Db ? "%" : "px",
                    k = c.widthUnits == Db ? "%" : "px",
                    l = c.viewportAnchorUnits == Db ? "%" : "px";
                  g.id = "shaka-text-region---" + e;
                  g.classList.add("shaka-text-region");
                  g.style.height = c.height + h;
                  g.style.width = c.width + k;
                  g.style.position = "absolute";
                  g.style.top = c.viewportAnchorY + l;
                  g.style.left = c.viewportAnchorX + l;
                  g.style.display = "flex";
                  g.style.flexDirection = "column";
                  g.style.alignItems = "center";
                  g.style.justifyContent = "before" == b.displayAlign ? "flex-start" : "center" == b.displayAlign ? "center" : "flex-end";
                  a.o.set(e, g);
                  c = g;
                }
                e = f;
                d && (e = document.createElement("span"), e.classList.add("shaka-text-wrapper"), e.style.backgroundColor = b.backgroundColor, e.style.lineHeight = "normal", f.appendChild(e));
                a.h.set(b, {
                  Bd: f,
                  ef: e,
                  tc: c
                });
              }
              function Zk(a, b, c, d, e) {
                var f = b.style,
                  g = 0 == c.nestedCues.length,
                  h = 1 < d.length;
                f.whiteSpace = "pre-wrap";
                var k = c.payload.replace(/\s+$/g, function (m) {
                  return "\u00a0".repeat(m.length);
                });
                f.webkitTextStrokeColor = c.textStrokeColor;
                f.webkitTextStrokeWidth = c.textStrokeWidth;
                f.color = c.color;
                f.direction = c.direction;
                f.opacity = c.opacity;
                f.paddingLeft = $k(c.linePadding, c, a.m);
                f.paddingRight = $k(c.linePadding, c, a.m);
                f.textShadow = c.textShadow;
                if (c.backgroundImage) f.backgroundImage = "url('" + c.backgroundImage + "')", f.backgroundRepeat = "no-repeat", f.backgroundSize = "contain", f.backgroundPosition = "center", f.width = "100%", f.height = "100%";else {
                  if (c.nestedCues.length) var l = b;else l = document.createElement("span"), b.appendChild(l);
                  c.border && (l.style.border = c.border);
                  e || ((b = al(d, function (m) {
                    return m.backgroundColor;
                  })) ? l.style.backgroundColor = b : k && (l.style.backgroundColor = "rgba(0, 0, 0, 0.8)"));
                  k && (l.textContent = k);
                }
                h && !d[d.length - 1].isContainer ? f.display = "inline" : (f.display = "flex", f.flexDirection = "column", f.alignItems = "center", f.justifyContent = "before" == c.displayAlign ? "flex-start" : "center" == c.displayAlign ? "center" : "flex-end");
                g || (f.margin = "0");
                f.fontFamily = c.fontFamily;
                f.fontWeight = c.fontWeight.toString();
                f.fontStyle = c.fontStyle;
                f.letterSpacing = c.letterSpacing;
                f.fontSize = $k(c.fontSize, c, a.m);
                null != c.line && 1 == c.lineInterpretation && (f.position = "absolute", c.writingMode == qb ? (f.width = "100%", c.lineAlign == sb ? f.top = c.line + "%" : "end" == c.lineAlign && (f.bottom = 100 - c.line + "%")) : "vertical-lr" == c.writingMode ? (f.height = "100%", c.lineAlign == sb ? f.left = c.line + "%" : "end" == c.lineAlign && (f.right = 100 - c.line + "%")) : (f.height = "100%", c.lineAlign == sb ? f.right = c.line + "%" : "end" == c.lineAlign && (f.left = 100 - c.line + "%")));
                f.lineHeight = c.lineHeight;
                null != c.position && (c.writingMode == qb ? f.paddingLeft = c.position : f.paddingTop = c.position);
                "line-left" == c.positionAlign ? f.cssFloat = "left" : "line-right" == c.positionAlign && (f.cssFloat = "right");
                f.textAlign = c.textAlign;
                f.textDecoration = c.textDecoration.join(" ");
                f.writingMode = c.writingMode;
                "writingMode" in document.documentElement.style && f.writingMode == c.writingMode || (f.webkitWritingMode = c.writingMode);
                c.size && (c.writingMode == qb ? f.width = c.size + "%" : f.height = c.size + "%");
              }
              function $k(a, b, c) {
                var d = (d = new RegExp(/(\d*\.?\d+)([a-z]+|%+)/).exec(a)) ? {
                  value: Number(d[1]),
                  unit: d[2]
                } : null;
                if (!d) return a;
                var e = d.value;
                switch (d.unit) {
                  case "%":
                    return e / 100 * c.clientHeight / b.cellResolution.rows + "px";
                  case "c":
                    return c.clientHeight * e / b.cellResolution.rows + "px";
                  default:
                    return a;
                }
              }
              function al(a, b) {
                for (var c = a.length - 1; 0 <= c; c--) {
                  var d = b(a[c]);
                  if (d || 0 === d) return d;
                }
                return null;
              }
              K("shaka.text.UITextDisplayer", Uk);
              Uk.prototype.setTextVisibility = Uk.prototype.setTextVisibility;
              Uk.prototype.isTextVisible = Uk.prototype.isTextVisible;
              Uk.prototype.remove = Uk.prototype.remove;
              Uk.prototype.destroy = Uk.prototype.destroy;
              Uk.prototype.append = Uk.prototype.append;
              function bl(a, b) {
                function c(f) {
                  for (var g = f, h = r(b), k = h.next(); !k.done; k = h.next()) k = k.value, k.end && k.start < f && (g += k.end - k.start);
                  f = Math.floor(g / 3600);
                  h = Math.floor(g / 60 % 60);
                  k = Math.floor(g % 60);
                  g = Math.floor(1E3 * g % 1E3);
                  return (10 > f ? "0" : "") + f + ":" + (10 > h ? "0" : "") + h + ":" + (10 > k ? "0" : "") + k + "." + (100 > g ? 10 > g ? "00" : "0" : "") + g;
                }
                var d = Ok(a, []);
                a = "WEBVTT\n\n";
                d = r(d);
                for (var e = d.next(); !e.done; e = d.next()) e = e.value, a += c(e.startTime) + " --\x3e " + c(e.endTime) + function (f) {
                  var g = [];
                  switch (f.textAlign) {
                    case "left":
                      g.push("align:left");
                      break;
                    case "right":
                      g.push("align:right");
                      break;
                    case ob:
                      g.push("align:middle");
                      break;
                    case "start":
                      g.push("align:start");
                      break;
                    case "end":
                      g.push("align:end");
                  }
                  switch (f.writingMode) {
                    case "vertical-lr":
                      g.push("vertical:lr");
                      break;
                    case "vertical-rl":
                      g.push("vertical:rl");
                  }
                  return g.length ? " " + g.join(" ") : "";
                }(e) + "\n", a += e.payload + "\n\n";
                return a;
              }
              K("shaka.text.WebVttGenerator", function () {});
              function cl(a, b) {
                this.h = a;
                this.g = b;
                this.j = "";
                this.o = void 0;
                this.i = !1;
                this.m = !0;
                this.l = !1;
              }
              function dl(a, b, c) {
                try {
                  if (a.g.enabled) {
                    var d = {
                      d: 1E3 * c.duration,
                      st: a.h.U() ? el : fl
                    };
                    d.ot = gl(c);
                    var e = d.ot === hl || d.ot === il || d.ot === jl || d.ot === kl;
                    e && (d.bl = ll(a, c.type));
                    c.bandwidth && (d.br = c.bandwidth / 1E3);
                    e && d.ot !== kl && (d.tb = ml(a, d.ot) / 1E3);
                    nl(a, b, d);
                  }
                } catch (f) {
                  Xa("CMCD_SEGMENT_ERROR", "Could not generate segment CMCD data.", f);
                }
              }
              function ol(a, b, c) {
                try {
                  if (!a.g.enabled) return b;
                  var d = pl(a);
                  a: {
                    switch (c) {
                      case "video/webm":
                      case "video/mp4":
                        var e = jl;
                        break a;
                      case "application/x-mpegurl":
                        e = ql;
                        break a;
                    }
                    e = void 0;
                  }
                  d.ot = e;
                  d.su = !0;
                  var f = rl(d);
                  return sl(b, f);
                } catch (g) {
                  return Xa("CMCD_SRC_ERROR", "Could not generate src CMCD data.", g), b;
                }
              }
              function pl(a) {
                a.j || (a.j = a.g.sessionId || window.crypto.randomUUID());
                return {
                  v: 1,
                  sf: a.o,
                  sid: a.j,
                  cid: a.g.contentId,
                  mtp: a.h.getBandwidthEstimate() / 1E3
                };
              }
              function nl(a, b, c) {
                c = void 0 === c ? {} : c;
                var d = void 0 === d ? a.g.useHeaders : d;
                if (a.g.enabled) {
                  Object.assign(c, pl(a));
                  c.pr = a.h.Rc();
                  var e = c.ot === hl || c.ot === jl;
                  a.l && e && (c.bs = !0, c.su = !0, a.l = !1);
                  null == c.su && (c.su = a.m);
                  if (d) a = tl(c), Object.keys(a).length && Object.assign(b.headers, a);else {
                    var f = rl(c);
                    f && (b.uris = b.uris.map(function (g) {
                      return sl(g, f);
                    }));
                  }
                }
              }
              function gl(a) {
                var b = a.type;
                if (a.init) return ul;
                if ("video" == b) return a.codecs.includes(",") ? jl : hl;
                if ("audio" == b) return il;
                if ("text" == b) return "application/mp4" === a.mimeType ? kl : vl;
              }
              function ll(a, b) {
                b = a.h.Na()[b];
                if (!b.length) return NaN;
                var c = a.h.getCurrentTime();
                return (a = b.find(function (d) {
                  return d.start <= c && d.end >= c;
                })) ? 1E3 * (a.end - c) : NaN;
              }
              function ml(a, b) {
                var c = a.h.Xa();
                if (!c.length) return NaN;
                a = c[0];
                c = r(c);
                for (var d = c.next(); !d.done; d = c.next()) d = d.value, "variant" === d.type && d.bandwidth > a.bandwidth && (a = d);
                switch (b) {
                  case hl:
                    return a.videoBandwidth || NaN;
                  case il:
                    return a.audioBandwidth || NaN;
                  default:
                    return a.bandwidth;
                }
              }
              function rl(a) {
                function b(n) {
                  return 100 * c(n / 100);
                }
                function c(n) {
                  return Math.round(n);
                }
                function d(n) {
                  return !Number.isNaN(n) && null != n && "" !== n && !1 !== n;
                }
                var e = [],
                  f = {
                    br: c,
                    d: c,
                    bl: b,
                    dl: b,
                    mtp: b,
                    nor: function nor(n) {
                      return encodeURIComponent(n);
                    },
                    rtp: b,
                    tb: c
                  },
                  g = Object.keys(a || {}).sort();
                g = r(g);
                for (var h = g.next(); !h.done; h = g.next()) {
                  h = h.value;
                  var k = a[h];
                  if (d(k) && ("v" !== h || 1 !== k) && ("pr" != h || 1 !== k)) {
                    var l = f[h];
                    l && (k = l(k));
                    l = typeof k;
                    var m = void 0;
                    m = "string" === l && "ot" !== h && "sf" !== h && "st" !== h ? h + "=" + JSON.stringify(k) : "boolean" === l ? h : "symbol" === l ? h + "=" + k.description : h + "=" + k;
                    e.push(m);
                  }
                }
                return e.join(",");
              }
              function tl(a) {
                var b = Object.keys(a),
                  c = {},
                  d = ["Object", "Request", "Session", "Status"],
                  e = [{}, {}, {}, {}],
                  f = {
                    br: 0,
                    d: 0,
                    ot: 0,
                    tb: 0,
                    bl: 1,
                    dl: 1,
                    mtp: 1,
                    nor: 1,
                    nrr: 1,
                    su: 1,
                    cid: 2,
                    pr: 2,
                    sf: 2,
                    sid: 2,
                    st: 2,
                    v: 2,
                    bs: 3,
                    rtp: 3
                  };
                b = r(b);
                for (var g = b.next(); !g.done; g = b.next()) g = g.value, e[null != f[g] ? f[g] : 1][g] = a[g];
                for (a = 0; a < e.length; a++) (f = rl(e[a])) && (c["CMCD-" + d[a]] = f);
                return c;
              }
              function sl(a, b) {
                if (!b || a.includes("offline:")) return a;
                a = new Nb(a);
                a.g.set("CMCD", b);
                return a.toString();
              }
              var ql = "m",
                il = "a",
                hl = "v",
                jl = "av",
                ul = "i",
                vl = "c",
                kl = "tt",
                fl = "v",
                el = "l";
              K("shaka.util.CmcdManager.StreamingFormat", {
                DASH: "d",
                HLS: "h",
                dh: "s",
                Yg: "o"
              });
              function wl() {}
              function xl(a, b, c, d, e) {
                var f = (e in d),
                  g = !0,
                  h;
                for (h in b) {
                  var k = e + "." + h,
                    l = f ? d[e] : c[h];
                  f || h in c ? void 0 === b[h] ? void 0 === l || f ? delete a[h] : a[h] = Ve(l) : l.constructor == Object && b[h] && b[h].constructor == Object ? (a[h] || (a[h] = Ve(l)), k = xl(a[h], b[h], l, d, k), g = g && k) : typeof b[h] != typeof l || null == b[h] || "function" != typeof b[h] && b[h].constructor != l.constructor ? (Va("Invalid config, wrong type for " + k), g = !1) : ("function" == typeof c[h] && c[h].length != b[h].length && Wa("Unexpected number of arguments for " + k), a[h] = b[h]) : (Va("Invalid config, unrecognized key " + k), g = !1);
                }
                return g;
              }
              function yl(a, b) {
                for (var c = {}, d = c, e = 0, f = 0;;) {
                  e = a.indexOf(".", e);
                  if (0 > e) break;
                  if (0 == e || "\\" != a[e - 1]) f = a.substring(f, e).replace(/\\\./g, "."), d[f] = {}, d = d[f], f = e + 1;
                  e += 1;
                }
                d[a.substring(f).replace(/\\\./g, ".")] = b;
                return c;
              }
              function zl(a, b) {
                return a && b;
              }
              K("shaka.util.ConfigUtils", wl);
              wl.convertToConfigObject = yl;
              wl.mergeConfigObjects = xl;
              function Al() {}
              function Bl(a) {
                a = Fc(a);
                return new Nb(a).Ha;
              }
              function Cl(a, b, c) {
                function d(h) {
                  Lb(f).setUint32(g, h.byteLength, !0);
                  g += 4;
                  f.set(M(h), g);
                  g += h.byteLength;
                }
                if (!c || !c.byteLength) throw new O(2, 6, 6015);
                var e;
                "string" == typeof b ? e = Hc(b, !0) : e = b;
                a = Fc(a);
                a = Hc(a, !0);
                var f = new Uint8Array(12 + a.byteLength + e.byteLength + c.byteLength),
                  g = 0;
                d(a);
                d(e);
                d(c);
                return f;
              }
              K("shaka.util.FairPlayUtils", Al);
              Al.commonFairPlayResponse = function (a, b) {
                if (2 === a) {
                  try {
                    var c = Cc(b.data);
                  } catch (e) {
                    return;
                  }
                  a = !1;
                  c = c.trim();
                  "<ckc>" === c.substr(0, 5) && "</ckc>" === c.substr(-6) && (c = c.slice(5, -6), a = !0);
                  try {
                    var d = JSON.parse(c);
                    d.ckc && (c = d.ckc, a = !0);
                    d.CkcMessage && (c = d.CkcMessage, a = !0);
                    d.License && (c = d.License, a = !0);
                  } catch (e) {}
                  a && (b.data = Ib(Lc(c)));
                }
              };
              Al.conaxFairPlayRequest = function (a, b) {
                2 === a && (b.headers["Content-Type"] = "application/octet-stream");
              };
              Al.ezdrmFairPlayRequest = function (a, b) {
                2 === a && (b.headers["Content-Type"] = "application/octet-stream");
              };
              Al.verimatrixFairPlayRequest = function (a, b) {
                2 === a && (a = M(b.body), a = Kc(a), b.headers["Content-Type"] = "application/x-www-form-urlencoded", b.body = Gc("spc=" + a));
              };
              Al.conaxInitDataTransform = function (a, b, c) {
                if ("skd" !== b) return a;
                b = c.serverCertificate;
                c = Fc(a).split("skd://").pop().split("?").shift();
                c = window.atob(c);
                var d = new ArrayBuffer(2 * c.length);
                d = new Uint16Array(d);
                for (var e = 0, f = c.length; e < f; e++) d[e] = c.charCodeAt(e);
                return Cl(a, d, b);
              };
              Al.ezdrmInitDataTransform = function (a, b, c) {
                if ("skd" !== b) return a;
                b = c.serverCertificate;
                c = Fc(a).split(";").pop();
                return Cl(a, c, b);
              };
              Al.verimatrixInitDataTransform = function (a, b, c) {
                if ("skd" !== b) return a;
                b = c.serverCertificate;
                c = Fc(a).split("skd://").pop();
                return Cl(a, c, b);
              };
              Al.initDataTransform = Cl;
              Al.defaultGetContentId = Bl;
              Al.isFairPlaySupported = function () {
                var a;
                return G(function (b) {
                  if (1 == b.g) return a = {
                    initDataTypes: ["cenc", "sinf", "skd"],
                    videoCapabilities: [{
                      contentType: 'video/mp4; codecs="avc1.42E01E"'
                    }]
                  }, D(b, 2), u(b, navigator.requestMediaKeySystemAccess("com.apple.fps", [a]), 4);
                  if (2 != b.g) return b.return(!0);
                  ua(b);
                  return b.return(!1);
                });
              };
              function Dl() {}
              function El() {
                var a = Infinity;
                navigator.connection && navigator.connection.saveData && (a = 360);
                var b = {
                    retryParameters: Je(),
                    servers: {},
                    clearKeys: {},
                    advanced: {},
                    delayLicenseRequestUntilPlayed: !1,
                    initDataTransform: function initDataTransform(g, h, k) {
                      "com.apple.fps.1_0" == k.keySystem && "skd" == h && (h = k.serverCertificate, k = Bl(g), g = Cl(g, k, h));
                      return g;
                    },
                    logLicenseExchange: !1,
                    updateExpirationTime: 1,
                    preferredKeySystems: [],
                    keySystemsMapping: {},
                    parseInbandPsshEnabled: sc()
                  },
                  c = {
                    retryParameters: Je(),
                    availabilityWindowOverride: NaN,
                    disableAudio: !1,
                    disableVideo: !1,
                    disableText: !1,
                    disableThumbnails: !1,
                    defaultPresentationDelay: 0,
                    segmentRelativeVttTiming: !1,
                    dash: {
                      clockSyncUri: "",
                      ignoreDrmInfo: !1,
                      disableXlinkProcessing: !1,
                      xlinkFailGracefully: !1,
                      ignoreMinBufferTime: !1,
                      autoCorrectDrift: !0,
                      initialSegmentLimit: 1E3,
                      ignoreSuggestedPresentationDelay: !1,
                      ignoreEmptyAdaptationSet: !1,
                      ignoreMaxSegmentDuration: !1,
                      keySystemsByURI: {
                        "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
                        "urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e": "org.w3.clearkey",
                        "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
                        "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
                        "urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95": "com.microsoft.playready",
                        "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
                      },
                      manifestPreprocessor: function manifestPreprocessor(g) {
                        return zl([g], g);
                      },
                      sequenceMode: !1
                    },
                    hls: {
                      ignoreTextStreamFailures: !1,
                      ignoreImageStreamFailures: !1,
                      defaultAudioCodec: "mp4a.40.2",
                      defaultVideoCodec: "avc1.42E01E",
                      ignoreManifestProgramDateTime: !1,
                      mediaPlaylistFullMimeType: 'video/mp2t; codecs="avc1.42E01E, mp4a.40.2"',
                      useSafariBehaviorForLive: !0,
                      liveSegmentsDelay: 3
                    }
                  },
                  d = {
                    retryParameters: Je(),
                    failureCallback: function failureCallback(g) {
                      return zl([g]);
                    },
                    rebufferingGoal: 2,
                    bufferingGoal: 10,
                    bufferBehind: 30,
                    ignoreTextStreamFailures: !1,
                    alwaysStreamText: !1,
                    startAtSegmentBoundary: !1,
                    gapDetectionThreshold: .5,
                    durationBackoff: 1,
                    forceTransmux: !1,
                    safeSeekOffset: 5,
                    stallEnabled: !0,
                    stallThreshold: 1,
                    stallSkip: .1,
                    useNativeHlsOnSafari: !0,
                    inaccurateManifestTolerance: 2,
                    lowLatencyMode: !1,
                    autoLowLatencyMode: !1,
                    forceHTTPS: !1,
                    preferNativeHls: !1,
                    updateIntervalSeconds: 1,
                    dispatchAllEmsgBoxes: !1,
                    observeQualityChanges: !1,
                    maxDisabledTime: 30,
                    parsePrftBox: !1
                  };
                if (tc("Web0S") || uc() || tc("CrKey")) d.stallSkip = 0;
                var e = {
                    trackSelectionCallback: function trackSelectionCallback(g) {
                      return G(function (h) {
                        return h.return(g);
                      });
                    },
                    downloadSizeCallback: function downloadSizeCallback(g) {
                      var h;
                      return G(function (k) {
                        if (1 == k.g) return navigator.storage && navigator.storage.estimate ? u(k, navigator.storage.estimate(), 3) : k.return(!0);
                        h = k.h;
                        return k.return(h.usage + g < .95 * h.quota);
                      });
                    },
                    progressCallback: function progressCallback(g, h) {
                      return zl([g, h]);
                    },
                    usePersistentLicense: !0,
                    numberOfParallelDownloads: 5
                  },
                  f = {
                    drm: b,
                    manifest: c,
                    streaming: d,
                    mediaSource: {
                      sourceBufferExtraFeatures: ""
                    },
                    offline: e,
                    abrFactory: function abrFactory() {
                      return new me();
                    },
                    abr: {
                      enabled: !0,
                      useNetworkInformation: !0,
                      defaultBandwidthEstimate: 1E6,
                      switchInterval: 8,
                      bandwidthUpgradeTarget: .85,
                      bandwidthDowngradeTarget: .95,
                      restrictions: {
                        minWidth: 0,
                        maxWidth: Infinity,
                        minHeight: 0,
                        maxHeight: a,
                        minPixels: 0,
                        maxPixels: Infinity,
                        minFrameRate: 0,
                        maxFrameRate: Infinity,
                        minBandwidth: 0,
                        maxBandwidth: Infinity
                      },
                      advanced: {
                        minTotalBytes: 128E3,
                        minBytes: 16E3,
                        fastHalfLife: 2,
                        slowHalfLife: 5
                      },
                      restrictToElementSize: !1,
                      restrictToScreenSize: !1,
                      ignoreDevicePixelRatio: !1
                    },
                    autoShowText: 3,
                    preferredAudioLanguage: "",
                    preferredTextLanguage: "",
                    preferredVariantRole: "",
                    preferredTextRole: "",
                    preferredAudioChannelCount: 2,
                    preferredVideoCodecs: [],
                    preferredAudioCodecs: [],
                    preferForcedSubs: !1,
                    preferredDecodingAttributes: [],
                    restrictions: {
                      minWidth: 0,
                      maxWidth: Infinity,
                      minHeight: 0,
                      maxHeight: Infinity,
                      minPixels: 0,
                      maxPixels: Infinity,
                      minFrameRate: 0,
                      maxFrameRate: Infinity,
                      minBandwidth: 0,
                      maxBandwidth: Infinity
                    },
                    playRangeStart: 0,
                    playRangeEnd: Infinity,
                    textDisplayFactory: function textDisplayFactory() {
                      return null;
                    },
                    cmcd: {
                      enabled: !1,
                      sessionId: "",
                      contentId: "",
                      useHeaders: !1
                    },
                    lcevc: {
                      enabled: !1,
                      dynamicPerformanceScaling: !0,
                      logLevel: 0,
                      drawLogo: !1
                    }
                  };
                e.trackSelectionCallback = function (g) {
                  return G(function (h) {
                    return h.return(Fl(g, f.preferredAudioLanguage));
                  });
                };
                return f;
              }
              function Gl(a, b, c) {
                var d = {
                  ".drm.keySystemsMapping": "",
                  ".drm.servers": "",
                  ".drm.clearKeys": "",
                  ".drm.advanced": {
                    distinctiveIdentifierRequired: !1,
                    persistentStateRequired: !1,
                    videoRobustness: "",
                    audioRobustness: "",
                    sessionType: "",
                    serverCertificate: new Uint8Array(0),
                    serverCertificateUri: "",
                    individualizationServer: ""
                  }
                };
                return xl(a, b, c || El(), d, "");
              }
              function Fl(a, b) {
                var c = a.filter(function (g) {
                    return "variant" == g.type;
                  }),
                  d = [],
                  e = vd(b, c.map(function (g) {
                    return g.language;
                  }));
                e && (d = c.filter(function (g) {
                  return od(g.language) == e;
                }));
                0 == d.length && (d = c.filter(function (g) {
                  return g.primary;
                }));
                0 == d.length && (c.map(function (g) {
                  return g.language;
                }), d = c);
                var f = d.filter(function (g) {
                  return g.height && 480 >= g.height;
                });
                f.length && (f.sort(function (g, h) {
                  return h.height - g.height;
                }), d = f.filter(function (g) {
                  return g.height == f[0].height;
                }));
                b = [];
                d.length && (c = Math.floor(d.length / 2), d.sort(function (g, h) {
                  return g.bandwidth - h.bandwidth;
                }), b.push(d[c]));
                a = r(a);
                for (d = a.next(); !d.done; d = a.next()) d = d.value, d.type != jc && "image" != d.type || b.push(d);
                return b;
              }
              K("shaka.util.PlayerConfiguration", Dl);
              Dl.mergeConfigObjects = Gl;
              Dl.createDefault = El;
              function Hl() {
                this.g = null;
                this.h = [];
              }
              function Il(a, b) {
                if (null == a.g) a.g = {
                  timestamp: Date.now() / 1E3,
                  state: b,
                  duration: 0
                };else {
                  var c = Date.now() / 1E3;
                  a.g.duration = c - a.g.timestamp;
                  a.g.state != b && (a.h.push(a.g), a.g = {
                    timestamp: c,
                    state: b,
                    duration: 0
                  });
                }
              }
              function Jl(a, b) {
                var c = 0;
                a.g && a.g.state == b && (c += a.g.duration);
                a = r(a.h);
                for (var d = a.next(); !d.done; d = a.next()) d = d.value, c += d.state == b ? d.duration : 0;
                return c;
              }
              function Kl(a) {
                function b(f) {
                  return {
                    timestamp: f.timestamp,
                    state: f.state,
                    duration: f.duration
                  };
                }
                for (var c = [], d = r(a.h), e = d.next(); !e.done; e = d.next()) c.push(b(e.value));
                a.g && c.push(b(a.g));
                return c;
              }
              function Ll() {
                this.i = this.h = null;
                this.g = [];
              }
              function Ml(a, b, c) {
                a.i != b && (a.i = b, a.g.push({
                  timestamp: Date.now() / 1E3,
                  id: b.id,
                  type: "text",
                  fromAdaptation: c,
                  bandwidth: null
                }));
              }
              function Nl() {
                this.u = this.B = this.G = this.D = this.s = this.j = this.F = this.m = this.i = this.M = this.O = this.H = this.J = this.L = this.l = this.o = NaN;
                this.g = new Hl();
                this.h = new Ll();
              }
              function V(a, b) {
                Ue.call(this);
                var c = this;
                this.l = Ol;
                this.Uc = this.g = null;
                this.ca = !1;
                this.Xc = new mf();
                this.Xb = new mf();
                this.s = new mf();
                this.Nb = this.i = this.Yc = this.J = this.j = this.ua = this.L = this.cf = this.V = this.Fa = this.M = this.Vc = this.H = this.xb = this.B = this.G = this.m = this.D = null;
                this.dc = !1;
                this.Nd = this.u = null;
                this.Yd = 1E9;
                this.h = Pl(this);
                this.ec = {
                  width: Infinity,
                  height: Infinity
                };
                this.o = null;
                this.ub = new Ae(this.h.preferredAudioLanguage, this.h.preferredVariantRole, this.h.preferredAudioChannelCount);
                this.vb = this.h.preferredTextLanguage;
                this.cc = this.h.preferredTextRole;
                this.$b = this.h.preferForcedSubs;
                this.Zb = [];
                this.fc = null;
                b && b(this);
                this.D = Ql(this);
                this.D.je(this.h.streaming.forceHTTPS);
                this.F = null;
                Rl && (this.F = Rl());
                this.Xc.C(window, "online", function () {
                  c.ce();
                });
                this.O = {
                  name: "detach"
                };
                this.W = {
                  name: "attach"
                };
                this.ea = {
                  name: "unload"
                };
                this.Zd = {
                  name: "manifest-parser"
                };
                this.Xd = {
                  name: "manifest"
                };
                this.wb = {
                  name: "media-source"
                };
                this.Qd = {
                  name: "drm-engine"
                };
                this.ba = {
                  name: "load"
                };
                this.de = {
                  name: "src-equals-drm-engine"
                };
                this.yb = {
                  name: "src-equals"
                };
                var d = new Map();
                d.set(this.W, function (e, f) {
                  return Pe(Sl(c, e, f));
                });
                d.set(this.O, function (e) {
                  e.mediaElement && (c.Xb.nb(), e.mediaElement = null);
                  c.F && c.F.release();
                  c.g = null;
                  e = Promise.resolve();
                  return Pe(e);
                });
                d.set(this.ea, function (e) {
                  return Pe(Tl(c, e));
                });
                d.set(this.wb, function (e) {
                  e = Ul(c, e);
                  return Pe(e);
                });
                d.set(this.Zd, function (e, f) {
                  e = Vl(c, e, f);
                  return Pe(e);
                });
                d.set(this.Xd, function (e) {
                  return Wl(c, e);
                });
                d.set(this.Qd, function (e) {
                  e = Xl(c, e);
                  return Pe(e);
                });
                d.set(this.ba, function (e, f) {
                  return Pe(Yl(c, e, f));
                });
                d.set(this.de, function (e, f) {
                  e = Zl(c, e, f);
                  return Pe(e);
                });
                d.set(this.yb, function (e, f) {
                  return $l(c, e, f);
                });
                this.Ga = new Gk(this.O, {
                  Mf: function Mf(e, f, g, h) {
                    var k = null;
                    e == c.O && (k = g == c.O ? c.O : c.W);
                    e == c.W && (k = g == c.O || f.mediaElement != h.mediaElement ? c.O : g == c.W ? c.W : g == c.wb || g == c.ba ? c.wb : g == c.yb ? c.de : null);
                    e == c.wb && (k = g == c.ba && f.mediaElement == h.mediaElement ? c.Zd : c.ea);
                    e == c.Zd && (k = am(c.ba, c.Xd, c.ea, g, f, h));
                    e == c.Xd && (k = am(c.ba, c.Qd, c.ea, g, f, h));
                    e == c.Qd && (k = am(c.ba, c.ba, c.ea, g, f, h));
                    e == c.de && (k = g == c.yb && f.mediaElement == h.mediaElement ? c.yb : c.ea);
                    if (e == c.ba || e == c.yb) k = c.ea;
                    e == c.ea && (k = h.mediaElement && f.mediaElement == h.mediaElement ? c.W : c.O);
                    return k;
                  },
                  yf: function yf(e, f, g) {
                    c.dispatchEvent(bm("onstatechange", new Map().set("state", e.name)));
                    return d.get(e)(f, g);
                  },
                  handleError: function handleError(e) {
                    return G(function (f) {
                      return 1 == f.g ? u(f, Tl(c, e), 2) : f.return(e.mediaElement ? c.W : c.O);
                    });
                  },
                  eg: function eg(e) {
                    c.dispatchEvent(bm("onstateidle", new Map().set("state", e.name)));
                  }
                });
                this.af = new P(function () {
                  Ld(c.i.variants, c.h.restrictions, c.ec) && cm(c);
                });
                a && this.Yb(a, !0);
              }
              oa(V, Ue);
              function dm(a) {
                null != a.L && (a.L.release(), a.L = null);
              }
              function em(a, b) {
                if (b.lcevc.enabled) {
                  var c = a.Xa();
                  c && c[0] && c[0].videoMimeType == fm.ts && (rc() || navigator.userAgent.match(/Edge\//)) && (b.streaming.forceTransmux || Wa("LCEVC Warning: For MPEG-2 TS decoding the config.streaming.forceTransmux must be enabled."));
                  dm(a);
                  null == a.L && (a.L = new Hi(a.g, a.cf, b.lcevc), a.G && (a.G.D = a.L));
                } else dm(a);
              }
              function bm(a, b) {
                return new S(a, b);
              }
              q = V.prototype;
              q.destroy = function () {
                var a = this,
                  b;
                return G(function (c) {
                  switch (c.g) {
                    case 1:
                      if (a.l == gm) return c.return();
                      dm(a);
                      a.l = gm;
                      b = Lk(a.Ga, function () {
                        return {
                          node: a.O,
                          payload: Hk(),
                          hb: !1
                        };
                      });
                      return u(c, new Promise(function (d) {
                        b.Jb = function () {};
                        b.bd = function () {
                          d();
                        };
                        b.mb = function () {
                          d();
                        };
                        b.onError = function () {
                          d();
                        };
                        b.dd = function () {
                          d();
                        };
                      }), 2);
                    case 2:
                      return u(c, a.Ga.destroy(), 3);
                    case 3:
                      a.Xc && (a.Xc.release(), a.Xc = null);
                      a.Xb && (a.Xb.release(), a.Xb = null);
                      a.s && (a.s.release(), a.s = null);
                      a.Nd = null;
                      a.u = null;
                      a.h = null;
                      a.o = null;
                      a.Uc = null;
                      a.V = null;
                      if (!a.D) {
                        c.A(4);
                        break;
                      }
                      return u(c, a.D.destroy(), 5);
                    case 5:
                      a.D = null;
                    case 4:
                      Ue.prototype.release.call(a), A(c);
                  }
                });
              };
              q.Yb = function (a, b) {
                b = void 0 === b ? !0 : b;
                if (this.l == gm) return Promise.reject(hm());
                var c = Hk();
                c.mediaElement = a;
                oc() || (b = !1);
                var d = b ? this.wb : this.W;
                a = Lk(this.Ga, function () {
                  return {
                    node: d,
                    payload: c,
                    hb: !1
                  };
                });
                a.Jb = function () {};
                return im(a);
              };
              q.lf = function (a) {
                this.cf = a;
              };
              q.detach = function () {
                var a = this;
                if (this.l == gm) return Promise.reject(hm());
                var b = Lk(this.Ga, function () {
                  return {
                    node: a.O,
                    payload: Hk(),
                    hb: !1
                  };
                });
                b.Jb = function () {};
                return im(b);
              };
              q.re = function (a) {
                var b = this;
                a = void 0 === a ? !0 : a;
                if (this.l == gm) return Promise.reject(hm());
                this.dc = !1;
                oc() || (a = !1);
                dm(this);
                var c = Hk(),
                  d = Lk(this.Ga, function (e) {
                    var f = e.mediaElement && a ? b.wb : e.mediaElement ? b.W : b.O;
                    c.mediaElement = e.mediaElement;
                    return {
                      node: f,
                      payload: c,
                      hb: !1
                    };
                  });
                d.Jb = function () {};
                return im(d);
              };
              q.Fg = function (a) {
                this.fc = a;
              };
              q.load = function (a, b, c) {
                var d = this;
                this.fc = null;
                this.dc = !1;
                if (this.l == gm) return Promise.reject(hm());
                this.dispatchEvent(bm("loading"));
                var e = Hk();
                e.uri = a;
                e.ne = Date.now() / 1E3;
                c && (e.mimeType = c);
                void 0 !== b && (e.startTime = b);
                var f = jm(this, e) ? this.yb : this.ba,
                  g = Lk(this.Ga, function (h) {
                    if (null == h.mediaElement) return null;
                    e.mediaElement = h.mediaElement;
                    return {
                      node: f,
                      payload: e,
                      hb: !0
                    };
                  });
                this.o = new Nl();
                this.V = km(this);
                g.Jb = function () {};
                return new Promise(function (h, k) {
                  g.dd = function () {
                    return k(new O(2, 7, 7002));
                  };
                  g.bd = function () {
                    h();
                    d.dispatchEvent(bm("loaded"));
                  };
                  g.mb = function () {
                    return k(hm());
                  };
                  g.onError = function (l) {
                    return k(l);
                  };
                });
              };
              function jm(a, b) {
                if (!oc()) return !0;
                var c = b.mimeType,
                  d = b.uri || "";
                c || (c = Ug(d), c = fm[c]);
                if (c) {
                  if ("" == (b.mediaElement || qc()).canPlayType(c)) return !1;
                  if (!oc() || !(c in Tg || Ug(d) in Vg) || a.h.streaming.preferNativeHls) return !0;
                  if (wc()) return a.h.streaming.useNativeHlsOnSafari;
                }
                return !1;
              }
              function Sl(a, b, c) {
                null == b.mediaElement && (b.mediaElement = c.mediaElement, a.Xb.C(b.mediaElement, "error", function () {
                  var d = lm(a);
                  d && mm(a, d);
                }));
                a.g = b.mediaElement;
                return Promise.resolve();
              }
              function Tl(a, b) {
                var c, d, e, f, g, h, k, l, m;
                return G(function (n) {
                  switch (n.g) {
                    case 1:
                      return a.l != gm && (a.l = Ol), c = a.Zb.map(function (p) {
                        return p();
                      }), a.Zb = [], u(n, Promise.all(c), 2);
                    case 2:
                      a.dispatchEvent(bm("unloading"));
                      b.mimeType = null;
                      b.startTime = null;
                      b.uri = null;
                      a.Fa && (a.Fa.release(), a.Fa = null);
                      b.mediaElement && a.s.nb();
                      a.af.stop();
                      a.xb && (a.xb.release(), a.xb = null);
                      a.Vc && (a.Vc.stop(), a.Vc = null);
                      if (!a.J) {
                        n.A(3);
                        break;
                      }
                      return u(n, a.J.stop(), 4);
                    case 4:
                      a.J = null, a.Yc = null;
                    case 3:
                      if (!a.u) {
                        n.A(5);
                        break;
                      }
                      return u(n, a.u.stop(), 5);
                    case 5:
                      if (!a.j) {
                        n.A(7);
                        break;
                      }
                      return u(n, a.j.destroy(), 8);
                    case 8:
                      a.j = null;
                    case 7:
                      a.H && (a.H.release(), a.H = null);
                      a.B && (a.B.release(), a.B = null);
                      if (!a.G) {
                        n.A(9);
                        break;
                      }
                      return u(n, a.G.destroy(), 10);
                    case 10:
                      a.G = null;
                    case 9:
                      if (a.F) a.F.onAssetUnload();
                      if (!b.mediaElement || !b.mediaElement.src) {
                        n.A(11);
                        break;
                      }
                      return u(n, new Promise(function (p) {
                        return new P(p).N(.1);
                      }), 12);
                    case 12:
                      for (b.mediaElement.removeAttribute("src"), b.mediaElement.load(); b.mediaElement.lastChild;) b.mediaElement.removeChild(b.mediaElement.firstChild);
                    case 11:
                      if (!a.m) {
                        n.A(13);
                        break;
                      }
                      return u(n, a.m.destroy(), 14);
                    case 14:
                      a.m = null;
                    case 13:
                      a.Nb = null;
                      a.M = null;
                      if (a.i) {
                        d = r(a.i.variants);
                        for (e = d.next(); !e.done; e = d.next()) for (f = e.value, g = r([f.audio, f.video]), h = g.next(); !h.done; h = g.next()) (k = h.value) && k.segmentIndex && k.segmentIndex.release();
                        l = r(a.i.textStreams);
                        for (h = l.next(); !h.done; h = l.next()) m = h.value, m.segmentIndex && m.segmentIndex.release();
                      }
                      a.i = null;
                      a.o = new Nl();
                      a.Ud = null;
                      nm(a);
                      A(n);
                  }
                });
              }
              function Ul(a, b) {
                var c, d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) return c = a.h.textDisplayFactory, d = c(), a.Ud = c, e = om(b.mediaElement, d, function (k, l, m) {
                    pm(a, k, l, m);
                  }, a.L), e.configure(a.h.mediaSource), f = a.h.manifest, g = f.segmentRelativeVttTiming, e.H = g, u(h, e.J, 2);
                  a.G = e;
                  A(h);
                });
              }
              function Vl(a, b, c) {
                var d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) return b.mimeType = c.mimeType, b.uri = c.uri, d = b.uri, e = a.D, a.Nb = d, f = a, u(h, Sg(d, e, a.h.manifest.retryParameters, b.mimeType), 2);
                  f.Yc = h.h;
                  a.J = a.Yc();
                  g = Ve(a.h.manifest);
                  c.mediaElement && "AUDIO" === c.mediaElement.nodeName && (g.disableVideo = !0);
                  a.J.configure(g);
                  A(h);
                });
              }
              function Wl(a, b) {
                var c = b.uri;
                b = a.D;
                a.Fa = new Wj(function () {
                  return a.uc();
                });
                a.Fa.addEventListener("regionadd", function (f) {
                  f = f.region;
                  qm(a, "timelineregionadded", f);
                  if (a.F) a.F.onDashTimedMetadata(f);
                });
                a.ua = null;
                a.h.streaming.observeQualityChanges && (a.ua = new Sj(function () {
                  return a.Na();
                }), a.ua.addEventListener("qualitychange", function (f) {
                  var g = f.quality;
                  f = f.position;
                  g = new Map().set("mediaQuality", {
                    bandwidth: g.bandwidth,
                    audioSamplingRate: g.audioSamplingRate,
                    codecs: g.codecs,
                    contentType: g.contentType,
                    frameRate: g.frameRate,
                    height: g.height,
                    mimeType: g.mimeType,
                    channelsCount: g.channelsCount,
                    pixelAspectRatio: g.pixelAspectRatio,
                    width: g.width
                  }).set("position", f);
                  a.dispatchEvent(bm("mediaqualitychanged", g));
                }));
                var d = {
                    networkingEngine: b,
                    modifyManifestRequest: function modifyManifestRequest(f, g) {
                      var h = a.V;
                      try {
                        h.g.enabled && (h.o = g.format, nl(h, f, {
                          ot: ql,
                          su: !h.i
                        }));
                      } catch (k) {
                        Xa("CMCD_MANIFEST_ERROR", "Could not generate manifest CMCD data.", k);
                      }
                    },
                    modifySegmentRequest: function modifySegmentRequest(f, g) {
                      dl(a.V, f, g);
                    },
                    filter: function filter(f) {
                      return rm(a, f);
                    },
                    makeTextStreamsForClosedCaptions: function makeTextStreamsForClosedCaptions(f) {
                      return sm(a, f);
                    },
                    onTimelineRegionAdded: function onTimelineRegionAdded(f) {
                      var g = a.Fa;
                      a: {
                        var h = r(g.g);
                        for (var k = h.next(); !k.done; k = h.next()) if (k = k.value, k.schemeIdUri == f.schemeIdUri && k.id == f.id && k.startTime == f.startTime && k.endTime == f.endTime) {
                          h = k;
                          break a;
                        }
                        h = null;
                      }
                      null == h && (g.g.add(f), f = new S("regionadd", new Map([["region", f]])), g.dispatchEvent(f));
                    },
                    onEvent: function onEvent(f) {
                      return a.dispatchEvent(f);
                    },
                    onError: function onError(f) {
                      return mm(a, f);
                    },
                    isLowLatencyMode: function isLowLatencyMode() {
                      return a.h.streaming.lowLatencyMode;
                    },
                    isAutoLowLatencyMode: function isAutoLowLatencyMode() {
                      return a.h.streaming.autoLowLatencyMode;
                    },
                    enableLowLatencyMode: function enableLowLatencyMode() {
                      a.configure("streaming.lowLatencyMode", !0);
                    },
                    updateDuration: function updateDuration() {
                      a.j && a.j.updateDuration();
                    },
                    newDrmInfo: function newDrmInfo(f) {
                      var g = a.m ? a.m.g : null;
                      g && a.m.u && tm(a, g.keySystem, f);
                    }
                  },
                  e = Date.now() / 1E3;
                return new Le(function () {
                  var f, g, h, k;
                  return G(function (l) {
                    if (1 == l.g) return f = a, u(l, a.J.start(c, d), 2);
                    f.i = l.h;
                    g = bm("manifestparsed");
                    a.dispatchEvent(g);
                    if (0 == a.i.variants.length) throw new O(2, 4, 4036);
                    um(a.i);
                    h = Date.now() / 1E3;
                    k = h - e;
                    a.o.F = k;
                    A(l);
                  });
                }(), function () {
                  return a.J.stop();
                });
              }
              function Xl(a, b) {
                var c, d;
                return G(function (e) {
                  return 1 == e.g ? (c = Date.now() / 1E3, d = !0, a.m = vm(a, {
                    kb: a.D,
                    onError: function onError(f) {
                      mm(a, f);
                    },
                    cd: function cd(f) {
                      wm(a, f);
                    },
                    onExpirationUpdated: function onExpirationUpdated(f, g) {
                      xm(a, f, g);
                    },
                    onEvent: function onEvent(f) {
                      a.dispatchEvent(f);
                      "drmsessionupdate" == f.type && d && (d = !1, a.o.j = Date.now() / 1E3 - c, a.L && (f = a.L, f.g && f.h.classList.add("shaka-hidden")));
                    }
                  }), a.m.configure(a.h.drm), u(e, mg(a.m, a.i.variants, a.i.offlineSessionIds), 2)) : 3 != e.g ? u(e, a.m.Yb(b.mediaElement), 3) : u(e, rm(a, a.i), 0);
                });
              }
              function Yl(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z;
                return G(function (B) {
                  switch (B.g) {
                    case 1:
                      b.startTime = c.startTime;
                      null != a.fc && (b.startTime = a.fc, a.fc = null);
                      d = b.mediaElement;
                      e = b.uri;
                      a.Nb = e;
                      a.H = new Oj({
                        Tc: function Tc() {
                          return d.playbackRate;
                        },
                        Pc: function Pc() {
                          return d.defaultPlaybackRate;
                        },
                        le: function le(E) {
                          d.playbackRate = E;
                        },
                        Me: function Me(E) {
                          d.currentTime += E;
                        }
                      });
                      f = function f() {
                        return ym(a);
                      };
                      g = function g() {
                        return zm(a);
                      };
                      a.s.C(d, "playing", f);
                      a.s.C(d, "pause", f);
                      a.s.C(d, "ended", f);
                      a.s.C(d, "ratechange", g);
                      em(a, a.h);
                      h = a.h.abrFactory;
                      a.u && a.Nd == h || (a.Nd = h, a.u = h(), "function" != typeof a.u.setMediaElement && (re("AbrManager", "Please use an AbrManager with setMediaElement function."), a.u.setMediaElement = function () {}), a.u.configure(a.h.abr));
                      a.ub = new Ae(a.h.preferredAudioLanguage, a.h.preferredVariantRole, a.h.preferredAudioChannelCount);
                      a.vb = a.h.preferredTextLanguage;
                      a.cc = a.h.preferredTextRole;
                      a.$b = a.h.preferForcedSubs;
                      Am(a.i.presentationTimeline, a.h.playRangeStart, a.h.playRangeEnd);
                      a.u.init(function (E, F, H) {
                        a.j && E != a.j.l && Bm(a, E, !0, void 0 === F ? !1 : F, void 0 === H ? 0 : H);
                      });
                      a.u.setMediaElement(d);
                      xd(a.i, a.h.preferredVideoCodecs, a.h.preferredAudioCodecs, a.h.preferredAudioChannelCount, a.h.preferredDecodingAttributes);
                      a.j = Cm(a);
                      a.j.configure(a.h.streaming);
                      a.l = Dm;
                      d.textTracks && a.s.C(d.textTracks, "addtrack", function (E) {
                        if (E.track) switch (E = E.track, E.kind) {
                          case "chapters":
                            Em(a, E);
                        }
                      });
                      a.dispatchEvent(bm("streaming"));
                      k = null;
                      (l = a.j.l) || (k = cm(a));
                      m = [];
                      n = l || k;
                      p = r([n.video, n.audio]);
                      for (t = p.next(); !t.done; t = p.next()) (v = t.value) && !v.segmentIndex && m.push(v.createSegmentIndex());
                      if (!(0 < m.length)) {
                        B.A(2);
                        break;
                      }
                      return u(B, Promise.all(m), 2);
                    case 2:
                      a.B = Fm(a, b.startTime);
                      a.xb = Gm(a);
                      y = Math.max(a.i.minBufferTime, a.h.streaming.rebufferingGoal);
                      Hm(a, y);
                      if (l) {
                        B.A(4);
                        break;
                      }
                      Bm(a, k, !0, !1, 0);
                      if (!a.h.streaming.startAtSegmentBoundary) {
                        B.A(5);
                        break;
                      }
                      w = a.B.Ic();
                      return u(B, Im(k, w), 6);
                    case 6:
                      x = B.h, a.B.zd(x);
                    case 5:
                      Jm(a, null, $d(k));
                    case 4:
                      return a.B.yd(), C = a.Fb().find(function (E) {
                        return E.active;
                      }), C || ((z = je(a.i.textStreams, a.vb, a.cc, a.$b)[0] || null) && Ml(a.o.h, z, !0), k && (z ? (k.audio && Km(a, k.audio, z) && (a.ca = !0), a.ca && a.G.m.setTextVisibility(!0), Lm(a)) : a.ca = !1), z && (a.h.streaming.alwaysStreamText || a.Hd()) && pk(a.j, z)), u(B, a.j.start(), 7);
                    case 7:
                      a.h.abr.enabled && (a.u.enable(), Mm(a)), Od(a.j ? a.j.l : null, a.i), Nm(a.i), Om(a), Pm(a), a.i.variants.some(function (E) {
                        return E.primary;
                      }), a.dc = !0, a.s.ma(d, "loadedmetadata", function () {
                        a.o.m = Date.now() / 1E3 - c.ne;
                      }), A(B);
                  }
                });
              }
              function Zl(a, b, c) {
                var d, e, f, g, h, k, l;
                return G(function (m) {
                  return 1 == m.g ? (d = kc, e = Date.now() / 1E3, f = !0, a.m = vm(a, {
                    kb: a.D,
                    onError: function onError(n) {
                      mm(a, n);
                    },
                    cd: function cd(n) {
                      wm(a, n);
                    },
                    onExpirationUpdated: function onExpirationUpdated(n, p) {
                      xm(a, n, p);
                    },
                    onEvent: function onEvent(n) {
                      a.dispatchEvent(n);
                      "drmsessionupdate" == n.type && f && (f = !1, a.o.j = Date.now() / 1E3 - e);
                    }
                  }), a.m.configure(a.h.drm), g = c.uri || "", h = Ug(g), k = fm[h], "application/x-mpegurl" == k && wc() && (k = "application/vnd.apple.mpegurl"), k || (k = "video/mp4"), l = {
                    id: 0,
                    language: "und",
                    disabledUntilTime: 0,
                    primary: !1,
                    audio: null,
                    video: {
                      id: 0,
                      originalId: null,
                      createSegmentIndex: function createSegmentIndex() {
                        return Promise.resolve();
                      },
                      segmentIndex: null,
                      mimeType: c.mimeType ? c.mimeType.split(";")[0] : k,
                      codecs: c.mimeType ? cd(c.mimeType) : "",
                      encrypted: !0,
                      drmInfos: [],
                      keyIds: new Set(),
                      language: "und",
                      label: null,
                      type: d.va,
                      primary: !1,
                      trickModeVideo: null,
                      emsgSchemeIdUris: null,
                      roles: [],
                      forced: !1,
                      channelsCount: null,
                      audioSamplingRate: null,
                      spatialAudio: !1,
                      closedCaptions: null
                    },
                    bandwidth: 100,
                    allowedByApplication: !0,
                    allowedByKeySystem: !0,
                    decodingInfos: []
                  }, a.m.V = !0, u(m, mg(a.m, [l], []), 2)) : u(m, a.m.Yb(b.mediaElement), 0);
                });
              }
              function $l(a, b, c) {
                function d() {
                  return ym(a);
                }
                b.uri = c.uri;
                b.startTime = c.startTime;
                a.Nb = b.uri;
                var e = b.mediaElement;
                a.B = new Cj(e);
                var f = !1;
                a.Zb.push(function () {
                  f = !0;
                });
                null != b.startTime && a.B.zd(b.startTime);
                a.H = new Oj({
                  Tc: function Tc() {
                    return e.playbackRate;
                  },
                  Pc: function Pc() {
                    return e.defaultPlaybackRate;
                  },
                  le: function le(k) {
                    e.playbackRate = k;
                  },
                  Me: function Me(k) {
                    e.currentTime += k;
                  }
                });
                Hm(a, a.h.streaming.rebufferingGoal);
                a.s.C(e, "playing", d);
                a.s.C(e, "pause", d);
                a.s.C(e, "ended", d);
                a.s.C(e, "ratechange", function () {
                  return zm(a);
                });
                "none" != e.preload && a.s.ma(e, "loadedmetadata", function () {
                  a.o.m = Date.now() / 1E3 - c.ne;
                });
                e.audioTracks && (a.s.C(e.audioTracks, "addtrack", function () {
                  return Om(a);
                }), a.s.C(e.audioTracks, "removetrack", function () {
                  return Om(a);
                }), a.s.C(e.audioTracks, "change", function () {
                  return Om(a);
                }));
                e.textTracks && (a.s.C(e.textTracks, "addtrack", function (k) {
                  if (k.track) switch (k = k.track, k.kind) {
                    case "metadata":
                      Qm(a, k);
                      break;
                    case "chapters":
                      Em(a, k);
                      break;
                    default:
                      Om(a);
                  }
                }), a.s.C(e.textTracks, "removetrack", function () {
                  return Om(a);
                }), a.s.C(e.textTracks, "change", function () {
                  return Om(a);
                }));
                var g = Ug(b.uri);
                e.src = ol(a.V, b.uri, fm[g]);
                (uc() || tc("Web0S")) && e.load();
                a.l = Rm;
                a.dispatchEvent(bm("streaming"));
                var h = new lc();
                tj(e, HTMLMediaElement.HAVE_METADATA, a.s, function () {
                  a.B.yd();
                  h.resolve();
                });
                tj(e, HTMLMediaElement.HAVE_CURRENT_DATA, a.s, function () {
                  var k;
                  return G(function (l) {
                    if (1 == l.g) return Sm(a), k = Tm(a), k.find(function (m) {
                      return "disabled" != m.mode;
                    }) ? (0 < k.length && (a.ca = !0), l.A(2)) : u(l, new Promise(function (m) {
                      a.s.ma(e.textTracks, "change", m);
                      new P(m).N(1);
                    }), 2);
                    if (f) return l.return();
                    Um(a);
                    A(l);
                  });
                });
                e.error ? h.reject(lm(a)) : "none" == e.preload && (Wa('With <video preload="none">, the browser will not load anything until play() is called. We are unable to measure load latency in a meaningful way, and we cannot provide track info yet. Please do not use preload="none" with Shaka Player.'), h.resolve());
                a.s.ma(e, "error", function () {
                  h.reject(lm(a));
                });
                return new Le(h, function () {
                  h.reject(new O(2, 7, 7001));
                  return Promise.resolve();
                }).Y(function () {
                  a.dc = !0;
                });
              }
              function Sm(a) {
                var b = a.h.preferredAudioLanguage;
                if ("" != b) {
                  a.ge(b);
                  var c = a.h.preferredVariantRole;
                  "" != c && a.ge(b, c);
                }
              }
              function Um(a) {
                var b = a.h.preferredTextLanguage,
                  c = a.h.preferForcedSubs;
                if ("" != b) {
                  a.he(b, "", c);
                  var d = a.h.preferredTextRole;
                  "" != d && a.he(b, d, c);
                }
              }
              function Qm(a, b) {
                if ("metadata" == b.kind) {
                  b.mode = "hidden";
                  a.s.C(b, "cuechange", function () {
                    if (b.activeCues) for (var d = r(b.activeCues), e = d.next(); !e.done; e = d.next()) if (e = e.value, Vm(a, e.startTime, e.endTime, e.type, e.value), a.F) a.F.onCueMetadataChange(e.value);
                  });
                  var c = new P(function () {
                    var d = Wm(a);
                    d = r(d);
                    for (var e = d.next(); !e.done; e = d.next()) e.value.mode = "hidden";
                  }).Mb().N(.5);
                  a.Zb.push(function () {
                    c.stop();
                  });
                }
              }
              function pm(a, b, c, d) {
                b = r(b);
                for (var e = b.next(); !e.done; e = b.next()) if (e = e.value, e.data && e.cueTime && e.frames) {
                  var f = e.cueTime + c,
                    g = d;
                  g && f > g && (g = f);
                  for (var h = r(e.frames), k = h.next(); !k.done; k = h.next()) Vm(a, f, g, "org.id3", k.value);
                  if (a.F) a.F.onHlsTimedMetadata(e, f);
                }
              }
              function Vm(a, b, c, d, e) {
                b = new Map().set("startTime", b).set("endTime", c).set("metadataType", d).set("payload", e);
                a.dispatchEvent(bm("metadata", b));
              }
              function Em(a, b) {
                if (b && "chapters" == b.kind) {
                  b.mode = "hidden";
                  var c = new P(function () {
                    b.mode = "hidden";
                  }).Mb().N(.5);
                  a.Zb.push(function () {
                    c.stop();
                  });
                }
              }
              function um(a) {
                function b(c) {
                  return c.video && c.audio || c.video && c.video.codecs.includes(",");
                }
                a.variants.some(b) && (a.variants = a.variants.filter(b));
              }
              function vm(a, b) {
                return new fg(b, a.h.drm.updateExpirationTime);
              }
              function Ql(a) {
                return new Ze(function (b, c) {
                  a.u && a.u.segmentDownloaded(b, c);
                }, function (b, c, d) {
                  b = new Map().set("headers", b).set("request", c).set("requestType", d);
                  a.dispatchEvent(bm("downloadheadersreceived", b));
                }, function (b, c, d, e) {
                  b = new Map().set("request", b).set("error", c).set("httpResponseCode", d).set("aborted", e);
                  a.dispatchEvent(bm("downloadfailed", b));
                });
              }
              function Fm(a, b) {
                return new Dj(a.g, a.i, a.h.streaming, b, function () {
                  a.xb && Rj(a.xb, !0);
                  a.j && a.j.vc();
                  a.M && Xm(a);
                }, function (c) {
                  return a.dispatchEvent(c);
                });
              }
              function Gm(a) {
                var b = new Xj(a.Fa);
                b.addEventListener("enter", function (d) {
                  qm(a, "timelineregionenter", d.region);
                });
                b.addEventListener("exit", function (d) {
                  qm(a, "timelineregionexit", d.region);
                });
                b.addEventListener("skip", function (d) {
                  var e = d.region;
                  d.seeking || (qm(a, "timelineregionenter", e), qm(a, "timelineregionexit", e));
                });
                var c = new Qj(a.g);
                c.g.add(b);
                a.ua && c.g.add(a.ua);
                return c;
              }
              function Hm(a, b) {
                a.M = new Ee();
                a.M.g = Ge;
                He(a.M, b, Math.min(.5, b / 2));
                nm(a);
                a.Vc = new P(function () {
                  Xm(a);
                }).Ca(.25);
              }
              function Xm(a) {
                switch (a.l) {
                  case Rm:
                    if (a.g.ended) var b = !0;else {
                      var c = ui(a.g.buffered);
                      b = null != c && c >= a.g.duration - 1;
                    }
                    break;
                  case Dm:
                    a: if (a.g.ended || Si(a.G)) b = !0;else {
                      if (a.i.presentationTimeline.U()) {
                        c = a.i.presentationTimeline.gb();
                        var d = ui(a.g.buffered);
                        if (null != d && d >= c) {
                          b = !0;
                          break a;
                        }
                      }
                      b = !1;
                    }
                    break;
                  default:
                    b = !1;
                }
                d = wi(a.g.buffered, a.g.currentTime);
                c = a.M;
                var e = b,
                  f = c.h.get(c.g);
                b = c.g;
                d = e || d >= f ? Fe : Ge;
                c.g = d;
                b != d && nm(a);
              }
              function om(a, b, c, d) {
                return new Mi(a, b, c, d);
              }
              function km(a) {
                return new cl({
                  getBandwidthEstimate: function getBandwidthEstimate() {
                    return a.u ? a.u.getBandwidthEstimate() : NaN;
                  },
                  Na: function Na() {
                    return a.Na();
                  },
                  getCurrentTime: function getCurrentTime() {
                    return a.g ? a.g.currentTime : 0;
                  },
                  Xa: function Xa() {
                    return a.Xa();
                  },
                  Rc: function Rc() {
                    return a.Rc();
                  },
                  U: function U() {
                    return a.U();
                  }
                }, a.h.cmcd);
              }
              function Cm(a) {
                return new dk(a.i, {
                  Sc: function Sc() {
                    return a.B ? a.B.Ic() : 0;
                  },
                  getBandwidthEstimate: function getBandwidthEstimate() {
                    return a.u.getBandwidthEstimate();
                  },
                  modifySegmentRequest: function modifySegmentRequest(b, c) {
                    dl(a.V, b, c);
                  },
                  R: a.G,
                  kb: a.D,
                  onError: function onError(b) {
                    return mm(a, b);
                  },
                  onEvent: function onEvent(b) {
                    return a.dispatchEvent(b);
                  },
                  gg: function gg() {
                    a.J && a.J.update && a.J.update();
                  },
                  Wd: function Wd(b, c, d) {
                    a.B && a.B.Ne();
                    Xm(a);
                    b = new Map().set("start", b).set("end", c).set("contentType", d);
                    a.dispatchEvent(bm("segmentappended", b));
                  },
                  fg: function fg(b, c) {
                    (c = c.Od) && a.ua && Uj(a.ua, c, b);
                  },
                  xe: function xe(b, c) {
                    var d = a.m;
                    if (d.h.parseInbandPsshEnabled && ["audio", "video"].includes(b)) {
                      c = new Jf(M(c));
                      var e = 0,
                        f = r(c.data);
                      for (b = f.next(); !b.done; b = f.next()) e += b.value.length;
                      if (0 == e) d = Promise.resolve();else {
                        e = new Uint8Array(e);
                        f = 0;
                        c = r(c.data);
                        for (b = c.next(); !b.done; b = c.next()) b = b.value, e.set(b, f), f += b.length;
                        vg(d, "cenc", e);
                        d = d.o;
                      }
                    } else d = Promise.resolve();
                    return d;
                  },
                  hg: function hg(b, c, d) {
                    pm(a, b, c, d);
                  }
                });
              }
              q.configure = function (a, b) {
                2 == arguments.length && "string" == typeof a && (a = yl(a, b));
                a.streaming && "forceTransmuxTS" in a.streaming && (re("streaming.forceTransmuxTS configuration", "Please Use streaming.forceTransmux instead."), a.streaming.forceTransmux = a.streaming.forceTransmuxTS, delete a.streaming.forceTransmuxTS);
                a.streaming && a.streaming.lowLatencyMode && (void 0 == a.streaming.inaccurateManifestTolerance && (a.streaming.inaccurateManifestTolerance = 0), void 0 == a.streaming.rebufferingGoal && (a.streaming.rebufferingGoal = .01));
                var c = Gl(this.h, a, Pl(this));
                Ym(this);
                return c;
              };
              function Ym(a) {
                if (a.J) {
                  var b = Ve(a.h.manifest);
                  a.g && "AUDIO" === a.g.nodeName && (b.disableVideo = !0);
                  a.J.configure(b);
                }
                a.m && a.m.configure(a.h.drm);
                if (a.j) {
                  a.j.configure(a.h.streaming);
                  try {
                    Zm(a, a.i);
                  } catch (f) {
                    mm(a, f);
                  }
                  a.u && Pm(a);
                  b = a.j.l;
                  !b || b.allowedByApplication && b.allowedByKeySystem || $m(a);
                }
                a.D && a.D.je(a.h.streaming.forceHTTPS);
                if (a.G && (a.G.configure(a.h.mediaSource), a.G.H = a.h.manifest.segmentRelativeVttTiming, b = a.h.textDisplayFactory, a.Ud != b)) {
                  var c = b(),
                    d = a.G,
                    e = d.m;
                  d.m = c;
                  e && (c.setTextVisibility(e.isTextVisible()), e.destroy());
                  d.g && (d.g.i = c);
                  a.Ud = b;
                  a.j && (b = a.j, (c = b.j.get(jc)) && nk(b, c.stream, !0, 0, !0));
                }
                a.u && (a.u.configure(a.h.abr), a.h.abr.enabled ? a.u.enable() : a.u.disable(), Mm(a));
                a.M && (b = a.h.streaming.rebufferingGoal, a.i && (b = Math.max(b, a.i.minBufferTime)), He(a.M, b, Math.min(.5, b / 2)));
                a.i && Am(a.i.presentationTimeline, a.h.playRangeStart, a.h.playRangeEnd);
              }
              q.getConfiguration = function () {
                var a = Pl(this);
                Gl(a, this.h, Pl(this));
                return a;
              };
              q.Bf = function () {
                if (this.g) {
                  var a = this.g.buffered.length;
                  a = a ? this.g.buffered.end(a - 1) : 0;
                  var b = this.getConfiguration().streaming.bufferingGoal;
                  b = Math.min(this.g.currentTime + b, this.uc().end);
                  if (a >= b) return 1;
                  if (!(a <= this.g.currentTime) && a < b) return (a - this.g.currentTime) / (b - this.g.currentTime);
                }
                return 0;
              };
              q.rg = function () {
                for (var a in this.h) delete this.h[a];
                Gl(this.h, Pl(this), Pl(this));
                Ym(this);
              };
              q.Hf = function () {
                return this.l;
              };
              q.Lf = function () {
                return this.g;
              };
              q.jc = function () {
                return this.D;
              };
              q.Dd = function () {
                return this.Nb;
              };
              q.Ge = function () {
                return this.F ? this.F : null;
              };
              q.U = function () {
                return this.i ? this.i.presentationTimeline.U() : this.g && this.g.src ? Infinity == this.g.duration : !1;
              };
              q.jb = function () {
                return this.i ? this.i.presentationTimeline.jb() : !1;
              };
              q.Zf = function () {
                if (this.i) {
                  var a = this.i.variants;
                  return a.length ? !a[0].video : !1;
                }
                return this.g && this.g.src ? this.g.videoTracks ? 0 == this.g.videoTracks.length : 0 == this.g.videoHeight : !1;
              };
              q.uc = function () {
                if (!this.dc) return {
                  start: 0,
                  end: 0
                };
                if (this.i) {
                  var a = this.i.presentationTimeline;
                  return {
                    start: a.Db(),
                    end: a.Oa()
                  };
                }
                return this.g && this.g.src && (a = this.g.seekable, a.length) ? {
                  start: a.start(0),
                  end: a.end(a.length - 1)
                } : {
                  start: 0,
                  end: 0
                };
              };
              q.Xf = function () {
                this.U() && (this.g.currentTime = this.uc().end);
              };
              q.keySystem = function () {
                var a = this.drmInfo();
                return a ? a.keySystem : "";
              };
              q.drmInfo = function () {
                return this.m ? this.m.g : null;
              };
              q.ic = function () {
                return this.m ? this.m.ic() : Infinity;
              };
              q.Qc = function () {
                return this.m ? this.m.Qc() : {};
              };
              q.Fd = function () {
                return this.M ? this.M.g == Ge : !1;
              };
              q.Rc = function () {
                return this.g ? this.H ? this.H.i : 1 : 0;
              };
              q.Ag = function (a) {
                0 == a ? Wa("A trick play rate of 0 is unsupported!") : (this.g.paused && this.g.play(), this.H.set(a), this.l == Dm && (this.u.playbackRateChanged(a), mk(this.j, 1 < Math.abs(a))));
              };
              q.pf = function () {
                var a = this.H.Pc();
                this.l == Rm && this.H.set(a);
                this.l == Dm && (this.H.set(a), this.u.playbackRateChanged(a), mk(this.j, !1));
              };
              q.Xa = function () {
                if (this.i) {
                  for (var a = this.j ? this.j.l : null, b = [], c = 0, d = r(this.i.variants), e = d.next(); !e.done; e = d.next()) if (e = e.value, he(e)) {
                    var f = $d(e);
                    f.active = e == a;
                    f.active || 1 == c || null == a || e.video != a.video || e.audio != a.audio || (f.active = !0);
                    f.active && c++;
                    b.push(f);
                  }
                  return b;
                }
                return this.g && this.g.audioTracks ? Array.from(this.g.audioTracks).map(function (g) {
                  return ge(g);
                }) : [];
              };
              q.Fb = function () {
                if (this.i) {
                  for (var a = this.j ? this.j.o : null, b = [], c = r(this.i.textStreams), d = c.next(); !d.done; d = c.next()) {
                    d = d.value;
                    var e = ae(d);
                    e.active = d == a;
                    b.push(e);
                  }
                  return b;
                }
                return this.g && this.g.src && this.g.textTracks ? Tm(this).map(function (f) {
                  return ee(f);
                }) : [];
              };
              q.Ff = function () {
                return this.i ? this.i.imageStreams.map(function (a) {
                  return be(a);
                }) : [];
              };
              q.Tf = function (a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l,
                  m,
                  n,
                  p,
                  t,
                  v,
                  y,
                  w,
                  x,
                  C,
                  z,
                  B,
                  E,
                  F;
                return G(function (H) {
                  if (1 == H.g) return c.i ? (d = c.i.imageStreams.find(function (I) {
                    return I.id == a;
                  })) ? d.segmentIndex ? H.A(3) : u(H, d.createSegmentIndex(), 3) : H.return(null) : H.A(2);
                  if (2 != H.g) {
                    e = d.segmentIndex.find(b);
                    if (null == e) return H.return(null);
                    f = d.segmentIndex.get(e);
                    g = f.tilesLayout || d.tilesLayout;
                    h = /(\d+)x(\d+)/.exec(g);
                    if (!h) return H.return(null);
                    k = d.width || 0;
                    l = d.height || 0;
                    m = parseInt(h[1], 10);
                    n = parseInt(h[2], 10);
                    p = k / m;
                    t = l / n;
                    v = m * n;
                    y = f.j - f.startTime;
                    w = f.s || y / v;
                    x = f.startTime;
                    z = C = 0;
                    1 < v && (B = Math.floor((b - f.startTime) / w), x = f.startTime + B * w, C = B % m * p, z = Math.floor(B / m) * t);
                    E = !1;
                    if (F = f.o) E = !0, t = F.height, C = F.positionX, z = F.positionY, p = F.width;
                    return H.return({
                      imageHeight: l,
                      imageWidth: k,
                      height: t,
                      positionX: C,
                      positionY: z,
                      startTime: x,
                      duration: w,
                      uris: f.ya(),
                      width: p,
                      sprite: E
                    });
                  }
                  return H.return(null);
                });
              };
              q.Se = function (a) {
                if (this.i && this.j) {
                  var b = this.i.textStreams.find(function (d) {
                    return d.id == a.id;
                  });
                  b && b != this.j.o && (Ml(this.o.h, b, !1), pk(this.j, b), an(this), this.vb = b.language);
                } else if (this.g && this.g.src && this.g.textTracks) {
                  b = Tm(this);
                  b = r(b);
                  for (var c = b.next(); !c.done; c = b.next()) c = c.value, ce(c) == a.id ? c.mode = this.ca ? "showing" : "hidden" : c.mode = "disabled";
                  an(this);
                }
              };
              q.Te = function (a, b, c) {
                b = void 0 === b ? !1 : b;
                c = void 0 === c ? 0 : c;
                if (this.i && this.j) {
                  this.h.abr.enabled && Wa("Changing tracks while abr manager is enabled will likely result in the selected track being overriden. Consider disabling abr before calling selectVariantTrack().");
                  var d = this.i.variants.find(function (e) {
                    return e.id == a.id;
                  });
                  d && he(d) && (Bm(this, d, !1, b, c), this.ub = new ze(d), Pm(this));
                } else if (this.g && this.g.audioTracks) for (b = Array.from(this.g.audioTracks), b = r(b), c = b.next(); !c.done; c = b.next()) if (c = c.value, ce(c) == a.id) {
                  bn(this, c);
                  break;
                }
              };
              q.Af = function () {
                return cn(this.Xa());
              };
              q.Rf = function () {
                return cn(this.Fb());
              };
              q.zf = function () {
                return Array.from(dn(this.Xa()));
              };
              q.Qf = function () {
                return Array.from(dn(this.Fb()));
              };
              q.ge = function (a, b, c) {
                c = void 0 === c ? 0 : c;
                if (this.i && this.B) {
                  this.ub = new Ae(a, b || "", c, "");
                  b = function b(h, k) {
                    return h.video || k.video ? h.video && k.video ? Math.abs((h.video.height || 0) - (k.video.height || 0)) + Math.abs((h.video.width || 0) - (k.video.width || 0)) : Infinity : 0;
                  };
                  a = this.j.l;
                  var d = this.ub.create(this.i.variants);
                  c = null;
                  d = r(d.values());
                  for (var e = d.next(); !e.done; e = d.next()) if (e = e.value, !c || b(c, a) > b(e, a)) c = e;
                  c ? (b = $d(c), this.Te(b, !0)) : $m(this);
                } else if (this.g && this.g.audioTracks) {
                  e = Array.from(this.g.audioTracks);
                  a = od(a);
                  d = c = null;
                  e = r(e);
                  for (var f = e.next(); !f.done; f = e.next()) {
                    f = f.value;
                    var g = ge(f);
                    od(g.language) == a && (c = f, b ? g.roles.includes(b) && (d = f) : 0 == g.roles.length && (d = f));
                  }
                  d ? bn(this, d) : c && bn(this, c);
                }
              };
              q.he = function (a, b, c) {
                c = void 0 === c ? !1 : c;
                if (this.i && this.B) {
                  if (this.vb = a, this.cc = b || "", this.$b = c, (a = je(this.i.textStreams, this.vb, this.cc, this.$b)[0] || null) && a != this.j.o && (Ml(this.o.h, a, !1), this.h.streaming.alwaysStreamText || this.Hd())) pk(this.j, a), an(this);
                } else {
                  var d = od(a);
                  (a = this.Fb().find(function (e) {
                    return od(e.language) == d && (!b || e.roles.includes(b)) && e.forced == c;
                  })) && this.Se(a);
                }
              };
              q.tg = function (a) {
                if (this.i && this.B) {
                  for (var b = null, c = r(this.i.variants), d = c.next(); !d.done; d = c.next()) if (d = d.value, d.audio.label == a) {
                    b = d;
                    break;
                  }
                  null != b && (this.ub = new Ae(b.language, "", 0, a), $m(this));
                }
              };
              q.Hd = function () {
                var a = this.ca;
                return this.G ? this.G.m.isTextVisible() : this.g && this.g.src && this.g.textTracks ? Tm(this).some(function (b) {
                  return "showing" == b.mode;
                }) : a;
              };
              q.He = function () {
                return this.g && this.g.src && this.g.textTracks ? en(this).map(function (a) {
                  return ee(a);
                }) : [];
              };
              q.Cf = function (a) {
                var b = od(a),
                  c = en(this).filter(function (h) {
                    return od(h.language) == b;
                  });
                if (!c || !c.length) return [];
                a = [];
                var d = new Set();
                c = r(c);
                for (var e = c.next(); !e.done; e = c.next()) if ((e = e.value) && e.cues) {
                  e = r(e.cues);
                  for (var f = e.next(); !f.done; f = e.next()) {
                    var g = f.value;
                    (f = g.id) && "" != f || (f = g.startTime + "-" + g.endTime + "-" + g.text);
                    g = {
                      id: f,
                      title: g.text,
                      startTime: g.startTime,
                      endTime: g.endTime
                    };
                    d.has(f) || (a.push(g), d.add(f));
                  }
                }
                return a;
              };
              function Tm(a) {
                return Array.from(a.g.textTracks).filter(function (b) {
                  return "metadata" != b.kind && "chapters" != b.kind && "Shaka Player TextTrack" != b.label;
                });
              }
              function Wm(a) {
                return Array.from(a.g.textTracks).filter(function (b) {
                  return "metadata" == b.kind;
                });
              }
              function en(a) {
                return Array.from(a.g.textTracks).filter(function (b) {
                  return "chapters" == b.kind;
                });
              }
              q.yg = function (a) {
                a = !!a;
                if (this.ca != a) {
                  this.ca = a;
                  if (this.l == Dm) this.G.m.setTextVisibility(a), this.h.streaming.alwaysStreamText || (a ? this.j.o || (a = je(this.i.textStreams, this.vb, this.cc, this.$b), 0 < a.length && (pk(this.j, a[0]), an(this))) : lk(this.j));else if (this.g && this.g.src && this.g.textTracks) {
                    var b = Tm(this);
                    b = r(b);
                    for (var c = b.next(); !c.done; c = b.next()) c = c.value, "disabled" != c.mode && (c.mode = a ? "showing" : "hidden");
                  }
                  Lm(this);
                }
              };
              q.Of = function () {
                if (!this.U()) return null;
                var a = this.Ga.l,
                  b = 0;
                if (this.B) b = this.B.Ic();else if (a) {
                  if (null == a.startTime) return new Date();
                  b = a.startTime;
                }
                return this.i ? new Date(1E3 * (this.i.presentationTimeline.i + b)) : this.g && this.g.getStartDate ? (a = this.g.getStartDate(), isNaN(a.getTime()) ? null : new Date(a.getTime() + 1E3 * b)) : null;
              };
              q.Ie = function () {
                if (!this.U()) return null;
                if (this.i) return new Date(1E3 * this.i.presentationTimeline.i);
                if (this.g && this.g.getStartDate) {
                  var a = this.g.getStartDate();
                  return isNaN(a.getTime()) ? null : a;
                }
                return null;
              };
              q.Na = function () {
                if (this.l == Dm) return this.G.Na();
                var a = {
                  total: [],
                  audio: [],
                  video: [],
                  text: []
                };
                this.l == Rm && (a.total = xi(this.g.buffered));
                return a;
              };
              q.getStats = function () {
                if (this.l != Dm && this.l != Rm) return {
                  width: NaN,
                  height: NaN,
                  streamBandwidth: NaN,
                  decodedFrames: NaN,
                  droppedFrames: NaN,
                  corruptedFrames: NaN,
                  stallsDetected: NaN,
                  gapsJumped: NaN,
                  estimatedBandwidth: NaN,
                  completionPercent: NaN,
                  loadLatency: NaN,
                  manifestTimeSeconds: NaN,
                  drmTimeSeconds: NaN,
                  playTime: NaN,
                  pauseTime: NaN,
                  bufferingTime: NaN,
                  licenseTime: NaN,
                  liveLatency: NaN,
                  maxSegmentDuration: NaN,
                  switchHistory: [],
                  stateHistory: []
                };
                ym(this);
                var a = this.g,
                  b = a.currentTime / a.duration;
                if (!isNaN(b)) {
                  var c = this.o;
                  b = Math.round(100 * b);
                  c.i = isNaN(c.i) ? b : Math.max(c.i, b);
                }
                this.B && (this.o.M = this.B.te(), this.o.O = this.B.ue());
                if (a.getVideoPlaybackQuality) {
                  c = a.getVideoPlaybackQuality();
                  b = this.o;
                  var d = Number(c.totalVideoFrames);
                  b.L = Number(c.droppedVideoFrames);
                  b.J = d;
                  this.o.H = Number(c.corruptedVideoFrames);
                }
                this.m ? (c = this.m, c = c.H ? c.H : NaN) : c = NaN;
                this.o.s = c;
                if (this.l == Dm) {
                  if (c = this.j.l) this.o.B = (this.H ? this.H.i : 1) * c.bandwidth;
                  c && c.video && (b = this.o, d = c.video.height || NaN, b.o = c.video.width || NaN, b.l = d);
                  this.U() && (c = this.Ie().valueOf() + 1E3 * this.uc().end, this.o.D = (Date.now() - c) / 1E3);
                  this.i && this.i.presentationTimeline && (this.o.G = this.i.presentationTimeline.g);
                  c = this.u.getBandwidthEstimate();
                  this.o.u = c;
                }
                this.l == Rm && (c = this.o, b = a.videoHeight || NaN, c.o = a.videoWidth || NaN, c.l = b);
                var e = this.o;
                a = e.o;
                c = e.l;
                b = e.B;
                d = e.J;
                var f = e.L,
                  g = e.H,
                  h = e.O,
                  k = e.M,
                  l = e.u,
                  m = e.i,
                  n = e.m,
                  p = e.F,
                  t = e.j,
                  v = Jl(e.g, "playing"),
                  y = Jl(e.g, "paused"),
                  w = Jl(e.g, "buffering"),
                  x = e.s,
                  C = e.D,
                  z = e.G,
                  B = Kl(e.g),
                  E = [];
                e = r(e.h.g);
                for (var F = e.next(); !F.done; F = e.next()) F = F.value, E.push({
                  timestamp: F.timestamp,
                  id: F.id,
                  type: F.type,
                  fromAdaptation: F.fromAdaptation,
                  bandwidth: F.bandwidth
                });
                return {
                  width: a,
                  height: c,
                  streamBandwidth: b,
                  decodedFrames: d,
                  droppedFrames: f,
                  corruptedFrames: g,
                  stallsDetected: h,
                  gapsJumped: k,
                  estimatedBandwidth: l,
                  completionPercent: m,
                  loadLatency: n,
                  manifestTimeSeconds: p,
                  drmTimeSeconds: t,
                  playTime: v,
                  pauseTime: y,
                  bufferingTime: w,
                  licenseTime: x,
                  liveLatency: C,
                  maxSegmentDuration: z,
                  stateHistory: B,
                  switchHistory: E
                };
              };
              q.hf = function (a, b, c, d, e, f, g) {
                g = void 0 === g ? !1 : g;
                var h = this,
                  k,
                  l,
                  m,
                  n,
                  p,
                  t,
                  v,
                  y,
                  w,
                  x,
                  C;
                return G(function (z) {
                  switch (z.g) {
                    case 1:
                      if (h.l != Dm && h.l != Rm) throw new O(1, 7, 7004);
                      if (d) {
                        z.A(2);
                        break;
                      }
                      return u(z, fn(h, a), 3);
                    case 3:
                      d = z.h;
                    case 2:
                      k = [];
                      if (h.F) try {
                        k = h.F.getServerSideCuePoints();
                      } catch (B) {}
                      if (h.l != Rm) {
                        z.A(4);
                        break;
                      }
                      g && (c = "forced");
                      return u(z, gn(h, a, b, c, d, f || "", k), 5);
                    case 5:
                      l = h.Fb();
                      if (m = l.find(function (B) {
                        return B.language == b && B.label == (f || "") && B.kind == c;
                      })) return Om(h), z.return(m);
                      throw new O(1, 2, 2012);
                    case 4:
                      n = kc;
                      p = h.i.presentationTimeline.getDuration();
                      if (Infinity == p) throw new O(1, 4, 4033);
                      if (!k.length) {
                        z.A(6);
                        break;
                      }
                      return u(z, hn(h, a, h.D, h.h.streaming.retryParameters), 7);
                    case 7:
                      t = z.h, v = jn(h, t, d, k), y = new Blob([v], {
                        type: "text/vtt"
                      }), a = Pi(y), d = "text/vtt";
                    case 6:
                      w = {
                        id: h.Yd++,
                        originalId: null,
                        createSegmentIndex: function createSegmentIndex() {
                          return Promise.resolve();
                        },
                        segmentIndex: Mj(0, p, [a]),
                        mimeType: d || "",
                        codecs: e || "",
                        kind: c,
                        encrypted: !1,
                        drmInfos: [],
                        keyIds: new Set(),
                        language: b,
                        label: f || null,
                        type: n.X,
                        primary: !1,
                        trickModeVideo: null,
                        emsgSchemeIdUris: null,
                        roles: [],
                        forced: !!g,
                        channelsCount: null,
                        audioSamplingRate: null,
                        spatialAudio: !1,
                        closedCaptions: null
                      };
                      x = Zc(w.mimeType, w.codecs);
                      C = ed(x);
                      if (!C) throw new O(2, 2, 2014, d);
                      h.i.textStreams.push(w);
                      Om(h);
                      return z.return(ae(w));
                  }
                });
              };
              q.jf = function (a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l,
                  m,
                  n,
                  p,
                  t,
                  v,
                  y,
                  w,
                  x,
                  C;
                return G(function (z) {
                  switch (z.g) {
                    case 1:
                      if (c.l != Dm && c.l != Rm) throw new O(1, 7, 7004);
                      if (c.l == Rm) throw new O(1, 2, 2016);
                      if (b) {
                        z.A(2);
                        break;
                      }
                      return u(z, fn(c, a), 3);
                    case 3:
                      b = z.h;
                    case 2:
                      if ("text/vtt" != b) throw new O(1, 2, 2017, a);
                      d = kc;
                      e = c.i.presentationTimeline.getDuration();
                      if (Infinity == e) throw new O(1, 4, 4045);
                      return u(z, hn(c, a, c.D, c.h.streaming.retryParameters), 4);
                    case 4:
                      f = z.h;
                      g = fd[b];
                      if (!g) throw new O(2, 2, 2014, b);
                      h = g();
                      k = {
                        periodStart: 0,
                        segmentStart: 0,
                        segmentEnd: e,
                        vttOffset: 0
                      };
                      l = M(f);
                      m = h.parseMedia(l, k);
                      n = [];
                      p = {};
                      t = r(m);
                      for (v = t.next(); !v.done; p = {
                        Rb: p.Rb
                      }, v = t.next()) y = v.value, p.Rb = ec([a], [y.payload])[0], w = new qi(y.startTime, y.endTime, function (B) {
                        return function () {
                          return [B.Rb];
                        };
                      }(p), 0, null, null, 0, 0, Infinity), p.Rb.includes("#xywh") && (x = p.Rb.split("#xywh=")[1].split(","), 4 === x.length && w.Ye({
                        height: parseInt(x[3], 10),
                        positionX: parseInt(x[0], 10),
                        positionY: parseInt(x[1], 10),
                        width: parseInt(x[2], 10)
                      })), n.push(w);
                      C = {
                        id: c.Yd++,
                        originalId: null,
                        createSegmentIndex: function createSegmentIndex() {
                          return Promise.resolve();
                        },
                        segmentIndex: new Jj(n),
                        mimeType: b || "",
                        codecs: "",
                        kind: "",
                        encrypted: !1,
                        drmInfos: [],
                        keyIds: new Set(),
                        language: "und",
                        label: null,
                        type: d.Wb,
                        primary: !1,
                        trickModeVideo: null,
                        emsgSchemeIdUris: null,
                        roles: [],
                        forced: !1,
                        channelsCount: null,
                        audioSamplingRate: null,
                        spatialAudio: !1,
                        closedCaptions: null,
                        tilesLayout: "1x1"
                      };
                      c.i.imageStreams.push(C);
                      Om(c);
                      return z.return(be(C));
                  }
                });
              };
              q.gf = function (a, b, c) {
                var d = this,
                  e,
                  f,
                  g,
                  h;
                return G(function (k) {
                  switch (k.g) {
                    case 1:
                      if (d.l != Dm && d.l != Rm) throw new O(1, 7, 7004);
                      if (c) {
                        k.A(2);
                        break;
                      }
                      return u(k, fn(d, a), 3);
                    case 3:
                      c = k.h;
                    case 2:
                      e = [];
                      if (d.F) try {
                        e = d.F.getServerSideCuePoints();
                      } catch (l) {}
                      return u(k, gn(d, a, b, "chapters", c, "", e), 4);
                    case 4:
                      f = k.h;
                      g = d.He();
                      h = g.find(function (l) {
                        return l.language == b;
                      });
                      if (!h) {
                        k.A(5);
                        break;
                      }
                      return u(k, new Promise(function (l, m) {
                        d.s.ma(f, "load", l);
                        d.s.ma(f, "error", function () {
                          m(new O(1, 2, 2015));
                        });
                      }), 6);
                    case 6:
                      return k.return(h);
                    case 5:
                      throw new O(1, 2, 2012);
                  }
                });
              };
              function fn(a, b) {
                var c, d;
                return G(function (e) {
                  switch (e.g) {
                    case 1:
                      c = Ug(b);
                      if (d = kn[c]) return e.return(d);
                      D(e, 2);
                      return u(e, Wg(b, a.D, a.h.streaming.retryParameters), 4);
                    case 4:
                      d = e.h;
                      ta(e, 3);
                      break;
                    case 2:
                      ua(e);
                    case 3:
                      if (d) return e.return(d);
                      throw new O(1, 2, 2011, c);
                  }
                });
              }
              function gn(a, b, c, d, e, f, g) {
                var h, k, l, m;
                return G(function (n) {
                  if (1 == n.g) return "text/vtt" != e || g.length ? u(n, hn(a, b, a.D, a.h.streaming.retryParameters), 3) : n.A(2);
                  2 != n.g && (h = n.h, k = jn(a, h, e, g), l = new Blob([k], {
                    type: "text/vtt"
                  }), b = Pi(l), e = "text/vtt");
                  m = document.createElement("track");
                  var p = a.V,
                    t = b;
                  try {
                    if (p.g.enabled) {
                      var v = pl(p);
                      v.ot = vl;
                      v.su = !0;
                      var y = rl(v);
                      var w = sl(t, y);
                    } else w = t;
                  } catch (x) {
                    Xa("CMCD_TEXT_TRACK_ERROR", "Could not generate text track CMCD data.", x), w = t;
                  }
                  m.src = w;
                  m.label = f;
                  m.kind = d;
                  m.srclang = c;
                  a.g.getAttribute("crossorigin") || a.g.setAttribute("crossorigin", "anonymous");
                  a.g.appendChild(m);
                  return n.return(m);
                });
              }
              function hn(a, b, c, d) {
                var e, f, g;
                return G(function (h) {
                  if (1 == h.g) {
                    e = jf;
                    f = cf([b], d);
                    f.method = "GET";
                    var k = a.V;
                    try {
                      k.g.enabled && nl(k, f, {
                        ot: vl,
                        su: !0
                      });
                    } catch (l) {
                      Xa("CMCD_TEXT_ERROR", "Could not generate text CMCD data.", l);
                    }
                    return u(h, c.request(e, f).promise, 2);
                  }
                  g = h.h;
                  return h.return(g.data);
                });
              }
              function jn(a, b, c, d) {
                var e = fd[c];
                if (e) return c = e(), a = {
                  periodStart: 0,
                  segmentStart: 0,
                  segmentEnd: a.g.duration,
                  vttOffset: 0
                }, b = M(b), b = c.parseMedia(b, a), bl(b, d);
                throw new O(2, 2, 2014, c);
              }
              q.ke = function (a, b) {
                this.ec.width = a;
                this.ec.height = b;
              };
              q.ce = function (a) {
                if (this.l == Dm) {
                  var b = this.j;
                  a = void 0 === a ? .1 : a;
                  if (b.h.g) b = !1;else if (b.s) b = !1;else {
                    for (var c = r(b.j.values()), d = c.next(); !d.done; d = c.next()) d = d.value, !d.nc || d.ra || d.Ka || (d.nc = !1, kk(b, d, a));
                    b = !0;
                  }
                } else b = !1;
                return b;
              };
              q.If = function () {
                Wa("Shaka Player's internal Manifest structure is NOT covered by semantic versioning compatibility guarantees.  It may change at any time!  Please consider filing a feature request for whatever you use getManifest() for.");
                return this.i;
              };
              q.Jf = function () {
                return this.Yc;
              };
              function Pl(a) {
                var b = El();
                b.streaming.failureCallback = function (c) {
                  if (a.U()) {
                    var d = null;
                    1001 == c.code || 1002 == c.code ? d = 1 : 1003 == c.code && (d = .1);
                    null != d && (c.severity = 1, a.ce(d));
                  }
                };
                b.textDisplayFactory = function () {
                  return a.Uc ? new Uk(a.g, a.Uc) : new Pk(a.g);
                };
                return b;
              }
              q.$e = function (a) {
                this.Uc = a;
              };
              function sm(a, b) {
                for (var c = new Set(), d = r(b.textStreams), e = d.next(); !e.done; e = d.next()) e = e.value, "application/cea-608" != e.mimeType && "application/cea-708" != e.mimeType || c.add(e.originalId);
                d = r(b.variants);
                for (e = d.next(); !e.done; e = d.next()) if ((e = e.value.video) && e.closedCaptions) for (var f = r(e.closedCaptions.keys()), g = f.next(); !g.done; g = f.next()) if (g = g.value, !c.has(g)) {
                  var h = g.startsWith("CC") ? "application/cea-608" : "application/cea-708",
                    k = new Nj();
                  h = {
                    id: a.Yd++,
                    originalId: g,
                    createSegmentIndex: function createSegmentIndex() {
                      return Promise.resolve();
                    },
                    segmentIndex: k,
                    mimeType: h,
                    codecs: "",
                    kind: "caption",
                    encrypted: !1,
                    drmInfos: [],
                    keyIds: new Set(),
                    language: e.closedCaptions.get(g),
                    label: null,
                    type: jc,
                    primary: !1,
                    trickModeVideo: null,
                    emsgSchemeIdUris: null,
                    roles: e.roles,
                    forced: !1,
                    channelsCount: null,
                    audioSamplingRate: null,
                    spatialAudio: !1,
                    closedCaptions: null
                  };
                  b.textStreams.push(h);
                  c.add(g);
                }
              }
              function rm(a, b) {
                return G(function (c) {
                  if (1 == c.g) return u(c, ln(a, b), 2);
                  Zm(a, b);
                  A(c);
                });
              }
              function ln(a, b) {
                var c;
                return G(function (d) {
                  if (1 == d.g) return c = a.j ? a.j.l : null, u(d, Md(c, b), 2);
                  Nm(b);
                  A(d);
                });
              }
              function Zm(a, b) {
                if (a.l != gm) {
                  Ld(b.variants, a.h.restrictions, a.ec) && a.j && Om(a);
                  var c = a.m ? a.m.g : null;
                  if (c && a.m.u) for (var d = r(b.variants), e = d.next(); !e.done; e = d.next()) e = e.value, tm(a, c.keySystem, e.video), tm(a, c.keySystem, e.audio);
                  mn(a, b);
                }
              }
              function tm(a, b, c) {
                if (c) {
                  c = r(c.drmInfos);
                  for (var d = c.next(); !d.done; d = c.next()) if (d = d.value, d.keySystem == b) {
                    d = r(d.initData || []);
                    for (var e = d.next(); !e.done; e = d.next()) e = e.value, vg(a.m, e.initDataType, e.initData);
                  }
                }
              }
              function Im(a, b) {
                var c, d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) return c = a.audio, d = a.video, e = function e(k, l) {
                    var m, n, p;
                    return G(function (t) {
                      if (1 == t.g) return k ? u(t, k.createSegmentIndex(), 2) : t.return(null);
                      n = (m = k.segmentIndex.Cb(l)) ? m.next().value : null;
                      if (!n) return t.return(null);
                      p = n.startTime;
                      return t.return(p);
                    });
                  }, u(h, e(c, b), 2);
                  if (3 != h.g) return f = h.h, u(h, e(d, b), 3);
                  g = h.h;
                  return null != g && null != f ? h.return(Math.max(g, f)) : null != g ? h.return(g) : null != f ? h.return(f) : h.return(b);
                });
              }
              function nm(a) {
                var b = a.Fd();
                if (a.o && a.M && a.B) {
                  var c = a.H;
                  c.j = b;
                  Pj(c);
                  a.V && (c = a.V, b || c.i || (c.i = !0), c.i && b && (c.l = !0), c.m = b);
                  ym(a);
                }
                b = new Map().set("buffering", b);
                a.dispatchEvent(bm("buffering", b));
              }
              function zm(a) {
                var b = a.g.playbackRate;
                0 != b && (a.H && a.H.set(b), b = bm("ratechange"), a.dispatchEvent(b));
              }
              function ym(a) {
                if (a.o && a.M) {
                  var b = a.o.g;
                  a.M.g == Ge ? Il(b, "buffering") : a.g.paused ? Il(b, "paused") : a.g.ended ? Il(b, "ended") : Il(b, "playing");
                }
              }
              function Pm(a) {
                try {
                  mn(a, a.i);
                } catch (c) {
                  return mm(a, c), !1;
                }
                var b = a.i.variants.filter(function (c) {
                  return he(c);
                });
                b = a.ub.create(b);
                a.u.setVariants(Array.from(b.values()));
                return !0;
              }
              function cm(a) {
                return Pm(a) ? a.u.chooseVariant() : null;
              }
              function $m(a) {
                var b = cm(a);
                b && Bm(a, b, !0, !0, 0);
              }
              function Bm(a, b, c, d, e) {
                var f = a.j.l;
                if (b == f) d && ok(a.j, b, d, e, !0);else {
                  var g = a.o.h;
                  g.h != b && (g.h = b, g.g.push({
                    timestamp: Date.now() / 1E3,
                    id: b.id,
                    type: "variant",
                    fromAdaptation: c,
                    bandwidth: b.bandwidth
                  }));
                  ok(a.j, b, d, e, void 0, c);
                  d = null;
                  f && (d = $d(f));
                  b = $d(b);
                  c ? Jm(a, d, b) : nn(a, d, b);
                }
              }
              function bn(a, b) {
                var c = Array.from(a.g.audioTracks).find(function (d) {
                  return d.enabled;
                });
                b.enabled = !0;
                b.id !== c.id && (c.enabled = !1);
                c = ge(c);
                b = ge(b);
                nn(a, c, b);
              }
              function Km(a, b, c) {
                if (0 == a.h.autoShowText) return !1;
                if (1 == a.h.autoShowText) return !0;
                var d = od(a.h.preferredTextLanguage);
                c = od(c.language);
                if (2 == a.h.autoShowText) return nd(c, d);
                if (3 == a.h.autoShowText) return a = od(b.language), nd(c, d) && !nd(a, c);
                Wa("Invalid autoShowText setting!");
                return !1;
              }
              function Jm(a, b, c) {
                b = new Map().set("oldTrack", b).set("newTrack", c);
                a.L && Ii(a.L, c);
                c = bm("adaptation", b);
                on(a, c);
              }
              function Om(a) {
                var b = bm("trackschanged");
                on(a, b);
              }
              function nn(a, b, c) {
                b = new Map().set("oldTrack", b).set("newTrack", c);
                a.L && Ii(a.L, c);
                c = bm("variantchanged", b);
                on(a, c);
              }
              function an(a) {
                var b = bm("textchanged");
                on(a, b);
              }
              function Lm(a) {
                var b = bm("texttrackvisibility");
                on(a, b);
              }
              function Mm(a) {
                var b = new Map().set("newStatus", a.h.abr.enabled);
                on(a, bm("abrstatuschanged", b));
              }
              function pn(a, b) {
                if (1002 != b.code && 1011 != b.code || 1 != b.category || !navigator.onLine) return !1;
                var c = a.h.streaming.maxDisabledTime;
                if (0 == c) if (1011 == b.code) c = 1;else return !1;
                b = a.Xa().find(function (g) {
                  return g.active;
                });
                for (var d = a.i, e = r(d.variants), f = e.next(); !f.done; f = e.next()) f = f.value, f.id === b.id && (f.disabledUntilTime = Date.now() / 1E3 + c);
                Ld(d.variants, a.h.restrictions, a.ec);
                b = cm(a);
                if (!b) return !1;
                d = a.Na().video.reduce(function (g, h) {
                  return g + h.end - h.start;
                }, 0);
                Bm(a, b, !1, !0, d);
                a.af.N(c);
                return !0;
              }
              function mm(a, b) {
                if (a.l != gm) if (pn(a, b)) b.handled = !0;else {
                  var c = bm("error", new Map().set("detail", b));
                  a.dispatchEvent(c);
                  c.defaultPrevented && (b.handled = !0);
                }
              }
              function qm(a, b, c) {
                c = new Map().set("detail", {
                  schemeIdUri: c.schemeIdUri,
                  value: c.value,
                  startTime: c.startTime,
                  endTime: c.endTime,
                  id: c.id,
                  eventElement: c.eventElement
                });
                a.dispatchEvent(bm(b, c));
              }
              function lm(a) {
                if (!a.g.error) return null;
                var b = a.g.error.code;
                if (1 == b) return null;
                var c = a.g.error.msExtendedCode;
                c && (0 > c && (c += Math.pow(2, 32)), c = c.toString(16));
                return new O(2, 3, 3016, b, c, a.g.error.message);
              }
              function wm(a, b) {
                if (a.j) {
                  var c = Object.keys(b),
                    d = 1 == c.length && "00" == c[0],
                    e = !1;
                  if (c.length) {
                    c = r(a.i.variants);
                    for (var f = c.next(); !f.done; f = c.next()) {
                      f = f.value;
                      var g = [];
                      f.audio && g.push(f.audio);
                      f.video && g.push(f.video);
                      g = r(g);
                      for (var h = g.next(); !h.done; h = g.next()) {
                        var k = h.value;
                        h = f.allowedByKeySystem;
                        if (k.keyIds.size) {
                          f.allowedByKeySystem = !0;
                          k = r(k.keyIds);
                          for (var l = k.next(); !l.done; l = k.next()) l = l.value, l = b[d ? "00" : l], f.allowedByKeySystem = f.allowedByKeySystem && !!l && !qn.includes(l);
                        }
                        h != f.allowedByKeySystem && (e = !0);
                      }
                    }
                  }
                  if (!e || Pm(a)) (b = a.j.l) && !b.allowedByKeySystem && $m(a), e && Om(a);
                }
              }
              function xm(a, b, c) {
                if (a.J && a.J.onExpirationUpdated) a.J.onExpirationUpdated(b, c);
                b = bm("expirationupdated");
                a.dispatchEvent(b);
              }
              function Am(a, b, c) {
                0 < b && (a.U() || a.Ze(b));
                b = a.getDuration();
                c < b && (a.U() || a.Aa(c));
              }
              function mn(a, b) {
                a = a.m ? a.m.Qc() : {};
                var c = Object.keys(a);
                c = c.length && "00" == c[0];
                var d = !1,
                  e = !1,
                  f = new Set(),
                  g = new Set();
                b = r(b.variants);
                for (var h = b.next(); !h.done; h = b.next()) {
                  h = h.value;
                  var k = [];
                  h.audio && k.push(h.audio);
                  h.video && k.push(h.video);
                  k = r(k);
                  for (var l = k.next(); !l.done; l = k.next()) if (l = l.value, l.keyIds.size) {
                    l = r(l.keyIds);
                    for (var m = l.next(); !m.done; m = l.next()) {
                      m = m.value;
                      var n = a[c ? "00" : m];
                      n ? qn.includes(n) && g.add(n) : f.add(m);
                    }
                  }
                  h.allowedByApplication ? h.allowedByKeySystem && (d = !0) : e = !0;
                }
                if (!d) throw a = {
                  hasAppRestrictions: e,
                  missingKeys: Array.from(f),
                  restrictedKeyStatuses: Array.from(g)
                }, new O(2, 4, 4012, a);
              }
              function Nm(a) {
                if (!a.variants.some(he)) throw new O(2, 4, 4032);
              }
              function on(a, b) {
                G(function (c) {
                  if (1 == c.g) return u(c, Promise.resolve(), 2);
                  a.l != gm && a.dispatchEvent(b);
                  A(c);
                });
              }
              function dn(a) {
                var b = new Set();
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) c = c.value, c.language ? b.add(od(c.language)) : b.add("und");
                return b;
              }
              function cn(a) {
                var b = new Map(),
                  c = new Map();
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) {
                  d = d.value;
                  var e = "und",
                    f = [];
                  d.language && (e = od(d.language));
                  "variant" == d.type ? f = d.audioRoles : f = d.roles;
                  f && f.length || (f = [""]);
                  b.has(e) || b.set(e, new Set());
                  f = r(f);
                  for (var g = f.next(); !g.done; g = f.next()) g = g.value, b.get(e).add(g), d.label && (c.has(e) || c.set(e, new Map()), c.get(e).set(g, d.label));
                }
                var h = [];
                b.forEach(function (k, l) {
                  k = r(k);
                  for (var m = k.next(); !m.done; m = k.next()) {
                    m = m.value;
                    var n = null;
                    c.has(l) && c.get(l).has(m) && (n = c.get(l).get(m));
                    h.push({
                      language: l,
                      role: m,
                      label: n
                    });
                  }
                });
                return h;
              }
              function hm() {
                return new O(2, 7, 7E3);
              }
              function am(a, b, c, d, e, f) {
                return d == a && e.mediaElement == f.mediaElement && e.uri == f.uri && e.mimeType == f.mimeType ? b : c;
              }
              function Hk() {
                return {
                  mediaElement: null,
                  mimeType: null,
                  startTime: null,
                  ne: NaN,
                  uri: null
                };
              }
              function im(a) {
                return new Promise(function (b, c) {
                  a.mb = function () {
                    return c(hm());
                  };
                  a.bd = function () {
                    return b();
                  };
                  a.onError = function (d) {
                    return c(d);
                  };
                  a.dd = function () {
                    return c(hm());
                  };
                });
              }
              K("shaka.Player", V);
              V.prototype.setVideoContainer = V.prototype.$e;
              V.prototype.getManifestParserFactory = V.prototype.Jf;
              V.prototype.getManifest = V.prototype.If;
              V.prototype.retryStreaming = V.prototype.ce;
              V.prototype.setMaxHardwareResolution = V.prototype.ke;
              V.prototype.addChaptersTrack = V.prototype.gf;
              V.prototype.addThumbnailsTrack = V.prototype.jf;
              V.prototype.addTextTrackAsync = V.prototype.hf;
              V.prototype.getStats = V.prototype.getStats;
              V.prototype.getBufferedInfo = V.prototype.Na;
              V.prototype.getPresentationStartTimeAsDate = V.prototype.Ie;
              V.prototype.getPlayheadTimeAsDate = V.prototype.Of;
              V.prototype.setTextTrackVisibility = V.prototype.yg;
              V.prototype.getChapters = V.prototype.Cf;
              V.prototype.getChaptersTracks = V.prototype.He;
              V.prototype.isTextTrackVisible = V.prototype.Hd;
              V.prototype.selectVariantsByLabel = V.prototype.tg;
              V.prototype.selectTextLanguage = V.prototype.he;
              V.prototype.selectAudioLanguage = V.prototype.ge;
              V.prototype.getTextLanguages = V.prototype.Qf;
              V.prototype.getAudioLanguages = V.prototype.zf;
              V.prototype.getTextLanguagesAndRoles = V.prototype.Rf;
              V.prototype.getAudioLanguagesAndRoles = V.prototype.Af;
              V.prototype.selectVariantTrack = V.prototype.Te;
              V.prototype.selectTextTrack = V.prototype.Se;
              V.prototype.getThumbnails = V.prototype.Tf;
              V.prototype.getImageTracks = V.prototype.Ff;
              V.prototype.getTextTracks = V.prototype.Fb;
              V.prototype.getVariantTracks = V.prototype.Xa;
              V.prototype.cancelTrickPlay = V.prototype.pf;
              V.prototype.trickPlay = V.prototype.Ag;
              V.prototype.getPlaybackRate = V.prototype.Rc;
              V.prototype.isBuffering = V.prototype.Fd;
              V.prototype.getKeyStatuses = V.prototype.Qc;
              V.prototype.getExpiration = V.prototype.ic;
              V.prototype.drmInfo = V.prototype.drmInfo;
              V.prototype.keySystem = V.prototype.keySystem;
              V.prototype.goToLive = V.prototype.Xf;
              V.prototype.seekRange = V.prototype.uc;
              V.prototype.isAudioOnly = V.prototype.Zf;
              V.prototype.isInProgress = V.prototype.jb;
              V.prototype.isLive = V.prototype.U;
              V.prototype.getAdManager = V.prototype.Ge;
              V.prototype.getAssetUri = V.prototype.Dd;
              V.prototype.getNetworkingEngine = V.prototype.jc;
              V.prototype.getMediaElement = V.prototype.Lf;
              V.prototype.getLoadMode = V.prototype.Hf;
              V.prototype.resetConfiguration = V.prototype.rg;
              V.prototype.getBufferFullness = V.prototype.Bf;
              V.prototype.getConfiguration = V.prototype.getConfiguration;
              V.prototype.configure = V.prototype.configure;
              V.prototype.load = V.prototype.load;
              V.prototype.updateStartTime = V.prototype.Fg;
              V.prototype.unload = V.prototype.re;
              V.prototype.detach = V.prototype.detach;
              V.prototype.attachCanvas = V.prototype.lf;
              V.prototype.attach = V.prototype.Yb;
              V.probeSupport = function (a) {
                a = void 0 === a ? !0 : a;
                var b, c, d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) return b = {}, a ? u(h, Mg(), 3) : h.A(2);
                  2 != h.g && (b = h.h);
                  var k = {};
                  if (oc()) {
                    for (var l in Tg) k[l] = !0;
                    for (var m in Vg) k[m] = !0;
                  }
                  l = {
                    mpd: "application/dash+xml",
                    m3u8: "application/x-mpegurl",
                    ism: "application/vnd.ms-sstr+xml"
                  };
                  m = r(["application/dash+xml", "application/x-mpegurl", "application/vnd.apple.mpegurl", "application/vnd.ms-sstr+xml"]);
                  for (var n = m.next(); !n.done; n = m.next()) n = n.value, k[n] = oc() ? !!Tg[n] : pc(n);
                  for (var p in l) k[p] = oc() ? !!Vg[p] : pc(l[p]);
                  c = k;
                  p = 'video/mp4; codecs="avc1.42E01E",video/mp4; codecs="avc3.42E01E",video/mp4; codecs="hev1.1.6.L93.90",video/mp4; codecs="hvc1.1.6.L93.90",video/mp4; codecs="hev1.2.4.L153.B0"; eotf="smpte2084",video/mp4; codecs="hvc1.2.4.L153.B0"; eotf="smpte2084",video/mp4; codecs="vp9",video/mp4; codecs="vp09.00.10.08",video/mp4; codecs="av01.0.01M.08",audio/mp4; codecs="mp4a.40.2",audio/mp4; codecs="ac-3",audio/mp4; codecs="ec-3",audio/mp4; codecs="opus",audio/mp4; codecs="flac",video/webm; codecs="vp8",video/webm; codecs="vp9",video/webm; codecs="vp09.00.10.08",audio/webm; codecs="vorbis",audio/webm; codecs="opus",video/mp2t; codecs="avc1.42E01E",video/mp2t; codecs="avc3.42E01E",video/mp2t; codecs="hvc1.1.6.L93.90",video/mp2t; codecs="mp4a.40.2",video/mp2t; codecs="ac-3",video/mp2t; codecs="ec-3",text/vtt,application/mp4; codecs="wvtt",application/ttml+xml,application/mp4; codecs="stpp"'.split(",").concat(ha(Yi));
                  k = {};
                  p = r(p);
                  for (l = p.next(); !l.done; l = p.next()) l = l.value, k[l] = oc() ? ed(l) ? !0 : eb(l) || Tc(l) : pc(l), m = l.split(";")[0], k[m] = k[m] || k[l];
                  d = k;
                  e = {
                    manifest: c,
                    media: d,
                    drm: b
                  };
                  f = rn;
                  for (g in f) e[g] = f[g]();
                  return h.return(e);
                });
              };
              V.isBrowserSupported = function () {
                window.Promise || Wa("A Promise implementation or polyfill is required");
                if (!(window.Promise && window.Uint8Array && Array.prototype.forEach) || tc("Trident/")) return !1;
                var a = yc();
                return a && 13 > a || !(window.MediaKeys && window.navigator && window.navigator.requestMediaKeySystemAccess && window.MediaKeySystemAccess && window.MediaKeySystemAccess.prototype.getConfiguration) ? !1 : oc() ? !0 : pc("application/x-mpegurl");
              };
              V.setAdManagerFactory = function (a) {
                Rl = a;
              };
              V.registerSupportPlugin = function (a, b) {
                rn[a] = b;
              };
              V.prototype.destroy = V.prototype.destroy;
              var gm = 0,
                Ol = 1,
                Dm = 2,
                Rm = 3;
              V.LoadMode = {
                DESTROYED: gm,
                NOT_LOADED: Ol,
                MEDIA_SOURCE: Dm,
                SRC_EQUALS: Rm
              };
              V.version = "v4.3.5";
              var sn = ["4", "3"];
              se = new function (a) {
                this.g = a;
                this.i = te;
                this.h = ue;
              }(new qe(Number(sn[0]), Number(sn[1])));
              var qn = ["output-restricted", "internal-error"],
                rn = {},
                Rl = null,
                fm = {
                  mp4: "video/mp4",
                  m4v: "video/mp4",
                  m4a: "audio/mp4",
                  webm: "video/webm",
                  weba: "audio/webm",
                  mkv: "video/webm",
                  ts: "video/mp2t",
                  ogv: "video/ogg",
                  ogg: "audio/ogg",
                  mpg: "video/mpeg",
                  mpeg: "video/mpeg",
                  m3u8: "application/x-mpegurl",
                  mpd: "application/dash+xml",
                  mp3: "audio/mpeg",
                  aac: "audio/aac",
                  flac: "audio/flac",
                  wav: "audio/wav"
                },
                kn = {
                  sbv: "text/x-subviewer",
                  srt: "text/srt",
                  vtt: "text/vtt",
                  webvtt: "text/vtt",
                  ttml: "application/ttml+xml",
                  lrc: "application/x-subtitle-lrc",
                  ssa: "text/x-ssa",
                  ass: "text/x-ssa"
                };
              function tn() {
                this.h = [];
                this.j = this.i = this.g = 0;
              }
              function W(a, b, c) {
                var d = this;
                this.h = a;
                this.g = b;
                this.m = c;
                this.i = !1;
                this.l = this.g.getVolume();
                this.j = new mf();
                this.j.C(this.g, google.ima.AdEvent.Type.PAUSED, function () {
                  d.i = !0;
                });
                this.j.C(this.g, google.ima.AdEvent.Type.RESUMED, function () {
                  d.i = !1;
                });
              }
              q = W.prototype;
              q.getDuration = function () {
                return this.h.getDuration();
              };
              q.getMinSuggestedDuration = function () {
                return this.h.getMinSuggestedDuration();
              };
              q.getRemainingTime = function () {
                return this.g.getRemainingTime();
              };
              q.isPaused = function () {
                return this.i;
              };
              q.isSkippable = function () {
                return 0 <= this.h.getSkipTimeOffset();
              };
              q.getTimeUntilSkippable = function () {
                var a = this.h.getSkipTimeOffset();
                a = this.getRemainingTime() - a;
                return Math.max(a, 0);
              };
              q.canSkipNow = function () {
                return this.g.getAdSkippableState();
              };
              q.skip = function () {
                return this.g.skip();
              };
              q.pause = function () {
                return this.g.pause();
              };
              q.play = function () {
                return this.g.resume();
              };
              q.getVolume = function () {
                return this.g.getVolume();
              };
              q.setVolume = function (a) {
                return this.g.setVolume(a);
              };
              q.isMuted = function () {
                return 0 == this.g.getVolume();
              };
              q.isLinear = function () {
                return this.h.isLinear();
              };
              q.resize = function (a, b) {
                var c = !1,
                  d = this.m;
                document.fullscreenEnabled ? c = !!document.fullscreenElement : d.webkitSupportsFullscreen && (c = d.webkitDisplayingFullscreen);
                this.g.resize(a, b, c ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
              };
              q.setMuted = function (a) {
                a ? (this.l = this.getVolume(), this.setVolume(0)) : this.setVolume(this.l);
              };
              q.getSequenceLength = function () {
                var a = this.h.getAdPodInfo();
                return null == a ? 1 : a.getTotalAds();
              };
              q.getPositionInSequence = function () {
                var a = this.h.getAdPodInfo();
                return null == a ? 1 : a.getAdPosition();
              };
              q.getTitle = function () {
                return this.h.getTitle();
              };
              q.getDescription = function () {
                return this.h.getDescription();
              };
              q.release = function () {
                this.g = this.h = null;
              };
              K("shaka.ads.ClientSideAd", W);
              W.prototype.release = W.prototype.release;
              W.prototype.getDescription = W.prototype.getDescription;
              W.prototype.getTitle = W.prototype.getTitle;
              W.prototype.getPositionInSequence = W.prototype.getPositionInSequence;
              W.prototype.getSequenceLength = W.prototype.getSequenceLength;
              W.prototype.setMuted = W.prototype.setMuted;
              W.prototype.resize = W.prototype.resize;
              W.prototype.isLinear = W.prototype.isLinear;
              W.prototype.isMuted = W.prototype.isMuted;
              W.prototype.setVolume = W.prototype.setVolume;
              W.prototype.getVolume = W.prototype.getVolume;
              W.prototype.play = W.prototype.play;
              W.prototype.pause = W.prototype.pause;
              W.prototype.skip = W.prototype.skip;
              W.prototype.canSkipNow = W.prototype.canSkipNow;
              W.prototype.getTimeUntilSkippable = W.prototype.getTimeUntilSkippable;
              W.prototype.isSkippable = W.prototype.isSkippable;
              W.prototype.isPaused = W.prototype.isPaused;
              W.prototype.getRemainingTime = W.prototype.getRemainingTime;
              W.prototype.getMinSuggestedDuration = W.prototype.getMinSuggestedDuration;
              W.prototype.getDuration = W.prototype.getDuration;
              function un(a, b, c, d) {
                var e = this;
                this.o = a;
                this.i = b;
                this.s = null;
                this.u = NaN;
                this.l = d;
                this.j = null;
                this.h = new mf();
                google.ima.settings.setLocale(c);
                a = new google.ima.AdDisplayContainer(this.o, this.i);
                a.initialize();
                this.m = new google.ima.AdsLoader(a);
                this.m.getSettings().setPlayerType("shaka-player");
                this.m.getSettings().setPlayerVersion("v4.3.5");
                this.g = null;
                this.h.ma(this.m, google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function (f) {
                  vn(e, f);
                });
                this.h.C(this.m, google.ima.AdErrorEvent.Type.AD_ERROR, function (f) {
                  wn(e, f);
                });
                this.h.C(this.i, "ended", function () {
                  e.m.contentComplete();
                });
              }
              un.prototype.stop = function () {
                this.g && this.g.stop();
                this.o && Tk(this.o);
              };
              un.prototype.release = function () {
                this.stop();
                this.s && this.s.disconnect();
                this.h && this.h.release();
                this.g && this.g.destroy();
                this.m.destroy();
              };
              function wn(a, b) {
                b.getError();
                xn(a, null);
                a.l(new S("ad-cue-points-changed", new Map().set("cuepoints", [])));
              }
              function vn(a, b) {
                a.l(new S("ads-loaded", new Map().set("loadTime", Date.now() / 1E3 - a.u)));
                a.g = b.getAdsManager(a.i);
                a.l(new S("ima-ad-manager-loaded", new Map().set("imaAdManager", a.g)));
                var c = a.g.getCuePoints();
                if (c.length) {
                  b = [];
                  c = r(c);
                  for (var d = c.next(); !d.done; d = c.next()) b.push({
                    start: d.value,
                    end: null
                  });
                  a.l(new S("ad-cue-points-changed", new Map().set("cuepoints", b)));
                }
                yn(a);
                try {
                  a.g.init(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL), a.h.C(a.i, "loadeddata", function () {
                    a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
                  }), "ResizeObserver" in window ? (a.s = new ResizeObserver(function () {
                    a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
                  }), a.s.observe(a.i)) : a.h.C(document, "fullscreenchange", function () {
                    a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
                  }), a.i.addEventListener("play", function () {
                    a.g.start();
                  }, {
                    once: !0
                  });
                } catch (e) {
                  xn(a, null);
                }
              }
              function zn(a) {
                if (document.fullscreenEnabled) return !!document.fullscreenElement;
                a = a.i;
                return a.webkitSupportsFullscreen ? a.webkitDisplayingFullscreen : !1;
              }
              function yn(a) {
                function b(c, d) {
                  c = new Map().set("originalEvent", c);
                  a.l(new S(d, c));
                }
                a.h.C(a.g, google.ima.AdErrorEvent.Type.AD_ERROR, function (c) {
                  wn(a, c);
                });
                a.h.C(a.g, google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, function (c) {
                  An(a, c);
                });
                a.h.C(a.g, google.ima.AdEvent.Type.STARTED, function (c) {
                  An(a, c);
                });
                a.h.C(a.g, google.ima.AdEvent.Type.FIRST_QUARTILE, function (c) {
                  b(c, "ad-first-quartile");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.MIDPOINT, function (c) {
                  b(c, "ad-midpoint");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.THIRD_QUARTILE, function (c) {
                  b(c, "ad-third-quartile");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.COMPLETE, function (c) {
                  b(c, "ad-complete");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, function (c) {
                  xn(a, c);
                });
                a.h.C(a.g, google.ima.AdEvent.Type.ALL_ADS_COMPLETED, function (c) {
                  xn(a, c);
                });
                a.h.C(a.g, google.ima.AdEvent.Type.SKIPPED, function (c) {
                  b(c, "ad-skipped");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.VOLUME_CHANGED, function (c) {
                  b(c, "ad-volume-changed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.VOLUME_MUTED, function (c) {
                  b(c, "ad-muted");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.PAUSED, function (c) {
                  a.j && (a.j.i = !0, b(c, "ad-paused"));
                });
                a.h.C(a.g, google.ima.AdEvent.Type.RESUMED, function (c) {
                  a.j && (a.j.i = !1, b(c, "ad-resumed"));
                });
                a.h.C(a.g, google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, function (c) {
                  a.j && b(c, "ad-skip-state-changed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.CLICK, function (c) {
                  b(c, "ad-clicked");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.AD_PROGRESS, function (c) {
                  b(c, "ad-progress");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.AD_BUFFERING, function (c) {
                  b(c, "ad-buffering");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.IMPRESSION, function (c) {
                  b(c, "ad-impression");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.DURATION_CHANGE, function (c) {
                  b(c, "ad-duration-changed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.USER_CLOSE, function (c) {
                  b(c, "ad-closed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.LOADED, function (c) {
                  b(c, "ad-loaded");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.ALL_ADS_COMPLETED, function (c) {
                  b(c, "all-ads-completed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.LINEAR_CHANGED, function (c) {
                  b(c, "ad-linear-changed");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.AD_METADATA, function (c) {
                  b(c, "ad-metadata");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.LOG, function (c) {
                  b(c, "ad-recoverable-error");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.AD_BREAK_READY, function (c) {
                  b(c, "ad-break-ready");
                });
                a.h.C(a.g, google.ima.AdEvent.Type.INTERACTION, function (c) {
                  b(c, "ad-interaction");
                });
              }
              function An(a, b) {
                var c = b.getAd();
                c ? (a.j = new W(c, a.g, a.i), b = new Map().set("ad", a.j).set("sdkAdObject", c).set("originalEvent", b), a.l(new S("ad-started", b)), a.j.isLinear() && (a.o.setAttribute("ad-active", "true"), a.i.pause(), a.j.setVolume(a.i.muted ? 0 : a.i.volume))) : Wa("The IMA SDK fired a " + b.type + " event with no associated ad. Unable to play ad!");
              }
              function xn(a, b) {
                a.l(new S("ad-stopped", new Map().set("originalEvent", b)));
                a.j && a.j.isLinear() && (a.o.removeAttribute("ad-active"), a.i.ended || a.i.play());
              }
              function X(a, b) {
                this.i = a;
                this.h = null;
                this.g = b;
              }
              q = X.prototype;
              q.getDuration = function () {
                return this.h ? this.h.duration : -1;
              };
              q.getMinSuggestedDuration = function () {
                return this.getDuration();
              };
              q.getRemainingTime = function () {
                return this.h ? this.h.duration - this.h.currentTime : -1;
              };
              q.isPaused = function () {
                return this.g.paused;
              };
              q.isSkippable = function () {
                return this.i.isSkippable();
              };
              q.getTimeUntilSkippable = function () {
                var a = this.i.getSkipTimeOffset();
                a = this.getRemainingTime() - a;
                return Math.max(a, 0);
              };
              q.canSkipNow = function () {
                return 0 == this.getTimeUntilSkippable();
              };
              q.skip = function () {
                this.g.currentTime += this.getRemainingTime();
              };
              q.pause = function () {
                return this.g.pause();
              };
              q.play = function () {
                return this.g.play();
              };
              q.getVolume = function () {
                return this.g.volume;
              };
              q.setVolume = function (a) {
                this.g.volume = a;
              };
              q.isMuted = function () {
                return this.g.muted;
              };
              q.isLinear = function () {
                return !0;
              };
              q.resize = function () {};
              q.setMuted = function (a) {
                this.g.muted = a;
              };
              q.getSequenceLength = function () {
                var a = this.i.getAdPodInfo();
                return null == a ? 1 : a.getTotalAds();
              };
              q.getPositionInSequence = function () {
                var a = this.i.getAdPodInfo();
                return null == a ? 1 : a.getAdPosition();
              };
              q.getTitle = function () {
                return this.i.getTitle();
              };
              q.getDescription = function () {
                return this.i.getDescription();
              };
              q.release = function () {
                this.g = this.h = this.i = null;
              };
              K("shaka.ads.ServerSideAd", X);
              X.prototype.release = X.prototype.release;
              X.prototype.getDescription = X.prototype.getDescription;
              X.prototype.getTitle = X.prototype.getTitle;
              X.prototype.getPositionInSequence = X.prototype.getPositionInSequence;
              X.prototype.getSequenceLength = X.prototype.getSequenceLength;
              X.prototype.setMuted = X.prototype.setMuted;
              X.prototype.resize = X.prototype.resize;
              X.prototype.isLinear = X.prototype.isLinear;
              X.prototype.isMuted = X.prototype.isMuted;
              X.prototype.setVolume = X.prototype.setVolume;
              X.prototype.getVolume = X.prototype.getVolume;
              X.prototype.play = X.prototype.play;
              X.prototype.pause = X.prototype.pause;
              X.prototype.skip = X.prototype.skip;
              X.prototype.canSkipNow = X.prototype.canSkipNow;
              X.prototype.getTimeUntilSkippable = X.prototype.getTimeUntilSkippable;
              X.prototype.isSkippable = X.prototype.isSkippable;
              X.prototype.isPaused = X.prototype.isPaused;
              X.prototype.getRemainingTime = X.prototype.getRemainingTime;
              X.prototype.getMinSuggestedDuration = X.prototype.getMinSuggestedDuration;
              X.prototype.getDuration = X.prototype.getDuration;
              function Bn(a, b, c, d) {
                var e = this;
                this.s = a;
                this.l = b;
                this.j = null;
                this.G = NaN;
                this.i = d;
                this.F = !1;
                this.u = this.m = this.o = null;
                this.B = "";
                this.D = [];
                this.h = new mf();
                a = new google.ima.dai.api.UiSettings();
                a.setLocale(c);
                this.g = new google.ima.dai.api.StreamManager(this.l, this.s, a);
                this.i(new S("ima-stream-manager-loaded", new Map().set("imaStreamManager", this.g)));
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.LOADED, function (f) {
                  Cn(e, f);
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.ERROR, function () {
                  e.B.length ? e.j.resolve(e.B) : e.j.reject("IMA Stream request returned an error and there was no backup asset uri provided.");
                  e.j = null;
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, function () {});
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.STARTED, function (f) {
                  f = f.getAd();
                  e.m = new X(f, e.l);
                  e.u && (e.m.h = e.u);
                  e.i(new S("ad-started", new Map().set("ad", e.m)));
                  e.s.setAttribute("ad-active", "true");
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED, function () {
                  e.s.removeAttribute("ad-active");
                  var f = e.l.currentTime;
                  e.o && e.o > f && (e.l.currentTime = e.o, e.o = null);
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_PROGRESS, function (f) {
                  e.u = f.getStreamData().adProgressData;
                  e.m && (e.m.h = e.u);
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.FIRST_QUARTILE, function () {
                  e.i(new S("ad-first-quartile"));
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.MIDPOINT, function () {
                  e.i(new S("ad-midpoint"));
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.THIRD_QUARTILE, function () {
                  e.i(new S("ad-third-quartile"));
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.COMPLETE, function () {
                  e.i(new S("ad-complete"));
                  e.i(new S("ad-stopped"));
                  e.s.removeAttribute("ad-active");
                  e.m = null;
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.SKIPPED, function () {
                  e.i(new S("ad-skipped"));
                  e.i(new S("ad-stopped"));
                });
                this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.CUEPOINTS_CHANGED, function (f) {
                  var g = f.getStreamData();
                  f = [];
                  g = r(g.cuepoints);
                  for (var h = g.next(); !h.done; h = g.next()) h = h.value, f.push({
                    start: h.start,
                    end: h.end
                  });
                  e.D = f;
                  e.i(new S("ad-cue-points-changed", new Map().set("cuepoints", f)));
                });
              }
              Bn.prototype.stop = function () {
                this.B = "";
                this.o = null;
                this.D = [];
              };
              Bn.prototype.release = function () {
                this.stop();
                this.h && this.h.release();
              };
              Bn.prototype.onCueMetadataChange = function (a) {
                if (a.key && a.data) {
                  var b = {};
                  b[a.key] = a.data;
                  this.g.onTimedMetadata(b);
                }
              };
              function Cn(a, b) {
                a.i(new S("ads-loaded", new Map().set("loadTime", Date.now() / 1E3 - a.G)));
                b = b.getStreamData().url;
                a.j.resolve(b);
                a.j = null;
                a.F || a.h.C(a.l, "seeked", function () {
                  var c = a.l.currentTime;
                  if (0 != c) {
                    a.g.streamTimeForContentTime(c);
                    var d = a.g.previousCuePointForStreamTime(c);
                    d && !d.played && (a.o = c, a.l.currentTime = d.start);
                  }
                });
              }
              function Y() {
                Ue.call(this);
                this.g = this.i = null;
                this.h = new tn();
                this.j = navigator.language;
              }
              oa(Y, Ue);
              q = Y.prototype;
              q.setLocale = function (a) {
                this.j = a;
              };
              q.initClientSide = function (a, b) {
                var c = this;
                if (!window.google || !google.ima || !google.ima.AdsLoader) throw new O(2, 10, 1E4);
                this.i && this.i.release();
                this.i = new un(a, b, this.j, function (d) {
                  if (d && d.type) switch (d.type) {
                    case "ads-loaded":
                      c.h.h.push(d.loadTime);
                      break;
                    case "ad-started":
                      c.h.g++;
                      break;
                    case "ad-complete":
                      c.h.i++;
                      break;
                    case "ad-skipped":
                      c.h.j++;
                  }
                  c.dispatchEvent(d);
                });
              };
              q.release = function () {
                this.i && (this.i.release(), this.i = null);
                this.g && (this.g.release(), this.g = null);
                Ue.prototype.release.call(this);
              };
              q.onAssetUnload = function () {
                this.i && this.i.stop();
                this.g && this.g.stop();
                this.dispatchEvent(new S("ad-stopped"));
                this.h = new tn();
              };
              q.requestClientSideAds = function (a) {
                if (!this.i) throw new O(1, 10, 10001);
                var b = this.i;
                b.u = Date.now() / 1E3;
                b.m.requestAds(a);
              };
              q.initServerSide = function (a, b) {
                var c = this;
                if (!window.google || !google.ima || !google.ima.dai) throw new O(2, 10, 10002);
                this.g && this.g.release();
                this.g = new Bn(a, b, this.j, function (d) {
                  if (d && d.type) switch (d.type) {
                    case "ads-loaded":
                      c.h.h.push(d.loadTime);
                      break;
                    case "ad-started":
                      c.h.g++;
                      break;
                    case "ad-complete":
                      c.h.i++;
                      break;
                    case "ad-skipped":
                      c.h.j++;
                  }
                  c.dispatchEvent(d);
                });
              };
              q.requestServerSideStream = function (a, b) {
                b = void 0 === b ? "" : b;
                if (!this.g) throw new O(1, 10, 10003);
                a.adTagParameters || (a.adTagParameters = {});
                var c = a.adTagParameters;
                (c.mpt || c.mpv) && Wa('You have attempted to set "mpt" and/or "mpv" parameters of the ad tag. Please note that those parameters are used for Shaka adoption tracking and will be overriden.');
                a.adTagParameters.mpt = "shaka-player";
                a.adTagParameters.mpv = "v4.3.5";
                c = this.g;
                c.j ? a = Promise.reject(new O(1, 10, 10004)) : (a instanceof google.ima.dai.api.LiveStreamRequest && (c.F = !0), c.j = new lc(), c.g.requestStream(a), c.B = b || "", c.G = Date.now() / 1E3, a = c.j);
                return a;
              };
              q.replaceServerSideAdTagParameters = function (a) {
                if (!this.g) throw new O(1, 10, 10003);
                (a.mpt || a.mpv) && Wa('You have attempted to set "mpt" and/or "mpv" parameters of the ad tag. Please note that those parameters are used for Shaka adoption tracking and will be overriden.');
                a.mpt = "Shaka Player";
                a.mpv = "v4.3.5";
                this.g.g.replaceAdTagParameters(a);
              };
              q.getServerSideCuePoints = function () {
                if (!this.g) throw new O(1, 10, 10003);
                return this.g.D;
              };
              q.getStats = function () {
                var a = this.h;
                return {
                  loadTimes: a.h,
                  started: a.g,
                  playedCompletely: a.i,
                  skipped: a.j
                };
              };
              q.onDashTimedMetadata = function (a) {
                if (this.g && "urn:google:dai:2018" == a.schemeIdUri) {
                  var b = a.schemeIdUri,
                    c = a.eventElement ? a.eventElement.getAttribute("messageData") : null;
                  this.g.g.processMetadata(b, c, a.startTime);
                }
              };
              q.onHlsTimedMetadata = function (a, b) {
                this.g && this.g.g.processMetadata("ID3", a.data, b);
              };
              q.onCueMetadataChange = function (a) {
                if (this.g) this.g.onCueMetadataChange(a);
              };
              K("shaka.ads.AdManager", Y);
              Y.prototype.onCueMetadataChange = Y.prototype.onCueMetadataChange;
              Y.prototype.onHlsTimedMetadata = Y.prototype.onHlsTimedMetadata;
              Y.prototype.onDashTimedMetadata = Y.prototype.onDashTimedMetadata;
              Y.prototype.getStats = Y.prototype.getStats;
              Y.prototype.getServerSideCuePoints = Y.prototype.getServerSideCuePoints;
              Y.prototype.replaceServerSideAdTagParameters = Y.prototype.replaceServerSideAdTagParameters;
              Y.prototype.requestServerSideStream = Y.prototype.requestServerSideStream;
              Y.prototype.initServerSide = Y.prototype.initServerSide;
              Y.prototype.requestClientSideAds = Y.prototype.requestClientSideAds;
              Y.prototype.onAssetUnload = Y.prototype.onAssetUnload;
              Y.prototype.release = Y.prototype.release;
              Y.prototype.initClientSide = Y.prototype.initClientSide;
              Y.prototype.setLocale = Y.prototype.setLocale;
              Y.ADS_LOADED = "ads-loaded";
              Y.AD_STARTED = "ad-started";
              Y.AD_FIRST_QUARTILE = "ad-first-quartile";
              Y.AD_MIDPOINT = "ad-midpoint";
              Y.AD_THIRD_QUARTILE = "ad-third-quartile";
              Y.AD_COMPLETE = "ad-complete";
              Y.AD_STOPPED = "ad-stopped";
              Y.AD_SKIPPED = "ad-skipped";
              Y.AD_VOLUME_CHANGED = "ad-volume-changed";
              Y.AD_MUTED = "ad-muted";
              Y.AD_PAUSED = "ad-paused";
              Y.AD_RESUMED = "ad-resumed";
              Y.AD_SKIP_STATE_CHANGED = "ad-skip-state-changed";
              Y.CUEPOINTS_CHANGED = "ad-cue-points-changed";
              Y.IMA_AD_MANAGER_LOADED = "ima-ad-manager-loaded";
              Y.IMA_STREAM_MANAGER_LOADED = "ima-stream-manager-loaded";
              Y.AD_CLICKED = "ad-clicked";
              Y.AD_PROGRESS = "ad-progress";
              Y.AD_BUFFERING = "ad-buffering";
              Y.AD_IMPRESSION = "ad-impression";
              Y.AD_DURATION_CHANGED = "ad-duration-changed";
              Y.AD_CLOSED = "ad-closed";
              Y.AD_LOADED = "ad-loaded";
              Y.ALL_ADS_COMPLETED = "all-ads-completed";
              Y.AD_LINEAR_CHANGED = "ad-linear-changed";
              Y.AD_METADATA = "ad-metadata";
              Y.AD_RECOVERABLE_ERROR = "ad-recoverable-error";
              Y.AD_BREAK_READY = "ad-break-ready";
              Y.AD_INTERACTION = "ad-interaction";
              Rl = function Rl() {
                return new Y();
              };
              function Dn(a) {
                return JSON.stringify(a, function (b, c) {
                  if ("function" != typeof c) {
                    if (c instanceof Event || c instanceof S) {
                      var d = {};
                      for (e in c) (b = c[e]) && "object" == typeof b ? "detail" == e && (d[e] = b) : e in Event || (d[e] = b);
                      return d;
                    }
                    if (c instanceof Error) {
                      var e = new Set(["name", "message", "stack"]);
                      for (d in c) e.add(d);
                      b = r(Object.getOwnPropertyNames(c));
                      for (d = b.next(); !d.done; d = b.next()) e.add(d.value);
                      b = {};
                      e = r(e);
                      for (d = e.next(); !d.done; d = e.next()) d = d.value, b[d] = c[d];
                      c = {
                        __type__: "Error",
                        contents: b
                      };
                    } else if (c instanceof TimeRanges) {
                      e = {
                        __type__: "TimeRanges",
                        length: c.length,
                        start: [],
                        end: []
                      };
                      c = r(xi(c));
                      for (d = c.next(); !d.done; d = c.next()) d = d.value, b = d.end, e.start.push(d.start), e.end.push(b);
                      c = e;
                    } else c = c instanceof Uint8Array ? {
                      __type__: "Uint8Array",
                      entries: Array.from(c)
                    } : "number" == typeof c ? isNaN(c) ? "NaN" : isFinite(c) ? c : 0 > c ? "-Infinity" : "Infinity" : c;
                    return c;
                  }
                });
              }
              function En(a) {
                return JSON.parse(a, function (b, c) {
                  if ("NaN" == c) var d = NaN;else if ("-Infinity" == c) d = -Infinity;else if ("Infinity" == c) d = Infinity;else if (c && "object" == typeof c && "TimeRanges" == c.__type__) d = Fn(c);else if (c && "object" == typeof c && "Uint8Array" == c.__type__) d = new Uint8Array(c.entries);else if (c && "object" == typeof c && "Error" == c.__type__) {
                    b = c.contents;
                    c = Error(b.message);
                    for (d in b) c[d] = b[d];
                    d = c;
                  } else d = c;
                  return d;
                });
              }
              function Fn(a) {
                return {
                  length: a.length,
                  start: function start(b) {
                    return a.start[b];
                  },
                  end: function end(b) {
                    return a.end[b];
                  }
                };
              }
              var Gn = "ended play playing pause pausing ratechange seeked seeking timeupdate volumechange".split(" "),
                Hn = "buffered currentTime duration ended loop muted paused playbackRate seeking videoHeight videoWidth volume".split(" "),
                In = ["loop", "playbackRate"],
                Jn = ["pause", "play"],
                Kn = {
                  getAssetUri: 2,
                  getAudioLanguages: 4,
                  getAudioLanguagesAndRoles: 4,
                  getBufferFullness: 1,
                  getBufferedInfo: 2,
                  getExpiration: 2,
                  getKeyStatuses: 2,
                  getPlaybackRate: 2,
                  getTextLanguages: 4,
                  getTextLanguagesAndRoles: 4,
                  getImageTracks: 2,
                  getThumbnails: 2,
                  isAudioOnly: 10,
                  isBuffering: 1,
                  isInProgress: 1,
                  isLive: 10,
                  isTextTrackVisible: 1,
                  keySystem: 10,
                  seekRange: 1,
                  getLoadMode: 10
                },
                Ln = {
                  getConfiguration: 4,
                  getStats: 5,
                  getTextTracks: 2,
                  getVariantTracks: 2
                },
                Mn = {
                  getPlayheadTimeAsDate: 1,
                  getPresentationStartTimeAsDate: 20
                },
                Nn = [["getConfiguration", "configure"]],
                On = [["isTextTrackVisible", "setTextTrackVisibility"]],
                Pn = "addChaptersTrack addTextTrackAsync addThumbnailsTrack cancelTrickPlay configure getChapters getChaptersTracks resetConfiguration retryStreaming selectAudioLanguage selectTextLanguage selectTextTrack selectVariantTrack selectVariantsByLabel setTextTrackVisibility trickPlay updateStartTime goToLive".split(" "),
                Qn = ["attach", "attachCanvas", "detach", "load", "unload"];
              function Rn(a, b, c, d, e, f, g) {
                var h = this;
                this.G = a;
                this.M = g;
                this.j = new P(b);
                this.O = c;
                this.u = !1;
                this.s = d;
                this.F = e;
                this.J = f;
                this.h = this.m = !1;
                this.L = "";
                this.o = null;
                this.B = function () {
                  return Sn(h);
                };
                this.D = function (k, l) {
                  k = En(l);
                  switch (k.type) {
                    case "event":
                      var m = k.targetName,
                        n = Se(k.event);
                      h.s(m, n);
                      break;
                    case "update":
                      m = k.update;
                      for (n in m) {
                        k = h.g[n] || {};
                        for (var p in m[n]) k[p] = m[n][p];
                      }
                      h.u && (h.O(), h.u = !1);
                      break;
                    case "asyncComplete":
                      if (n = k.id, p = k.error, k = h.i[n], delete h.i[n], k) if (p) {
                        n = new O(p.severity, p.category, p.code);
                        for (m in p) n[m] = p[m];
                        k.reject(n);
                      } else k.resolve();
                  }
                };
                this.g = {
                  video: {},
                  player: {}
                };
                this.H = 0;
                this.i = {};
                this.l = null;
                Tn.add(this);
              }
              q = Rn.prototype;
              q.destroy = function () {
                Tn.delete(this);
                Un(this);
                Vn && Xn(this);
                this.j && (this.j.stop(), this.j = null);
                this.F = this.s = null;
                this.h = this.m = !1;
                this.D = this.B = this.l = this.i = this.g = this.o = null;
                return Promise.resolve();
              };
              q.sa = function () {
                return this.h;
              };
              q.ae = function () {
                return this.L;
              };
              q.init = function () {
                if (this.G.length) if (window.chrome && chrome.cast && chrome.cast.isAvailable) {
                  this.m = !0;
                  this.j.Mb();
                  var a = new chrome.cast.SessionRequest(this.G, [], null, this.M, null);
                  a = new chrome.cast.ApiConfig(a, function (b) {
                    for (var c = r(Tn), d = c.next(); !d.done; d = c.next()) Yn(d.value, b);
                  }, function (b) {
                    for (var c = r(Tn), d = c.next(); !d.done; d = c.next()) d = d.value, Zn = "available" == b, d.j.Mb();
                  }, "origin_scoped");
                  chrome.cast.initialize(a, function () {}, function () {});
                  Zn && this.j.N($n);
                  (a = Vn) && a.status != chrome.cast.SessionStatus.STOPPED ? Yn(this, a) : Vn = null;
                } else window.__onGCastApiAvailable !== ao && (bo = window.__onGCastApiAvailable || null, window.__onGCastApiAvailable = ao);
              };
              q.ie = function (a) {
                this.o = a;
                this.h && co(this, {
                  type: "appData",
                  appData: this.o
                });
              };
              q.cast = function (a) {
                var b = this;
                return G(function (c) {
                  if (!b.m) throw new O(1, 8, 8E3);
                  if (!Zn) throw new O(1, 8, 8001);
                  if (b.h) throw new O(1, 8, 8002);
                  b.l = new lc();
                  chrome.cast.requestSession(function (d) {
                    return eo(b, a, d);
                  }, function (d) {
                    return fo(b, d);
                  });
                  return u(c, b.l, 0);
                });
              };
              function go(a) {
                if (a.h) {
                  var b = a.J();
                  chrome.cast.requestSession(function (c) {
                    return eo(a, b, c);
                  }, function (c) {
                    return fo(a, c);
                  });
                }
              }
              q.Ab = function () {
                if (this.h) {
                  Un(this);
                  if (Vn) {
                    Xn(this);
                    try {
                      Vn.stop(function () {}, function () {});
                    } catch (a) {}
                    Vn = null;
                  }
                  Sn(this);
                }
              };
              q.get = function (a, b) {
                var c = this;
                if ("video" == a) {
                  if (Jn.includes(b)) return function () {
                    return c.Qe.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
                  };
                } else if ("player" == a) {
                  if (Mn[b] && !this.get("player", "isLive")()) return function () {};
                  if (Pn.includes(b)) return function () {
                    return c.Qe.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
                  };
                  if (Qn.includes(b)) return function () {
                    return c.og.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
                  };
                  if (Kn[b] || Ln[b]) return function () {
                    return c.g[a][b];
                  };
                }
                return this.g[a][b];
              };
              q.set = function (a, b, c) {
                this.g[a][b] = c;
                co(this, {
                  type: "set",
                  targetName: a,
                  property: b,
                  value: c
                });
              };
              function eo(a, b, c) {
                Vn = c;
                c.addUpdateListener(a.B);
                c.addMessageListener("urn:x-cast:com.google.shaka.v2", a.D);
                Sn(a);
                co(a, {
                  type: "init",
                  initState: b,
                  appData: a.o
                });
                a.l.resolve();
              }
              function fo(a, b) {
                var c = 8003;
                switch (b.code) {
                  case "cancel":
                    c = 8004;
                    break;
                  case "timeout":
                    c = 8005;
                    break;
                  case "receiver_unavailable":
                    c = 8006;
                }
                a.l.reject(new O(2, 8, c, b));
              }
              q.Qe = function (a, b) {
                co(this, {
                  type: "call",
                  targetName: a,
                  methodName: b,
                  args: Fa.apply(2, arguments)
                });
              };
              q.og = function (a, b) {
                var c = Fa.apply(2, arguments),
                  d = new lc(),
                  e = this.H.toString();
                this.H++;
                this.i[e] = d;
                try {
                  co(this, {
                    type: "asyncCall",
                    targetName: a,
                    methodName: b,
                    args: c,
                    id: e
                  });
                } catch (f) {
                  d.reject(f);
                }
                return d;
              };
              function Yn(a, b) {
                var c = a.J();
                a.l = new lc();
                a.u = !0;
                eo(a, c, b);
              }
              function Xn(a) {
                var b = Vn;
                b.removeUpdateListener(a.B);
                b.removeMessageListener("urn:x-cast:com.google.shaka.v2", a.D);
              }
              function Sn(a) {
                var b = Vn ? "connected" == Vn.status : !1;
                if (a.h && !b) {
                  a.F();
                  for (var c in a.g) a.g[c] = {};
                  Un(a);
                }
                a.h = b;
                a.L = b ? Vn.receiver.friendlyName : "";
                a.j.Mb();
              }
              function Un(a) {
                for (var b in a.i) {
                  var c = a.i[b];
                  delete a.i[b];
                  c.reject(new O(1, 7, 7E3));
                }
              }
              function co(a, b) {
                b = Dn(b);
                var c = Vn;
                try {
                  c.sendMessage("urn:x-cast:com.google.shaka.v2", b, function () {}, Za);
                } catch (d) {
                  throw b = new O(2, 8, 8005, d), c = new S("error", new Map().set("detail", b)), a.s("player", c), a.Ab(), b;
                }
              }
              var $n = .02,
                Zn = !1,
                Vn = null,
                bo = null,
                Tn = new Set();
              function ao(a) {
                bo ? window.__onGCastApiAvailable = bo : delete window.__onGCastApiAvailable;
                bo = null;
                if (a) for (var b = r(Tn), c = b.next(); !c.done; c = b.next()) c.value.init();
                "function" === typeof window.__onGCastApiAvailable && window.__onGCastApiAvailable(a);
              }
              function ho(a, b, c, d) {
                d = void 0 === d ? !1 : d;
                Ue.call(this);
                var e = this;
                this.i = a;
                this.h = b;
                this.m = this.o = this.j = this.s = this.l = null;
                this.D = c;
                this.B = d;
                this.u = new Map();
                this.g = new Rn(c, function () {
                  return io(e);
                }, function () {
                  return jo(e);
                }, function (f, g) {
                  return ko(e, f, g);
                }, function () {
                  return lo(e);
                }, function () {
                  return mo(e);
                }, d);
                no(this);
              }
              oa(ho, Ue);
              q = ho.prototype;
              q.destroy = function (a) {
                a && this.g.Ab();
                this.m && (this.m.release(), this.m = null);
                a = [];
                this.h && (a.push(this.h.destroy()), this.h = null);
                this.g && (a.push(this.g.destroy()), this.g = null);
                this.s = this.l = this.i = null;
                Ue.prototype.release.call(this);
                return Promise.all(a);
              };
              q.Wf = function () {
                return this.l;
              };
              q.Nf = function () {
                return this.s;
              };
              q.nf = function () {
                return this.g.m && Zn;
              };
              q.sa = function () {
                return this.g.sa();
              };
              q.ae = function () {
                return this.g.ae();
              };
              q.cast = function () {
                var a = this,
                  b;
                return G(function (c) {
                  return 1 == c.g ? (b = mo(a), u(c, a.g.cast(b), 2)) : a.h ? u(c, a.h.re(), 0) : c.return();
                });
              };
              q.ie = function (a) {
                this.g.ie(a);
              };
              q.zg = function () {
                go(this.g);
              };
              q.Ab = function () {
                this.g.Ab();
              };
              q.qf = function (a, b) {
                b = void 0 === b ? !1 : b;
                var c = this;
                return G(function (d) {
                  if (1 == d.g) {
                    if (a == c.D && b == c.B) return d.return();
                    c.D = a;
                    c.B = b;
                    c.g.Ab();
                    return u(d, c.g.destroy(), 2);
                  }
                  c.g = null;
                  c.g = new Rn(a, function () {
                    return io(c);
                  }, function () {
                    return jo(c);
                  }, function (e, f) {
                    return ko(c, e, f);
                  }, function () {
                    return lo(c);
                  }, function () {
                    return mo(c);
                  }, b);
                  c.g.init();
                  A(d);
                });
              };
              function no(a) {
                a.g.init();
                a.m = new mf();
                for (var b = r(Gn), c = b.next(); !c.done; c = b.next()) a.m.C(a.i, c.value, function (f) {
                  a.g.sa() || (f = Se(f), a.j.dispatchEvent(f));
                });
                for (var d in Te) a.m.C(a.h, Te[d], function (f) {
                  a.g.sa() || a.o.dispatchEvent(f);
                });
                a.l = {};
                b = {};
                for (var e in a.i) b.Sb = e, Object.defineProperty(a.l, b.Sb, {
                  configurable: !1,
                  enumerable: !0,
                  get: function (f) {
                    return function () {
                      return oo(a, f.Sb);
                    };
                  }(b),
                  set: function (f) {
                    return function (g) {
                      var h = f.Sb;
                      a.g.sa() ? a.g.set("video", h, g) : a.i[h] = g;
                    };
                  }(b)
                }), b = {
                  Sb: b.Sb
                };
                a.s = {};
                po(a, function (f) {
                  Object.defineProperty(a.s, f, {
                    configurable: !1,
                    enumerable: !0,
                    get: function get() {
                      return qo(a, f);
                    }
                  });
                });
                ro(a);
                a.j = new Ue();
                a.j.Wc = a.l;
                a.o = new Ue();
                a.o.Wc = a.s;
              }
              function ro(a) {
                var b = new Map();
                po(a, function (c, d) {
                  b.has(d) ? (d = b.get(d), c.length < d.length ? a.u.set(c, d) : a.u.set(d, c)) : b.set(d, c);
                });
              }
              function po(a, b) {
                function c(k) {
                  return "constructor" == k || "function" != typeof d[k] ? !1 : !e.has(k);
                }
                var d = a.h,
                  e = new Set(),
                  f;
                for (f in d) c(f) && (e.add(f), b(f, d[f]));
                a = Object.getPrototypeOf(d);
                for (f = Object.getPrototypeOf({}); a && a != f;) {
                  for (var g = r(Object.getOwnPropertyNames(a)), h = g.next(); !h.done; h = g.next()) h = h.value, c(h) && (e.add(h), b(h, d[h]));
                  a = Object.getPrototypeOf(a);
                }
              }
              function mo(a) {
                var b = {
                  video: {},
                  player: {},
                  playerAfterLoad: {},
                  manifest: a.h.Dd(),
                  startTime: null
                };
                a.i.pause();
                for (var c = r(In), d = c.next(); !d.done; d = c.next()) d = d.value, b.video[d] = a.i[d];
                a.i.ended || (b.startTime = a.i.currentTime);
                c = r(Nn);
                for (d = c.next(); !d.done; d = c.next()) {
                  var e = d.value;
                  d = e[1];
                  e = a.h[e[0]]();
                  b.player[d] = e;
                }
                c = r(On);
                for (d = c.next(); !d.done; d = c.next()) e = d.value, d = e[1], e = a.h[e[0]](), b.playerAfterLoad[d] = e;
                return b;
              }
              function io(a) {
                var b = new S("caststatuschanged");
                a.dispatchEvent(b);
              }
              function jo(a) {
                var b = new S(a.l.paused ? "pause" : "play");
                a.j.dispatchEvent(b);
              }
              function lo(a) {
                for (var b = r(Nn), c = b.next(); !c.done; c = b.next()) {
                  var d = c.value;
                  c = d[1];
                  d = a.g.get("player", d[0])();
                  a.h[c](d);
                }
                var e = a.g.get("player", "getAssetUri")();
                c = a.g.get("video", "ended");
                b = Promise.resolve();
                var f = a.i.autoplay;
                d = null;
                c || (d = a.g.get("video", "currentTime"));
                e && (a.i.autoplay = !1, b = a.h.load(e, d));
                var g = {};
                c = r(In);
                for (d = c.next(); !d.done; d = c.next()) d = d.value, g[d] = a.g.get("video", d);
                b.then(function () {
                  if (a.i) {
                    for (var h = r(In), k = h.next(); !k.done; k = h.next()) k = k.value, a.i[k] = g[k];
                    h = r(On);
                    for (k = h.next(); !k.done; k = h.next()) {
                      var l = k.value;
                      k = l[1];
                      l = a.g.get("player", l[0])();
                      a.h[k](l);
                    }
                    a.i.autoplay = f;
                    e && a.i.play();
                  }
                }, function (h) {
                  h = new Map().set("detail", h);
                  h = new S("error", h);
                  a.h.dispatchEvent(h);
                });
              }
              function oo(a, b) {
                if ("addEventListener" == b) return function (d, e, f) {
                  return a.j.addEventListener(d, e, f);
                };
                if ("removeEventListener" == b) return function (d, e, f) {
                  return a.j.removeEventListener(d, e, f);
                };
                if (a.g.sa() && 0 == Object.keys(a.g.g.video).length) {
                  var c = a.i[b];
                  if ("function" != typeof c) return c;
                }
                return a.g.sa() ? a.g.get("video", b) : (b = a.i[b], "function" == typeof b && (b = b.bind(a.i)), b);
              }
              function qo(a, b) {
                a.u.has(b) && (b = a.u.get(b));
                if ("addEventListener" == b) return function (c, d, e) {
                  return a.o.addEventListener(c, d, e);
                };
                if ("removeEventListener" == b) return function (c, d, e) {
                  return a.o.removeEventListener(c, d, e);
                };
                if ("getMediaElement" == b) return function () {
                  return a.l;
                };
                if ("getSharedConfiguration" == b) return a.g.get("player", "getConfiguration");
                if ("getNetworkingEngine" == b) return function () {
                  return a.h.jc();
                };
                if ("getDrmEngine" == b) return function () {
                  return a.h.m;
                };
                if ("getAdManager" == b) return function () {
                  return a.h.Ge();
                };
                if ("setVideoContainer" == b) return function (c) {
                  return a.h.$e(c);
                };
                if (a.g.sa()) {
                  if ("getManifest" == b || "drmInfo" == b) return function () {
                    Wa(b + "() does not work while casting!");
                    return null;
                  };
                  if ("attach" == b || "detach" == b) return function () {
                    Wa(b + "() does not work while casting!");
                    return Promise.resolve();
                  };
                }
                return a.g.sa() && 0 == Object.keys(a.g.g.video).length && (Kn[b] || Ln[b]) || !a.g.sa() ? a.h[b].bind(a.h) : a.g.get("player", b);
              }
              function ko(a, b, c) {
                a.g.sa() && ("video" == b ? a.j.dispatchEvent(c) : "player" == b && a.o.dispatchEvent(c));
              }
              K("shaka.cast.CastProxy", ho);
              ho.prototype.changeReceiverId = ho.prototype.qf;
              ho.prototype.forceDisconnect = ho.prototype.Ab;
              ho.prototype.suggestDisconnect = ho.prototype.zg;
              ho.prototype.setAppData = ho.prototype.ie;
              ho.prototype.cast = ho.prototype.cast;
              ho.prototype.receiverName = ho.prototype.ae;
              ho.prototype.isCasting = ho.prototype.sa;
              ho.prototype.canCast = ho.prototype.nf;
              ho.prototype.getPlayer = ho.prototype.Nf;
              ho.prototype.getVideo = ho.prototype.Wf;
              ho.prototype.destroy = ho.prototype.destroy;
              function so(a, b, c, d) {
                Ue.call(this);
                var e = this;
                this.g = a;
                this.h = b;
                this.j = new mf();
                this.H = {
                  video: a,
                  player: b
                };
                this.D = c || function () {};
                this.J = d || function (f) {
                  return f;
                };
                this.i = null;
                this.F = !1;
                this.o = !0;
                this.m = 0;
                this.B = !1;
                this.u = !0;
                this.s = this.l = null;
                this.G = new P(function () {
                  to(e);
                });
                uo(this);
              }
              oa(so, Ue);
              q = so.prototype;
              q.isConnected = function () {
                return this.F;
              };
              q.$f = function () {
                return this.o;
              };
              q.wg = function (a) {
                this.i = a;
              };
              q.uf = function () {
                this.i = null;
              };
              q.xg = function (a) {
                this.i || (this.i = {
                  metadataType: cast.receiver.media.MetadataType.GENERIC
                });
                this.i.title = a;
              };
              q.vg = function (a) {
                this.i || (this.i = {
                  metadataType: cast.receiver.media.MetadataType.GENERIC
                });
                this.i.images = [{
                  url: a
                }];
              };
              q.ug = function (a) {
                this.i || (this.i = {});
                this.i.artist = a;
                this.i.metadataType = cast.receiver.media.MetadataType.MUSIC_TRACK;
              };
              q.destroy = function () {
                var a = this,
                  b,
                  c;
                return G(function (d) {
                  if (1 == d.g) return a.j && (a.j.release(), a.j = null), b = [], a.h && (b.push(a.h.destroy()), a.h = null), a.G && (a.G.stop(), a.G = null), a.g = null, a.H = null, a.D = null, a.F = !1, a.o = !0, a.l = null, a.s = null, Ue.prototype.release.call(a), u(d, Promise.all(b), 2);
                  c = cast.receiver.CastReceiverManager.getInstance();
                  c.stop();
                  A(d);
                });
              };
              function uo(a) {
                var b = cast.receiver.CastReceiverManager.getInstance();
                b.onSenderConnected = function () {
                  return vo(a);
                };
                b.onSenderDisconnected = function () {
                  return vo(a);
                };
                b.onSystemVolumeChanged = function () {
                  var e = cast.receiver.CastReceiverManager.getInstance().getSystemVolume();
                  e && wo(a, {
                    type: "update",
                    update: {
                      video: {
                        volume: e.level,
                        muted: e.muted
                      }
                    }
                  }, a.l);
                  wo(a, {
                    type: "event",
                    targetName: "video",
                    event: {
                      type: "volumechange"
                    }
                  }, a.l);
                };
                a.s = b.getCastMessageBus("urn:x-cast:com.google.cast.media");
                a.s.onMessage = function (e) {
                  return xo(a, e);
                };
                a.l = b.getCastMessageBus("urn:x-cast:com.google.shaka.v2");
                a.l.onMessage = function (e) {
                  return yo(a, e);
                };
                b.start();
                b = r(Gn);
                for (var c = b.next(); !c.done; c = b.next()) a.j.C(a.g, c.value, function (e) {
                  return zo(a, "video", e);
                });
                for (var d in Te) a.j.C(a.h, Te[d], function (e) {
                  return zo(a, "player", e);
                });
                cast.__platform__ && cast.__platform__.canDisplayType('video/mp4; codecs="avc1.640028"; width=3840; height=2160') ? a.h.ke(3840, 2160) : a.h.ke(1920, 1080);
                a.j.C(a.g, "loadeddata", function () {
                  a.B = !0;
                });
                a.j.C(a.h, "loading", function () {
                  a.o = !1;
                  Ao(a);
                });
                a.j.C(a.g, "playing", function () {
                  a.o = !1;
                  Ao(a);
                });
                a.j.C(a.g, "pause", function () {
                  Ao(a);
                });
                a.j.C(a.h, "unloading", function () {
                  a.o = !0;
                  Ao(a);
                });
                a.j.C(a.g, "ended", function () {
                  new P(function () {
                    a.g && a.g.ended && (a.o = !0, Ao(a));
                  }).N(Bo);
                });
              }
              function vo(a) {
                a.m = 0;
                a.u = !0;
                a.F = 0 != cast.receiver.CastReceiverManager.getInstance().getSenders().length;
                Ao(a);
              }
              function Ao(a) {
                var b;
                G(function (c) {
                  if (1 == c.g) return u(c, Promise.resolve(), 2);
                  if (!a.h) return c.return();
                  b = new S("caststatuschanged");
                  a.dispatchEvent(b);
                  Co(a) || Do(a);
                  A(c);
                });
              }
              function Eo(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p;
                G(function (t) {
                  switch (t.g) {
                    case 1:
                      for (d in b.player) e = b.player[d], a.h[d](e);
                      a.D(c);
                      f = a.g.autoplay;
                      return b.manifest ? (a.g.autoplay = !1, D(t, 5), u(t, a.h.load(b.manifest, b.startTime), 7)) : u(t, Promise.resolve(), 3);
                    case 7:
                      ta(t, 3);
                      break;
                    case 5:
                      return g = ua(t), h = new Map().set("detail", g), k = new S("error", h), a.h && a.h.dispatchEvent(k), t.return();
                    case 3:
                      if (!a.h) return t.return();
                      for (l in b.video) m = b.video[l], a.g[l] = m;
                      for (n in b.playerAfterLoad) p = b.playerAfterLoad[n], a.h[n](p);
                      a.g.autoplay = f;
                      b.manifest && (a.g.play(), Do(a));
                      A(t);
                  }
                });
              }
              function zo(a, b, c) {
                a.h && (to(a), wo(a, {
                  type: "event",
                  targetName: b,
                  event: c
                }, a.l));
              }
              function to(a) {
                a.G.N(Fo);
                for (var b = {
                    video: {},
                    player: {}
                  }, c = r(Hn), d = c.next(); !d.done; d = c.next()) d = d.value, b.video[d] = a.g[d];
                if (a.h.U()) for (var e in Mn) 0 == a.m % Mn[e] && (b.player[e] = a.h[e]());
                for (var f in Kn) 0 == a.m % Kn[f] && (b.player[f] = a.h[f]());
                if (c = cast.receiver.CastReceiverManager.getInstance().getSystemVolume()) b.video.volume = c.level, b.video.muted = c.muted;
                wo(a, {
                  type: "update",
                  update: b
                }, a.l);
                for (var g in Ln) 0 == a.m % Ln[g] && (b = {
                  player: {}
                }, b.player[g] = a.h[g](), wo(a, {
                  type: "update",
                  update: b
                }, a.l));
                a.B && (a.m += 1);
                Co(a);
              }
              function Co(a) {
                return a.u && (a.g.duration || a.h.U()) ? (Go(a), a.u = !1, !0) : !1;
              }
              function Go(a, b) {
                var c = {
                  contentId: a.h.Dd(),
                  streamType: a.h.U() ? "LIVE" : "BUFFERED",
                  contentType: ""
                };
                a.h.U() || (c.duration = a.g.duration);
                a.i && (c.metadata = a.i);
                Do(a, void 0 === b ? 0 : b, c);
              }
              function yo(a, b) {
                var c = En(b.data);
                switch (c.type) {
                  case "init":
                    a.m = 0;
                    a.B = !1;
                    a.u = !0;
                    Eo(a, c.initState, c.appData);
                    to(a);
                    break;
                  case "appData":
                    a.D(c.appData);
                    break;
                  case "set":
                    var d = c.targetName,
                      e = c.property;
                    c = c.value;
                    if ("video" == d) if (b = cast.receiver.CastReceiverManager.getInstance(), "volume" == e) {
                      b.setSystemVolumeLevel(c);
                      break;
                    } else if ("muted" == e) {
                      b.setSystemVolumeMuted(c);
                      break;
                    }
                    a.H[d][e] = c;
                    break;
                  case "call":
                    d = a.H[c.targetName];
                    d[c.methodName].apply(d, c.args);
                    break;
                  case "asyncCall":
                    d = c.targetName;
                    e = c.methodName;
                    "player" == d && "load" == e && (a.m = 0, a.B = !1);
                    var f = c.id,
                      g = b.senderId;
                    b = a.H[d];
                    c = b[e].apply(b, c.args);
                    "player" == d && "load" == e && (c = c.then(function () {
                      a.u = !0;
                    }));
                    c.then(function () {
                      return Ho(a, g, f, null);
                    }, function (h) {
                      return Ho(a, g, f, h);
                    });
                }
              }
              function xo(a, b) {
                var c = En(b.data);
                switch (c.type) {
                  case "PLAY":
                    a.g.play();
                    Do(a);
                    break;
                  case "PAUSE":
                    a.g.pause();
                    Do(a);
                    break;
                  case "SEEK":
                    b = c.currentTime;
                    var d = c.resumeState;
                    null != b && (a.g.currentTime = Number(b));
                    d && "PLAYBACK_START" == d ? (a.g.play(), Do(a)) : d && "PLAYBACK_PAUSE" == d && (a.g.pause(), Do(a));
                    break;
                  case "STOP":
                    a.h.re().then(function () {
                      a.h && Do(a);
                    });
                    break;
                  case "GET_STATUS":
                    Go(a, Number(c.requestId));
                    break;
                  case "VOLUME":
                    d = c.volume;
                    b = d.level;
                    d = d.muted;
                    var e = a.g.volume,
                      f = a.g.muted;
                    null != b && (a.g.volume = Number(b));
                    null != d && (a.g.muted = d);
                    e == a.g.volume && f == a.g.muted || Do(a);
                    break;
                  case "LOAD":
                    a.m = 0;
                    a.B = !1;
                    a.u = !1;
                    b = c.media;
                    d = c.currentTime;
                    e = a.J(b.contentId);
                    f = c.autoplay || !0;
                    a.D(b.customData);
                    f && (a.g.autoplay = !0);
                    a.h.load(e, d).then(function () {
                      a.h && Go(a);
                    }).catch(function (g) {
                      var h = "LOAD_FAILED";
                      7 == g.category && 7E3 == g.code && (h = "LOAD_CANCELLED");
                      wo(a, {
                        requestId: Number(c.requestId),
                        type: h
                      }, a.s);
                    });
                    break;
                  default:
                    wo(a, {
                      requestId: Number(c.requestId),
                      type: "INVALID_REQUEST",
                      reason: "INVALID_COMMAND"
                    }, a.s);
                }
              }
              function Ho(a, b, c, d) {
                a.h && wo(a, {
                  type: "asyncComplete",
                  id: c,
                  error: d
                }, a.l, b);
              }
              function wo(a, b, c, d) {
                a.F && (a = Dn(b), d ? c.getCastChannel(d).send(a) : c.broadcast(a));
              }
              function Do(a, b, c) {
                c = void 0 === c ? null : c;
                var d = {
                  mediaSessionId: 0,
                  playbackRate: a.g.playbackRate,
                  playerState: a.o ? Io : a.h.Fd() ? Jo : a.g.paused ? Ko : Lo,
                  currentTime: a.g.currentTime,
                  supportedMediaCommands: 63,
                  volume: {
                    level: a.g.volume,
                    muted: a.g.muted
                  }
                };
                c && (d.media = c);
                wo(a, {
                  requestId: void 0 === b ? 0 : b,
                  type: "MEDIA_STATUS",
                  status: [d]
                }, a.s);
              }
              K("shaka.cast.CastReceiver", so);
              so.prototype.destroy = so.prototype.destroy;
              so.prototype.setContentArtist = so.prototype.ug;
              so.prototype.setContentImage = so.prototype.vg;
              so.prototype.setContentTitle = so.prototype.xg;
              so.prototype.clearContentMetadata = so.prototype.uf;
              so.prototype.setContentMetadata = so.prototype.wg;
              so.prototype.isIdle = so.prototype.$f;
              so.prototype.isConnected = so.prototype.isConnected;
              var Fo = .5,
                Bo = 5,
                Io = "IDLE",
                Lo = "PLAYING",
                Jo = "BUFFERING",
                Ko = "PAUSED";
              function Mo(a, b, c) {
                var d = No(a),
                  e = null;
                a = [];
                var f = [],
                  g = new Set(d.map(function (h) {
                    return h.keyId;
                  }));
                g.delete(null);
                if (1 < g.size) throw new O(2, 4, 4010);
                b || (f = d.filter(function (h) {
                  return "urn:mpeg:dash:mp4protection:2011" == h.fe ? (e = h.init || e, !1) : !0;
                }), f.length && (a = Oo(e, f, c, g), 0 == a.length && (a = [fc("", e)])));
                if (d.length && (b || !f.length)) for (a = [], b = r(Object.values(c)), c = b.next(); !c.done; c = b.next()) c = c.value, "org.w3.clearkey" != c && a.push(fc(c, e));
                if (g = Array.from(g)[0] || null) for (b = r(a), c = b.next(); !c.done; c = b.next()) for (c = r(c.value.initData), d = c.next(); !d.done; d = c.next()) d.value.keyId = g;
                return {
                  Be: g,
                  sh: e,
                  drmInfos: a,
                  Fe: !0
                };
              }
              function Po(a, b, c, d) {
                var e = Mo(a, c, d);
                if (b.Fe) {
                  a = 1 == b.drmInfos.length && !b.drmInfos[0].keySystem;
                  c = 0 == e.drmInfos.length;
                  if (0 == b.drmInfos.length || a && !c) b.drmInfos = e.drmInfos;
                  b.Fe = !1;
                } else if (0 < e.drmInfos.length && (b.drmInfos = b.drmInfos.filter(function (f) {
                  return e.drmInfos.some(function (g) {
                    return g.keySystem == f.keySystem;
                  });
                }), 0 == b.drmInfos.length)) throw new O(2, 4, 4008);
                return e.Be || b.Be;
              }
              function Qo(a) {
                var b = 0,
                  c = Lb(a),
                  d = c.getUint32(b, !0);
                if (d != a.byteLength) return [];
                a: {
                  a = b + 6;
                  for (b = []; a < c.byteLength - 1;) {
                    d = c.getUint16(a, !0);
                    a += 2;
                    var e = c.getUint16(a, !0);
                    a += 2;
                    if (0 != (e & 1) || e + a > c.byteLength) {
                      c = [];
                      break a;
                    }
                    var f = M(c, a, e);
                    b.push({
                      type: d,
                      value: f
                    });
                    a += e;
                  }
                  c = b;
                }
                return c;
              }
              function Ro(a) {
                a = r(a.getElementsByTagName("DATA"));
                for (var b = a.next(); !b.done; b = a.next()) {
                  b = r(b.value.childNodes);
                  for (var c = b.next(); !c.done; c = b.next()) if (c = c.value, c instanceof Element && "LA_URL" == c.tagName) return c.textContent;
                }
                return "";
              }
              function So(a) {
                a = Nf(a.node, "urn:microsoft:playready", "pro");
                if (!a) return "";
                a = Lc(a.textContent);
                a = Qo(a).filter(function (b) {
                  return b.type === To;
                })[0];
                if (!a) return "";
                a = Dc(a.value, !0);
                return (a = cg(a, "WRMHEADER")) ? Ro(a) : "";
              }
              function Oo(a, b, c, d) {
                var e = [];
                b = r(b);
                for (var f = b.next(); !f.done; f = b.next()) {
                  f = f.value;
                  var g = c[f.fe];
                  if (g) {
                    var h;
                    if (h = Nf(f.node, "urn:microsoft:playready", "pro")) {
                      h = Lc(h.textContent);
                      var k = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                      h = [{
                        initData: Kf(h, k, new Set(), 0),
                        initDataType: "cenc",
                        keyId: f.keyId
                      }];
                    } else h = null;
                    k = null;
                    if ("urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e" === f.fe) if (k = d, 0 == k.size) k = null;else {
                      var l = new Uint8Array([16, 119, 239, 236, 192, 178, 77, 2, 172, 227, 60, 30, 82, 226, 251, 75]),
                        m = new Uint8Array([]);
                      k = [{
                        initData: Kf(m, l, k, 1),
                        initDataType: "cenc",
                        keyId: f.keyId
                      }];
                    }
                    h = fc(g, f.init || a || h || k);
                    if (g = Uo.get(g)) h.licenseServerUri = g(f);
                    e.push(h);
                  }
                }
                return e;
              }
              function No(a) {
                var b = [];
                a = r(a);
                for (var c = a.next(); !c.done; c = a.next()) (c = Vo(c.value)) && b.push(c);
                return b;
              }
              function Vo(a) {
                var b = a.getAttribute("schemeIdUri"),
                  c = Qf(a, "urn:mpeg:cenc:2013", "default_KID"),
                  d = Of(a, "urn:mpeg:cenc:2013", "pssh").map(Sf);
                if (!b) return null;
                b = b.toLowerCase();
                if (c && (c = c.replace(/-/g, "").toLowerCase(), c.includes(" "))) throw new O(2, 4, 4009);
                var e = [];
                try {
                  e = d.map(function (f) {
                    return {
                      initDataType: "cenc",
                      initData: Lc(f),
                      keyId: null
                    };
                  });
                } catch (f) {
                  throw new O(2, 4, 4007);
                }
                return {
                  node: a,
                  fe: b,
                  keyId: c,
                  init: 0 < e.length ? e : null
                };
              }
              var To = 1,
                Uo = new Map().set("com.widevine.alpha", function (a) {
                  return (a = Nf(a.node, "urn:microsoft", "laurl")) ? a.getAttribute("licenseUrl") || "" : "";
                }).set("com.microsoft.playready", So).set("com.microsoft.playready.recommendation", So).set("com.microsoft.playready.software", So).set("com.microsoft.playready.hardware", So).set("org.w3.clearkey", function (a) {
                  return (a = Nf(a.node, "http://dashif.org/guidelines/clearKey", "Laurl")) && "EME-1.0" === a.getAttribute("Lic_type") && a.textContent ? a.textContent : "";
                });
              function Wo(a, b, c, d, e) {
                var f = {
                  RepresentationID: b,
                  Number: c,
                  Bandwidth: d,
                  Time: e
                };
                return a.replace(/\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\$/g, function (g, h, k, l) {
                  if ("$$" == g) return "$";
                  var m = f[h];
                  if (null == m) return g;
                  "RepresentationID" == h && k && (k = void 0);
                  "Time" == h && (m = Math.round(m));
                  switch (l) {
                    case void 0:
                    case "d":
                    case "i":
                    case "u":
                      g = m.toString();
                      break;
                    case "o":
                      g = m.toString(8);
                      break;
                    case "x":
                      g = m.toString(16);
                      break;
                    case "X":
                      g = m.toString(16).toUpperCase();
                      break;
                    default:
                      g = m.toString();
                  }
                  k = window.parseInt(k, 10) || 1;
                  return Array(Math.max(0, k - g.length) + 1).join("0") + g;
                });
              }
              function Xo(a, b) {
                var c = Yo(a, b, "timescale"),
                  d = 1;
                c && (d = Zf(c) || 1);
                var e = Yo(a, b, "duration");
                c = Zf(e || "");
                "image" == a.I.contentType && (c = ag(e || ""));
                c && (c /= d);
                var f = Yo(a, b, "startNumber");
                e = Number(Yo(a, b, "presentationTimeOffset")) || 0;
                var g = $f(f || "");
                if (null == f || null == g) g = 1;
                f = Zo(a, b, "SegmentTimeline");
                b = null;
                if (f) {
                  b = d;
                  a = a.T.duration || Infinity;
                  f = Mf(f, "S");
                  for (var h = [], k = -e, l = 0; l < f.length; ++l) {
                    var m = f[l],
                      n = f[l + 1],
                      p = Uf(m, "t", $f),
                      t = Uf(m, "d", $f);
                    m = Uf(m, "r", Yf);
                    null != p && (p -= e);
                    if (!t) break;
                    p = null != p ? p : k;
                    m = m || 0;
                    if (0 > m) if (n) {
                      n = Uf(n, "t", $f);
                      if (null == n) break;else if (p >= n) break;
                      m = Math.ceil((n - p) / t) - 1;
                    } else {
                      if (Infinity == a) break;else if (p / b >= a) break;
                      m = Math.ceil((a * b - p) / t) - 1;
                    }
                    0 < h.length && p != k && (h[h.length - 1].end = p / b);
                    for (n = 0; n <= m; ++n) k = p + t, h.push({
                      start: p / b,
                      end: k / b,
                      Dg: p
                    }), p = k;
                  }
                  b = h;
                }
                return {
                  timescale: d,
                  ia: c,
                  Lb: g,
                  Sa: e / d || 0,
                  se: e,
                  timeline: b
                };
              }
              function Yo(a, b, c) {
                return [b(a.I), b(a.fa), b(a.$)].filter(dc).map(function (d) {
                  return d.getAttribute(c);
                }).reduce(function (d, e) {
                  return d || e;
                });
              }
              function Zo(a, b, c) {
                return [b(a.I), b(a.fa), b(a.$)].filter(dc).map(function (d) {
                  return Lf(d, c);
                }).reduce(function (d, e) {
                  return d || e;
                });
              }
              function $o(a, b, c, d, e, f) {
                for (var g = Qf(a, "http://www.w3.org/1999/xlink", "href"), h = Qf(a, "http://www.w3.org/1999/xlink", "actuate") || "onRequest", k = r(Array.from(a.attributes)), l = k.next(); !l.done; l = k.next()) l = l.value, "http://www.w3.org/1999/xlink" == l.namespaceURI && a.removeAttributeNS(l.namespaceURI, l.localName);
                if (5 <= f) return Me(new O(2, 4, 4028));
                if ("onLoad" != h) return Me(new O(2, 4, 4027));
                var m = ec([d], [g]);
                return e.request(0, cf(m, b)).Y(function (n) {
                  n = eg(n.data, a.tagName);
                  if (!n) return Me(new O(2, 4, 4001, g));
                  for (; a.childNodes.length;) a.removeChild(a.childNodes[0]);
                  for (; n.childNodes.length;) {
                    var p = n.childNodes[0];
                    n.removeChild(p);
                    a.appendChild(p);
                  }
                  n = r(Array.from(n.attributes));
                  for (p = n.next(); !p.done; p = n.next()) a.setAttributeNode(p.value.cloneNode(!1));
                  return ap(a, b, c, m[0], e, f + 1);
                });
              }
              function ap(a, b, c, d, e, f) {
                f = void 0 === f ? 0 : f;
                if (Qf(a, "http://www.w3.org/1999/xlink", "href")) {
                  var g = $o(a, b, c, d, e, f);
                  c && (g = g.Y(void 0, function () {
                    return ap(a, b, c, d, e, f);
                  }));
                  return g;
                }
                g = [];
                for (var h = r(Array.from(a.childNodes)), k = h.next(); !k.done; k = h.next()) k = k.value, k instanceof Element && ("urn:mpeg:dash:resolve-to-zero:2013" == Qf(k, "http://www.w3.org/1999/xlink", "href") ? a.removeChild(k) : "SegmentTimeline" != k.tagName && g.push(ap(k, b, c, d, e, f)));
                return Qe(g).Y(function () {
                  return a;
                });
              }
              function bp(a, b, c, d, e, f, g) {
                var h,
                  k = new zf().P("sidx", function (l) {
                    h = cp(b, d, e, f, g, c, l);
                  });
                a && k.parse(a);
                if (h) return h;
                throw new O(2, 3, 3004);
              }
              function cp(a, b, c, d, e, f, g) {
                var h = [];
                g.reader.skip(4);
                var k = g.reader.K();
                if (0 == k) throw new O(2, 3, 3005);
                if (0 == g.version) {
                  var l = g.reader.K();
                  var m = g.reader.K();
                } else l = g.reader.$a(), m = g.reader.$a();
                g.reader.skip(2);
                var n = g.reader.$d();
                a = a + g.size + m;
                for (m = 0; m < n; m++) {
                  var p = g.reader.K(),
                    t = (p & 2147483648) >>> 31;
                  p &= 2147483647;
                  var v = g.reader.K();
                  g.reader.skip(4);
                  if (1 == t) throw new O(2, 3, 3006);
                  h.push(new qi(l / k + c, (l + v) / k + c, function () {
                    return f;
                  }, a, a + p - 1, b, c, d, e));
                  l += v;
                  a += p;
                }
                g.parser.stop();
                return h;
              }
              function dp(a) {
                this.h = Lb(a);
                this.g = new wf(this.h, 0);
              }
              dp.prototype.ha = function () {
                return this.g.ha();
              };
              function ep(a) {
                var b = fp(a);
                if (7 < b.length) throw new O(2, 3, 3002);
                var c = 0;
                b = r(b);
                for (var d = b.next(); !d.done; d = b.next()) c = 256 * c + d.value;
                b = fp(a);
                a: {
                  d = r(gp);
                  for (var e = d.next(); !e.done; e = d.next()) if (Gb(b, new Uint8Array(e.value))) {
                    d = !0;
                    break a;
                  }
                  d = !1;
                }
                if (d) b = a.h.byteLength - a.g.Z();else {
                  if (8 == b.length && b[1] & 224) throw new O(2, 3, 3001);
                  for (e = d = 0; e < b.length; e++) {
                    var f = b[e];
                    d = 0 == e ? f & (1 << 8 - b.length) - 1 : 256 * d + f;
                  }
                  b = d;
                }
                b = a.g.Z() + b <= a.h.byteLength ? b : a.h.byteLength - a.g.Z();
                d = Lb(a.h, a.g.Z(), b);
                a.g.skip(b);
                return new hp(c, d);
              }
              function fp(a) {
                var b = a.g.Z(),
                  c = a.g.Ra();
                if (0 == c) throw new O(2, 3, 3002);
                c = 8 - Math.floor(Math.log2(c));
                a.g.skip(c - 1);
                return M(a.h, b, c);
              }
              var gp = [[255], [127, 255], [63, 255, 255], [31, 255, 255, 255], [15, 255, 255, 255, 255], [7, 255, 255, 255, 255, 255], [3, 255, 255, 255, 255, 255, 255], [1, 255, 255, 255, 255, 255, 255, 255]];
              function hp(a, b) {
                this.id = a;
                this.g = b;
              }
              function ip(a) {
                if (8 < a.g.byteLength) throw new O(2, 3, 3002);
                if (8 == a.g.byteLength && a.g.getUint8(0) & 224) throw new O(2, 3, 3001);
                for (var b = 0, c = 0; c < a.g.byteLength; c++) {
                  var d = a.g.getUint8(c);
                  b = 256 * b + d;
                }
                return b;
              }
              function jp(a, b, c, d, e, f, g, h, k) {
                function l() {
                  return e;
                }
                var m = [];
                a = new dp(a.g);
                for (var n = null, p = null; a.ha();) {
                  var t = ep(a);
                  if (187 == t.id) {
                    var v = kp(t);
                    v && (t = c * v.Eg, v = b + v.ng, null != n && m.push(new qi(n + g, t + g, l, p, v - 1, f, g, h, k)), n = t, p = v);
                  }
                }
                null != n && m.push(new qi(n + g, d + g, l, p, null, f, g, h, k));
                return m;
              }
              function kp(a) {
                var b = new dp(a.g);
                a = ep(b);
                if (179 != a.id) throw new O(2, 3, 3013);
                a = ip(a);
                b = ep(b);
                if (183 != b.id) throw new O(2, 3, 3012);
                b = new dp(b.g);
                for (var c = 0; b.ha();) {
                  var d = ep(b);
                  if (241 == d.id) {
                    c = ip(d);
                    break;
                  }
                }
                return {
                  Eg: a,
                  ng: c
                };
              }
              function lp(a, b) {
                b = Zo(a, b, "Initialization");
                if (!b) return null;
                var c = a.I.wa,
                  d = b.getAttribute("sourceURL");
                d && (c = ec(a.I.wa, [d]));
                d = 0;
                var e = null;
                if (b = Uf(b, "range", Xf)) d = b.start, e = b.end;
                return new oi(function () {
                  return c;
                }, d, e, mp(a));
              }
              function np(a, b) {
                var c = Number(Yo(a, op, "presentationTimeOffset")) || 0,
                  d = Yo(a, op, "timescale"),
                  e = 1;
                d && (e = Zf(d) || 1);
                var f = c / e || 0,
                  g = lp(a, op);
                pp(a, g);
                var h = We(a);
                return {
                  Bb: function Bb() {
                    var k = Zo(h, op, "RepresentationIndex");
                    var l = h.I.wa;
                    k && (k = k.getAttribute("sourceURL")) && (l = ec(h.I.wa, [k]));
                    k = qp(h);
                    return rp(h, b, g, l, k.start, k.end, f);
                  }
                };
              }
              function rp(a, b, c, d, e, f, g) {
                var h, k, l, m, n, p, t, v, y, w, x, C, z, B, E;
                return G(function (F) {
                  if (1 == F.g) return h = a.presentationTimeline, k = !a.Ma || !a.T.Gd, l = a.T.start, m = a.T.duration, n = a.I.mimeType.split("/")[1], p = b, t = null, v = [p(d, e, f), "webm" == n ? p(c.ya(), c.Ba, c.ka) : null], p = null, u(F, Promise.all(v), 2);
                  y = F.h;
                  w = y[0];
                  x = y[1] || null;
                  C = null;
                  z = l - g;
                  B = l;
                  E = m ? l + m : Infinity;
                  if ("mp4" == n) var H = bp(w, e, d, c, z, B, E);else {
                    H = new dp(x);
                    if (440786851 != ep(H).id) throw new O(2, 3, 3008);
                    var I = ep(H);
                    if (408125543 != I.id) throw new O(2, 3, 3009);
                    H = I.g.byteOffset;
                    I = new dp(I.g);
                    for (var J = null; I.ha();) {
                      var L = ep(I);
                      if (357149030 == L.id) {
                        J = L;
                        break;
                      }
                    }
                    if (!J) throw new O(2, 3, 3010);
                    J = new dp(J.g);
                    L = 1E6;
                    for (I = null; J.ha();) {
                      var R = ep(J);
                      if (2807729 == R.id) L = ip(R);else if (17545 == R.id) if (4 == R.g.byteLength) I = R.g.getFloat32(0);else if (8 == R.g.byteLength) I = R.g.getFloat64(0);else throw new O(2, 3, 3003);
                    }
                    if (null == I) throw new O(2, 3, 3011);
                    J = L / 1E9;
                    I *= J;
                    L = ep(new dp(w));
                    if (475249515 != L.id) throw new O(2, 3, 3007);
                    H = jp(L, H, J, I, d, c, z, B, E);
                  }
                  C = H;
                  h.Ib(C);
                  t = new Jj(C);
                  k && t.Wa(B, E, !0);
                  return F.return(t);
                });
              }
              function op(a) {
                return a.wc;
              }
              function qp(a) {
                var b = Zo(a, op, "RepresentationIndex");
                a = Yo(a, op, "indexRange");
                a = Xf(a || "");
                b && (a = Uf(b, "range", Xf, a));
                return a;
              }
              function pp(a, b) {
                sp(a, b);
                if (!qp(a)) throw new O(2, 4, 4002);
              }
              function sp(a, b) {
                var c = a.I.mimeType.split("/")[1];
                if (a.I.contentType != jc && "mp4" != c && "webm" != c) throw new O(2, 4, 4006);
                if ("webm" == c && !b) throw new O(2, 4, 4005);
              }
              function mp(a) {
                var b = a.I;
                return {
                  bandwidth: a.bandwidth,
                  audioSamplingRate: b.audioSamplingRate,
                  codecs: b.codecs,
                  contentType: b.contentType,
                  frameRate: b.frameRate || null,
                  height: b.height || null,
                  mimeType: b.mimeType,
                  channelsCount: b.ad,
                  pixelAspectRatio: b.pixelAspectRatio || null,
                  width: b.width || null
                };
              }
              function tp(a, b) {
                var c = lp(a, up),
                  d = vp(a);
                if (!d.ia && !d.timeline && 1 < d.Gb.length) throw new O(2, 4, 4002);
                if (!d.ia && !a.T.duration && !d.timeline && 1 == d.Gb.length) throw new O(2, 4, 4002);
                if (d.timeline && 0 == d.timeline.length) throw new O(2, 4, 4002);
                var e = null,
                  f = null;
                a.$.id && a.I.id && (f = b[a.$.id + "," + a.I.id]) && (e = f.segmentIndex);
                var g = wp(a.T.start, a.T.duration, a.I.wa, d, c);
                b = !e;
                e ? e.Hb(g, a.presentationTimeline.Pa()) : e = new Jj(g);
                a.presentationTimeline.Ib(g);
                a.Ma && a.T.Gd || e.Wa(a.T.start, a.T.duration ? a.T.start + a.T.duration : Infinity, b);
                f && (f.segmentIndex = e);
                return {
                  Bb: function Bb() {
                    e && 0 != e.g.length || e.pc(g);
                    return Promise.resolve(e);
                  }
                };
              }
              function up(a) {
                return a.ab;
              }
              function vp(a) {
                var b = xp(a);
                a = Xo(a, up);
                var c = a.Lb;
                0 == c && (c = 1);
                var d = 0;
                a.ia ? d = a.ia * (c - 1) : a.timeline && 0 < a.timeline.length && (d = a.timeline[0].start);
                return {
                  ia: a.ia,
                  startTime: d,
                  Lb: c,
                  Sa: a.Sa,
                  timeline: a.timeline,
                  Gb: b
                };
              }
              function wp(a, b, c, d, e) {
                var f = d.Gb.length;
                d.timeline && d.timeline.length != d.Gb.length && (f = Math.min(d.timeline.length, d.Gb.length));
                for (var g = a - d.Sa, h = b ? a + b : Infinity, k = [], l = d.startTime, m = {}, n = 0; n < f; m = {
                  od: m.od
                }, n++) {
                  var p = d.Gb[n];
                  m.od = ec(c, [p.dg]);
                  var t = void 0;
                  t = null != d.ia ? l + d.ia : d.timeline ? d.timeline[n].end : l + b;
                  k.push(new qi(a + l, a + t, function (v) {
                    return function () {
                      return v.od;
                    };
                  }(m), p.start, p.end, e, g, a, h));
                  l = t;
                }
                return k;
              }
              function xp(a) {
                return [a.I.ab, a.fa.ab, a.$.ab].filter(dc).map(function (b) {
                  return Mf(b, "SegmentURL");
                }).reduce(function (b, c) {
                  return 0 < b.length ? b : c;
                }).map(function (b) {
                  b.getAttribute("indexRange") && !a.Ke && (a.Ke = !0);
                  var c = b.getAttribute("media");
                  b = Uf(b, "mediaRange", Xf, {
                    start: 0,
                    end: null
                  });
                  return {
                    dg: c,
                    start: b.start,
                    end: b.end
                  };
                });
              }
              function yp(a, b, c, d, e, f) {
                var g = zp(a),
                  h = Ap(a);
                Bp(h);
                var k = We(a);
                if (h.oc) return sp(a, g), {
                  Bb: function Bb() {
                    var t = Wo(h.oc, k.I.id, null, k.bandwidth || null, null);
                    t = ec(k.I.wa, [t]);
                    return rp(k, b, g, t, 0, null, h.Sa);
                  }
                };
                if (h.ia) return d || "image" === a.fa.contentType || (a.presentationTimeline.Sd(h.ia), a.presentationTimeline.Td(a.T.start)), {
                  Bb: function Bb() {
                    return Cp(k, h, e, g, f);
                  }
                };
                var l = null;
                d = d = null;
                a.$.id && a.I.id && (d = a.$.id + "," + a.I.id, d = c[d]) && (l = d.segmentIndex);
                var m = Dp(k, h, g);
                c = a.T.start;
                var n = a.T.duration ? a.T.start + a.T.duration : Infinity,
                  p = !(a.Ma && a.T.Gd);
                l ? (p && new Jj(m).Wa(c, n, !0), l.Hb(m, a.presentationTimeline.Pa())) : l = new Jj(m);
                a.presentationTimeline.Ib(m);
                p && l.Wa(c, n);
                d && a.Ma && (d.segmentIndex = l);
                return {
                  Bb: function Bb() {
                    l && 0 != l.g.length || l.pc(m);
                    return Promise.resolve(l);
                  }
                };
              }
              function Ep(a) {
                return a.xc;
              }
              function Ap(a) {
                var b = Xo(a, Ep),
                  c = Yo(a, Ep, "media");
                a = Yo(a, Ep, "index");
                return {
                  ia: b.ia,
                  timescale: b.timescale,
                  Lb: b.Lb,
                  Sa: b.Sa,
                  se: b.se,
                  timeline: b.timeline,
                  Pd: c,
                  oc: a
                };
              }
              function Bp(a) {
                var b = a.oc ? 1 : 0;
                b += a.timeline ? 1 : 0;
                b += a.ia ? 1 : 0;
                if (0 == b) throw new O(2, 4, 4002);
                1 != b && (a.oc && (a.timeline = null), a.ia = null);
                if (!a.oc && !a.Pd) throw new O(2, 4, 4002);
              }
              function Cp(a, b, c, d, e) {
                function f(J) {
                  var L = (J - t) * p,
                    R = L + b.Sa,
                    Q = L + l;
                  L = Q + p;
                  var U = Math.min(L, h());
                  Q = new qi(Q, U, function () {
                    var N = Wo(y, x, J, w, R * v);
                    return ec(C, [N]);
                  }, 0, null, d, z, l, h());
                  Q.j = L;
                  return Q;
                }
                function g() {
                  var J = [Math.max(k.Pa(), l), Math.min(k.gb(), h())].map(function (L) {
                    return L - l;
                  });
                  return [Math.ceil(J[0] / p), Math.ceil(J[1] / p) - 1].map(function (L) {
                    return L + t;
                  });
                }
                function h() {
                  var J = null != m && e[m] || n;
                  return J ? l + J : Infinity;
                }
                var k = a.presentationTimeline,
                  l = a.T.start,
                  m = a.$.id,
                  n = a.T.duration,
                  p = b.ia,
                  t = b.Lb,
                  v = b.timescale,
                  y = b.Pd,
                  w = a.bandwidth || null,
                  x = a.I.id,
                  C = a.I.wa,
                  z = l - b.Sa,
                  B = g();
                a = a.Ma ? Math.max(B[0], B[1] - c + 1) : B[0];
                B = B[1];
                c = [];
                for (var E = a; E <= B; ++E) {
                  var F = f(E);
                  c.push(F);
                }
                var H = new Jj(c);
                c = k.gb() < h();
                E = k.U();
                if (c || E) {
                  var I = Math.max(a, B + 1);
                  H.fd(p, function () {
                    var J = k.Pa();
                    H.eb(J);
                    var L = r(g());
                    L.next();
                    L = L.next().value;
                    for (var R = []; I <= L;) {
                      var Q = f(I);
                      R.push(Q);
                      I++;
                    }
                    return J > h() && !R.length ? null : R;
                  });
                }
                return Promise.resolve(H);
              }
              function Dp(a, b, c) {
                var d = a.T.start,
                  e = a.T.duration,
                  f = d - b.Sa;
                e = e ? d + e : Infinity;
                for (var g = [], h = {}, k = 0; k < b.timeline.length; h = {
                  nd: h.nd,
                  rd: h.rd,
                  ud: h.ud,
                  kd: h.kd,
                  wd: h.wd,
                  ld: h.ld
                }, k++) {
                  var l = b.timeline[k],
                    m = l.start,
                    n = l.Dg;
                  l = l.end;
                  h.ud = k + b.Lb;
                  h.wd = n + b.se;
                  h.rd = a.I.id;
                  h.kd = a.bandwidth || null;
                  h.nd = b.Pd;
                  h.ld = a.I.wa;
                  g.push(new qi(d + m, d + l, function (p) {
                    return function () {
                      var t = Wo(p.nd, p.rd, p.ud, p.kd || null, p.wd);
                      return ec(p.ld, [t]).map(function (v) {
                        return v.toString();
                      });
                    };
                  }(h), 0, null, c, f, d, e));
                }
                return g;
              }
              function zp(a) {
                var b = Yo(a, Ep, "initialization");
                if (!b) return null;
                var c = a.I.id,
                  d = a.bandwidth || null,
                  e = a.I.wa;
                return new oi(function () {
                  var f = Wo(b, c, null, d, null);
                  return ec(e, [f]);
                }, 0, null, mp(a));
              }
              function Fp() {
                this.l = [];
                this.g = [];
                this.h = [];
                this.j = [];
                this.i = [];
                this.m = new Set();
              }
              Fp.prototype.release = function () {
                for (var a = r(this.g.concat(this.h, this.j, this.i)), b = a.next(); !b.done; b = a.next()) b = b.value, b.segmentIndex && b.segmentIndex.release();
                this.g = [];
                this.h = [];
                this.j = [];
                this.i = [];
                this.l = [];
              };
              function Gp(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N, wa, va;
                return G(function (Ma) {
                  switch (Ma.g) {
                    case 1:
                      d = kc;
                      Hp(b);
                      Ip(b);
                      Jp(b);
                      Kp(b);
                      if (!c && 1 == b.length) {
                        e = b[0];
                        a.g = e.Kc;
                        a.h = e.gd;
                        a.j = e.textStreams;
                        a.i = e.imageStreams;
                        Ma.A(2);
                        break;
                      }
                      f = -1;
                      for (g = 0; g < b.length; g++) h = b[g], a.m.has(h.id) || (a.m.add(h.id), -1 == f && (f = g));
                      if (-1 == f) return Ma.return();
                      k = b.map(function (Sa) {
                        return Sa.Kc;
                      });
                      l = b.map(function (Sa) {
                        return Sa.gd;
                      });
                      m = b.map(function (Sa) {
                        return Sa.textStreams;
                      });
                      n = b.map(function (Sa) {
                        return Sa.imageStreams;
                      });
                      p = r(m);
                      for (t = p.next(); !t.done; t = p.next()) v = t.value, v.push(Lp(d.X));
                      y = r(n);
                      for (w = y.next(); !w.done; w = y.next()) x = w.value, x.push(Lp(d.Wb));
                      return u(Ma, Mp(a.g, k, f, Np, Op), 3);
                    case 3:
                      return u(Ma, Mp(a.h, l, f, Np, Op), 4);
                    case 4:
                      return u(Ma, Mp(a.j, m, f, Np, Op), 5);
                    case 5:
                      return u(Ma, Mp(a.i, n, f, Np, Op), 2);
                    case 2:
                      C = 0;
                      z = [];
                      if (a.h.length && a.g.length) for (J = r(a.g), L = J.next(); !L.done; L = J.next()) for (R = L.value, Q = r(a.h), U = Q.next(); !U.done; U = Q.next()) N = U.value, wa = Pg(R.drmInfos, N.drmInfos), R.drmInfos.length && N.drmInfos.length && !wa.length || (va = C++, z.push({
                        id: va,
                        language: R.language,
                        primary: R.primary,
                        audio: R,
                        video: N,
                        bandwidth: (R.bandwidth || 0) + (N.bandwidth || 0),
                        drmInfos: wa,
                        allowedByApplication: !0,
                        allowedByKeySystem: !0,
                        decodingInfos: []
                      }));else for (B = a.h.concat(a.g), E = r(B), F = E.next(); !F.done; F = E.next()) H = F.value, I = C++, z.push({
                        id: I,
                        language: H.language,
                        primary: H.primary,
                        audio: H.type == d.Hc ? H : null,
                        video: H.type == d.va ? H : null,
                        bandwidth: H.bandwidth || 0,
                        drmInfos: H.drmInfos,
                        allowedByApplication: !0,
                        allowedByKeySystem: !0,
                        decodingInfos: []
                      });
                      a.l = z;
                      A(Ma);
                  }
                });
              }
              function Hp(a) {
                a = r(a);
                for (var b = a.next(); !b.done; b = a.next()) {
                  b = b.value;
                  for (var c = [], d = r(b.Kc), e = d.next(); !e.done; e = d.next()) {
                    e = e.value;
                    for (var f = !1, g = r(c), h = g.next(); !h.done; h = g.next()) h = h.value, e.id != h.id && e.channelsCount == h.channelsCount && e.language == h.language && e.bandwidth == h.bandwidth && e.label == h.label && e.codecs == h.codecs && e.mimeType == h.mimeType && ib(e.roles, h.roles) && e.audioSamplingRate == h.audioSamplingRate && e.primary == h.primary && (f = !0);
                    f || c.push(e);
                  }
                  b.Kc = c;
                }
              }
              function Jp(a) {
                a = r(a);
                for (var b = a.next(); !b.done; b = a.next()) {
                  b = b.value;
                  for (var c = [], d = r(b.textStreams), e = d.next(); !e.done; e = d.next()) {
                    e = e.value;
                    for (var f = !1, g = r(c), h = g.next(); !h.done; h = g.next()) h = h.value, e.id != h.id && e.language == h.language && e.label == h.label && e.codecs == h.codecs && e.mimeType == h.mimeType && e.bandwidth == h.bandwidth && ib(e.roles, h.roles) && (f = !0);
                    f || c.push(e);
                  }
                  b.textStreams = c;
                }
              }
              function Ip(a) {
                a = r(a);
                for (var b = a.next(); !b.done; b = a.next()) {
                  b = b.value;
                  for (var c = [], d = r(b.gd), e = d.next(); !e.done; e = d.next()) {
                    e = e.value;
                    for (var f = !1, g = r(c), h = g.next(); !h.done; h = g.next()) h = h.value, e.id != h.id && e.width == h.width && e.frameRate == h.frameRate && e.codecs == h.codecs && e.mimeType == h.mimeType && e.label == h.label && ib(e.roles, h.roles) && vf(e.closedCaptions, h.closedCaptions) && e.bandwidth == h.bandwidth && (f = !0);
                    f || c.push(e);
                  }
                  b.gd = c;
                }
              }
              function Kp(a) {
                a = r(a);
                for (var b = a.next(); !b.done; b = a.next()) {
                  b = b.value;
                  for (var c = [], d = r(b.imageStreams), e = d.next(); !e.done; e = d.next()) {
                    e = e.value;
                    for (var f = !1, g = r(c), h = g.next(); !h.done; h = g.next()) h = h.value, e.id != h.id && e.width == h.width && e.codecs == h.codecs && e.mimeType == h.mimeType && (f = !0);
                    f || c.push(e);
                  }
                  b.imageStreams = c;
                }
              }
              function Pp(a) {
                var b, c, d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R;
                return G(function (Q) {
                  switch (Q.g) {
                    case 1:
                      b = kc;
                      if (1 == a.length) return Q.return(a[0]);
                      c = a.map(function (U) {
                        return U.filter(function (N) {
                          return N.type == b.Hc;
                        });
                      });
                      d = a.map(function (U) {
                        return U.filter(function (N) {
                          return N.type == b.va;
                        });
                      });
                      e = a.map(function (U) {
                        return U.filter(function (N) {
                          return N.type == b.X;
                        });
                      });
                      f = a.map(function (U) {
                        return U.filter(function (N) {
                          return N.type == b.Wb;
                        });
                      });
                      g = r(e);
                      for (h = g.next(); !h.done; h = g.next()) k = h.value, k.push(Qp(b.X));
                      l = r(f);
                      for (m = l.next(); !m.done; m = l.next()) n = m.value, n.push(Qp(b.Wb));
                      return u(Q, Mp([], c, 0, Rp, Sp), 2);
                    case 2:
                      return p = Q.h, u(Q, Mp([], d, 0, Rp, Sp), 3);
                    case 3:
                      return t = Q.h, u(Q, Mp([], e, 0, Rp, Sp), 4);
                    case 4:
                      return v = Q.h, u(Q, Mp([], f, 0, Rp, Sp), 5);
                    case 5:
                      y = Q.h;
                      w = 0;
                      if (t.length && p.length) for (E = r(p), F = E.next(); !F.done; F = E.next()) for (H = F.value, I = r(t), J = I.next(); !J.done; J = I.next()) L = J.value, R = w++, L.variantIds.push(R), H.variantIds.push(R);else for (x = t.concat(p), C = r(x), z = C.next(); !z.done; z = C.next()) B = z.value, B.variantIds = [w++];
                      return Q.return(t.concat(p).concat(v).concat(y));
                  }
                });
              }
              function Mp(a, b, c, d, e) {
                var f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I;
                return G(function (L) {
                  switch (L.g) {
                    case 1:
                      f = kc;
                      g = [];
                      for (h = 0; h < b.length; h++) h >= c ? g.push(new Set(b[h])) : g.push(new Set());
                      k = r(a);
                      l = k.next();
                    case 2:
                      if (l.done) {
                        L.A(4);
                        break;
                      }
                      m = l.value;
                      return u(L, Tp(m, b, c, e, g), 5);
                    case 5:
                      n = L.h;
                      if (!n) throw new O(2, 4, 4037);
                      l = k.next();
                      L.A(2);
                      break;
                    case 4:
                      p = r(g);
                      for (t = p.next(); !t.done; t = p.next()) for (v = t.value, y = r(v), w = y.next(); !w.done; w = y.next()) x = w.value, (C = Up(x, b, d, e, g)) && a.push(C);
                      z = r(g);
                      for (t = z.next(); !t.done; t = z.next()) for (B = t.value, E = {}, F = r(B), w = F.next(); !w.done; E = {
                        Va: E.Va
                      }, w = F.next()) if (E.Va = w.value, H = E.Va.type == f.X && !E.Va.language, I = E.Va.type == f.Wb && !E.Va.tilesLayout, !H && !I && a.some(function (R) {
                        return function (Q) {
                          return Q.mimeType == R.Va.mimeType && ad(Q.codecs) == ad(R.Va.codecs);
                        };
                      }(E))) throw new O(2, 4, 4037);
                      return L.return(a);
                  }
                });
              }
              function Tp(a, b, c, d, e) {
                return G(function (f) {
                  if (1 == f.g) return Vp(b, a), a.matchedStreams ? a.segmentIndex ? u(f, Wp(a, c), 2) : f.A(2) : f.return(!1);
                  Xp(a, c, d, e);
                  return f.return(!0);
                });
              }
              function Wp(a, b) {
                var c, d, e, f, g, h, k;
                return G(function (l) {
                  if (1 == l.g) {
                    c = [];
                    d = a.matchedStreams;
                    e = r(d);
                    for (f = e.next(); !f.done; f = e.next()) g = f.value, c.push(g.createSegmentIndex()), g.trickModeVideo && !g.trickModeVideo.segmentIndex && c.push(g.trickModeVideo.createSegmentIndex());
                    return u(l, Promise.all(c), 2);
                  }
                  if (a.segmentIndex instanceof Nj) for (h = 0; h < d.length; h++) k = d[h], k.segmentIndex && h >= b && a.segmentIndex.l.push(k.segmentIndex);
                  A(l);
                });
              }
              function Up(a, b, c, d, e) {
                var f = c(a);
                Vp(b, f);
                f.createSegmentIndex && (f.createSegmentIndex = function () {
                  return G(function (g) {
                    if (f.segmentIndex) return g.A(0);
                    f.segmentIndex = new Nj();
                    return u(g, Wp(f, 0), 0);
                  });
                });
                if (!f.matchedStreams) return null;
                Xp(f, 0, d, e);
                return f;
              }
              function Xp(a, b, c, d) {
                for (var e = a.matchedStreams, f = 0; f < e.length; f++) if (f >= b) {
                  var g = e[f];
                  c(a, g);
                  var h = !0;
                  "audio" == a.type && 0 == sd(a.language, g.language) && (h = !1);
                  h && d[f].delete(g);
                }
              }
              function Np(a) {
                var b = Object.assign({}, a);
                b.originalId = null;
                b.createSegmentIndex = function () {
                  return Promise.resolve();
                };
                b.closeSegmentIndex = function () {
                  b.segmentIndex && (b.segmentIndex.release(), b.segmentIndex = null);
                  if (b.matchedStreams) for (var c = r(b.matchedStreams), d = c.next(); !d.done; d = c.next()) d = d.value, d.segmentIndex && (d.segmentIndex.release(), d.segmentIndex = null);
                };
                b.segmentIndex = null;
                b.emsgSchemeIdUris = [];
                b.keyIds = new Set();
                b.closedCaptions = null;
                b.trickModeVideo = null;
                return b;
              }
              function Rp(a) {
                a = Object.assign({}, a);
                a.keyIds = new Set();
                a.segments = [];
                a.variantIds = [];
                a.closedCaptions = null;
                return a;
              }
              function Op(a, b) {
                a.roles = Array.from(new Set(a.roles.concat(b.roles)));
                b.emsgSchemeIdUris && (a.emsgSchemeIdUris = Array.from(new Set(a.emsgSchemeIdUris.concat(b.emsgSchemeIdUris))));
                a.keyIds = function (f, g) {
                  return new Set([].concat(ha(f), ha(g)));
                }(a.keyIds, b.keyIds);
                null == a.originalId ? a.originalId = b.originalId : a.originalId += "," + (b.originalId || "");
                var c = Pg(a.drmInfos, b.drmInfos);
                if (b.drmInfos.length && a.drmInfos.length && !c.length) throw new O(2, 4, 4038);
                a.drmInfos = c;
                a.encrypted = a.encrypted || b.encrypted;
                if (b.closedCaptions) {
                  a.closedCaptions || (a.closedCaptions = new Map());
                  c = r(b.closedCaptions);
                  for (var d = c.next(); !d.done; d = c.next()) {
                    var e = r(d.value);
                    d = e.next().value;
                    e = e.next().value;
                    a.closedCaptions.set(d, e);
                  }
                }
                b.trickModeVideo ? (a.trickModeVideo || (a.trickModeVideo = Np(b.trickModeVideo), a.trickModeVideo.createSegmentIndex = function () {
                  a.trickModeVideo.segmentIndex = a.segmentIndex.clone();
                  return Promise.resolve();
                }), Op(a.trickModeVideo, b.trickModeVideo)) : a.trickModeVideo && Op(a.trickModeVideo, b);
              }
              function Sp(a, b) {
                a.roles = Array.from(new Set(a.roles.concat(b.roles)));
                var c = b.keyIds;
                c = new Set([].concat(ha(a.keyIds), ha(c)));
                a.keyIds = c;
                a.encrypted = a.encrypted && b.encrypted;
                a.segments.push.apply(a.segments, ha(b.segments));
                if (b.closedCaptions) for (a.closedCaptions || (a.closedCaptions = new Map()), b = r(b.closedCaptions), c = b.next(); !c.done; c = b.next()) {
                  var d = r(c.value);
                  c = d.next().value;
                  d = d.next().value;
                  a.closedCaptions.set(c, d);
                }
              }
              function Vp(a, b) {
                var c = [];
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) {
                  var e = b,
                    f = {
                      audio: Yp,
                      video: Yp,
                      text: Zp,
                      image: $p
                    }[e.type],
                    g = {
                      audio: aq,
                      video: bq,
                      text: cq,
                      image: dq
                    }[e.type],
                    h = null;
                  d = r(d.value);
                  for (var k = d.next(); !k.done; k = d.next()) k = k.value, !f(e, k) || h && !g(e, h, k) || (h = k);
                  e = h;
                  if (!e) return;
                  c.push(e);
                }
                b.matchedStreams = c;
              }
              function Yp(a, b) {
                var c;
                !(c = b.mimeType != a.mimeType || ad(b.codecs) != ad(a.codecs)) && (c = a.drmInfos) && (a = a.drmInfos, b = b.drmInfos, c = !(a.length && b.length ? 0 < Pg(a, b).length : 1));
                return c ? !1 : !0;
              }
              function Zp(a, b) {
                return a.language ? b.language ? 0 == sd(a.language, b.language) || b.kind != a.kind ? !1 : !0 : !0 : !1;
              }
              function $p(a) {
                return a.tilesLayout ? !0 : !1;
              }
              function aq(a, b, c) {
                if (a.id == c.id) return !0;
                var d = sd(a.language, b.language),
                  e = sd(a.language, c.language);
                if (e > d) return !0;
                if (e < d) return !1;
                if (a.roles.length) return d = b.roles.filter(function (f) {
                  return a.roles.includes(f);
                }), e = c.roles.filter(function (f) {
                  return a.roles.includes(f);
                }), e.length > d.length ? !0 : e.length < d.length ? !1 : c.roles.length < b.roles.length;
                if (!c.roles.length && b.roles.length) return !0;
                if (c.roles.length && !b.roles.length) return !1;
                if (!b.primary && c.primary) return !0;
                if (b.primary && !c.primary) return !1;
                d = eq(a.channelsCount, b.channelsCount, c.channelsCount);
                if (d == fq) return !0;
                if (d == gq) return !1;
                d = eq(a.audioSamplingRate, b.audioSamplingRate, c.audioSamplingRate);
                return d == fq ? !0 : d == gq ? !1 : a.bandwidth && hq(a.bandwidth, b.bandwidth, c.bandwidth) == fq ? !0 : !1;
              }
              function bq(a, b, c) {
                if (a.id == c.id) return !0;
                var d = eq(a.width * a.height, b.width * b.height, c.width * c.height);
                if (d == fq) return !0;
                if (d == gq) return !1;
                if (a.frameRate) {
                  d = eq(a.frameRate, b.frameRate, c.frameRate);
                  if (d == fq) return !0;
                  if (d == gq) return !1;
                }
                return a.bandwidth && hq(a.bandwidth, b.bandwidth, c.bandwidth) == fq ? !0 : !1;
              }
              function cq(a, b, c) {
                if (a.id == c.id) return !0;
                var d = sd(a.language, b.language),
                  e = sd(a.language, c.language);
                if (e > d) return !0;
                if (e < d) return !1;
                if (!b.primary && c.primary) return !0;
                if (b.primary && !c.primary) return !1;
                if (a.roles.length) {
                  d = b.roles.filter(function (f) {
                    return a.roles.includes(f);
                  });
                  e = c.roles.filter(function (f) {
                    return a.roles.includes(f);
                  });
                  if (e.length > d.length) return !0;
                  if (e.length < d.length) return !1;
                } else {
                  if (!c.roles.length && b.roles.length) return !0;
                  if (c.roles.length && !b.roles.length) return !1;
                }
                return c.mimeType != a.mimeType || c.codecs != a.codecs || b.mimeType == a.mimeType && b.codecs == a.codecs ? !1 : !0;
              }
              function dq(a, b, c) {
                return a.id == c.id ? !0 : eq(a.width * a.height, b.width * b.height, c.width * c.height) == fq ? !0 : !1;
              }
              function Qp(a) {
                return {
                  id: 0,
                  originalId: "",
                  primary: !1,
                  type: a,
                  mimeType: "",
                  codecs: "",
                  language: "",
                  label: null,
                  width: null,
                  height: null,
                  encrypted: !1,
                  keyIds: new Set(),
                  segments: [],
                  variantIds: [],
                  roles: [],
                  forced: !1,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  closedCaptions: null
                };
              }
              function Lp(a) {
                return {
                  id: 0,
                  originalId: "",
                  createSegmentIndex: function createSegmentIndex() {
                    return Promise.resolve();
                  },
                  segmentIndex: new Jj([]),
                  mimeType: "",
                  codecs: "",
                  encrypted: !1,
                  drmInfos: [],
                  keyIds: new Set(),
                  language: "",
                  label: null,
                  type: a,
                  primary: !1,
                  trickModeVideo: null,
                  emsgSchemeIdUris: null,
                  roles: [],
                  forced: !1,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: !1,
                  closedCaptions: null
                };
              }
              function eq(a, b, c) {
                if (b == a && a != c) return gq;
                if (c == a && a != b) return fq;
                if (b > a) {
                  if (c <= a || c - a < b - a) return fq;
                  if (c - a > b - a) return gq;
                } else {
                  if (c > a) return gq;
                  if (a - c < a - b) return fq;
                  if (a - c > a - b) return gq;
                }
                return iq;
              }
              function hq(a, b, c) {
                b = Math.abs(a - b);
                a = Math.abs(a - c);
                return a < b ? fq : b < a ? gq : iq;
              }
              var fq = 1,
                iq = 0,
                gq = -1;
              function jq() {
                var a = this;
                this.h = this.g = null;
                this.m = [];
                this.i = null;
                this.G = 1;
                this.l = {};
                this.L = {};
                this.j = new Fp();
                this.F = 0;
                this.H = new Pa(5);
                this.D = new P(function () {
                  kq(a);
                });
                this.o = new Xe();
                this.s = null;
                this.J = [];
                this.u = Infinity;
                this.B = !1;
              }
              q = jq.prototype;
              q.configure = function (a) {
                this.g = a;
              };
              q.start = function (a, b) {
                var c = this,
                  d;
                return G(function (e) {
                  if (1 == e.g) return c.B = b.isLowLatencyMode(), c.m = [a], c.h = b, u(e, lq(c), 2);
                  d = e.h;
                  c.h && mq(c, d);
                  if (!c.h) throw new O(2, 7, 7001);
                  return e.return(c.i);
                });
              };
              q.stop = function () {
                for (var a = r(Object.values(this.l)), b = a.next(); !b.done; b = a.next()) b = b.value, b.segmentIndex && b.segmentIndex.release();
                this.j && this.j.release();
                this.g = this.h = null;
                this.m = [];
                this.i = null;
                this.l = {};
                this.j = null;
                null != this.D && (this.D.stop(), this.D = null);
                return this.o.destroy();
              };
              q.update = function () {
                var a = this,
                  b;
                return G(function (c) {
                  if (1 == c.g) return D(c, 2), u(c, lq(a), 4);
                  if (2 != c.g) return ta(c, 0);
                  b = ua(c);
                  if (!a.h || !b) return c.return();
                  a.h.onError(b);
                  A(c);
                });
              };
              q.onExpirationUpdated = function () {};
              function lq(a) {
                var b, c, d, e, f, g, h;
                return G(function (k) {
                  if (1 == k.g) return b = cf(a.m, a.g.retryParameters), c = a.h.networkingEngine, a.h.modifyManifestRequest(b, {
                    format: "d"
                  }), d = Date.now(), e = c.request(0, b), Ye(a.o, e), u(k, e.promise, 2);
                  if (3 != k.g) {
                    f = k.h;
                    if (!a.h) return k.return(0);
                    f.uri && !a.m.includes(f.uri) && a.m.unshift(f.uri);
                    return u(k, nq(a, f.data, f.uri), 3);
                  }
                  g = Date.now();
                  h = (g - d) / 1E3;
                  a.H.sample(1, h);
                  return k.return(h);
                });
              }
              function nq(a, b, c) {
                var d, f, g, h;
                return G(function (k) {
                  if (1 == k.g) {
                    d = eg(b, "MPD");
                    if (!d) throw new O(2, 4, 4001, c);
                    if (a.g.dash.disableXlinkProcessing) return k.return(oq(a, d, c));
                    f = a.g.dash.xlinkFailGracefully;
                    g = ap(d, a.g.retryParameters, f, c, a.h.networkingEngine);
                    Ye(a.o, g);
                    return u(k, g.promise, 2);
                  }
                  h = k.h;
                  return k.return(oq(a, h, c));
                });
              }
              function oq(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, R, Q, U, N, wa, Ma, Sa;
                return G(function (Ga) {
                  switch (Ga.g) {
                    case 1:
                      (d = a.g.dash.manifestPreprocessor) && d(b);
                      e = [c];
                      f = Mf(b, "Location").map(Sf).filter(dc);
                      0 < f.length && (g = ec(e, f), e = a.m = g);
                      h = Mf(b, "BaseURL");
                      k = h.map(Sf);
                      l = ec(e, k);
                      m = 0;
                      h && h.length && (m = Uf(h[0], "availabilityTimeOffset", ag) || 0);
                      n = a.g.dash.ignoreMinBufferTime;
                      p = 0;
                      n || (p = Uf(b, "minBufferTime", Wf) || 0);
                      a.F = Uf(b, "minimumUpdatePeriod", Wf, -1);
                      t = Uf(b, "availabilityStartTime", Vf);
                      v = Uf(b, "timeShiftBufferDepth", Wf);
                      y = a.g.dash.ignoreSuggestedPresentationDelay;
                      w = null;
                      y || (w = Uf(b, "suggestedPresentationDelay", Wf));
                      x = a.g.dash.ignoreMaxSegmentDuration;
                      C = null;
                      x || (C = Uf(b, "maxSegmentDuration", Wf));
                      z = b.getAttribute("type") || "static";
                      if (a.i) for (B = a.i.presentationTimeline, E = r(Object.values(a.l)), F = E.next(); !F.done; F = E.next()) H = F.value, H.segmentIndex && H.segmentIndex.eb(B.Pa());else I = a.g.defaultPresentationDelay || 1.5 * p, J = null != w ? w : I, B = new T(t, J, a.g.dash.autoCorrectDrift);
                      B.yc("static" == z);
                      B.U() && !isNaN(a.g.availabilityWindowOverride) && (v = a.g.availabilityWindowOverride);
                      null == v && (v = Infinity);
                      B.me(v);
                      R = b.getAttribute("profiles") || "";
                      Q = {
                        Ma: "static" != z,
                        presentationTimeline: B,
                        $: null,
                        T: null,
                        fa: null,
                        I: null,
                        bandwidth: 0,
                        Ke: !1,
                        zb: m,
                        profiles: R.split(",")
                      };
                      U = pq(a, Q, l, b);
                      N = U.duration;
                      wa = U.periods;
                      "static" != z && U.De || B.Aa(N || Infinity);
                      a.u && !a.B && a.h.isAutoLowLatencyMode() && (a.h.enableLowLatencyMode(), a.B = a.h.isLowLatencyMode());
                      a.B ? B.Ue(a.u) : a.u && Wa("Low-latency DASH live stream detected, but low-latency streaming mode is not enabled in Shaka Player. Set streaming.lowLatencyMode configuration to true, and see https://bit.ly/3clctcj for details.");
                      B.Sd(C || 1);
                      return u(Ga, Gp(a.j, wa, Q.Ma), 2);
                    case 2:
                      if (a.i) {
                        a.i.variants = a.j.l;
                        a.i.textStreams = a.j.j.slice();
                        a.i.imageStreams = a.j.i;
                        a.h.filter(a.i);
                        Ga.A(3);
                        break;
                      }
                      a.i = {
                        presentationTimeline: B,
                        variants: a.j.l,
                        textStreams: a.j.j.slice(),
                        imageStreams: a.j.i,
                        offlineSessionIds: [],
                        minBufferTime: p || 0,
                        sequenceMode: a.g.dash.sequenceMode
                      };
                      if (!B.df()) {
                        Ga.A(4);
                        break;
                      }
                      Ma = Mf(b, "UTCTiming");
                      return u(Ga, qq(a, l, Ma), 5);
                    case 5:
                      Sa = Ga.h;
                      if (!a.h) return Ga.return();
                      B.Ve(Sa);
                    case 4:
                      B.Md();
                    case 3:
                      a.h.makeTextStreamsForClosedCaptions(a.i), A(Ga);
                  }
                });
              }
              function pq(a, b, c, d) {
                var e = Uf(d, "mediaPresentationDuration", Wf),
                  f = [],
                  g = 0;
                d = Mf(d, "Period");
                for (var h = 0; h < d.length; h++) {
                  var k = d[h],
                    l = d[h + 1],
                    m = Uf(k, "start", Wf, g),
                    n = k.id,
                    p = Uf(k, "duration", Wf),
                    t = null;
                  if (l) {
                    var v = Uf(l, "start", Wf);
                    null != v && (t = v - m);
                  } else null != e && (t = e - m);
                  null == t && (t = p);
                  if (!(null !== a.s && null !== n && null !== m && m < a.s) || a.J.includes(n) || h + 1 == d.length) {
                    null !== m && (null === a.s || m > a.s) && (a.s = m);
                    g = rq(a, b, c, {
                      start: m,
                      duration: t,
                      node: k,
                      Gd: null == t || !l
                    });
                    f.push(g);
                    b.$.id && t && (a.L[b.$.id] = t);
                    if (null == t) {
                      g = null;
                      break;
                    }
                    g = m + t;
                  }
                }
                a.J = f.map(function (y) {
                  return y.id;
                });
                return null != e ? {
                  periods: f,
                  duration: e,
                  De: !1
                } : {
                  periods: f,
                  duration: g,
                  De: !0
                };
              }
              function rq(a, b, c, d) {
                b.$ = sq(d.node, null, c);
                b.T = d;
                b.$.zb = b.zb;
                b.$.id || (b.$.id = "__shaka_period_" + d.start);
                var e = Mf(d.node, "EventStream");
                c = b.presentationTimeline.Pa();
                e = r(e);
                for (var f = e.next(); !f.done; f = e.next()) tq(a, d.start, d.duration, f.value, c);
                c = Mf(d.node, "AdaptationSet").map(function (m) {
                  return uq(a, b, m);
                }).filter(dc);
                if (b.Ma) {
                  d = [];
                  e = r(c);
                  for (f = e.next(); !f.done; f = e.next()) {
                    f = r(f.value.qg);
                    for (var g = f.next(); !g.done; g = f.next()) d.push(g.value);
                  }
                  if (d.length != new Set(d).size) throw new O(2, 4, 4018);
                }
                d = c.filter(function (m) {
                  return !m.qe;
                });
                c = c.filter(function (m) {
                  return m.qe;
                });
                c = r(c);
                for (e = c.next(); !e.done; e = c.next()) {
                  e = e.value;
                  f = e.qe.split(" ");
                  g = r(d);
                  for (var h = g.next(); !h.done; h = g.next()) {
                    var k = h.value;
                    if (f.includes(k.id)) {
                      h = {};
                      k = r(k.streams);
                      for (var l = k.next(); !l.done; h = {
                        Gc: h.Gc
                      }, l = k.next()) h.Gc = l.value, h.Gc.trickModeVideo = e.streams.find(function (m) {
                        return function (n) {
                          return ad(m.Gc.codecs) == ad(n.codecs);
                        };
                      }(h));
                    }
                  }
                }
                e = a.g.disableAudio ? [] : vq(d, "audio");
                g = a.g.disableVideo ? [] : vq(d, "video");
                f = a.g.disableText ? [] : vq(d, jc);
                c = a.g.disableThumbnails ? [] : vq(d, "image");
                if (!g.length && !e.length) throw new O(2, 4, 4004);
                d = [];
                e = r(e);
                for (h = e.next(); !h.done; h = e.next()) d.push.apply(d, ha(h.value.streams));
                e = [];
                g = r(g);
                for (h = g.next(); !h.done; h = g.next()) e.push.apply(e, ha(h.value.streams));
                g = [];
                f = r(f);
                for (h = f.next(); !h.done; h = f.next()) g.push.apply(g, ha(h.value.streams));
                f = [];
                c = r(c);
                for (h = c.next(); !h.done; h = c.next()) f.push.apply(f, ha(h.value.streams));
                return {
                  id: b.$.id,
                  Kc: d,
                  gd: e,
                  textStreams: g,
                  imageStreams: f
                };
              }
              function vq(a, b) {
                return a.filter(function (c) {
                  return c.contentType == b;
                });
              }
              function uq(a, b, c) {
                function d(F) {
                  switch (F) {
                    case 1:
                    case 6:
                    case 13:
                    case 14:
                    case 15:
                      return "SDR";
                    case 16:
                      return "PQ";
                    case 18:
                      return "HLG";
                  }
                }
                b.fa = sq(c, b.$, null);
                var e = !1,
                  f = Mf(c, "Role"),
                  g = f.map(function (F) {
                    return F.getAttribute("value");
                  }).filter(dc),
                  h = void 0,
                  k = b.fa.contentType == jc;
                k && (h = "subtitle");
                f = r(f);
                for (var l = f.next(); !l.done; l = f.next()) {
                  l = l.value;
                  var m = l.getAttribute("schemeIdUri");
                  if (null == m || "urn:mpeg:dash:role:2011" == m) switch (l = l.getAttribute("value"), l) {
                    case "main":
                      e = !0;
                      break;
                    case "caption":
                    case "subtitle":
                      h = l;
                  }
                }
                var n;
                m = Mf(c, "EssentialProperty");
                f = null;
                l = !1;
                m = r(m);
                for (var p = m.next(); !p.done; p = m.next()) {
                  p = p.value;
                  var t = p.getAttribute("schemeIdUri");
                  "http://dashif.org/guidelines/trickmode" == t ? f = p.getAttribute("value") : "urn:mpeg:mpegB:cicp:TransferCharacteristics" == t ? n = d(parseInt(p.getAttribute("value"), 10)) : l = !0;
                }
                m = Mf(c, "SupplementalProperty");
                m = r(m);
                for (p = m.next(); !p.done; p = m.next()) p = p.value, "urn:mpeg:mpegB:cicp:TransferCharacteristics" == p.getAttribute("schemeIdUri") && (n = d(parseInt(p.getAttribute("value"), 10)));
                m = Mf(c, "Accessibility");
                var v = new Map();
                m = r(m);
                for (p = m.next(); !p.done; p = m.next()) if (t = p.value, p = t.getAttribute("schemeIdUri"), t = t.getAttribute("value"), "urn:scte:dash:cc:cea-608:2015" == p) {
                  if (p = 1, null != t) {
                    t = t.split(";");
                    for (var y = r(t), w = y.next(); !w.done; w = y.next()) {
                      var x = w.value,
                        C = w = void 0;
                      x.includes("=") ? (x = x.split("="), w = x[0].startsWith("CC") ? x[0] : "CC" + x[0], C = x[1] || "und") : (w = "CC" + p, 2 == t.length ? p += 2 : p++, C = x);
                      v.set(w, od(C));
                    }
                  } else v.set("CC1", "und");
                } else if ("urn:scte:dash:cc:cea-708:2015" == p) {
                  if (p = 1, null != t) for (t = r(t.split(";")), w = t.next(); !w.done; w = t.next()) w = w.value, x = y = void 0, w.includes("=") ? (w = w.split("="), y = "svc" + w[0], x = w[1].split(",")[0].split(":").pop()) : (y = "svc" + p, p++, x = w), v.set(y, od(x));else v.set("svc1", "und");
                } else "urn:mpeg:dash:role:2011" == p && null != t && (g.push(t), "captions" == t && (h = "caption"));
                if (l) return null;
                l = Mf(c, "ContentProtection");
                var z = Mo(l, a.g.dash.ignoreDrmInfo, a.g.dash.keySystemsByURI),
                  B = od(c.getAttribute("lang") || "und"),
                  E = c.getAttribute("label");
                (l = Mf(c, "Label")) && l.length && (l = l[0], l.textContent && (E = l.textContent));
                l = Mf(c, "Representation");
                c = l.map(function (F) {
                  if (F = wq(a, b, z, h, B, E, e, g, v, F)) F.hdr = F.hdr || n;
                  return F;
                }).filter(function (F) {
                  return !!F;
                });
                if (0 == c.length) {
                  f = "image" == b.fa.contentType;
                  if (a.g.dash.ignoreEmptyAdaptationSet || k || f) return null;
                  throw new O(2, 4, 4003);
                }
                if (!b.fa.contentType || "application" == b.fa.contentType) for (b.fa.contentType = xq(c[0].mimeType, c[0].codecs), k = r(c), m = k.next(); !m.done; m = k.next()) m.value.type = b.fa.contentType;
                k = r(c);
                for (m = k.next(); !m.done; m = k.next()) for (m = m.value, p = r(z.drmInfos), t = p.next(); !t.done; t = p.next()) t = t.value, t.keyIds = t.keyIds && m.keyIds ? new Set([].concat(ha(t.keyIds), ha(m.keyIds))) : t.keyIds || m.keyIds;
                k = l.map(function (F) {
                  return F.getAttribute("id");
                }).filter(dc);
                return {
                  id: b.fa.id || "__fake__" + a.G++,
                  contentType: b.fa.contentType,
                  language: B,
                  th: e,
                  streams: c,
                  drmInfos: z.drmInfos,
                  qe: f,
                  qg: k
                };
              }
              function wq(a, b, c, d, e, f, g, h, k, l) {
                b.I = sq(l, b.fa, null);
                a.u = Math.min(a.u, b.I.zb);
                if (!yq(b.I)) return null;
                var m = b.T.start;
                b.bandwidth = Uf(l, "bandwidth", Zf) || 0;
                var n = b.I.contentType,
                  p = n == jc || "application" == n;
                n = "image" == n;
                try {
                  var t = function t(H, I, J) {
                    return zq(a, H, I, J);
                  };
                  if (b.I.wc) var v = np(b, t);else if (b.I.ab) v = tp(b, a.l);else if (b.I.xc) v = yp(b, t, a.l, !!a.i, a.g.dash.initialSegmentLimit, a.L);else {
                    var y = b.I.wa,
                      w = b.T.duration || 0;
                    v = {
                      Bb: function Bb() {
                        return Promise.resolve(Mj(m, w, y));
                      }
                    };
                  }
                } catch (H) {
                  if ((p || n) && 4002 == H.code) return null;
                  throw H;
                }
                t = Mf(l, "ContentProtection");
                t = Po(t, c, a.g.dash.ignoreDrmInfo, a.g.dash.keySystemsByURI);
                t = new Set(t ? [t] : []);
                var x = !1;
                Mf(l, "SupplementalProperty").some(function (H) {
                  return "tag:dolby.com,2018:dash:EC3_ExtensionType:2018" == H.getAttribute("schemeIdUri") && "JOC" == H.getAttribute("value");
                }) && (x = !0);
                var C = !1;
                p && (C = h.includes("forced_subtitle") || h.includes("forced-subtitle"));
                var z;
                if (n && ((l = Mf(l, "EssentialProperty").find(function (H) {
                  return ["http://dashif.org/thumbnail_tile", "http://dashif.org/guidelines/thumbnail_tile"].includes(H.getAttribute("schemeIdUri"));
                })) && (z = l.getAttribute("value")), !z)) return null;
                var B;
                l = b.I.codecs;
                b.profiles.includes("http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10") && (l.includes("hvc1.2.4.L153.B0") || l.includes("hev1.2.4.L153.B0")) && (B = "PQ");
                var E = b.I.id ? b.$.id + "," + b.I.id : "",
                  F = {
                    id: a.G++,
                    originalId: b.I.id,
                    createSegmentIndex: function createSegmentIndex() {
                      var I, J;
                      return G(function (L) {
                        if (1 == L.g) {
                          I = E && b.Ma && a.l[E] ? a.l[E] : F;
                          if (I.segmentIndex) return L.A(0);
                          J = I;
                          return u(L, v.Bb(), 3);
                        }
                        J.segmentIndex = L.h;
                        A(L);
                      });
                    },
                    closeSegmentIndex: function closeSegmentIndex() {
                      F.segmentIndex && (F.segmentIndex.release(), F.segmentIndex = null);
                    },
                    segmentIndex: null,
                    mimeType: b.I.mimeType,
                    codecs: b.I.codecs,
                    frameRate: b.I.frameRate,
                    pixelAspectRatio: b.I.pixelAspectRatio,
                    bandwidth: b.bandwidth,
                    width: b.I.width,
                    height: b.I.height,
                    kind: d,
                    encrypted: 0 < c.drmInfos.length,
                    drmInfos: c.drmInfos,
                    keyIds: t,
                    language: e,
                    label: f,
                    type: b.fa.contentType,
                    primary: g,
                    trickModeVideo: null,
                    emsgSchemeIdUris: b.I.emsgSchemeIdUris,
                    roles: h,
                    forced: C,
                    channelsCount: b.I.ad,
                    audioSamplingRate: b.I.audioSamplingRate,
                    spatialAudio: x,
                    closedCaptions: k,
                    hdr: B,
                    tilesLayout: z,
                    matchedStreams: []
                  };
                E && b.Ma && !a.l[E] && (a.l[E] = F);
                return F;
              }
              function kq(a) {
                var b, c;
                G(function (d) {
                  switch (d.g) {
                    case 1:
                      return b = 0, D(d, 2), u(d, lq(a), 4);
                    case 4:
                      b = d.h;
                      ta(d, 3);
                      break;
                    case 2:
                      c = ua(d), a.h && (c.severity = 1, a.h.onError(c));
                    case 3:
                      if (!a.h) return d.return();
                      mq(a, b);
                      A(d);
                  }
                });
              }
              function mq(a, b) {
                0 > a.F || a.D.N(Math.max(3, a.F - b, Qa(a.H)));
              }
              function sq(a, b, c) {
                b = b || {
                  contentType: "",
                  mimeType: "",
                  codecs: "",
                  emsgSchemeIdUris: [],
                  frameRate: void 0,
                  pixelAspectRatio: void 0,
                  ad: null,
                  audioSamplingRate: null,
                  zb: 0
                };
                c = c || b.wa;
                var d = Mf(a, "BaseURL"),
                  e = d.map(Sf),
                  f = a.getAttribute("contentType") || b.contentType,
                  g = a.getAttribute("mimeType") || b.mimeType,
                  h = a.getAttribute("codecs") || b.codecs,
                  k = Uf(a, "frameRate", bg) || b.frameRate,
                  l = a.getAttribute("sar") || b.pixelAspectRatio,
                  m = Mf(a, "InbandEventStream"),
                  n = b.emsgSchemeIdUris.slice();
                m = r(m);
                for (var p = m.next(); !p.done; p = m.next()) p = p.value.getAttribute("schemeIdUri"), n.includes(p) || n.push(p);
                m = Mf(a, "AudioChannelConfiguration");
                m = Aq(m) || b.ad;
                p = Uf(a, "audioSamplingRate", $f) || b.audioSamplingRate;
                f || (f = xq(g, h));
                var t = Lf(a, "SegmentBase"),
                  v = Lf(a, "SegmentTemplate"),
                  y = t ? Uf(t, "availabilityTimeOffset", ag) || 0 : 0,
                  w = v ? Uf(v, "availabilityTimeOffset", ag) || 0 : 0;
                d = d && d.length ? Uf(d[0], "availabilityTimeOffset", ag) || 0 : 0;
                d = b.zb + d + y + w;
                return {
                  wa: ec(c, e),
                  wc: t || b.wc,
                  ab: Lf(a, "SegmentList") || b.ab,
                  xc: v || b.xc,
                  width: Uf(a, "width", $f) || b.width,
                  height: Uf(a, "height", $f) || b.height,
                  contentType: f,
                  mimeType: g,
                  codecs: h,
                  frameRate: k,
                  pixelAspectRatio: l,
                  emsgSchemeIdUris: n,
                  id: a.getAttribute("id"),
                  ad: m,
                  audioSamplingRate: p,
                  zb: d
                };
              }
              function Aq(a) {
                a = r(a);
                for (var b = a.next(); !b.done; b = a.next()) {
                  var c = b.value;
                  if (b = c.getAttribute("schemeIdUri")) if (c = c.getAttribute("value")) switch (b) {
                    case "urn:mpeg:dash:outputChannelPositionList:2012":
                      return c.trim().split(/ +/).length;
                    case "urn:mpeg:dash:23003:3:audio_channel_configuration:2011":
                    case "urn:dts:dash:audio_channel_configuration:2012":
                      b = parseInt(c, 10);
                      if (!b) continue;
                      return b;
                    case "tag:dolby.com,2014:dash:audio_channel_configuration:2011":
                    case "urn:dolby:dash:audio_channel_configuration:2011":
                      b = parseInt(c, 16);
                      if (!b) continue;
                      for (a = 0; b;) b & 1 && ++a, b >>= 1;
                      return a;
                    case "urn:mpeg:mpegB:cicp:ChannelConfiguration":
                      if (b = [0, 1, 2, 3, 4, 5, 6, 8, 2, 3, 4, 7, 8, 24, 8, 12, 10, 12, 14, 12, 14], (c = parseInt(c, 10)) && 0 < c && c < b.length) return b[c];
                  }
                }
                return null;
              }
              function yq(a) {
                var b = a.wc ? 1 : 0;
                b += a.ab ? 1 : 0;
                b += a.xc ? 1 : 0;
                if (0 == b) return a.contentType == jc || "application" == a.contentType ? !0 : !1;
                1 != b && (a.wc && (a.ab = null), a.xc = null);
                return !0;
              }
              function Bq(a, b, c, d) {
                var e, f, g, h, k, l;
                return G(function (m) {
                  if (1 == m.g) return e = ec(b, [c]), f = cf(e, a.g.retryParameters), f.method = d, g = a.h.networkingEngine.request(4, f), Ye(a.o, g), u(m, g.promise, 2);
                  h = m.h;
                  if ("HEAD" == d) {
                    if (!h.headers || !h.headers.date) return m.return(0);
                    k = h.headers.date;
                  } else k = Cc(h.data);
                  l = Date.parse(k);
                  return isNaN(l) ? m.return(0) : m.return(l - Date.now());
                });
              }
              function qq(a, b, c) {
                var d, e, f, g, h, k, l, m;
                return G(function (n) {
                  switch (n.g) {
                    case 1:
                      d = c.map(function (p) {
                        return {
                          scheme: p.getAttribute("schemeIdUri"),
                          value: p.getAttribute("value")
                        };
                      }), e = a.g.dash.clockSyncUri, !d.length && e && d.push({
                        scheme: "urn:mpeg:dash:utc:http-head:2014",
                        value: e
                      }), f = r(d), g = f.next();
                    case 2:
                      if (g.done) {
                        n.A(4);
                        break;
                      }
                      h = g.value;
                      D(n, 5);
                      k = h.scheme;
                      l = h.value;
                      switch (k) {
                        case "urn:mpeg:dash:utc:http-head:2014":
                        case "urn:mpeg:dash:utc:http-head:2012":
                          return n.A(7);
                        case "urn:mpeg:dash:utc:http-xsdate:2014":
                        case "urn:mpeg:dash:utc:http-iso:2014":
                        case "urn:mpeg:dash:utc:http-xsdate:2012":
                        case "urn:mpeg:dash:utc:http-iso:2012":
                          return n.A(8);
                        case "urn:mpeg:dash:utc:direct:2014":
                        case "urn:mpeg:dash:utc:direct:2012":
                          return m = Date.parse(l), n.return(isNaN(m) ? 0 : m - Date.now());
                        case "urn:mpeg:dash:utc:http-ntp:2014":
                        case "urn:mpeg:dash:utc:ntp:2014":
                        case "urn:mpeg:dash:utc:sntp:2014":
                          Wa("NTP UTCTiming scheme is not supported");
                          break;
                        default:
                          Wa("Unrecognized scheme in UTCTiming element", k);
                      }
                      n.A(9);
                      break;
                    case 7:
                      return u(n, Bq(a, b, l, "HEAD"), 10);
                    case 10:
                      return n.return(n.h);
                    case 8:
                      return u(n, Bq(a, b, l, "GET"), 11);
                    case 11:
                      return n.return(n.h);
                    case 9:
                      ta(n, 3);
                      break;
                    case 5:
                      ua(n);
                    case 3:
                      g = f.next();
                      n.A(2);
                      break;
                    case 4:
                      return Wa("A UTCTiming element should always be given in live manifests! This content may not play on clients with bad clocks!"), n.return(0);
                  }
                });
              }
              function tq(a, b, c, d, e) {
                var f = d.getAttribute("schemeIdUri") || "",
                  g = d.getAttribute("value") || "",
                  h = Uf(d, "timescale", $f) || 1;
                d = r(Mf(d, "Event"));
                for (var k = d.next(); !k.done; k = d.next()) {
                  k = k.value;
                  var l = Uf(k, "presentationTime", $f) || 0,
                    m = Uf(k, "duration", $f) || 0;
                  l = l / h + b;
                  m = l + m / h;
                  null != c && (l = Math.min(l, b + c), m = Math.min(m, b + c));
                  m < e || (k = {
                    schemeIdUri: f,
                    value: g,
                    startTime: l,
                    endTime: m,
                    id: k.getAttribute("id") || "",
                    eventElement: k
                  }, a.h.onTimelineRegionAdded(k));
                }
              }
              function zq(a, b, c, d) {
                var e, f, g, h, k;
                return G(function (l) {
                  if (1 == l.g) return e = jf, f = ck(b, c, d, a.g.retryParameters), g = a.h.networkingEngine, h = g.request(e, f), Ye(a.o, h), u(l, h.promise, 2);
                  k = l.h;
                  return l.return(k.data);
                });
              }
              function xq(a, b) {
                return ed(Zc(a, b)) ? jc : a.split("/")[0];
              }
              K("shaka.dash.DashParser", jq);
              Vg.mpd = function () {
                return new jq();
              };
              Tg["application/dash+xml"] = function () {
                return new jq();
              };
              Tg["video/vnd.mpeg.dash.mpd"] = function () {
                return new jq();
              };
              function Cq(a, b, c, d) {
                this.h = a;
                this.type = b;
                this.g = c;
                this.segments = d || null;
              }
              function Dq(a, b, c, d) {
                this.id = a;
                this.name = b;
                this.g = c;
                this.value = void 0 === d ? null : d;
              }
              Dq.prototype.toString = function () {
                function a(d) {
                  return d.name + "=" + (isNaN(Number(d.value)) ? '"' + d.value + '"' : d.value);
                }
                var b = "#" + this.name,
                  c = this.g ? this.g.map(a) : [];
                this.value && c.unshift(this.value);
                0 < c.length && (b += ":" + c.join(","));
                return b;
              };
              Dq.prototype.getAttribute = function (a) {
                var b = this.g.filter(function (c) {
                  return c.name == a;
                });
                return b.length ? b[0] : null;
              };
              function Z(a, b, c) {
                return (a = a.getAttribute(b)) ? a.value : c || null;
              }
              function Eq(a, b) {
                a = a.getAttribute(b);
                if (!a) throw new O(2, 4, 4023, b);
                return a.value;
              }
              function Fq(a, b, c) {
                c = void 0 === c ? [] : c;
                this.g = b;
                this.i = a;
                this.h = c;
              }
              function Gq(a, b) {
                this.name = a;
                this.value = b;
              }
              function Hq(a, b) {
                return a.filter(function (c) {
                  return c.name == b;
                });
              }
              function Iq(a, b) {
                return a.filter(function (c) {
                  return Eq(c, "TYPE") == b;
                });
              }
              function Jq(a, b) {
                a = Hq(a, b);
                return a.length ? a[0] : null;
              }
              function Kq(a, b) {
                var c = 0;
                c = void 0 === c ? 0 : c;
                return (a = Jq(a, b)) ? Number(a.value) : c;
              }
              function Lq(a, b) {
                return ec([a], [b])[0];
              }
              function Mq(a) {
                this.h = a;
                this.g = 0;
              }
              function Nq(a) {
                Oq(a, /[ \t]+/gm);
              }
              function Oq(a, b) {
                b.lastIndex = a.g;
                b = b.exec(a.h);
                b = null == b ? null : {
                  position: b.index,
                  length: b[0].length,
                  results: b
                };
                if (a.g == a.h.length || null == b || b.position != a.g) return null;
                a.g += b.length;
                return b.results;
              }
              function Pq(a) {
                return a.g == a.h.length ? null : (a = Oq(a, /[^ \t\n]*/gm)) ? a[0] : null;
              }
              function Qq() {
                this.g = 0;
              }
              function Rq(a, b, c) {
                b = Cc(b);
                b = b.replace(/\r\n|\r(?=[^\n]|$)/gm, "\n").trim();
                var d = b.split(/\n+/m);
                if (!/^#EXTM3U($|[ \t\n])/m.test(d[0])) throw new O(2, 4, 4015);
                b = 0;
                for (var e = !0, f = r(d), g = f.next(); !g.done; g = f.next()) if (g = g.value, /^#(?!EXT)/m.test(g) || e) e = !1;else if (g = Sq(a, g), --a.g, Tq.includes(g.name)) {
                  b = 1;
                  break;
                } else "EXT-X-STREAM-INF" == g.name && (e = !0);
                f = [];
                e = !0;
                for (g = 0; g < d.length; g++) {
                  var h = d[g],
                    k = d[g + 1];
                  if (/^#(?!EXT)/m.test(h) || e) e = !1;else {
                    h = Sq(a, h);
                    if (Uq.includes(h.name)) {
                      if (1 != b) throw new O(2, 4, 4017);
                      var l = d.splice(g, d.length - g);
                      d = c;
                      e = [];
                      g = [];
                      k = [];
                      h = null;
                      l = r(l);
                      for (var m = l.next(); !m.done; m = l.next()) m = m.value, /^(#EXT)/.test(m) ? (m = Sq(a, m), Tq.includes(m.name) ? f.push(m) : "EXT-X-MAP" == m.name ? h = m : "EXT-X-PART" == m.name ? k.push(m) : "EXT-X-PRELOAD-HINT" == m.name ? "PART" == Z(m, "TYPE") ? k.push(m) : "MAP" == Z(m, "TYPE") && (m.name = "EXT-X-MAP", h = m) : g.push(m)) : /^#(?!EXT)/m.test(m) || (m = Lq(d, m.trim()), h && g.push(h), e.push(new Fq(m, g, k)), g = [], k = []);
                      k.length && (h && g.push(h), e.push(new Fq("", g, k)));
                      return new Cq(c, b, f, e);
                    }
                    f.push(h);
                    "EXT-X-STREAM-INF" == h.name && (h.g.push(new Gq("URI", k)), e = !0);
                  }
                }
                return new Cq(c, b, f);
              }
              function Sq(a, b) {
                a = a.g++;
                var c = b.match(/^#(EXT[^:]*)(?::(.*))?$/);
                if (!c) throw new O(2, 4, 4016, b);
                b = c[1];
                var d = c[2];
                c = [];
                var e;
                if (d) {
                  d = new Mq(d);
                  var f;
                  (f = Oq(d, /^([^,=]+)(?:,|$)/g)) && (e = f[1]);
                  for (var g = /([^=]+)=(?:"([^"]*)"|([^",]*))(?:,|$)/g; f = Oq(d, g);) c.push(new Gq(f[1], f[2] || f[3])), Nq(d);
                }
                return new Dq(a, b, c, e);
              }
              var Tq = "EXT-X-TARGETDURATION EXT-X-MEDIA-SEQUENCE EXT-X-DISCONTINUITY-SEQUENCE EXT-X-PLAYLIST-TYPE EXT-X-I-FRAMES-ONLY EXT-X-ENDLIST EXT-X-SERVER-CONTROL EXT-X-SKIP".split(" "),
                Uq = "EXTINF EXT-X-BYTERANGE EXT-X-DISCONTINUITY EXT-X-PROGRAM-DATE-TIME EXT-X-KEY EXT-X-DATERANGE EXT-X-MAP".split(" ");
              function Vq() {}
              function Wq(a) {
                try {
                  var b = Xq(a);
                  return Oe({
                    uri: a,
                    Oe: a,
                    data: b.data,
                    headers: {
                      "content-type": b.contentType
                    }
                  });
                } catch (c) {
                  return Me(c);
                }
              }
              function Xq(a) {
                var b = a.split(":");
                if (2 > b.length || "data" != b[0]) throw new O(2, 1, 1004, a);
                b = b.slice(1).join(":").split(",");
                if (2 > b.length) throw new O(2, 1, 1004, a);
                var c = b[0];
                a = window.decodeURIComponent(b.slice(1).join(","));
                b = c.split(";");
                c = b[0];
                var d = !1;
                1 < b.length && "base64" == b[b.length - 1] && (d = !0, b.pop());
                var e;
                d ? e = Lc(a) : e = Gc(a);
                return {
                  data: e,
                  contentType: c
                };
              }
              K("shaka.net.DataUriPlugin", Vq);
              Vq.parse = Wq;
              $e("data", Wq);
              function Yq() {
                var a = this;
                this.g = this.i = null;
                this.Fa = 1;
                this.o = new Map();
                this.u = new Map();
                this.F = new Map();
                this.F.set("video", new Map());
                this.F.set("audio", new Map());
                this.F.set(jc, new Map());
                this.F.set("image", new Map());
                this.ua = new Set();
                this.h = new Map();
                this.j = null;
                this.M = "";
                this.W = new Qq();
                this.O = 0;
                this.B = -1;
                this.H = Infinity;
                this.Ga = !1;
                this.m = new P(function () {
                  Zq(a);
                });
                this.ea = $q;
                this.D = null;
                this.ca = 0;
                this.J = Infinity;
                this.V = this.da = 0;
                this.G = new Xe();
                this.L = new Map();
                this.s = new Map();
                this.ba = new Map();
                this.l = !1;
              }
              q = Yq.prototype;
              q.configure = function (a) {
                this.g = a;
              };
              q.start = function (a, b) {
                var c = this,
                  d;
                return G(function (e) {
                  return 1 == e.g ? (c.i = b, c.l = b.isLowLatencyMode(), u(e, ar(c, a), 2)) : 3 != e.g ? (d = e.h, c.M = d.uri, u(e, br(c, d.data, a), 3)) : e.return(c.D);
                });
              };
              q.stop = function () {
                this.m && (this.m.stop(), this.m = null);
                var a = [];
                this.G && (a.push(this.G.destroy()), this.G = null);
                this.g = this.i = null;
                this.ua.clear();
                this.D = null;
                this.h.clear();
                this.u.clear();
                this.s.clear();
                this.o.clear();
                return Promise.all(a);
              };
              q.update = function () {
                var a = this,
                  b,
                  c,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l;
                return G(function (m) {
                  if (1 == m.g) {
                    if (!cr(a)) return m.return();
                    b = [];
                    c = Array.from(a.h.values());
                    d = c.filter(function (n) {
                      return n.stream.segmentIndex;
                    });
                    e = r(d);
                    for (f = e.next(); !f.done; f = e.next()) g = f.value, b.push(dr(a, g));
                    return u(m, Promise.all(b), 2);
                  }
                  er(a, d.map(function (n) {
                    return n.stream;
                  }));
                  h = d.some(function (n) {
                    return 0 == n.mc;
                  });
                  d.length && !h && (k = fr, gr(a, k.ff), l = d.map(function (n) {
                    return n.Ya;
                  }), a.j.Aa(Math.min.apply(Math, ha(l))), a.i.updateDuration());
                  A(m);
                });
              };
              function hr(a, b) {
                return cr(a) ? a.F.get(b.type) : b.$c;
              }
              function dr(a, b) {
                var c, d, e, f, g, h, k, l, m, n, p, t, v, y, w, x;
                return G(function (z) {
                  if (1 == z.g) return c = b.Jc, d = new Nb(c), a.l && b.Mc && Qb(d, new Sb("_HLS_skip=YES")), u(z, ar(a, d.toString()), 2);
                  e = z.h;
                  if (!b.stream.segmentIndex) return z.return();
                  f = Rq(a.W, e.data, e.uri);
                  if (1 != f.type) throw new O(2, 4, 4017);
                  g = Hq(f.g, "EXT-X-DEFINE");
                  h = ir(a, g);
                  k = b.stream;
                  l = hr(a, b);
                  m = jr(f, k.mimeType);
                  n = m.keyIds;
                  p = m.drmInfos;
                  t = function t(B, E) {
                    return B.size === E.size && [].concat(ha(B)).every(function (F) {
                      return E.has(F);
                    });
                  };
                  t(k.keyIds, n) || (k.keyIds = n, k.drmInfos = p, a.i.newDrmInfo(k));
                  v = kr(a, f, k.type, l, h);
                  k.segmentIndex.Hb(v, a.j.Pa());
                  v.length && (y = Kq(f.g, "EXT-X-MEDIA-SEQUENCE"), w = l.get(y), k.segmentIndex.eb(w));
                  x = v[v.length - 1];
                  if (Jq(f.g, "EXT-X-ENDLIST")) b.mc = !0, b.Ya = x.endTime;
                  A(z);
                });
              }
              q.onExpirationUpdated = function () {};
              function lr(a, b) {
                for (var c = -1 == a.B, d = r(b), e = d.next(); !e.done; e = d.next()) {
                  e = e.value;
                  var f = e.stream.segmentIndex,
                    g = hr(a, e);
                  if (f = f.g[0] || null) {
                    g = r(g);
                    for (var h = g.next(); !h.done; h = g.next()) {
                      h = r(h.value);
                      var k = h.next().value;
                      if (h.next().value == f.startTime) {
                        c && (a.B = Math.max(a.B, k));
                        e.Cd = k;
                        break;
                      }
                    }
                  }
                }
                if (!(0 > a.B)) for (b = r(b), e = b.next(); !e.done; e = b.next()) if (c = e.value, d = c.stream.segmentIndex) if (d.g.splice(0, a.B - c.Cd), d = d.g[0] || null) d = -d.startTime, c.stream.segmentIndex.offset(d), mr(a, c, d);
              }
              function nr(a, b) {
                if (Infinity == a.H) {
                  b = r(b);
                  for (var c = b.next(); !c.done; c = b.next()) {
                    var d = c.value.stream.segmentIndex.g[0] || null;
                    null != d && null != d.g && (a.H = Math.min(a.H, d.g));
                  }
                }
                b = a.H;
                if (Infinity != b) for (d = r(a.h.values()), c = d.next(); !c.done; c = d.next()) {
                  c = c.value;
                  var e = c.stream.segmentIndex;
                  if (null != e) {
                    var f = e.g[0] || null;
                    if (null == f.g) Va("Missing EXT-X-PROGRAM-DATE-TIME for stream", c.Ac, "Expect AV sync issues!");else for (mr(a, c, f.g - b - f.startTime), c = r(e), e = c.next(); !e.done; e = c.next()) e.value.oe(b);
                  }
                }
              }
              function mr(a, b, c) {
                b.Ya += c;
                a = hr(a, b);
                b = r(a);
                for (var d = b.next(); !d.done; d = b.next()) {
                  var e = r(d.value);
                  d = e.next().value;
                  e = e.next().value;
                  a.set(d, e + c);
                }
              }
              function br(a, b, c) {
                var d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N, wa, va, Ma, Sa;
                return G(function (Ga) {
                  switch (Ga.g) {
                    case 1:
                      d = Rq(a.W, b, a.M);
                      e = Hq(d.g, "EXT-X-DEFINE");
                      for (var Kb = r(e), Ja = Kb.next(); !Ja.done; Ja = Kb.next()) {
                        var Ua = Ja.value;
                        Ja = Z(Ua, "NAME");
                        Ua = Z(Ua, "VALUE");
                        Ja && Ua && (a.o.has(Ja) || a.o.set(Ja, Ua));
                      }
                      f = [];
                      g = [];
                      h = [];
                      if (1 == d.type) return F = a.g.hls.mediaPlaylistFullMimeType, d.segments.length && (H = new Nb(d.segments[0].i), I = H.qa.split(".").pop(), (J = or[I]) ? F = J : "ts" !== I && "mp4" !== I && (pr[I] ? (J = pr[I], L = a.g.hls.defaultAudioCodec, F = J + '; codecs="' + L + '"') : qr[I] && (J = qr[I], R = a.g.hls.defaultVideoCodec, F = J + '; codecs="' + R + '"'))), Q = F.split(";")[0], U = Q.split("/")[0], N = cd(F), wa = new Map(), u(Ga, rr(a, d, c, c, N, U, "", !0, "Media Playlist", null, wa, null, !1, !1, Q), 5);
                      k = Hq(d.g, "EXT-X-MEDIA");
                      l = Hq(d.g, "EXT-X-STREAM-INF");
                      m = Hq(d.g, "EXT-X-IMAGE-STREAM-INF");
                      n = Hq(d.g, "EXT-X-SESSION-KEY");
                      Kb = r(l);
                      for (Ja = Kb.next(); !Ja.done; Ja = Kb.next()) {
                        var Zb = Ja.value;
                        Ua = Z(Zb, "AUDIO");
                        Ja = Z(Zb, "VIDEO");
                        var pb = Z(Zb, "SUBTITLES");
                        Zb = sr(a, Zb);
                        if (pb) {
                          var Wn = hc(jc, Zb);
                          a.s.set(pb, Wn);
                          hb(Zb, Wn);
                        }
                        Ua && (pb = hc("audio", Zb), pb || (pb = a.g.hls.defaultAudioCodec), a.s.set(Ua, pb));
                        Ja && (Ua = hc("video", Zb), Ua || (Ua = a.g.hls.defaultVideoCodec), a.s.set(Ja, Ua));
                      }
                      p = Hq(d.g, "EXT-X-SESSION-DATA");
                      t = r(p);
                      for (v = t.next(); !v.done; v = t.next()) if (y = v.value, w = Z(y, "DATA-ID"), x = Z(y, "URI"), C = Z(y, "LANGUAGE"), z = Z(y, "VALUE"), B = new Map().set("id", w), x && B.set("uri", Lq(a.M, x)), C && B.set("language", C), z && B.set("value", z), E = new S("sessiondata", B), a.i) a.i.onEvent(E);
                      tr(a, k);
                      Kb = Iq(k, "CLOSED-CAPTIONS");
                      Kb = r(Kb);
                      for (Ja = Kb.next(); !Ja.done; Ja = Kb.next()) pb = Ja.value, Ja = ur(pb), Ua = Eq(pb, "GROUP-ID"), pb = Eq(pb, "INSTREAM-ID"), a.L.get(Ua) || a.L.set(Ua, new Map()), a.L.get(Ua).set(pb, Ja);
                      f = vr(a, l, n);
                      g = wr(a, k);
                      return u(Ga, xr(a, m), 4);
                    case 4:
                      h = Ga.h;
                      Ga.A(3);
                      break;
                    case 5:
                      va = Ga.h, a.h.set(c, va), f.push({
                        id: 0,
                        language: "und",
                        disabledUntilTime: 0,
                        primary: !0,
                        audio: "audio" == U ? va.stream : null,
                        video: "video" == U ? va.stream : null,
                        bandwidth: 0,
                        allowedByApplication: !0,
                        allowedByKeySystem: !0,
                        decodingInfos: []
                      });
                    case 3:
                      if (!a.i) throw new O(2, 7, 7001);
                      a.j = new T(null, 0);
                      a.j.yc(!0);
                      1 == d.type && (cr(a) && (yr(a), Ma = a.O, a.m.N(Ma)), Sa = Array.from(a.h.values()), zr(a, Sa), Ar(a));
                      a.D = {
                        presentationTimeline: a.j,
                        variants: f,
                        textStreams: g,
                        imageStreams: h,
                        offlineSessionIds: [],
                        minBufferTime: 0,
                        sequenceMode: !0
                      };
                      a.i.makeTextStreamsForClosedCaptions(a.D);
                      A(Ga);
                  }
                });
              }
              function Ar(a) {
                if (cr(a)) {
                  if (a.O = a.J, a.ea == Br) {
                    var b = Cr(a);
                    a.g.hls.useSafariBehaviorForLive && (b = a.j.m);
                    isNaN(a.g.availabilityWindowOverride) || (b = a.g.availabilityWindowOverride);
                    a.j.me(b);
                  }
                } else a.j.Aa(Cr(a));
                a.j.Md();
              }
              function ir(a, b) {
                var c = new Map();
                b = r(b);
                for (var d = b.next(); !d.done; d = b.next()) {
                  var e = d.value;
                  d = Z(e, "NAME");
                  var f = Z(e, "VALUE");
                  e = Z(e, "IMPORT");
                  d && f && c.set(d, f);
                  e && (d = a.o.get(e)) && c.set(e, d);
                }
                return c;
              }
              function wr(a, b) {
                var c = Iq(b, "SUBTITLES");
                b = c.map(function (g) {
                  if (a.g.disableText) return null;
                  try {
                    return Dr(a, g).stream;
                  } catch (h) {
                    if (a.g.hls.ignoreTextStreamFailures) return null;
                    throw h;
                  }
                });
                c = r(c);
                for (var d = c.next(); !d.done; d = c.next()) {
                  var e = Eq(d.value, "GROUP-ID");
                  if (d = a.s.get(e)) if (e = a.u.get(e)) {
                    e = r(e);
                    for (var f = e.next(); !f.done; f = e.next()) f = f.value, f.stream.codecs = d, f.stream.mimeType = Er(jc, d) || Fr(jc);
                  }
                }
                return b.filter(function (g) {
                  return g;
                });
              }
              function xr(a, b) {
                var c, d;
                return G(function (e) {
                  if (1 == e.g) return c = b.map(function (f) {
                    var h, k;
                    return G(function (l) {
                      if (1 == l.g) {
                        if (a.g.disableThumbnails) return l.return(null);
                        D(l, 2);
                        return u(l, Gr(a, f), 4);
                      }
                      if (2 != l.g) return h = l.h, l.return(h.stream);
                      k = ua(l);
                      if (a.g.hls.ignoreImageStreamFailures) return l.return(null);
                      throw k;
                    });
                  }), u(e, Promise.all(c), 2);
                  d = e.h;
                  return e.return(d.filter(function (f) {
                    return f;
                  }));
                });
              }
              function tr(a, b) {
                b = b.filter(function (d) {
                  var e = Z(d, "URI") || "";
                  return "SUBTITLES" != Z(d, "TYPE") && "" != e;
                });
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) Dr(a, c.value);
              }
              function vr(a, b, c) {
                var d = [],
                  e = new Set();
                if (0 < c.length) {
                  c = r(c);
                  for (var f = c.next(); !f.done; f = c.next()) {
                    f = f.value;
                    var g = Eq(f, "METHOD");
                    if ("NONE" != g && "AES-128" != g && (g = Z(f, "KEYFORMAT") || "identity", f = (g = Hr[g]) ? g(f, "") : null)) {
                      if (f.keyIds) {
                        g = r(f.keyIds);
                        for (var h = g.next(); !h.done; h = g.next()) e.add(h.value);
                      }
                      d.push(f);
                    }
                  }
                }
                b = b.map(function (k) {
                  var l = Z(k, "FRAME-RATE"),
                    m = Number(Z(k, "AVERAGE-BANDWIDTH")) || Number(Eq(k, "BANDWIDTH")),
                    n = Z(k, "RESOLUTION");
                  n = r(n ? n.split("x") : [null, null]);
                  var p = n.next().value,
                    t = n.next().value,
                    v = Z(k, "VIDEO-RANGE");
                  k = Ir(a, k);
                  n = k.audio;
                  k = k.video;
                  for (var y = r(k), w = y.next(); !w.done; w = y.next()) if (w = w.value.stream) w.width = Number(p) || void 0, w.height = Number(t) || void 0, w.frameRate = Number(l) || void 0, w.hdr = v || void 0;
                  l = a.g.disableAudio;
                  if (!n.length || l) n = [null];
                  l = a.g.disableVideo;
                  if (!k.length || l) k = [null];
                  l = [];
                  n = r(n);
                  for (p = n.next(); !p.done; p = n.next()) for (p = p.value, t = r(k), v = t.next(); !v.done; v = t.next()) {
                    var x = v.value;
                    if (v = p ? p.stream : null) v.drmInfos = d, v.keyIds = e;
                    if (y = x ? x.stream : null) y.drmInfos = d, y.keyIds = e;
                    w = p ? p.stream.drmInfos : null;
                    var C = x ? x.stream.drmInfos : null;
                    x = (x ? x.Ac : "") + " - " + (p ? p.Ac : "");
                    v && y && w.length && C.length && !(0 < Pg(w, C).length) || a.ua.has(x) || (v = {
                      id: a.Fa++,
                      language: v ? v.language : "und",
                      primary: !!v && v.primary || !!y && y.primary,
                      audio: v,
                      video: y,
                      bandwidth: m,
                      allowedByApplication: !0,
                      allowedByKeySystem: !0,
                      decodingInfos: []
                    }, l.push(v), a.ua.add(x));
                  }
                  return l;
                }).reduce(bc, []);
                return b = b.filter(function (k) {
                  return null != k;
                });
              }
              function Ir(a, b) {
                var c = sr(a, b),
                  d = Z(b, "AUDIO"),
                  e = Z(b, "VIDEO"),
                  f = d || e;
                f = f && a.u.has(f) ? a.u.get(f) : [];
                d = {
                  audio: d ? f : [],
                  video: e ? f : []
                };
                e = !1;
                var g = Eq(b, "URI"),
                  h = d.audio.find(function (m) {
                    return m && m.Ac == g;
                  }),
                  k = hc("video", c),
                  l = hc("audio", c);
                l && !k ? f = "audio" : !f.length && l && k ? (f = "video", c = [[k, l].join()]) : d.audio.length && h ? (f = "audio", e = !0) : f = d.video.length && !d.audio.length ? "audio" : "video";
                e || (a = Jr(a, b, c, f), d[a.stream.type] = [a]);
                return d;
              }
              function sr(a, b) {
                var c = [];
                a.g.disableVideo || c.push(a.g.hls.defaultVideoCodec);
                a.g.disableAudio || c.push(a.g.hls.defaultAudioCodec);
                c = Z(b, "CODECS", c.join(",")).split(/\s*,\s*/);
                a = new Set();
                b = [];
                c = r(c);
                for (var d = c.next(); !d.done; d = c.next()) {
                  d = d.value;
                  var e = bd(d)[0];
                  a.has(e) || (b.push(d), a.add(e));
                }
                return b;
              }
              function ur(a) {
                a = Z(a, "LANGUAGE") || "und";
                return od(a);
              }
              function Dr(a, b) {
                var c = Eq(b, "GROUP-ID"),
                  d = "",
                  e = Eq(b, "TYPE").toLowerCase();
                "subtitles" == e && (e = jc);
                var f = e;
                f != jc && c && a.s.has(c) && (d = a.s.get(c));
                e = Kr(Eq(b, "URI"), a.o);
                if (a.h.has(e)) return a.h.get(e);
                var g = ur(b),
                  h = Z(b, "NAME"),
                  k = "YES" == Z(b, "DEFAULT");
                var l = "audio" == f ? (l = Z(b, "CHANNELS")) ? parseInt(l.split("/")[0], 10) : null : null;
                var m = "audio" == f ? (m = Z(b, "CHANNELS")) ? m.includes("/JOC") : !1 : !1;
                var n = Z(b, "CHARACTERISTICS");
                b = "YES" == Z(b, "FORCED");
                d = Lr(a, e, d, f, g, k, h, l, null, n, b, m);
                a.u.has(c) ? a.u.get(c).push(d) : a.u.set(c, [d]);
                if (a.h.has(e)) return a.h.get(e);
                a.h.set(e, d);
                return d;
              }
              function Gr(a, b) {
                var c, d, e, f, g, h, k, l, m, n;
                return G(function (p) {
                  if (1 == p.g) {
                    c = Kr(Eq(b, "URI"), a.o);
                    d = Z(b, "CODECS", "jpeg") || "";
                    if (a.h.has(c)) return p.return(a.h.get(c));
                    e = ur(b);
                    f = Z(b, "NAME");
                    g = Z(b, "CHARACTERISTICS");
                    h = Lr(a, c, d, "image", e, !1, f, null, null, g, !1, !1);
                    return a.h.has(c) ? p.return(a.h.get(c)) : (k = Z(b, "RESOLUTION")) ? u(p, h.stream.createSegmentIndex(), 3) : p.A(2);
                  }
                  2 != p.g && (l = h.stream.segmentIndex.get(0), m = l.tilesLayout) && (h.stream.width = Number(k.split("x")[0]) * Number(m.split("x")[0]), h.stream.height = Number(k.split("x")[1]) * Number(m.split("x")[1]));
                  if (n = Z(b, "BANDWIDTH")) h.stream.bandwidth = Number(n);
                  a.h.set(c, h);
                  return p.return(h);
                });
              }
              function Jr(a, b, c, d) {
                var e = Kr(Eq(b, "URI"), a.o);
                if (a.h.has(e)) return a.h.get(e);
                b = Z(b, "CLOSED-CAPTIONS");
                b = "video" == d && b && "NONE" != b ? a.L.get(b) : null;
                c = gc(d, c);
                d = Lr(a, e, c, d, "und", !1, null, null, b, null, !1, !1);
                if (a.h.has(e)) return a.h.get(e);
                a.h.set(e, d);
                return d;
              }
              function Lr(a, b, c, d, e, f, g, h, k, l, m, n) {
                function p(C) {
                  var z, B, E, F, H, I, J, L, R, Q, U, N, wa;
                  return G(function (va) {
                    if (1 == va.g) return u(va, ar(a, y.Jc), 2);
                    if (3 != va.g) {
                      z = va.h;
                      if (C.aborted) return va.return();
                      B = z.uri;
                      E = Rq(a.W, z.data, B);
                      F = cr(a);
                      return u(va, rr(a, E, b, B, c, d, e, f, g, h, k, l, m, n), 3);
                    }
                    H = va.h;
                    if (C.aborted) return va.return();
                    I = H.stream;
                    cr(a) && !F && yr(a);
                    y.Jc = B;
                    y.Ya = H.Ya;
                    y.Mc = H.Mc;
                    y.mc = H.mc;
                    y.$c = H.$c;
                    y.Ld = !0;
                    v.segmentIndex = I.segmentIndex;
                    v.encrypted = I.encrypted;
                    v.drmInfos = I.drmInfos;
                    v.keyIds = I.keyIds;
                    v.mimeType = I.mimeType;
                    Yi.includes(v.mimeType) && (v.codecs = "");
                    v.drmInfos.length && a.i.newDrmInfo(v);
                    J = kc;
                    if (d == J.va || d == J.Hc) for (L = r(a.h.values()), R = L.next(); !R.done; R = L.next()) Q = R.value, Q.Ld || Q.type != d || (Q.stream.mimeType = I.mimeType, Yi.includes(Q.stream.mimeType) && (Q.stream.codecs = ""));
                    Mr(a) && (a.Ga ? zr(a, [y]) : (a.Ga = !0, U = Array.from(a.h.values()), N = U.filter(function (Ma) {
                      return Ma.stream.segmentIndex;
                    }), zr(a, N), Ar(a), wa = a.O, 0 < wa && a.m.N(wa)));
                    A(va);
                  });
                }
                var t = Lq(a.M, b),
                  v = Nr(a, c, d, e, f, g, h, k, l, m, n);
                Yi.includes(v.mimeType) && (v.codecs = "");
                var y = {
                    stream: v,
                    type: d,
                    Ac: b,
                    Jc: t,
                    Ya: 0,
                    $c: new Map(),
                    Mc: !1,
                    mc: !1,
                    Cd: -1,
                    Ld: !1
                  },
                  w = null,
                  x = new AbortController();
                v.createSegmentIndex = function () {
                  if (w) return w;
                  x = new AbortController();
                  return w = new Promise(function (C) {
                    C(p(x.signal));
                  });
                };
                v.closeSegmentIndex = function () {
                  w && !v.segmentIndex && x.abort();
                  v.segmentIndex && (v.segmentIndex.release(), v.segmentIndex = null);
                  w = null;
                };
                return y;
              }
              function Cr(a) {
                var b = Infinity;
                a = r(a.h.values());
                for (var c = a.next(); !c.done; c = a.next()) c = c.value, c.stream.segmentIndex && "text" != c.stream.type && (b = Math.min(b, c.Ya));
                return b;
              }
              function er(a, b) {
                var c = [];
                b = r(b);
                for (var d = b.next(); !d.done; d = b.next()) d = d.value, d.segmentIndex && Kj(d.segmentIndex, function (e) {
                  c.push(e);
                });
                a.j.Ib(c);
              }
              function zr(a, b) {
                if (!cr(a)) for (var c = Cr(a), d = r(b), e = d.next(); !e.done; e = d.next()) e.value.stream.segmentIndex.Wa(0, c);
                c = r(b);
                for (e = c.next(); !e.done; e = c.next()) e = e.value.stream, Yi.includes(e.mimeType) && (e.codecs = "");
                er(a, b.map(function (f) {
                  return f.stream;
                }));
                a.g.hls.ignoreManifestProgramDateTime ? lr(a, b) : nr(a, b);
              }
              function Mr(a) {
                if (!a.D) return !1;
                var b = [],
                  c = [];
                a = r(a.D.variants);
                for (var d = a.next(); !d.done; d = a.next()) d = d.value, d.video && b.push(d.video), d.audio && c.push(d.audio);
                return 0 < b.length && !b.some(function (e) {
                  return e.segmentIndex;
                }) || 0 < c.length && !c.some(function (e) {
                  return e.segmentIndex;
                }) ? !1 : !0;
              }
              function rr(a, b, c, d, e, f, g, h, k, l, m, n, p, t, v) {
                var y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U;
                return G(function (N) {
                  if (1 == N.g) {
                    if (1 != b.type) throw new O(2, 4, 4017);
                    y = Hq(b.g, "EXT-X-DEFINE");
                    w = ir(a, y);
                    Or(a, b);
                    return v ? N.A(2) : u(N, Pr(a, f, e, b, w), 3);
                  }
                  2 != N.g && (v = N.h);
                  x = jr(b, v);
                  C = x.drmInfos;
                  z = x.keyIds;
                  B = x.encrypted;
                  E = x.kf;
                  if (B && !C.length && !E) throw new O(2, 4, 4026);
                  F = cr(a) ? a.F.get(f) : new Map();
                  H = a.l;
                  I = kr(a, b, f, F, w);
                  H != a.l && Or(a, b);
                  J = I[I.length - 1].endTime;
                  L = new Jj(I);
                  Q = (R = Jq(b.g, "EXT-X-SERVER-CONTROL")) ? null != R.getAttribute("CAN-SKIP-UNTIL") : !1;
                  U = Nr(a, e, f, g, h, k, l, m, n, p, t);
                  U.segmentIndex = L;
                  U.encrypted = B;
                  U.drmInfos = C;
                  U.keyIds = z;
                  U.mimeType = v;
                  return N.return({
                    stream: U,
                    type: f,
                    Ac: c,
                    Jc: d,
                    Ya: J,
                    Mc: Q,
                    mc: !1,
                    Cd: -1,
                    $c: F,
                    Ld: !1
                  });
                });
              }
              function Nr(a, b, c, d, e, f, g, h, k, l, m) {
                var n = Er(c, b) || Fr(c);
                return {
                  id: a.Fa++,
                  originalId: f,
                  createSegmentIndex: function createSegmentIndex() {
                    return Promise.resolve();
                  },
                  segmentIndex: null,
                  mimeType: n,
                  codecs: b,
                  kind: c == jc ? "subtitle" : void 0,
                  encrypted: !1,
                  drmInfos: [],
                  keyIds: new Set(),
                  language: d,
                  label: f,
                  type: c,
                  primary: e,
                  trickModeVideo: null,
                  emsgSchemeIdUris: null,
                  frameRate: void 0,
                  pixelAspectRatio: void 0,
                  width: void 0,
                  height: void 0,
                  bandwidth: void 0,
                  roles: k ? k.split(",") : [],
                  forced: l,
                  channelsCount: g,
                  audioSamplingRate: null,
                  spatialAudio: m,
                  closedCaptions: h,
                  hdr: void 0,
                  tilesLayout: void 0
                };
              }
              function jr(a, b) {
                var c = [];
                if (a.segments) {
                  a = r(a.segments);
                  for (var d = a.next(); !d.done; d = a.next()) d = Hq(d.value.g, "EXT-X-KEY"), c.push.apply(c, ha(d));
                }
                d = a = !1;
                var e = [],
                  f = new Set();
                c = r(c);
                for (var g = c.next(); !g.done; g = c.next()) {
                  g = g.value;
                  var h = Eq(g, "METHOD");
                  if ("NONE" != h) if (a = !0, "AES-128" == h) d = !0;else if (h = Z(g, "KEYFORMAT") || "identity", g = (h = Hr[h]) ? h(g, b) : null) {
                    if (g.keyIds) {
                      h = r(g.keyIds);
                      for (var k = h.next(); !k.done; k = h.next()) f.add(k.value);
                    }
                    e.push(g);
                  }
                }
                return {
                  drmInfos: e,
                  keyIds: f,
                  encrypted: a,
                  kf: d
                };
              }
              function Qr(a, b, c) {
                if (!window.crypto || !window.crypto.subtle) throw Wa("Web Crypto API is not available to decrypt AES-128. (Web Crypto only exists in secure origins like https)"), new O(2, 4, 4042);
                var d = 0,
                  e = Z(b, "IV", "");
                if (e) {
                  var f = Mc(e.substr(2));
                  if (16 != f.byteLength) throw new O(2, 4, 4043);
                } else d = Kq(c.g, "EXT-X-MEDIA-SEQUENCE");
                b = Lq(c.h, Eq(b, "URI"));
                var g = cf([b], a.g.retryParameters),
                  h = {
                    method: "AES-128",
                    iv: f,
                    firstMediaSequenceNumber: d,
                    fetchKey: function fetchKey() {
                      var k, l, m;
                      return G(function (n) {
                        if (1 == n.g) return u(n, Rr(a, g, 6), 2);
                        if (3 != n.g) {
                          k = n.h;
                          if (!k.data || 16 != k.data.byteLength) throw new O(2, 4, 4044);
                          l = {
                            name: "AES-CBC"
                          };
                          m = h;
                          return u(n, window.crypto.subtle.importKey("raw", k.data, l, !0, ["decrypt"]), 3);
                        }
                        m.cryptoKey = n.h;
                        h.fetchKey = void 0;
                        A(n);
                      });
                    }
                  };
                return h;
              }
              function Or(a, b) {
                var c = Jq(b.g, "EXT-X-PLAYLIST-TYPE"),
                  d = Jq(b.g, "EXT-X-ENDLIST");
                d = c && "VOD" == c.value || d;
                c = c && "EVENT" == c.value && !d;
                c = !d && !c;
                if (d) gr(a, $q);else {
                  c ? gr(a, Br) : gr(a, Sr);
                  d = Jq(b.g, "EXT-X-TARGETDURATION");
                  if (!d) throw new O(2, 4, 4024, "EXT-X-TARGETDURATION");
                  d = Number(d.value);
                  c = Jq(b.g, "EXT-X-PART-INF");
                  a.l && c ? (a.da = Number(Eq(c, "PART-TARGET")), a.J = Math.min(a.da, a.J), b = Jq(b.g, "EXT-X-SERVER-CONTROL"), a.V = b ? Number(Eq(b, "PART-HOLD-BACK")) : 0) : a.J = Math.min(d, a.J);
                  a.ca = Math.max(d, a.ca);
                }
              }
              function yr(a) {
                var b = a.g.defaultPresentationDelay ? a.g.defaultPresentationDelay : a.V ? a.V : a.ca * a.g.hls.liveSegmentsDelay;
                a.j.Xe(0);
                a.j.We(b);
                a.j.yc(!1);
              }
              function Tr(a, b, c, d) {
                c = Jq(c, "EXT-X-MAP");
                if (!c) return null;
                var e = Eq(c, "URI");
                d = Kr(Lq(b, e), d);
                b = [d, Z(c, "BYTERANGE", "")].join("-");
                a.ba.has(b) || (c = Ur(d, c), a.ba.set(b, c));
                return a.ba.get(b);
              }
              function Ur(a, b) {
                var c = 0,
                  d = null;
                if (b = Z(b, "BYTERANGE")) c = b.split("@"), d = Number(c[0]), c = Number(c[1]), d = c + d - 1;
                return new oi(function () {
                  return [a];
                }, c, d);
              }
              function Vr(a, b, c, d, e, f, g, h, k) {
                var l = d.g,
                  m = Kr(d.i, f),
                  n = Jq(l, "EXTINF"),
                  p = f = 0,
                  t = null;
                d.h.length && !a.l && Wa("Low-latency HLS live stream detected, but low-latency streaming mode is not enabled in Shaka Player. Set streaming.lowLatencyMode configuration to true, and see https://bit.ly/3clctcj for details.");
                var v = null;
                if (!a.g.hls.ignoreManifestProgramDateTime) {
                  var y = Jq(l, "EXT-X-PROGRAM-DATE-TIME");
                  y && y.value && (v = Vf(y.value));
                }
                y = ri;
                Jq(l, "EXT-X-GAP") && (y = 2);
                if (!n) {
                  if (0 == d.h.length) throw new O(2, 4, 4024, "EXTINF");
                  if (!a.l) return null;
                }
                var w = [];
                if (a.l) for (var x = {}, C = 0; C < d.h.length; x = {
                  pd: x.pd
                }, C++) {
                  var z = d.h[C],
                    B = 0 == C ? c : w[w.length - 1],
                    E = 0 == C ? e : B.endTime,
                    F = Number(Z(z, "DURATION")) || a.da;
                  if (F) {
                    F = E + F;
                    var H = 0,
                      I = null;
                    "EXT-X-PRELOAD-HINT" == z.name ? H = (H = Z(z, "BYTERANGE-START")) ? Number(H) : 0 : (H = Z(z, "BYTERANGE"), I = r(Wr(B, H)), H = I.next().value, I = I.next().value);
                    if (B = Z(z, "URI")) x.pd = Lq(g, B), B = ri, "YES" == Z(z, "GAP") && (B = 2), w.push(new qi(E, F, function (J) {
                      return function () {
                        return [J.pd];
                      };
                    }(x), H, I, b, 0, 0, Infinity, [], "", null, null, B));
                  }
                }
                n ? f = e + Number(n.value.split(",")[0]) : f = w[w.length - 1].endTime;
                (a = Jq(l, "EXT-X-BYTERANGE")) ? (t = r(Wr(c, a.value)), p = t.next().value, t = t.next().value) : w.length && (p = w[0].Ba, t = w[w.length - 1].ka);
                c = "";
                a = null;
                "image" == h && (c = "1x1", h = Jq(l, "EXT-X-TILES")) && (c = Eq(h, "LAYOUT"), (h = Z(h, "DURATION")) && (a = Number(h)));
                return new qi(e, f, function () {
                  return m.length ? [m] : [];
                }, p, t, b, 0, 0, Infinity, w, c, a, v, y, k);
              }
              function Wr(a, b) {
                var c = 0,
                  d = null;
                b && (c = b.split("@"), b = Number(c[0]), c = c[1] ? Number(c[1]) : a.ka + 1, d = c + b - 1);
                return [c, d];
              }
              function kr(a, b, c, d, e) {
                var f = b.segments,
                  g = void 0,
                  h = Kq(b.g, "EXT-X-DISCONTINUITY-SEQUENCE"),
                  k = Kq(b.g, "EXT-X-MEDIA-SEQUENCE"),
                  l = Jq(b.g, "EXT-X-SKIP");
                l = l ? Number(Z(l, "SKIPPED-SEGMENTS")) : 0;
                var m = k + l,
                  n = 0;
                cr(a) && d.has(m) && (n = d.get(m));
                for (var p = [], t = null, v = 0; v < f.length; v++) {
                  var y = f[v],
                    w = 0 == v ? n : t.endTime;
                  m = k + l + v;
                  Jq(y.g, "EXT-X-DISCONTINUITY") && h++;
                  var x = r(y.g);
                  for (var C = x.next(); !C.done; C = x.next()) C = C.value, "EXT-X-KEY" == C.name && ("AES-128" == Eq(C, "METHOD") ? g = Qr(a, C, b) : g = void 0);
                  d.set(m, w);
                  x = Tr(a, b.h, y.g, e);
                  !a.l && a.i.isAutoLowLatencyMode() && (a.i.enableLowLatencyMode(), a.l = a.i.isLowLatencyMode());
                  if (t = y = Vr(a, x, t, y, w, e, b.h, c, g)) y.m = h, a.g.hls.ignoreManifestProgramDateTime && null != a.B && m < a.B || p.push(y);
                }
                if (b = p.some(function (z) {
                  return null != z.g;
                })) for (c = {}, d = 0; d < p.length; c = {
                  Qb: c.Qb,
                  Pb: c.Pb,
                  Bc: c.Bc,
                  Ta: c.Ta,
                  Ob: c.Ob
                }, d++) if (c.Ta = p[d], null == c.Ta.g) for (c.Pb = 0, c.Qb = d, e = function (z) {
                  return function () {
                    var B = p[z.Qb];
                    if (B) {
                      if (null != B.g) return B.g + z.Pb;
                      z.Pb -= B.endTime - B.startTime;
                      z.Qb += 1;
                    }
                    return null;
                  };
                }(c), c.Ob = 0, c.Bc = d, f = function (z) {
                  return function () {
                    var B = p[z.Bc];
                    if (B) {
                      B != z.Ta && (z.Ob += B.endTime - B.startTime);
                      if (null != B.g) return B.g + z.Ob;
                      --z.Bc;
                    }
                    return null;
                  };
                }(c); null == c.Ta.g;) c.Ta.g = f(), null == c.Ta.g && (c.Ta.g = e());
                if (b) for (c = r(p), d = c.next(); !d.done; d = c.next()) for (e = d.value, d = e.g, e = r(e.i), f = e.next(); !f.done; f = e.next()) f = f.value, f.g = d, d += f.endTime - f.startTime;
                a = a.H;
                if (b && Infinity != a) for (b = r(p), d = b.next(); !d.done; d = b.next()) d.value.oe(a);
                return p;
              }
              function Kr(a, b) {
                a = String(a).replace(/%7B/g, "{").replace(/%7D/g, "}");
                var c = a.match(/{\$\w*}/g);
                if (c) {
                  c = r(c);
                  for (var d = c.next(); !d.done; d = c.next()) {
                    d = d.value;
                    var e = d.slice(2, d.length - 1),
                      f = b.get(e);
                    if (f) a = a.replace(d, f);else throw new O(2, 4, 4039, e);
                  }
                }
                return a;
              }
              function Er(a, b) {
                if (a == jc) {
                  if ("vtt" == b || "wvtt" == b) return "text/vtt";
                  if (b && "" !== b) return "application/mp4";
                }
                return "image" != a || b && "jpeg" != b ? "audio" == a && "mp4a.40.34" == b ? "audio/mpeg" : null : "image/jpeg";
              }
              function Fr(a) {
                return a == jc ? "text/vtt" : Xr[a].mp4;
              }
              function Pr(a, b, c, d, e) {
                var f, g, h, k, l, m, n, p, t, v;
                return G(function (y) {
                  if (1 == y.g) {
                    f = jf;
                    g = Math.trunc((d.segments.length - 1) / 2);
                    h = Kr(d.segments[g].i, e);
                    k = new Nb(h);
                    l = k.qa.split(".").pop();
                    m = Xr[b];
                    if ((n = m[l]) || (n = or[l]) || (n = Er(b, c))) return y.return(n);
                    p = cf([h], a.g.retryParameters);
                    p.method = "HEAD";
                    return u(y, Rr(a, p, f), 2);
                  }
                  t = y.h;
                  return (v = t.headers["content-type"]) ? y.return(v.split(";")[0]) : y.return(Fr(b));
                });
              }
              function ar(a, b) {
                b = cf([b], a.g.retryParameters);
                a.i.modifyManifestRequest(b, {
                  format: "h"
                });
                return Rr(a, b, 0);
              }
              function Zq(a) {
                var b, c;
                G(function (d) {
                  if (1 == d.g) {
                    if (!a.i) return d.return();
                    D(d, 2);
                    return u(d, a.update(), 4);
                  }
                  if (2 != d.g) return cr(a) && (b = a.O, a.m.N(b)), ta(d, 0);
                  c = ua(d);
                  if (!a.i) return d.return();
                  c.severity = 1;
                  a.i.onError(c);
                  a.m.N(.1);
                  A(d);
                });
              }
              function cr(a) {
                return a.ea != $q;
              }
              function gr(a, b) {
                a.ea = b;
                a.j && a.j.yc(!cr(a));
                cr(a) || a.m.stop();
              }
              function Rr(a, b, c) {
                if (!a.G) throw new O(2, 7, 7001);
                b = a.i.networkingEngine.request(c, b);
                Ye(a.G, b);
                return b.promise;
              }
              K("shaka.hls.HlsParser", Yq);
              var or = {
                  aac: "audio/aac",
                  ac3: "audio/ac3",
                  ec3: "audio/ec3",
                  mp3: "audio/mpeg"
                },
                pr = {
                  mp4: "audio/mp4",
                  mp4a: "audio/mp4",
                  m4s: "audio/mp4",
                  m4i: "audio/mp4",
                  m4a: "audio/mp4",
                  m4f: "audio/mp4",
                  cmfa: "audio/mp4",
                  ts: "video/mp2t",
                  tsa: "video/mp2t"
                },
                qr = {
                  mp4: "video/mp4",
                  mp4v: "video/mp4",
                  m4s: "video/mp4",
                  m4i: "video/mp4",
                  m4v: "video/mp4",
                  m4f: "video/mp4",
                  cmfv: "video/mp4",
                  ts: "video/mp2t",
                  tsv: "video/mp2t"
                },
                Xr = {
                  audio: pr,
                  video: qr,
                  text: {
                    mp4: "application/mp4",
                    m4s: "application/mp4",
                    m4i: "application/mp4",
                    m4f: "application/mp4",
                    cmft: "application/mp4",
                    vtt: "text/vtt",
                    webvtt: "text/vtt",
                    ttml: "application/ttml+xml"
                  },
                  image: {
                    jpg: "image/jpeg",
                    png: "image/png",
                    svg: "image/svg+xml",
                    webp: "image/webp",
                    avif: "image/avif"
                  }
                },
                Hr = {
                  "com.apple.streamingkeydelivery": function comAppleStreamingkeydelivery(a, b) {
                    if ("video/mp2t" == b) throw new O(2, 4, 4040);
                    if (window.shakaMediaKeysPolyfill) throw new O(2, 4, 4041);
                    return fc("com.apple.fps", [{
                      initDataType: "sinf",
                      initData: new Uint8Array(0),
                      keyId: null
                    }]);
                  },
                  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": function urnUuidEdef8ba979d64aceA3c827dcd51d21ed(a) {
                    var b = Eq(a, "METHOD");
                    if (!["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(b)) return null;
                    b = Eq(a, "URI");
                    b = Xq(b);
                    b = M(b.data);
                    b = fc("com.widevine.alpha", [{
                      initDataType: "cenc",
                      initData: b
                    }]);
                    if (a = Z(a, "KEYID")) b.keyIds = new Set([a.toLowerCase().substr(2)]);
                    return b;
                  },
                  "com.microsoft.playready": function comMicrosoftPlayready(a) {
                    var b = Eq(a, "METHOD");
                    if (!["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(b)) return null;
                    a = Eq(a, "URI");
                    a = Xq(a);
                    a = M(a.data);
                    b = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                    a = Kf(a, b, new Set(), 0);
                    return fc("com.microsoft.playready", [{
                      initDataType: "cenc",
                      initData: a
                    }]);
                  },
                  identity: function identity(a) {
                    a = Eq(a, "METHOD");
                    return ["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(a) ? fc("org.w3.clearkey", null) : null;
                  }
                },
                $q = "VOD",
                Sr = "EVENT",
                Br = "LIVE",
                fr = {
                  ff: $q,
                  Og: Sr,
                  Sg: Br
                };
              tc("Tizen 3") || tc("Tizen 2") || vc() || (Vg.m3u8 = function () {
                return new Yq();
              }, Tg["application/x-mpegurl"] = function () {
                return new Yq();
              }, Tg["application/vnd.apple.mpegurl"] = function () {
                return new Yq();
              });
              function Yr(a, b, c, d, e, f) {
                if (200 <= c && 299 >= c && 202 != c) return {
                  uri: e || d,
                  Oe: d,
                  data: b,
                  status: c,
                  headers: a,
                  fromCache: !!a["x-shaka-from-cache"]
                };
                e = null;
                try {
                  e = Fc(b);
                } catch (g) {}
                throw new O(401 == c || 403 == c ? 2 : 1, 1, 1001, d, c, e, a, f);
              }
              function Zr() {}
              function $r(a, b, c, d, e) {
                var f = new as();
                tf(b.headers).forEach(function (l, m) {
                  f.append(m, l);
                });
                var g = new bs(),
                  h = {
                    ye: !1,
                    bf: !1
                  };
                a = cs(a, c, {
                  body: b.body || void 0,
                  headers: f,
                  method: b.method,
                  signal: g.signal,
                  credentials: b.allowCrossSiteCredentials ? "include" : void 0
                }, h, d, e, b.streamDataCallback);
                a = new Le(a, function () {
                  h.ye = !0;
                  g.abort();
                  return Promise.resolve();
                });
                if (b = b.retryParameters.timeout) {
                  var k = new P(function () {
                    h.bf = !0;
                    g.abort();
                  });
                  k.N(b / 1E3);
                  a.finally(function () {
                    k.stop();
                  });
                }
                return a;
              }
              function cs(a, b, c, d, e, f, g) {
                var h, k, l, m, n, p, t, v, y, w, x, C, z;
                return G(function (B) {
                  switch (B.g) {
                    case 1:
                      return h = ds, k = es, p = n = 0, t = Date.now(), D(B, 2), u(B, h(a, c), 4);
                    case 4:
                      return l = B.h, f(fs(l.headers)), v = l.clone().body.getReader(), w = (y = l.headers.get("Content-Length")) ? parseInt(y, 10) : 0, x = function x(E) {
                        function F() {
                          var H, I;
                          return G(function (J) {
                            switch (J.g) {
                              case 1:
                                return D(J, 2), u(J, v.read(), 4);
                              case 4:
                                H = J.h;
                                ta(J, 3);
                                break;
                              case 2:
                                return ua(J), J.return();
                              case 3:
                                if (H.done) {
                                  J.A(5);
                                  break;
                                }
                                n += H.value.byteLength;
                                if (!g) {
                                  J.A(5);
                                  break;
                                }
                                return u(J, g(H.value), 5);
                              case 5:
                                I = Date.now();
                                if (100 < I - t || H.done) e(I - t, n - p, w - n), p = n, t = I;
                                H.done ? E.close() : (E.enqueue(H.value), F());
                                A(J);
                            }
                          });
                        }
                        F();
                      }, new k({
                        start: x
                      }), u(B, l.arrayBuffer(), 5);
                    case 5:
                      m = B.h;
                      ta(B, 3);
                      break;
                    case 2:
                      C = ua(B);
                      if (d.ye) throw new O(1, 1, 7001, a, b);
                      if (d.bf) throw new O(1, 1, 1003, a, b);
                      throw new O(1, 1, 1002, a, C, b);
                    case 3:
                      return z = fs(l.headers), B.return(Yr(z, m, l.status, a, l.url, b));
                  }
                });
              }
              function fs(a) {
                var b = {};
                a.forEach(function (c, d) {
                  b[d.trim()] = c;
                });
                return b;
              }
              function gs() {
                if (window.ReadableStream) try {
                  new ReadableStream({});
                } catch (a) {
                  return !1;
                } else return !1;
                return !(!window.fetch || !window.AbortController);
              }
              K("shaka.net.HttpFetchPlugin", Zr);
              Zr.isSupported = gs;
              Zr.parse = $r;
              var ds = window.fetch,
                bs = window.AbortController,
                es = window.ReadableStream,
                as = window.Headers;
              gs() && ($e("http", $r, 2, !0), $e("https", $r, 2, !0), $e("blob", $r, 2, !0));
              function hs() {}
              function is(a, b, c, d, e) {
                var f = new js(),
                  g = Date.now(),
                  h = 0,
                  k = new Promise(function (l, m) {
                    f.open(b.method, a, !0);
                    f.responseType = "arraybuffer";
                    f.timeout = b.retryParameters.timeout;
                    f.withCredentials = b.allowCrossSiteCredentials;
                    f.onabort = function () {
                      m(new O(1, 1, 7001, a, c));
                    };
                    var n = !1;
                    f.onreadystatechange = function () {
                      if (2 == f.readyState && !n) {
                        var t = ks(f);
                        e(t);
                        n = !0;
                      }
                    };
                    f.onload = function () {
                      var t = ks(f),
                        v = f.response;
                      try {
                        var y = Yr(t, v, f.status, a, f.responseURL, c);
                        l(y);
                      } catch (w) {
                        m(w);
                      }
                    };
                    f.onerror = function (t) {
                      m(new O(1, 1, 1002, a, t, c));
                    };
                    f.ontimeout = function () {
                      m(new O(1, 1, 1003, a, c));
                    };
                    f.onprogress = function (t) {
                      var v = Date.now();
                      if (100 < v - g || t.lengthComputable && t.loaded == t.total) d(v - g, t.loaded - h, t.total - t.loaded), h = t.loaded, g = v;
                    };
                    for (var p in b.headers) f.setRequestHeader(p.toLowerCase(), b.headers[p]);
                    f.send(b.body);
                  });
                return new Le(k, function () {
                  f.abort();
                  return Promise.resolve();
                });
              }
              function ks(a) {
                var b = a.getAllResponseHeaders().trim().split("\r\n");
                a = {};
                b = r(b);
                for (var c = b.next(); !c.done; c = b.next()) c = c.value.split(": "), a[c[0].toLowerCase()] = c.slice(1).join(": ");
                return a;
              }
              K("shaka.net.HttpXHRPlugin", hs);
              hs.parse = is;
              var js = window.XMLHttpRequest;
              $e("http", is, 1, !0);
              $e("https", is, 1, !0);
              $e("blob", is, 1, !0);
              function ls(a, b, c, d) {
                this.g = a;
                this.i = b;
                this.groupId = c;
                this.h = d;
              }
              function ms(a) {
                return a.ya().map(function (b) {
                  return "{" + encodeURI(b) + "}";
                }).join("") + ":" + a.Ba + ":" + a.ka;
              }
              function ns(a, b) {
                return ck(a.g.ya(), a.g.Ba, a.g.ka, b.streaming.retryParameters);
              }
              function os() {
                this.h = this.j = this.i = 0;
                this.g = new Map();
                this.l = 0;
              }
              function ps(a, b) {
                a.i += b;
                var c = a.l;
                a.l++;
                a.g.set(c, b);
                return c;
              }
              os.prototype.close = function (a, b) {
                if (this.g.has(a)) {
                  var c = this.g.get(a);
                  this.g.delete(a);
                  this.j += c;
                  this.h += b;
                }
              };
              function qs(a) {
                var b = this;
                this.o = a;
                this.j = new Map();
                this.i = new kf(function () {
                  return rs(b).catch(function () {});
                });
                this.h = [];
                this.m = function () {};
                this.l = function () {};
                this.g = new os();
              }
              qs.prototype.destroy = function () {
                return this.i.destroy();
              };
              function ss(a, b, c) {
                a.m = b;
                a.l = c;
              }
              function rs(a) {
                var b = a.h.map(function (c) {
                  return c();
                });
                a.h = [];
                return Promise.all(b);
              }
              function ts(a, b, c, d, e, f) {
                lf(a.i);
                var g = (a.j.get(b) || Promise.resolve()).then(function () {
                  var h, k, l, m, n, p, t;
                  return G(function (v) {
                    if (1 == v.g) return u(v, us(a, c), 2);
                    h = v.h;
                    if (a.i.g) throw new O(2, 9, 7001);
                    if (e) for (m in k = M(h), l = new Jf(k), l.data) n = Number(m), p = l.data[n], t = l.g[n], a.l(p, t);
                    a.g.close(d, h.byteLength);
                    var y = a.g;
                    a.m(0 == y.i ? 0 : y.j / y.i, a.g.h);
                    return v.return(f(h));
                  });
                });
                a.j.set(b, g);
              }
              function vs(a) {
                return G(function (b) {
                  return 1 == b.g ? u(b, Promise.all(a.j.values()), 2) : b.return(a.g.h);
                });
              }
              function us(a, b) {
                var c, d, e, f;
                return G(function (g) {
                  if (1 == g.g) return c = jf, d = a.o.request(c, b), e = function e() {
                    return d.abort();
                  }, a.h.push(e), u(g, d.promise, 2);
                  f = g.h;
                  hb(a.h, e);
                  return g.return(f.data);
                });
              }
              function ws(a, b) {
                var c = this;
                this.i = a;
                this.h = a.objectStore(b);
                this.g = new lc();
                a.onabort = function (d) {
                  d.preventDefault();
                  c.g.reject();
                };
                a.onerror = function (d) {
                  d.preventDefault();
                  c.g.reject();
                };
                a.oncomplete = function () {
                  c.g.resolve();
                };
              }
              ws.prototype.abort = function () {
                var a = this;
                return G(function (b) {
                  if (1 == b.g) {
                    try {
                      a.i.abort();
                    } catch (c) {}
                    D(b, 2);
                    return u(b, a.g, 4);
                  }
                  if (2 != b.g) return ta(b, 0);
                  ua(b);
                  A(b);
                });
              };
              function xs(a, b) {
                return new Promise(function (c, d) {
                  var e = a.h.openCursor();
                  e.onerror = d;
                  e.onsuccess = function () {
                    var f;
                    return G(function (g) {
                      if (1 == g.g) {
                        if (null == e.result) return c(), g.return();
                        f = e.result;
                        return u(g, b(f.key, f.value, f), 2);
                      }
                      f.continue();
                      A(g);
                    });
                  };
                });
              }
              ws.prototype.store = function () {
                return this.h;
              };
              ws.prototype.promise = function () {
                return this.g;
              };
              function ys(a) {
                this.h = a;
                this.g = [];
              }
              ys.prototype.destroy = function () {
                return Promise.all(this.g.map(function (a) {
                  return a.abort();
                }));
              };
              function zs(a, b) {
                return As(a, b, "readwrite");
              }
              function As(a, b, c) {
                c = a.h.transaction([b], c);
                var d = new ws(c, b);
                a.g.push(d);
                d.promise().then(function () {
                  hb(a.g, d);
                }, function () {
                  hb(a.g, d);
                });
                return d;
              }
              function Bs(a, b, c) {
                this.h = new ys(a);
                this.i = b;
                this.g = c;
              }
              q = Bs.prototype;
              q.destroy = function () {
                return this.h.destroy();
              };
              q.hasFixedKeySpace = function () {
                return !0;
              };
              q.addSegments = function () {
                return Cs(this.i);
              };
              q.removeSegments = function (a, b) {
                return Ds(this, this.i, a, b);
              };
              q.getSegments = function (a) {
                var b = this,
                  c;
                return G(function (d) {
                  if (1 == d.g) return u(d, Es(b, b.i, a), 2);
                  c = d.h;
                  return d.return(c.map(function (e) {
                    return b.ze(e);
                  }));
                });
              };
              q.addManifests = function () {
                return Cs(this.g);
              };
              q.updateManifest = function () {
                return Promise.reject(new O(2, 9, 9016, "Cannot modify values in " + this.g));
              };
              function Fs(a, b, c) {
                a = zs(a.h, a.g);
                var d = a.store();
                d.get(b).onsuccess = function () {
                  d.put(c, b);
                };
                return a.promise();
              }
              q.updateManifestExpiration = function (a, b) {
                var c = zs(this.h, this.g),
                  d = c.store();
                d.get(a).onsuccess = function (e) {
                  if (e = e.target.result) e.expiration = b, d.put(e, a);
                };
                return c.promise();
              };
              q.removeManifests = function (a, b) {
                return Ds(this, this.g, a, b);
              };
              q.getManifests = function (a) {
                var b = this,
                  c;
                return G(function (d) {
                  if (1 == d.g) return u(d, Es(b, b.g, a), 2);
                  c = d.h;
                  return d.return(Promise.all(c.map(function (e) {
                    return b.bc(e);
                  })));
                });
              };
              q.getAllManifests = function () {
                var a = this,
                  b,
                  c;
                return G(function (d) {
                  return 1 == d.g ? (b = As(a.h, a.g, "readonly"), c = new Map(), u(d, xs(b, function (e, f) {
                    var g;
                    return G(function (h) {
                      if (1 == h.g) return u(h, a.bc(f), 2);
                      g = h.h;
                      c.set(e, g);
                      A(h);
                    });
                  }), 2)) : 3 != d.g ? u(d, b.promise(), 3) : d.return(c);
                });
              };
              q.ze = function (a) {
                return a;
              };
              q.bc = function (a) {
                return Promise.resolve(a);
              };
              function Cs(a) {
                return Promise.reject(new O(2, 9, 9011, "Cannot add new value to " + a));
              }
              q.add = function (a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l;
                return G(function (m) {
                  if (1 == m.g) {
                    d = zs(c.h, a);
                    e = d.store();
                    f = [];
                    g = {};
                    h = r(b);
                    for (k = h.next(); !k.done; g = {
                      Fc: g.Fc
                    }, k = h.next()) l = k.value, g.Fc = e.add(l), g.Fc.onsuccess = function (n) {
                      return function () {
                        f.push(n.Fc.result);
                      };
                    }(g);
                    return u(m, d.promise(), 2);
                  }
                  return m.return(f);
                });
              };
              function Ds(a, b, c, d) {
                a = zs(a.h, b);
                b = a.store();
                var e = {};
                c = r(c);
                for (var f = c.next(); !f.done; e = {
                  Ec: e.Ec
                }, f = c.next()) e.Ec = f.value, b.delete(e.Ec).onsuccess = function (g) {
                  return function () {
                    return d(g.Ec);
                  };
                }(e);
                return a.promise();
              }
              function Es(a, b, c) {
                var d, e, f, g, h, k, l;
                return G(function (m) {
                  if (1 == m.g) {
                    d = As(a.h, b, "readonly");
                    e = d.store();
                    f = {};
                    g = [];
                    h = {};
                    k = r(c);
                    for (l = k.next(); !l.done; h = {
                      Vb: h.Vb,
                      Tb: h.Tb
                    }, l = k.next()) h.Tb = l.value, h.Vb = e.get(h.Tb), h.Vb.onsuccess = function (n) {
                      return function () {
                        void 0 == n.Vb.result && g.push(n.Tb);
                        f[n.Tb] = n.Vb.result;
                      };
                    }(h);
                    return u(m, d.promise(), 2);
                  }
                  if (g.length) throw new O(2, 9, 9012, "Could not find values for " + g);
                  return m.return(c.map(function (n) {
                    return f[n];
                  }));
                });
              }
              function Gs(a) {
                this.g = new ys(a);
              }
              Gs.prototype.destroy = function () {
                return this.g.destroy();
              };
              Gs.prototype.getAll = function () {
                var a = this,
                  b,
                  c;
                return G(function (d) {
                  return 1 == d.g ? (b = As(a.g, "session-ids", "readonly"), c = [], u(d, xs(b, function (e, f) {
                    c.push(f);
                  }), 2)) : 3 != d.g ? u(d, b.promise(), 3) : d.return(c);
                });
              };
              Gs.prototype.add = function (a) {
                var b = zs(this.g, "session-ids"),
                  c = b.store();
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) c.add(d.value);
                return b.promise();
              };
              Gs.prototype.remove = function (a) {
                var b = this,
                  c;
                return G(function (d) {
                  return 1 == d.g ? (c = zs(b.g, "session-ids"), u(d, xs(c, function (e, f, g) {
                    a.includes(f.sessionId) && g.delete();
                  }), 2)) : u(d, c.promise(), 0);
                });
              };
              function Hs() {
                this.g = new Map();
              }
              Hs.prototype.destroy = function () {
                for (var a = [], b = r(this.g.values()), c = b.next(); !c.done; c = b.next()) a.push(c.value.destroy());
                this.g.clear();
                return Promise.all(a);
              };
              Hs.prototype.init = function () {
                var a = this;
                Is.forEach(function (e, f) {
                  (e = e()) && a.g.set(f, e);
                });
                for (var b = [], c = r(this.g.values()), d = c.next(); !d.done; d = c.next()) b.push(d.value.init());
                return Promise.all(b);
              };
              function Js(a) {
                var b = null;
                a.g.forEach(function (c, d) {
                  c.getCells().forEach(function (e, f) {
                    e.hasFixedKeySpace() || b || (b = {
                      path: {
                        za: d,
                        ja: f
                      },
                      ja: e
                    });
                  });
                });
                if (b) return b;
                throw new O(2, 9, 9013, "Could not find a cell that supports add-operations");
              }
              function Ks(a, b) {
                a.g.forEach(function (c, d) {
                  c.getCells().forEach(function (e, f) {
                    b({
                      za: d,
                      ja: f
                    }, e);
                  });
                });
              }
              function Ls(a, b, c) {
                a = a.g.get(b);
                if (!a) throw new O(2, 9, 9013, "Could not find mechanism with name " + b);
                b = a.getCells().get(c);
                if (!b) throw new O(2, 9, 9013, "Could not find cell with name " + c);
                return b;
              }
              function Ms(a, b) {
                a.g.forEach(function (c) {
                  b(c.getEmeSessionCell());
                });
              }
              function Ns(a) {
                var b = Array.from(a.g.keys());
                if (!b.length) throw new O(2, 9, 9E3, "No supported storage mechanisms found");
                return a.g.get(b[0]).getEmeSessionCell();
              }
              function Os(a) {
                var b, c, d;
                return G(function (e) {
                  return 1 == e.g ? (b = Array.from(a.g.values()), c = 0 < b.length, c || (d = Is, d.forEach(function (f) {
                    (f = f()) && b.push(f);
                  })), u(e, Promise.all(b.map(function (f) {
                    return f.erase();
                  })), 2)) : c ? e.A(0) : u(e, Promise.all(b.map(function (f) {
                    return f.destroy();
                  })), 0);
                });
              }
              function Ps(a, b) {
                Is.set(a, b);
              }
              K("shaka.offline.StorageMuxer", Hs);
              Hs.unregister = function (a) {
                Is.delete(a);
              };
              Hs.register = Ps;
              Hs.prototype.destroy = Hs.prototype.destroy;
              var Is = new Map();
              function Qs() {
                Bs.apply(this, arguments);
              }
              oa(Qs, Bs);
              Qs.prototype.updateManifestExpiration = function (a, b) {
                var c = this,
                  d,
                  e,
                  f;
                return G(function (g) {
                  d = zs(c.h, c.g);
                  e = d.store();
                  f = new lc();
                  e.get(a).onsuccess = function (h) {
                    (h = h.target.result) ? (h.expiration = b, e.put(h), f.resolve()) : f.reject(new O(2, 9, 9012, "Could not find values for " + a));
                  };
                  return u(g, Promise.all([d.promise(), f]), 0);
                });
              };
              Qs.prototype.bc = function (a) {
                var b, c, d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) {
                    b = [];
                    for (c = 0; c < a.periods.length; ++c) d = c == a.periods.length - 1 ? a.duration : a.periods[c + 1].startTime, e = d - a.periods[c].startTime, f = Rs(a.periods[c], e), b.push(f);
                    return u(h, Pp(b), 2);
                  }
                  g = h.h;
                  return h.return({
                    creationTime: 0,
                    originalManifestUri: a.originalManifestUri,
                    duration: a.duration,
                    size: a.size,
                    expiration: null == a.expiration ? Infinity : a.expiration,
                    streams: g,
                    sessionIds: a.sessionIds,
                    drmInfo: a.drmInfo,
                    appMetadata: a.appMetadata,
                    sequenceMode: !1
                  });
                });
              };
              function Rs(a, b) {
                Ss(a);
                for (var c = r(a.streams), d = c.next(); !d.done; d = c.next());
                return a.streams.map(function (e) {
                  return Ts(e, a.startTime, b);
                });
              }
              function Ts(a, b, c) {
                var d = a.initSegmentUri ? Us(a.initSegmentUri) : null,
                  e = b + a.presentationTimeOffset,
                  f = b + c;
                return {
                  id: a.id,
                  originalId: null,
                  primary: a.primary,
                  type: a.contentType,
                  mimeType: a.mimeType,
                  codecs: a.codecs,
                  frameRate: a.frameRate,
                  pixelAspectRatio: void 0,
                  hdr: void 0,
                  kind: a.kind,
                  language: a.language,
                  label: a.label,
                  width: a.width,
                  height: a.height,
                  initSegmentKey: d,
                  encrypted: a.encrypted,
                  keyIds: new Set([a.keyId]),
                  segments: a.segments.map(function (g) {
                    var h = Us(g.uri);
                    return {
                      startTime: b + g.startTime,
                      endTime: b + g.endTime,
                      dataKey: h,
                      initSegmentKey: d,
                      appendWindowStart: b,
                      appendWindowEnd: f,
                      timestampOffset: e,
                      tilesLayout: ""
                    };
                  }),
                  variantIds: a.variantIds,
                  roles: [],
                  forced: !1,
                  audioSamplingRate: null,
                  channelsCount: null,
                  spatialAudio: !1,
                  closedCaptions: null,
                  tilesLayout: void 0
                };
              }
              Qs.prototype.ze = function (a) {
                return {
                  data: a.data
                };
              };
              function Us(a) {
                var b;
                if ((b = /^offline:[0-9]+\/[0-9]+\/([0-9]+)$/.exec(a)) || (b = /^offline:segment\/([0-9]+)$/.exec(a))) return Number(b[1]);
                throw new O(2, 9, 9004, "Could not parse uri " + a);
              }
              function Ss(a) {
                var b = a.streams.filter(function (h) {
                  return "audio" == h.contentType;
                });
                a = a.streams.filter(function (h) {
                  return "video" == h.contentType;
                });
                if (!b.every(function (h) {
                  return h.variantIds;
                }) || !a.every(function (h) {
                  return h.variantIds;
                })) {
                  for (var c = r(b), d = c.next(); !d.done; d = c.next()) d.value.variantIds = [];
                  c = r(a);
                  for (d = c.next(); !d.done; d = c.next()) d.value.variantIds = [];
                  c = 0;
                  if (a.length && !b.length) {
                    var e = c++,
                      f = r(a);
                    for (d = f.next(); !d.done; d = f.next()) d.value.variantIds.push(e);
                  }
                  if (!a.length && b.length) for (e = c++, f = r(b), d = f.next(); !d.done; d = f.next()) d.value.variantIds.push(e);
                  if (a.length && b.length) for (b = r(b), d = b.next(); !d.done; d = b.next()) for (d = d.value, e = r(a), f = e.next(); !f.done; f = e.next()) {
                    f = f.value;
                    var g = c++;
                    d.variantIds.push(g);
                    f.variantIds.push(g);
                  }
                }
              }
              function Vs() {
                Bs.apply(this, arguments);
              }
              oa(Vs, Bs);
              Vs.prototype.bc = function (a) {
                var b, c, d, e, f, g;
                return G(function (h) {
                  if (1 == h.g) {
                    b = [];
                    for (c = 0; c < a.periods.length; ++c) {
                      d = c == a.periods.length - 1 ? a.duration : a.periods[c + 1].startTime;
                      e = d - a.periods[c].startTime;
                      for (var k = a.periods[c], l = [], m = r(k.streams), n = m.next(); !n.done; n = m.next()) n = n.value, 0 != n.variantIds.length && l.push(Ws(n, k.startTime, k.startTime + e));
                      f = l;
                      b.push(f);
                    }
                    return u(h, Pp(b), 2);
                  }
                  g = h.h;
                  return h.return({
                    appMetadata: a.appMetadata,
                    creationTime: 0,
                    drmInfo: a.drmInfo,
                    duration: a.duration,
                    expiration: null == a.expiration ? Infinity : a.expiration,
                    originalManifestUri: a.originalManifestUri,
                    sessionIds: a.sessionIds,
                    size: a.size,
                    streams: g,
                    sequenceMode: !1
                  });
                });
              };
              function Ws(a, b, c) {
                return {
                  id: a.id,
                  originalId: a.originalId,
                  primary: a.primary,
                  type: a.contentType,
                  mimeType: a.mimeType,
                  codecs: a.codecs,
                  frameRate: a.frameRate,
                  pixelAspectRatio: a.pixelAspectRatio,
                  hdr: void 0,
                  kind: a.kind,
                  language: a.language,
                  label: a.label,
                  width: a.width,
                  height: a.height,
                  encrypted: a.encrypted,
                  keyIds: new Set([a.keyId]),
                  segments: a.segments.map(function (d) {
                    return {
                      startTime: b + d.startTime,
                      endTime: b + d.endTime,
                      initSegmentKey: a.initSegmentKey,
                      appendWindowStart: b,
                      appendWindowEnd: c,
                      timestampOffset: b - a.presentationTimeOffset,
                      dataKey: d.dataKey,
                      tilesLayout: ""
                    };
                  }),
                  variantIds: a.variantIds,
                  roles: [],
                  forced: !1,
                  audioSamplingRate: null,
                  channelsCount: null,
                  spatialAudio: !1,
                  closedCaptions: null,
                  tilesLayout: void 0
                };
              }
              function Xs() {
                Bs.apply(this, arguments);
              }
              oa(Xs, Bs);
              q = Xs.prototype;
              q.hasFixedKeySpace = function () {
                return !1;
              };
              q.addSegments = function (a) {
                return this.add(this.i, a);
              };
              q.addManifests = function (a) {
                return this.add(this.g, a);
              };
              q.updateManifest = function (a, b) {
                return Fs(this, a, b);
              };
              q.bc = function (a) {
                null == a.expiration && (a.expiration = Infinity);
                return Promise.resolve(a);
              };
              function Ys() {
                this.m = this.j = this.i = this.h = this.g = this.l = null;
              }
              q = Ys.prototype;
              q.init = function () {
                var a = this,
                  b = new lc(),
                  c = !1,
                  d = new P(function () {
                    c = !0;
                    b.reject(new O(2, 9, 9017));
                  });
                d.N(5);
                var e = window.indexedDB.open("shaka_offline_db", 5);
                e.onsuccess = function () {
                  if (!c) {
                    var f = e.result;
                    a.l = f;
                    var g = f.objectStoreNames;
                    g = g.contains("manifest") && g.contains("segment") ? new Qs(f, "segment", "manifest") : null;
                    a.g = g;
                    g = f.objectStoreNames;
                    g = g.contains("manifest-v2") && g.contains("segment-v2") ? new Vs(f, "segment-v2", "manifest-v2") : null;
                    a.h = g;
                    g = f.objectStoreNames;
                    g = g.contains("manifest-v3") && g.contains("segment-v3") ? new Vs(f, "segment-v3", "manifest-v3") : null;
                    a.i = g;
                    g = f.objectStoreNames;
                    g = g.contains("manifest-v5") && g.contains("segment-v5") ? new Xs(f, "segment-v5", "manifest-v5") : null;
                    a.j = g;
                    f = f.objectStoreNames.contains("session-ids") ? new Gs(f) : null;
                    a.m = f;
                    d.stop();
                    b.resolve();
                  }
                };
                e.onupgradeneeded = function () {
                  for (var f = e.result, g = r(["segment-v5", "manifest-v5", "session-ids"]), h = g.next(); !h.done; h = g.next()) h = h.value, f.objectStoreNames.contains(h) || f.createObjectStore(h, {
                    autoIncrement: !0
                  });
                };
                e.onerror = function (f) {
                  c || (b.reject(new O(2, 9, 9001, e.error)), d.stop(), f.preventDefault());
                };
                return b;
              };
              q.destroy = function () {
                var a = this;
                return G(function (b) {
                  switch (b.g) {
                    case 1:
                      if (!a.g) {
                        b.A(2);
                        break;
                      }
                      return u(b, a.g.destroy(), 2);
                    case 2:
                      if (!a.h) {
                        b.A(4);
                        break;
                      }
                      return u(b, a.h.destroy(), 4);
                    case 4:
                      if (!a.i) {
                        b.A(6);
                        break;
                      }
                      return u(b, a.i.destroy(), 6);
                    case 6:
                      if (!a.j) {
                        b.A(8);
                        break;
                      }
                      return u(b, a.j.destroy(), 8);
                    case 8:
                      if (!a.m) {
                        b.A(10);
                        break;
                      }
                      return u(b, a.m.destroy(), 10);
                    case 10:
                      a.l && a.l.close(), A(b);
                  }
                });
              };
              q.getCells = function () {
                var a = new Map();
                this.g && a.set("v1", this.g);
                this.h && a.set("v2", this.h);
                this.i && a.set("v3", this.i);
                this.j && a.set("v5", this.j);
                return a;
              };
              q.getEmeSessionCell = function () {
                return this.m;
              };
              q.erase = function () {
                var a = this;
                return G(function (b) {
                  switch (b.g) {
                    case 1:
                      if (!a.g) {
                        b.A(2);
                        break;
                      }
                      return u(b, a.g.destroy(), 2);
                    case 2:
                      if (!a.h) {
                        b.A(4);
                        break;
                      }
                      return u(b, a.h.destroy(), 4);
                    case 4:
                      if (!a.i) {
                        b.A(6);
                        break;
                      }
                      return u(b, a.i.destroy(), 6);
                    case 6:
                      if (!a.j) {
                        b.A(8);
                        break;
                      }
                      return u(b, a.j.destroy(), 8);
                    case 8:
                      return a.l && a.l.close(), u(b, Zs(), 10);
                    case 10:
                      return a.l = null, a.g = null, a.h = null, a.i = null, a.j = null, u(b, a.init(), 0);
                  }
                });
              };
              function Zs() {
                var a = new lc(),
                  b = window.indexedDB.deleteDatabase("shaka_offline_db");
                b.onblocked = function () {};
                b.onsuccess = function () {
                  a.resolve();
                };
                b.onerror = function (c) {
                  a.reject(new O(2, 9, 9001, b.error));
                  c.preventDefault();
                };
                return a;
              }
              Ps("idb", function () {
                return tc("CrKey") || sc() || !window.indexedDB ? null : new Ys();
              });
              function $s(a, b, c, d) {
                this.g = a;
                this.i = b;
                this.h = c;
                this.l = d;
                this.j = ["offline:", a, "/", b, "/", c, "/", d].join("");
              }
              $s.prototype.za = function () {
                return this.i;
              };
              $s.prototype.ja = function () {
                return this.h;
              };
              $s.prototype.key = function () {
                return this.l;
              };
              $s.prototype.toString = function () {
                return this.j;
              };
              function at(a) {
                a = /^offline:([a-z]+)\/([^/]+)\/([^/]+)\/([0-9]+)$/.exec(a);
                if (null == a) return null;
                var b = a[1];
                if ("manifest" != b && "segment" != b) return null;
                var c = a[2];
                if (!c) return null;
                var d = a[3];
                return d && null != b ? new $s(b, c, d, Number(a[4])) : null;
              }
              function bt(a, b) {
                this.h = a;
                this.g = b;
              }
              function ct(a, b) {
                var c = new T(null, 0);
                c.Aa(b.duration);
                var d = b.streams.filter(function (l) {
                    return "audio" == l.type;
                  }),
                  e = b.streams.filter(function (l) {
                    return "video" == l.type;
                  });
                d = dt(a, d, e, c);
                e = b.streams.filter(function (l) {
                  return l.type == jc;
                }).map(function (l) {
                  return et(a, l, c);
                });
                var f = b.streams.filter(function (l) {
                    return "image" == l.type;
                  }).map(function (l) {
                    return et(a, l, c);
                  }),
                  g = b.drmInfo ? [b.drmInfo] : [];
                if (b.drmInfo) for (var h = r(d.values()), k = h.next(); !k.done; k = h.next()) k = k.value, k.audio && k.audio.encrypted && (k.audio.drmInfos = g), k.video && k.video.encrypted && (k.video.drmInfos = g);
                return {
                  presentationTimeline: c,
                  minBufferTime: 2,
                  offlineSessionIds: b.sessionIds,
                  variants: Array.from(d.values()),
                  textStreams: e,
                  imageStreams: f,
                  sequenceMode: b.sequenceMode || !1
                };
              }
              function dt(a, b, c, d) {
                for (var e = new Set(), f = r(b), g = f.next(); !g.done; g = f.next()) {
                  var h = r(g.value.variantIds);
                  for (g = h.next(); !g.done; g = h.next()) e.add(g.value);
                }
                f = r(c);
                for (g = f.next(); !g.done; g = f.next()) for (h = r(g.value.variantIds), g = h.next(); !g.done; g = h.next()) e.add(g.value);
                f = new Map();
                e = r(e);
                for (g = e.next(); !g.done; g = e.next()) g = g.value, f.set(g, {
                  id: g,
                  language: "",
                  disabledUntilTime: 0,
                  primary: !1,
                  audio: null,
                  video: null,
                  bandwidth: 0,
                  allowedByApplication: !0,
                  allowedByKeySystem: !0,
                  decodingInfos: []
                });
                b = r(b);
                for (e = b.next(); !e.done; e = b.next()) for (e = e.value, g = et(a, e, d), h = r(e.variantIds), e = h.next(); !e.done; e = h.next()) e = f.get(e.value), e.language = g.language, e.primary = e.primary || g.primary, e.audio = g;
                c = r(c);
                for (b = c.next(); !b.done; b = c.next()) for (e = b.value, b = et(a, e, d), g = r(e.variantIds), e = g.next(); !e.done; e = g.next()) e = f.get(e.value), e.primary = e.primary || b.primary, e.video = b;
                return f;
              }
              function et(a, b, c) {
                var d = b.segments.map(function (e) {
                  return ft(a, e);
                });
                c.Ib(d);
                return {
                  id: b.id,
                  originalId: b.originalId,
                  createSegmentIndex: function createSegmentIndex() {
                    return Promise.resolve();
                  },
                  segmentIndex: new Jj(d),
                  mimeType: b.mimeType,
                  codecs: b.codecs,
                  width: b.width || void 0,
                  height: b.height || void 0,
                  frameRate: b.frameRate,
                  pixelAspectRatio: b.pixelAspectRatio,
                  hdr: b.hdr,
                  kind: b.kind,
                  encrypted: b.encrypted,
                  drmInfos: [],
                  keyIds: b.keyIds,
                  language: b.language,
                  label: b.label,
                  type: b.type,
                  primary: b.primary,
                  trickModeVideo: null,
                  emsgSchemeIdUris: null,
                  roles: b.roles,
                  forced: b.forced,
                  channelsCount: b.channelsCount,
                  audioSamplingRate: b.audioSamplingRate,
                  spatialAudio: b.spatialAudio,
                  closedCaptions: b.closedCaptions,
                  tilesLayout: b.tilesLayout
                };
              }
              function ft(a, b) {
                var c = new $s("segment", a.h, a.g, b.dataKey);
                return new qi(b.startTime, b.endTime, function () {
                  return [c.toString()];
                }, 0, null, null != b.initSegmentKey ? gt(a, b.initSegmentKey) : null, b.timestampOffset, b.appendWindowStart, b.appendWindowEnd, [], b.tilesLayout || "");
              }
              function gt(a, b) {
                var c = new $s("segment", a.h, a.g, b);
                return new oi(function () {
                  return [c.toString()];
                }, 0, null);
              }
              function ht() {
                this.g = null;
              }
              q = ht.prototype;
              q.configure = function () {};
              q.start = function (a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l;
                return G(function (m) {
                  switch (m.g) {
                    case 1:
                      d = at(a);
                      c.g = d;
                      if (null == d || "manifest" != d.g) throw new O(2, 1, 9004, a);
                      e = new Hs();
                      sa(m);
                      return u(m, e.init(), 4);
                    case 4:
                      return u(m, Ls(e, d.za(), d.ja()), 5);
                    case 5:
                      return f = m.h, u(m, f.getManifests([d.key()]), 6);
                    case 6:
                      return g = m.h, h = g[0], k = new bt(d.za(), d.ja()), l = ct(k, h), b.makeTextStreamsForClosedCaptions(l), m.return(l);
                    case 2:
                      return xa(m), u(m, e.destroy(), 7);
                    case 7:
                      ya(m, 0);
                  }
                });
              };
              q.stop = function () {
                return Promise.resolve();
              };
              q.update = function () {};
              q.onExpirationUpdated = function (a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l;
                return G(function (m) {
                  switch (m.g) {
                    case 1:
                      return d = c.g, e = new Hs(), D(m, 2, 3), u(m, e.init(), 5);
                    case 5:
                      return u(m, Ls(e, d.za(), d.ja()), 6);
                    case 6:
                      return f = m.h, u(m, f.getManifests([d.key()]), 7);
                    case 7:
                      g = m.h;
                      h = g[0];
                      k = h.sessionIds.includes(a);
                      l = void 0 == h.expiration || h.expiration > b;
                      if (!k || !l) {
                        m.A(3);
                        break;
                      }
                      return u(m, f.updateManifestExpiration(d.key(), b), 3);
                    case 3:
                      return xa(m), u(m, e.destroy(), 10);
                    case 10:
                      ya(m, 0);
                      break;
                    case 2:
                      ua(m), m.A(3);
                  }
                });
              };
              Tg["application/x-offline-manifest"] = function () {
                return new ht();
              };
              function it() {}
              function jt(a) {
                var b = at(a);
                b && "manifest" == b.g ? (a = {
                  uri: a,
                  Oe: a,
                  data: new ArrayBuffer(0),
                  headers: {
                    "content-type": "application/x-offline-manifest"
                  }
                }, a = Oe(a)) : a = b && "segment" == b.g ? kt(b.key(), b) : Me(new O(2, 1, 9004, a));
                return a;
              }
              function kt(a, b) {
                var c = new Hs();
                return Oe(void 0).Y(function () {
                  return c.init();
                }).Y(function () {
                  return Ls(c, b.za(), b.ja());
                }).Y(function (d) {
                  return d.getSegments([b.key()]);
                }).Y(function (d) {
                  return {
                    uri: b,
                    data: d[0].data,
                    headers: {}
                  };
                }).finally(function () {
                  return c.destroy();
                });
              }
              K("shaka.offline.OfflineScheme", it);
              it.plugin = jt;
              $e("offline", jt);
              function lt(a, b, c) {
                var d, e, f, g, h, k;
                return G(function (l) {
                  switch (l.g) {
                    case 1:
                      d = [];
                      for (var m = [], n = r(c), p = n.next(); !p.done; p = n.next()) {
                        p = p.value;
                        for (var t = !1, v = r(m), y = v.next(); !y.done; y = v.next()) if (y = y.value, mt(y.info, p)) {
                          y.sessionIds.push(p.sessionId);
                          t = !0;
                          break;
                        }
                        t || m.push({
                          info: p,
                          sessionIds: [p.sessionId]
                        });
                      }
                      e = r(m);
                      f = e.next();
                    case 2:
                      if (f.done) {
                        l.A(4);
                        break;
                      }
                      g = f.value;
                      h = nt(a, b, g);
                      return u(l, h, 5);
                    case 5:
                      k = l.h;
                      d = d.concat(k);
                      f = e.next();
                      l.A(2);
                      break;
                    case 4:
                      return l.return(d);
                  }
                });
              }
              function nt(a, b, c) {
                var d, e;
                return G(function (f) {
                  switch (f.g) {
                    case 1:
                      return d = new fg({
                        kb: b,
                        onError: function onError() {},
                        cd: function cd() {},
                        onExpirationUpdated: function onExpirationUpdated() {},
                        onEvent: function onEvent() {}
                      }), D(f, 2), d.configure(a), u(f, ng(d, c.info.keySystem, c.info.licenseUri, c.info.serverCertificate, c.info.audioCapabilities, c.info.videoCapabilities), 4);
                    case 4:
                      ta(f, 3);
                      break;
                    case 2:
                      return ua(f), u(f, d.destroy(), 5);
                    case 5:
                      return f.return([]);
                    case 3:
                      return D(f, 6), u(f, yg(d), 8);
                    case 8:
                      ta(f, 7);
                      break;
                    case 6:
                      return ua(f), u(f, d.destroy(), 9);
                    case 9:
                      return f.return([]);
                    case 7:
                      return e = [], u(f, Promise.all(c.sessionIds.map(function (g) {
                        return G(function (h) {
                          if (1 == h.g) return D(h, 2), u(h, zg(d, g), 4);
                          if (2 != h.g) return e.push(g), ta(h, 0);
                          ua(h);
                          A(h);
                        });
                      })), 10);
                    case 10:
                      return u(f, d.destroy(), 11);
                    case 11:
                      return f.return(e);
                  }
                });
              }
              function mt(a, b) {
                function c(d, e) {
                  return d.robustness == e.robustness && d.contentType == e.contentType;
                }
                return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri && ib(a.audioCapabilities, b.audioCapabilities, c) && ib(a.videoCapabilities, b.videoCapabilities, c);
              }
              function ot(a, b, c) {
                var d = b.presentationTimeline.getDuration();
                b = pt(b);
                return {
                  offlineUri: null,
                  originalManifestUri: a,
                  duration: d,
                  size: 0,
                  expiration: Infinity,
                  tracks: b,
                  appMetadata: c,
                  isIncomplete: !1
                };
              }
              function qt(a, b) {
                var c = ct(new bt(a.za(), a.ja()), b),
                  d = b.appMetadata || {};
                c = pt(c);
                return {
                  offlineUri: a.toString(),
                  originalManifestUri: b.originalManifestUri,
                  duration: b.duration,
                  size: b.size,
                  expiration: b.expiration,
                  tracks: c,
                  appMetadata: d,
                  isIncomplete: b.isIncomplete || !1
                };
              }
              function pt(a) {
                var b = [],
                  c = ie(a.variants);
                c = r(c);
                for (var d = c.next(); !d.done; d = c.next()) b.push($d(d.value));
                a = r(a.textStreams);
                for (c = a.next(); !c.done; c = a.next()) b.push(ae(c.value));
                return b;
              }
              function rt() {
                this.g = {};
              }
              function st(a, b) {
                var c = b.audio,
                  d = b.video;
                c && !d && (a.g[c.id] = c.bandwidth || b.bandwidth);
                !c && d && (a.g[d.id] = d.bandwidth || b.bandwidth);
                if (c && d) {
                  var e = c.bandwidth || 393216,
                    f = d.bandwidth || b.bandwidth - e;
                  0 >= f && (f = b.bandwidth);
                  a.g[c.id] = e;
                  a.g[d.id] = f;
                }
              }
              function tt(a, b) {
                a.g[b.id] = b.bandwidth || 2048;
              }
              function ut(a, b) {
                a = a.g[b];
                null == a && (a = 0);
                return a;
              }
              function vt(a) {
                var b = this;
                if (a && a.constructor != V) throw new O(2, 9, 9008);
                this.g = this.h = null;
                a ? (this.h = a.h, this.g = a.jc()) : (this.h = El(), this.g = new Ze());
                this.i = [];
                this.j = [];
                var c = !a;
                this.l = new kf(function () {
                  var d, e, f, g, h;
                  return G(function (k) {
                    switch (k.g) {
                      case 1:
                        return u(k, Promise.all(b.j.map(function (l) {
                          return rs(l);
                        })), 2);
                      case 2:
                        d = function d() {};
                        e = [];
                        f = r(b.i);
                        for (g = f.next(); !g.done; g = f.next()) h = g.value, e.push(h.then(d, d));
                        return u(k, Promise.all(e), 3);
                      case 3:
                        if (!c) {
                          k.A(4);
                          break;
                        }
                        return u(k, b.g.destroy(), 4);
                      case 4:
                        b.h = null, b.g = null, A(k);
                    }
                  });
                });
              }
              function wt() {
                if (oc()) a: {
                  var a = r(Is.values());
                  for (var b = a.next(); !b.done; b = a.next()) if (b = b.value, b = b()) {
                    b.destroy();
                    a = !0;
                    break a;
                  }
                  a = !1;
                } else a = !1;
                return a;
              }
              q = vt.prototype;
              q.destroy = function () {
                return this.l.destroy();
              };
              q.configure = function (a, b) {
                2 == arguments.length && "string" == typeof a && (a = yl(a, b));
                return Gl(this.h, a);
              };
              q.getConfiguration = function () {
                var a = El();
                Gl(a, this.h, El());
                return a;
              };
              q.jc = function () {
                return this.g;
              };
              q.store = function (a, b, c) {
                var d = this,
                  e = this.getConfiguration(),
                  f = new qs(this.g);
                this.j.push(f);
                b = xt(this, a, b || {}, function () {
                  var g;
                  return G(function (h) {
                    if (1 == h.g) return u(h, Sg(a, d.g, e.manifest.retryParameters, c || null), 2);
                    g = h.h;
                    return h.return(g());
                  });
                }, e, f);
                b = new Le(b, function () {
                  return rs(f);
                });
                b.finally(function () {
                  hb(d.j, f);
                });
                return yt(this, b);
              };
              function xt(a, b, c, d, e, f) {
                var g, h, k, l, m, n, p, t, v, y, w, x, C, z;
                return G(function (B) {
                  switch (B.g) {
                    case 1:
                      return zt(), h = g = null, k = new Hs(), n = m = l = null, D(B, 2, 3), u(B, d(), 5);
                    case 5:
                      return g = B.h, u(B, At(a, b, g, e), 6);
                    case 6:
                      p = B.h;
                      Bt(a);
                      t = !p.presentationTimeline.U() && !p.presentationTimeline.jb();
                      if (!t) throw new O(2, 9, 9005, b);
                      return u(B, Ct(a, p, function (E) {
                        n = n || E;
                      }, e), 7);
                    case 7:
                      h = B.h;
                      Bt(a);
                      if (n) throw n;
                      return u(B, Dt(p, e), 8);
                    case 8:
                      return u(B, k.init(), 9);
                    case 9:
                      return Bt(a), u(B, Js(k), 10);
                    case 10:
                      return l = B.h, Bt(a), v = Et(h, p, b, c, e, f), y = v.ag, w = v.pe, u(B, l.ja.addManifests([y]), 11);
                    case 11:
                      x = B.h;
                      Bt(a);
                      m = x[0];
                      Bt(a);
                      if (n) throw n;
                      return u(B, Ft(a, w, m, y, f, e, l.ja, p, h), 12);
                    case 12:
                      return Bt(a), C = new $s("manifest", l.path.za, l.path.ja, m), B.return(qt(C, y));
                    case 3:
                      return xa(B), u(B, k.destroy(), 13);
                    case 13:
                      if (!g) {
                        B.A(14);
                        break;
                      }
                      return u(B, g.stop(), 14);
                    case 14:
                      if (!h) {
                        B.A(16);
                        break;
                      }
                      return u(B, h.destroy(), 16);
                    case 16:
                      ya(B, 0);
                      break;
                    case 2:
                      z = ua(B);
                      if (null == m) {
                        B.A(18);
                        break;
                      }
                      return u(B, Gt(m), 18);
                    case 18:
                      throw n || z;
                  }
                });
              }
              function Ft(a, b, c, d, e, f, g, h, k) {
                var l, m, n, p, t, v, y, w, x, C;
                return G(function (z) {
                  switch (z.g) {
                    case 1:
                      l = {};
                      m = 0;
                      n = function n(B, E) {
                        var F, H, I, J, L, R, Q;
                        return G(function (U) {
                          if (1 == U.g) {
                            F = {};
                            H = r(B);
                            for (I = H.next(); !I.done; F = {
                              cb: F.cb
                            }, I = H.next()) F.cb = I.value, J = ns(F.cb, f), L = F.cb.i, R = F.cb.h, Q = function (N) {
                              return function (wa) {
                                var va, Ma, Sa;
                                return G(function (Ga) {
                                  if (1 == Ga.g) return u(Ga, g.addSegments([{
                                    data: wa
                                  }]), 2);
                                  va = Ga.h;
                                  Bt(a);
                                  Ma = N.cb.g;
                                  Sa = ms(Ma);
                                  l[Sa] = va[0];
                                  m += wa.byteLength;
                                  A(Ga);
                                });
                              };
                            }(F), ts(e, F.cb.groupId, J, L, R, Q);
                            return u(U, vs(e), 2);
                          }
                          if (!E) return U.A(0);
                          Bt(a);
                          Ht(h, d, k, f);
                          return u(U, g.updateManifest(c, d), 0);
                        });
                      };
                      p = !1;
                      D(z, 2);
                      if (!It(h) || !p || Jt(h)) {
                        z.A(4);
                        break;
                      }
                      return u(z, n(b.filter(function (B) {
                        return B.h;
                      }), !0), 5);
                    case 5:
                      return Bt(a), b = b.filter(function (B) {
                        return !B.h;
                      }), t = l, v = m, l = {}, m = 0, u(z, Kt(g, c, d, t, v, function () {
                        return Bt(a);
                      }), 6);
                    case 6:
                      Bt(a);
                    case 4:
                      if (p) {
                        z.A(7);
                        break;
                      }
                      return u(z, n(b, !1), 8);
                    case 8:
                      return Bt(a), y = l, w = m, l = {}, m = 0, u(z, Kt(g, c, d, y, w, function () {
                        return Bt(a);
                      }), 9);
                    case 9:
                      Bt(a);
                    case 7:
                      ta(z, 0);
                      break;
                    case 2:
                      return x = ua(z), C = Object.values(l), u(z, g.removeSegments(C, function () {}), 10);
                    case 10:
                      throw x;
                  }
                });
              }
              function Gt(a) {
                var b, c, d, e;
                return G(function (f) {
                  switch (f.g) {
                    case 1:
                      return b = new Hs(), u(f, b.init(), 2);
                    case 2:
                      return u(f, Js(b), 3);
                    case 3:
                      return c = f.h, d = new $s("manifest", c.path.za, c.path.ja, a), u(f, b.destroy(), 4);
                    case 4:
                      return e = new vt(), u(f, e.remove(d.toString()), 0);
                  }
                });
              }
              function Kt(a, b, c, d, e, f) {
                var g, h, k, l, m, n, p, t, v, y, w;
                return G(function (x) {
                  switch (x.g) {
                    case 1:
                      g = !1;
                      D(x, 2);
                      h = !0;
                      k = r(c.streams);
                      for (l = k.next(); !l.done; l = k.next()) for (m = l.value, n = r(m.segments), p = n.next(); !p.done; p = n.next()) t = p.value, v = t.pendingSegmentRefId ? d[t.pendingSegmentRefId] : null, null != v && (t.dataKey = v, t.pendingSegmentRefId = void 0), v = t.pendingInitSegmentRefId ? d[t.pendingInitSegmentRefId] : null, null != v && (t.initSegmentKey = v, t.pendingInitSegmentRefId = void 0), t.pendingSegmentRefId && (h = !1), t.pendingInitSegmentRefId && (h = !1);
                      c.size += e;
                      h && (c.isIncomplete = !1);
                      return u(x, a.updateManifest(b, c), 4);
                    case 4:
                      g = !0;
                      f();
                      ta(x, 0);
                      break;
                    case 2:
                      return y = ua(x), u(x, Gt(b), 5);
                    case 5:
                      if (g) {
                        x.A(6);
                        break;
                      }
                      w = Object.values(d);
                      return u(x, a.removeSegments(w, function () {}), 6);
                    case 6:
                      throw y;
                  }
                });
              }
              function Dt(a, b) {
                var c, d, e, f, g, h, k, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N;
                return G(function (wa) {
                  switch (wa.g) {
                    case 1:
                      return c = {
                        width: Infinity,
                        height: Infinity
                      }, Jd(a, b.restrictions, c), u(wa, Nd(a, b.offline.usePersistentLicense), 2);
                    case 2:
                      d = [];
                      e = b.preferredAudioChannelCount;
                      f = b.preferredDecodingAttributes;
                      g = b.preferredVideoCodecs;
                      h = b.preferredAudioCodecs;
                      xd(a, g, h, e, f);
                      k = r(a.variants);
                      for (l = k.next(); !l.done; l = k.next()) m = l.value, d.push($d(m));
                      n = r(a.textStreams);
                      for (p = n.next(); !p.done; p = n.next()) t = p.value, d.push(ae(t));
                      v = r(a.imageStreams);
                      for (y = v.next(); !y.done; y = v.next()) w = y.value, d.push(be(w));
                      return u(wa, b.offline.trackSelectionCallback(d), 3);
                    case 3:
                      x = wa.h;
                      C = a.presentationTimeline.getDuration();
                      z = 0;
                      B = r(x);
                      for (E = B.next(); !E.done; E = B.next()) F = E.value, H = F.bandwidth * C / 8, z += H;
                      D(wa, 4);
                      return u(wa, b.offline.downloadSizeCallback(z), 6);
                    case 6:
                      I = wa.h;
                      if (!I) throw new O(2, 9, 9014);
                      ta(wa, 5);
                      break;
                    case 4:
                      J = ua(wa);
                      if (J instanceof O) throw J;
                      throw new O(2, 9, 9015);
                    case 5:
                      L = new Set();
                      R = new Set();
                      Q = new Set();
                      U = r(x);
                      for (E = U.next(); !E.done; E = U.next()) N = E.value, "variant" == N.type && L.add(N.id), "text" == N.type && R.add(N.id), "image" == N.type && Q.add(N.id);
                      a.variants = a.variants.filter(function (va) {
                        return L.has(va.id);
                      });
                      a.textStreams = a.textStreams.filter(function (va) {
                        return R.has(va.id);
                      });
                      a.imageStreams = a.imageStreams.filter(function (va) {
                        return Q.has(va.id);
                      });
                      Lt(a);
                      A(wa);
                  }
                });
              }
              function Et(a, b, c, d, e, f) {
                var g = ot(c, b, d),
                  h = e.offline.progressCallback;
                ss(f, function (t, v) {
                  g.size = v;
                  h(g, t);
                }, function (t, v) {
                  k && e.offline.usePersistentLicense && l == v && vg(a, "cenc", t);
                });
                var k = It(b) && !Jt(b),
                  l = null;
                k && (l = Mt.get(a.g.keySystem));
                for (var m = new rt(), n = r(b.textStreams), p = n.next(); !p.done; p = n.next()) m.g[p.value.id] = 52;
                n = r(b.imageStreams);
                for (p = n.next(); !p.done; p = n.next()) tt(m, p.value);
                p = r(b.variants);
                for (n = p.next(); !n.done; n = p.next()) st(m, n.value);
                m = Nt(f, m, b, e);
                f = m.streams;
                m = m.pe;
                p = a.g;
                n = e.offline.usePersistentLicense;
                p && n && (p.initData = []);
                return {
                  ag: {
                    creationTime: Date.now(),
                    originalManifestUri: c,
                    duration: b.presentationTimeline.getDuration(),
                    size: 0,
                    expiration: a.ic(),
                    streams: f,
                    sessionIds: n ? Eg(a) : [],
                    drmInfo: p,
                    appMetadata: d,
                    isIncomplete: !0,
                    sequenceMode: b.sequenceMode
                  },
                  pe: m
                };
              }
              function It(a) {
                return a.variants.some(function (b) {
                  var c = b.audio && b.audio.encrypted;
                  return b.video && b.video.encrypted || c;
                });
              }
              function Jt(a) {
                return a.variants.some(function (b) {
                  return (b.video ? b.video.drmInfos : []).concat(b.audio ? b.audio.drmInfos : []).some(function (c) {
                    return c.initData && c.initData.length;
                  });
                });
              }
              function Ht(a, b, c, d) {
                b.expiration = c.ic();
                c = Eg(c);
                b.sessionIds = d.offline.usePersistentLicense ? c : [];
                if (It(a) && d.offline.usePersistentLicense && !c.length) throw new O(2, 9, 9007);
              }
              q.remove = function (a) {
                return Ot(this, Pt(this, a));
              };
              function Pt(a, b) {
                var c, d, e, f, g, h;
                return G(function (k) {
                  switch (k.g) {
                    case 1:
                      zt();
                      c = at(b);
                      if (null == c || "manifest" != c.g) throw new O(2, 9, 9004, b);
                      d = c;
                      e = new Hs();
                      sa(k);
                      return u(k, e.init(), 4);
                    case 4:
                      return u(k, Ls(e, d.za(), d.ja()), 5);
                    case 5:
                      return f = k.h, u(k, f.getManifests([d.key()]), 6);
                    case 6:
                      return g = k.h, h = g[0], u(k, Promise.all([Qt(a, h, e), Rt(f, d, h)]), 2);
                    case 2:
                      return xa(k), u(k, e.destroy(), 8);
                    case 8:
                      ya(k, 0);
                  }
                });
              }
              function St(a, b) {
                for (var c = [], d = r(a.streams), e = d.next(); !e.done; e = d.next()) e = e.value, b && "video" == e.type ? c.push({
                  contentType: Zc(e.mimeType, e.codecs),
                  robustness: a.drmInfo.videoRobustness
                }) : b || "audio" != e.type || c.push({
                  contentType: Zc(e.mimeType, e.codecs),
                  robustness: a.drmInfo.audioRobustness
                });
                return c;
              }
              function Qt(a, b, c) {
                return G(function (d) {
                  return u(d, Tt(a.g, a.h.drm, c, b), 0);
                });
              }
              function Rt(a, b, c) {
                function d() {}
                var e = Ut(c);
                qt(b, c);
                return Promise.all([a.removeSegments(e, d), a.removeManifests([b.key()], d)]);
              }
              q.pg = function () {
                return Ot(this, Vt(this));
              };
              function Vt(a) {
                var b, c, d, e, f, g, h, k, l, m;
                return G(function (n) {
                  switch (n.g) {
                    case 1:
                      return zt(), b = a.g, c = a.h.drm, d = new Hs(), e = !1, sa(n), u(n, d.init(), 4);
                    case 4:
                      f = [], Ms(d, function (p) {
                        return f.push(p);
                      }), g = r(f), h = g.next();
                    case 5:
                      if (h.done) {
                        n.A(2);
                        break;
                      }
                      k = h.value;
                      return u(n, k.getAll(), 8);
                    case 8:
                      return l = n.h, u(n, lt(c, b, l), 9);
                    case 9:
                      return m = n.h, u(n, k.remove(m), 10);
                    case 10:
                      m.length != l.length && (e = !0);
                      h = g.next();
                      n.A(5);
                      break;
                    case 2:
                      return xa(n), u(n, d.destroy(), 11);
                    case 11:
                      ya(n, 3);
                      break;
                    case 3:
                      return n.return(!e);
                  }
                });
              }
              q.list = function () {
                return Ot(this, Wt());
              };
              function Wt() {
                var a, b, c;
                return G(function (d) {
                  switch (d.g) {
                    case 1:
                      return zt(), a = [], b = new Hs(), sa(d), u(d, b.init(), 4);
                    case 4:
                      return c = Promise.resolve(), Ks(b, function (e, f) {
                        c = c.then(function () {
                          var g;
                          return G(function (h) {
                            if (1 == h.g) return u(h, f.getAllManifests(), 2);
                            g = h.h;
                            g.forEach(function (k, l) {
                              k = qt(new $s("manifest", e.za, e.ja, l), k);
                              a.push(k);
                            });
                            A(h);
                          });
                        });
                      }), u(d, c, 2);
                    case 2:
                      return xa(d), u(d, b.destroy(), 6);
                    case 6:
                      ya(d, 3);
                      break;
                    case 3:
                      return d.return(a);
                  }
                });
              }
              function At(a, b, c, d) {
                var e, f, g, h, k;
                return G(function (l) {
                  if (1 == l.g) return e = null, f = a.g, g = {
                    networkingEngine: f,
                    modifyManifestRequest: function modifyManifestRequest() {},
                    modifySegmentRequest: function modifySegmentRequest() {},
                    filter: function filter() {
                      return Promise.resolve();
                    },
                    makeTextStreamsForClosedCaptions: function makeTextStreamsForClosedCaptions() {},
                    onTimelineRegionAdded: function onTimelineRegionAdded() {},
                    onEvent: function onEvent() {},
                    onError: function onError(m) {
                      e = m;
                    },
                    isLowLatencyMode: function isLowLatencyMode() {
                      return !1;
                    },
                    isAutoLowLatencyMode: function isAutoLowLatencyMode() {
                      return !1;
                    },
                    enableLowLatencyMode: function enableLowLatencyMode() {},
                    updateDuration: function updateDuration() {},
                    newDrmInfo: function newDrmInfo() {}
                  }, c.configure(d.manifest), Bt(a), u(l, c.start(b, g), 2);
                  if (3 != l.g) return h = l.h, Bt(a), k = Xt(h), u(l, Promise.all(rf(k, function (m) {
                    return m.createSegmentIndex();
                  })), 3);
                  Bt(a);
                  if (e) throw e;
                  return l.return(h);
                });
              }
              function Ct(a, b, c, d) {
                var e;
                return G(function (f) {
                  switch (f.g) {
                    case 1:
                      return e = new fg({
                        kb: a.g,
                        onError: c,
                        cd: function cd() {},
                        onExpirationUpdated: function onExpirationUpdated() {},
                        onEvent: function onEvent() {}
                      }), e.configure(d.drm), u(f, kg(e, b.variants, d.offline.usePersistentLicense), 2);
                    case 2:
                      return u(f, yg(e), 3);
                    case 3:
                      return u(f, xg(e), 4);
                    case 4:
                      return f.return(e);
                  }
                });
              }
              function Nt(a, b, c, d) {
                var e = new Map(),
                  f = Xt(c),
                  g = new Map();
                f = r(f);
                for (var h = f.next(); !h.done; h = f.next()) {
                  h = h.value;
                  var k = Yt(a, b, c, h, d, e);
                  g.set(h.id, k);
                }
                a = r(c.variants);
                for (b = a.next(); !b.done; b = a.next()) b = b.value, b.audio && g.get(b.audio.id).variantIds.push(b.id), b.video && g.get(b.video.id).variantIds.push(b.id);
                return {
                  streams: Array.from(g.values()),
                  pe: Array.from(e.values())
                };
              }
              function Yt(a, b, c, d, e, f) {
                var g = {
                    id: d.id,
                    originalId: d.originalId,
                    primary: d.primary,
                    type: d.type,
                    mimeType: d.mimeType,
                    codecs: d.codecs,
                    frameRate: d.frameRate,
                    pixelAspectRatio: d.pixelAspectRatio,
                    hdr: d.hdr,
                    kind: d.kind,
                    language: d.language,
                    label: d.label,
                    width: d.width || null,
                    height: d.height || null,
                    encrypted: d.encrypted,
                    keyIds: d.keyIds,
                    segments: [],
                    variantIds: [],
                    roles: d.roles,
                    forced: d.forced,
                    channelsCount: d.channelsCount,
                    audioSamplingRate: d.audioSamplingRate,
                    spatialAudio: d.spatialAudio,
                    closedCaptions: d.closedCaptions,
                    tilesLayout: d.tilesLayout
                  },
                  h = e.offline.numberOfParallelDownloads,
                  k = 0;
                Zt(d, c.presentationTimeline.Pa(), function (l) {
                  var m = ms(l),
                    n = void 0;
                  if (!f.has(m)) {
                    var p = l.endTime - l.startTime;
                    p = ut(b, d.id) * p;
                    p = ps(a.g, p);
                    f.set(m, new ls(l, p, k, !1));
                  }
                  l.h && (n = ms(l.h), f.has(n) || (p = .5 * ut(b, d.id), p = ps(a.g, p), f.set(n, new ls(l.h, p, k, !0))));
                  g.segments.push({
                    pendingInitSegmentRefId: n,
                    initSegmentKey: n ? 0 : null,
                    startTime: l.startTime,
                    endTime: l.endTime,
                    appendWindowStart: l.appendWindowStart,
                    appendWindowEnd: l.appendWindowEnd,
                    timestampOffset: l.timestampOffset,
                    tilesLayout: l.tilesLayout,
                    pendingSegmentRefId: m,
                    dataKey: 0
                  });
                  k = (k + 1) % h;
                });
                return g;
              }
              function Zt(a, b, c) {
                b = a.segmentIndex.find(b);
                if (null != b) for (var d = a.segmentIndex.get(b); d;) c(d), d = a.segmentIndex.get(++b);
              }
              function Bt(a) {
                if (a.l.g) throw new O(2, 9, 7001);
              }
              function zt() {
                if (!wt()) throw new O(2, 9, 9E3);
              }
              function Ot(a, b) {
                return G(function (c) {
                  if (1 == c.g) return a.i.push(b), sa(c), u(c, b, 4);
                  if (2 != c.g) return c.return(c.h);
                  xa(c);
                  hb(a.i, b);
                  return ya(c, 0);
                });
              }
              function yt(a, b) {
                var c = b.promise;
                a.i.push(c);
                return b.finally(function () {
                  hb(a.i, c);
                });
              }
              function Ut(a) {
                var b = new Set();
                a = r(a.streams);
                for (var c = a.next(); !c.done; c = a.next()) {
                  c = r(c.value.segments);
                  for (var d = c.next(); !d.done; d = c.next()) d = d.value, null != d.initSegmentKey && b.add(d.initSegmentKey), b.add(d.dataKey);
                }
                return Array.from(b);
              }
              function Tt(a, b, c, d) {
                var e, f, g;
                return G(function (h) {
                  if (1 == h.g) {
                    if (!d.drmInfo) return h.return();
                    e = Ns(c);
                    f = d.sessionIds.map(function (k) {
                      return {
                        sessionId: k,
                        keySystem: d.drmInfo.keySystem,
                        licenseUri: d.drmInfo.licenseServerUri,
                        serverCertificate: d.drmInfo.serverCertificate,
                        audioCapabilities: St(d, !1),
                        videoCapabilities: St(d, !0)
                      };
                    });
                    return u(h, lt(b, a, f), 2);
                  }
                  return 3 != h.g ? (g = h.h, u(h, e.remove(g), 3)) : u(h, e.add(f.filter(function (k) {
                    return !g.includes(k.sessionId);
                  })), 0);
                });
              }
              function Xt(a) {
                for (var b = new Set(), c = r(a.textStreams), d = c.next(); !d.done; d = c.next()) b.add(d.value);
                c = r(a.imageStreams);
                for (d = c.next(); !d.done; d = c.next()) b.add(d.value);
                a = r(a.variants);
                for (c = a.next(); !c.done; c = a.next()) c = c.value, c.audio && b.add(c.audio), c.video && b.add(c.video);
                return b;
              }
              function Lt(a) {
                a.variants.map(function (f) {
                  return f.video;
                });
                var b = new Set(a.variants.map(function (f) {
                  return f.audio;
                }));
                a = a.textStreams;
                for (var c = r(b), d = c.next(); !d.done; d = c.next()) {
                  d = r(b);
                  for (var e = d.next(); !e.done; e = d.next());
                }
                b = r(a);
                for (c = b.next(); !c.done; c = b.next()) for (c = r(a), d = c.next(); !d.done; d = c.next());
              }
              K("shaka.offline.Storage", vt);
              vt.deleteAll = function () {
                var a;
                return G(function (b) {
                  return 1 == b.g ? (a = new Hs(), sa(b), u(b, Os(a), 2)) : 5 != b.g ? (xa(b), u(b, a.destroy(), 5)) : ya(b, 0);
                });
              };
              vt.prototype.list = vt.prototype.list;
              vt.prototype.removeEmeSessions = vt.prototype.pg;
              vt.prototype.remove = vt.prototype.remove;
              vt.prototype.store = vt.prototype.store;
              vt.prototype.getNetworkingEngine = vt.prototype.jc;
              vt.prototype.getConfiguration = vt.prototype.getConfiguration;
              vt.prototype.configure = vt.prototype.configure;
              vt.prototype.destroy = vt.prototype.destroy;
              vt.support = wt;
              var Mt = new Map().set("org.w3.clearkey", "1077efecc0b24d02ace33c1e52e2fb4b").set("com.widevine.alpha", "edef8ba979d64acea3c827dcd51d21ed").set("com.microsoft.playready", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.recommendation", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.software", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.hardware", "9a04f07998404286ab92e65be0885f95").set("com.adobe.primetime", "f239e769efa348509c16a903c6932efb");
              rn.offline = wt;
              function $t() {}
              function au(a, b) {
                a = {
                  priority: b || 0,
                  mf: a
                };
                for (b = 0; b < bu.length; b++) if (bu[b].priority < a.priority) {
                  bu.splice(b, 0, a);
                  return;
                }
                bu.push(a);
              }
              K("shaka.polyfill", $t);
              $t.register = au;
              $t.installAll = function () {
                for (var a = r(bu), b = a.next(); !b.done; b = a.next()) {
                  b = b.value;
                  try {
                    b.mf();
                  } catch (c) {
                    Wa("Error installing polyfill!", c);
                  }
                }
              };
              var bu = [];
              function cu() {
                this.g = new du();
              }
              function eu() {
                window.AbortController || (window.AbortController = cu, window.AbortSignal = du);
              }
              cu.prototype.abort = function (a) {
                var b = this.g;
                if (!b.h) {
                  b.h = !0;
                  b.g = a;
                  void 0 === b.g && (b.g = new DOMException("signal is aborted without reason", "AbortError"));
                  a = new S("abort");
                  if (b.onabort) b.onabort(a);
                  b.dispatchEvent(a);
                }
              };
              da.Object.defineProperties(cu.prototype, {
                signal: {
                  configurable: !0,
                  enumerable: !0,
                  get: function get() {
                    return this.g;
                  }
                }
              });
              $t.AbortController = cu;
              cu.install = eu;
              function du() {
                Ue.call(this);
                this.h = !1;
                this.g = void 0;
                this.onabort = null;
              }
              oa(du, Ue);
              da.Object.defineProperties(du.prototype, {
                aborted: {
                  configurable: !0,
                  enumerable: !0,
                  get: function get() {
                    return this.h;
                  }
                },
                reason: {
                  configurable: !0,
                  enumerable: !0,
                  get: function get() {
                    return this.g;
                  }
                }
              });
              au(eu);
              function fu() {}
              function gu() {
                if (!Object.getOwnPropertyDescriptor(Element.prototype, "ariaHidden")) for (var a = r(["ariaHidden", "ariaLabel", "ariaPressed", "ariaSelected"]), b = a.next(); !b.done; b = a.next()) hu(b.value);
              }
              function hu(a) {
                var b = "aria-" + a.toLowerCase().replace(/^aria/, "");
                Object.defineProperty(Element.prototype, a, {
                  get: function get() {
                    return this.getAttribute(b);
                  },
                  set: function set(c) {
                    null == c || void 0 == c ? this.removeAttribute(b) : this.setAttribute(b, c);
                  }
                });
              }
              $t.Aria = fu;
              fu.install = gu;
              au(gu);
              function iu() {}
              function ju() {
                ku();
              }
              $t.EncryptionScheme = iu;
              iu.install = ju;
              au(ju, -2);
              function lu() {}
              function mu() {
                if (window.Document) {
                  var a = Element.prototype;
                  a.requestFullscreen = a.requestFullscreen || a.mozRequestFullScreen || a.msRequestFullscreen || a.webkitRequestFullscreen;
                  a = Document.prototype;
                  a.exitFullscreen = a.exitFullscreen || a.mozCancelFullScreen || a.msExitFullscreen || a.webkitCancelFullScreen;
                  "fullscreenElement" in document || (Object.defineProperty(document, "fullscreenElement", {
                    get: function get() {
                      return document.mozFullScreenElement || document.msFullscreenElement || document.webkitCurrentFullScreenElement || document.webkitFullscreenElement;
                    }
                  }), Object.defineProperty(document, "fullscreenEnabled", {
                    get: function get() {
                      return document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled;
                    }
                  }));
                  document.addEventListener("webkitfullscreenchange", nu);
                  document.addEventListener("webkitfullscreenerror", nu);
                  document.addEventListener("mozfullscreenchange", nu);
                  document.addEventListener("mozfullscreenerror", nu);
                  document.addEventListener("MSFullscreenChange", nu);
                  document.addEventListener("MSFullscreenError", nu);
                }
              }
              function nu(a) {
                var b = a.type.replace(/^(webkit|moz|MS)/, "").toLowerCase(),
                  c = document.createEvent("Event");
                c.initEvent(b, a.bubbles, a.cancelable);
                a.target.dispatchEvent(c);
              }
              $t.Fullscreen = lu;
              lu.install = mu;
              au(mu);
              function ou() {}
              function pu() {
                var a = !0;
                if (wc() || tc("PlayStation 5") || xc() || tc("Web0S") || uc() || tc("CrKey") || tc("PC=EOS") || tc("Hisense") || tc("VIDAA")) a = !1;
                a && navigator.mediaCapabilities || (navigator.mediaCapabilities || (navigator.mediaCapabilities = {}), qu = navigator.mediaCapabilities, navigator.mediaCapabilities.decodingInfo = ru);
              }
              function ru(a) {
                var b, c, d, e, f, g, h, k, l, m, n, p, t, v, y, w, x;
                return G(function (C) {
                  switch (C.g) {
                    case 1:
                      b = {
                        supported: !1,
                        powerEfficient: !0,
                        smooth: !0,
                        keySystemAccess: null,
                        configuration: a
                      };
                      if (!a) return C.return(b);
                      c = a.video;
                      d = a.audio;
                      if ("media-source" == a.type) {
                        if (!oc()) return C.return(b);
                        if (c) {
                          if (tc("CrKey")) {
                            if (window.cast && cast.__platform__ && cast.__platform__.canDisplayType) {
                              var z = c.contentType;
                              c.width && c.height && (z += "; width=" + c.width + "; height=" + c.height);
                              c.framerate && (z += "; framerate=" + c.framerate);
                              "pq" === c.transferFunction && (z += "; eotf=smpte2084");
                              z = cast.__platform__.canDisplayType(z);
                            } else z = eb(c.contentType);
                          } else z = eb(c.contentType);
                          e = z;
                          if (!e) return C.return(b);
                        }
                        if (d && (f = d.contentType, g = eb(f), !g)) return C.return(b);
                      } else if ("file" == a.type) {
                        if (c && (h = c.contentType, k = pc(h), !k) || d && (l = d.contentType, m = pc(l), !m)) return C.return(b);
                      } else return C.return(b);
                      if (!a.keySystemConfiguration) return b.supported = !0, C.return(Promise.resolve(b));
                      n = a.keySystemConfiguration;
                      p = [];
                      t = [];
                      n.audio && (v = {
                        robustness: n.audio.robustness || "",
                        contentType: a.audio.contentType
                      }, p.push(v));
                      n.video && (y = {
                        robustness: n.video.robustness || "",
                        contentType: a.video.contentType
                      }, t.push(y));
                      w = {
                        initDataTypes: [n.initDataType],
                        distinctiveIdentifier: n.distinctiveIdentifier,
                        persistentState: n.persistentState,
                        sessionTypes: n.sessionTypes
                      };
                      p.length && (w.audioCapabilities = p);
                      t.length && (w.videoCapabilities = t);
                      D(C, 3);
                      return u(C, navigator.requestMediaKeySystemAccess(n.keySystem, [w]), 5);
                    case 5:
                      x = C.h;
                      ta(C, 4);
                      break;
                    case 3:
                      ua(C);
                    case 4:
                      x && (b.supported = !0, b.keySystemAccess = x);
                    case 2:
                      return C.return(b);
                  }
                });
              }
              $t.MediaCapabilities = ou;
              ou.install = pu;
              var qu = null;
              ou.originalMcap = qu;
              au(pu, -1);
              function su() {}
              function tu() {
                var a = yc();
                window.MediaSource && (window.cast && cast.__platform__ && cast.__platform__.canDisplayType ? uu() : a ? 12 >= a ? (vu(), wu()) : 15 >= a && vu() : rc() ? xu() : (tc("Tizen 2") || tc("Tizen 3") || tc("Tizen 4")) && yu());
                window.MediaSource && MediaSource.isTypeSupported('video/webm; codecs="vp9"') && !MediaSource.isTypeSupported('video/webm; codecs="vp09.00.10.08"') && zu();
              }
              function vu() {
                var a = MediaSource.prototype.addSourceBuffer;
                MediaSource.prototype.addSourceBuffer = function () {
                  var b = a.apply(this, Fa.apply(0, arguments));
                  b.abort = function () {};
                  return b;
                };
              }
              function wu() {
                var a = SourceBuffer.prototype.remove;
                SourceBuffer.prototype.remove = function (b, c) {
                  return a.call(this, b, c - .001);
                };
              }
              function xu() {
                var a = MediaSource.isTypeSupported;
                MediaSource.isTypeSupported = function (b) {
                  return "mp2t" != b.split(";")[0].split("/")[1] && a(b);
                };
              }
              function yu() {
                var a = MediaSource.isTypeSupported;
                MediaSource.isTypeSupported = function (b) {
                  return "opus" != bd(b)[0] && a(b);
                };
              }
              function uu() {
                var a = MediaSource.isTypeSupported;
                MediaSource.isTypeSupported = function (b) {
                  var c = b.split(/ *; */);
                  c.shift();
                  return c.some(function (d) {
                    return d.startsWith("codecs=");
                  }) ? cast.__platform__.canDisplayType(b) : a(b);
                };
              }
              function zu() {
                var a = MediaSource.isTypeSupported;
                tc("Web0S") || (MediaSource.isTypeSupported = function (b) {
                  var c = b.split(/ *; */),
                    d = c.findIndex(function (g) {
                      return g.startsWith("codecs=");
                    });
                  if (0 > d) return a(b);
                  var e = c[d].replace("codecs=", "").replace(/"/g, "").split(/\s*,\s*/),
                    f = e.findIndex(function (g) {
                      return g.startsWith("vp09");
                    });
                  0 <= f && (e[f] = "vp9", c[d] = 'codecs="' + e.join(",") + '"', b = c.join("; "));
                  return a(b);
                });
              }
              $t.MediaSource = su;
              su.install = tu;
              au(tu);
              function Au() {}
              function Bu() {
                screen.orientation || void 0 != window.orientation && Cu();
              }
              function Cu() {
                function a() {
                  switch (window.orientation) {
                    case -90:
                      b.type = "landscape-secondary";
                      b.angle = 270;
                      break;
                    case 0:
                      b.type = "portrait-primary";
                      b.angle = 0;
                      break;
                    case 90:
                      b.type = "landscape-primary";
                      b.angle = 90;
                      break;
                    case 180:
                      b.type = "portrait-secondary", b.angle = 180;
                  }
                }
                var b = new Du();
                screen.orientation = b;
                a();
                window.addEventListener("orientationchange", function () {
                  a();
                  var c = new S("change");
                  b.dispatchEvent(c);
                });
              }
              $t.Orientation = Au;
              Au.install = Bu;
              function Du() {
                Ue.call(this);
                this.type = "";
                this.angle = 0;
              }
              oa(Du, Ue);
              Du.prototype.lock = function (a) {
                function b(d) {
                  return screen.lockOrientation ? screen.lockOrientation(d) : screen.mozLockOrientation ? screen.mozLockOrientation(d) : screen.msLockOrientation ? screen.msLockOrientation(d) : !1;
                }
                var c = !1;
                switch (a) {
                  case "natural":
                    c = b("default");
                    break;
                  case "any":
                    c = !0;
                    this.unlock();
                    break;
                  default:
                    c = b(a);
                }
                if (c) return Promise.resolve();
                a = Error("screen.orientation.lock() is not available on this device");
                a.name = "NotSupportedError";
                a.code = DOMException.NOT_SUPPORTED_ERR;
                return Promise.reject(a);
              };
              Du.prototype.unlock = function () {
                screen.unlockOrientation ? screen.unlockOrientation() : screen.mozUnlockOrientation ? screen.mozUnlockOrientation() : screen.msUnlockOrientation && screen.msUnlockOrientation();
              };
              au(Bu);
              function Eu() {}
              var Fu, Gu, Hu, Iu, Ju, Ku;
              function Lu(a, b) {
                try {
                  var c = new Mu(a, b);
                  return Promise.resolve(c);
                } catch (d) {
                  return Promise.reject(d);
                }
              }
              function Nu(a) {
                var b = this.mediaKeys;
                b && b != a && Ou(b, null);
                delete this.mediaKeys;
                return (this.mediaKeys = a) ? Ou(a, this) : Promise.resolve();
              }
              function Pu(a) {
                a = M(a.initData);
                if (Lb(a).getUint32(0, !0) + 4 != a.byteLength) throw new RangeError("Malformed FairPlay init data");
                a = Dc(a.subarray(4), !0);
                a = Gc(a);
                var b = new Event("encrypted");
                b.initDataType = "skd";
                b.initData = Ib(a);
                this.dispatchEvent(b);
              }
              $t.PatchedMediaKeysApple = Eu;
              Eu.uninstall = function () {
                Fu && (Fu = !1, Object.defineProperty(HTMLMediaElement.prototype, "mediaKeys", Gu), HTMLMediaElement.prototype.setMediaKeys = Hu, window.MediaKeys = Iu, window.MediaKeySystemAccess = Ju, navigator.requestMediaKeySystemAccess = Ku, Gu = Ku = Hu = Ju = Iu = null, window.shakaMediaKeysPolyfill = !1);
              };
              Eu.install = function (a) {
                if (window.HTMLVideoElement && window.WebKitMediaKeys) {
                  if (void 0 === a ? 0 : a) Fu = !0, Gu = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, "mediaKeys"), Hu = HTMLMediaElement.prototype.setMediaKeys, Iu = window.MediaKeys, Ju = window.MediaKeySystemAccess, Ku = navigator.requestMediaKeySystemAccess;
                  delete HTMLMediaElement.prototype.mediaKeys;
                  HTMLMediaElement.prototype.mediaKeys = null;
                  HTMLMediaElement.prototype.setMediaKeys = Nu;
                  window.MediaKeys = Qu;
                  window.MediaKeySystemAccess = Mu;
                  navigator.requestMediaKeySystemAccess = Lu;
                  window.shakaMediaKeysPolyfill = !0;
                }
              };
              function Mu(a, b) {
                this.keySystem = a;
                if (a.startsWith("com.apple.fps")) for (a = r(b), b = a.next(); !b.done; b = a.next()) {
                  var c = b.value;
                  if ("required" == c.persistentState) b = null;else {
                    b = {
                      audioCapabilities: [],
                      videoCapabilities: [],
                      persistentState: "optional",
                      distinctiveIdentifier: "optional",
                      initDataTypes: c.initDataTypes,
                      sessionTypes: ["temporary"],
                      label: c.label
                    };
                    var d = !1,
                      e = !1;
                    if (c.audioCapabilities) for (var f = r(c.audioCapabilities), g = f.next(); !g.done; g = f.next()) g = g.value, g.contentType && (d = !0, WebKitMediaKeys.isTypeSupported(this.keySystem, g.contentType.split(";")[0]) && (b.audioCapabilities.push(g), e = !0));
                    if (c.videoCapabilities) for (c = r(c.videoCapabilities), g = c.next(); !g.done; g = c.next()) f = g.value, f.contentType && (d = !0, WebKitMediaKeys.isTypeSupported(this.keySystem, f.contentType.split(";")[0]) && (b.videoCapabilities.push(f), e = !0));
                    d || (e = WebKitMediaKeys.isTypeSupported(this.keySystem, "video/mp4"));
                    b = e ? b : null;
                  }
                  if (b) {
                    this.g = b;
                    return;
                  }
                }
                a = Error("Unsupported keySystem");
                a.name = "NotSupportedError";
                a.code = DOMException.NOT_SUPPORTED_ERR;
                throw a;
              }
              Mu.prototype.createMediaKeys = function () {
                var a = new Qu(this.keySystem);
                return Promise.resolve(a);
              };
              Mu.prototype.getConfiguration = function () {
                return this.g;
              };
              function Qu(a) {
                this.h = new WebKitMediaKeys(a);
                this.g = new mf();
              }
              Qu.prototype.createSession = function (a) {
                a = a || "temporary";
                if ("temporary" != a) throw new TypeError("Session type " + a + " is unsupported on this platform.");
                return new Ru(this.h);
              };
              Qu.prototype.setServerCertificate = function () {
                return Promise.resolve(!1);
              };
              function Ou(a, b) {
                a.g.nb();
                if (!b) return Promise.resolve();
                a.g.C(b, "webkitneedkey", Pu);
                try {
                  return tj(b, HTMLMediaElement.HAVE_METADATA, a.g, function () {
                    b.webkitSetMediaKeys(a.h);
                  }), Promise.resolve();
                } catch (c) {
                  return Promise.reject(c);
                }
              }
              function Ru(a) {
                Ue.call(this);
                this.i = null;
                this.l = a;
                this.g = this.h = null;
                this.j = new mf();
                this.sessionId = "";
                this.expiration = NaN;
                this.closed = new lc();
                this.keyStatuses = new Su();
              }
              oa(Ru, Ue);
              q = Ru.prototype;
              q.generateRequest = function (a, b) {
                var c = this;
                this.h = new lc();
                try {
                  var d = this.l.createSession("video/mp4", M(b));
                  this.i = d;
                  this.sessionId = d.sessionId || "";
                  this.j.C(this.i, "webkitkeymessage", function (e) {
                    c.h && (c.h.resolve(), c.h = null);
                    e = new Map().set("messageType", void 0 == c.keyStatuses.Eb() ? "license-request" : "license-renewal").set("message", Ib(e.message));
                    e = new S("message", e);
                    c.dispatchEvent(e);
                  });
                  this.j.C(d, "webkitkeyadded", function () {
                    c.g && (Tu(c, "usable"), c.g.resolve(), c.g = null);
                  });
                  this.j.C(d, "webkitkeyerror", function () {
                    var e = Error("EME PatchedMediaKeysApple key error");
                    e.errorCode = c.i.error;
                    if (null != c.h) c.h.reject(e), c.h = null;else if (null != c.g) c.g.reject(e), c.g = null;else switch (c.i.error.code) {
                      case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:
                      case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:
                        Tu(c, "output-not-allowed");
                        break;
                      default:
                        Tu(c, "internal-error");
                    }
                  });
                  Tu(this, "status-pending");
                } catch (e) {
                  this.h.reject(e);
                }
                return this.h;
              };
              q.load = function () {
                return Promise.reject(Error("MediaKeySession.load not yet supported"));
              };
              q.update = function (a) {
                this.g = new lc();
                try {
                  this.i.update(M(a));
                } catch (b) {
                  this.g.reject(b);
                }
                return this.g;
              };
              q.close = function () {
                try {
                  this.i.close(), this.closed.resolve(), this.j.nb();
                } catch (a) {
                  this.closed.reject(a);
                }
                return this.closed;
              };
              q.remove = function () {
                return Promise.reject(Error("MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform"));
              };
              function Tu(a, b) {
                var c = a.keyStatuses;
                c.size = void 0 == b ? 0 : 1;
                c.g = b;
                b = new S("keystatuseschange");
                a.dispatchEvent(b);
              }
              function Su() {
                this.size = 0;
                this.g = void 0;
              }
              q = Su.prototype;
              q.Eb = function () {
                return this.g;
              };
              q.forEach = function (a) {
                this.g && a(this.g, Qg.value());
              };
              q.get = function (a) {
                if (this.has(a)) return this.g;
              };
              q.has = function (a) {
                var b = Qg.value();
                return this.g && Gb(a, b) ? !0 : !1;
              };
              q.entries = function () {};
              q.keys = function () {};
              q.values = function () {};
              function Uu() {}
              function Vu() {
                !window.HTMLVideoElement || navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration || (navigator.requestMediaKeySystemAccess = Wu, delete HTMLMediaElement.prototype.mediaKeys, HTMLMediaElement.prototype.mediaKeys = null, HTMLMediaElement.prototype.setMediaKeys = Xu, window.MediaKeys = Yu, window.MediaKeySystemAccess = Zu, window.shakaMediaKeysPolyfill = !0);
              }
              function Wu() {
                return Promise.reject(Error("The key system specified is not supported."));
              }
              function Xu(a) {
                return null == a ? Promise.resolve() : Promise.reject(Error("MediaKeys not supported."));
              }
              $t.PatchedMediaKeysNop = Uu;
              Uu.install = Vu;
              function Yu() {
                throw new TypeError("Illegal constructor.");
              }
              Yu.prototype.createSession = function () {};
              Yu.prototype.setServerCertificate = function () {};
              function Zu() {
                this.keySystem = "";
                throw new TypeError("Illegal constructor.");
              }
              Zu.prototype.getConfiguration = function () {};
              Zu.prototype.createMediaKeys = function () {};
              au(Vu, -10);
              function $u() {}
              function av() {
                if (!(!window.HTMLVideoElement || navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration)) {
                  if (HTMLMediaElement.prototype.webkitGenerateKeyRequest) bv = "webkit";else if (!HTMLMediaElement.prototype.generateKeyRequest) return;
                  navigator.requestMediaKeySystemAccess = cv;
                  delete HTMLMediaElement.prototype.mediaKeys;
                  HTMLMediaElement.prototype.mediaKeys = null;
                  HTMLMediaElement.prototype.setMediaKeys = dv;
                  window.MediaKeys = ev;
                  window.MediaKeySystemAccess = fv;
                  window.shakaMediaKeysPolyfill = !0;
                }
              }
              function gv(a) {
                var b = bv;
                return b ? b + a.charAt(0).toUpperCase() + a.slice(1) : a;
              }
              function cv(a, b) {
                try {
                  var c = new fv(a, b);
                  return Promise.resolve(c);
                } catch (d) {
                  return Promise.reject(d);
                }
              }
              function dv(a) {
                var b = this.mediaKeys;
                b && b != a && hv(b, null);
                delete this.mediaKeys;
                (this.mediaKeys = a) && hv(a, this);
                return Promise.resolve();
              }
              $t.PatchedMediaKeysWebkit = $u;
              $u.install = av;
              function fv(a, b) {
                this.g = this.keySystem = a;
                var c = !1;
                "org.w3.clearkey" == a && (this.g = "webkit-org.w3.clearkey", c = !1);
                var d = !1;
                var e = document.getElementsByTagName("video");
                e = e.length ? e[0] : document.createElement("video");
                b = r(b);
                for (var f = b.next(); !f.done; f = b.next()) {
                  f = f.value;
                  var g = {
                      audioCapabilities: [],
                      videoCapabilities: [],
                      persistentState: "optional",
                      distinctiveIdentifier: "optional",
                      initDataTypes: f.initDataTypes,
                      sessionTypes: ["temporary"],
                      label: f.label
                    },
                    h = !1;
                  if (f.audioCapabilities) for (var k = r(f.audioCapabilities), l = k.next(); !l.done; l = k.next()) l = l.value, l.contentType && (h = !0, e.canPlayType(l.contentType.split(";")[0], this.g) && (g.audioCapabilities.push(l), d = !0));
                  if (f.videoCapabilities) for (k = r(f.videoCapabilities), l = k.next(); !l.done; l = k.next()) l = l.value, l.contentType && (h = !0, e.canPlayType(l.contentType, this.g) && (g.videoCapabilities.push(l), d = !0));
                  h || (d = e.canPlayType("video/mp4", this.g) || e.canPlayType("video/webm", this.g));
                  "required" == f.persistentState && (c ? (g.persistentState = "required", g.sessionTypes = ["persistent-license"]) : d = !1);
                  if (d) {
                    this.h = g;
                    return;
                  }
                }
                c = "Unsupported keySystem";
                if ("org.w3.clearkey" == a || "com.widevine.alpha" == a) c = "None of the requested configurations were supported.";
                a = Error(c);
                a.name = "NotSupportedError";
                a.code = DOMException.NOT_SUPPORTED_ERR;
                throw a;
              }
              fv.prototype.createMediaKeys = function () {
                var a = new ev(this.g);
                return Promise.resolve(a);
              };
              fv.prototype.getConfiguration = function () {
                return this.h;
              };
              function ev(a) {
                this.l = a;
                this.h = null;
                this.g = new mf();
                this.i = [];
                this.j = new Map();
              }
              function hv(a, b) {
                a.h = b;
                a.g.nb();
                var c = bv;
                b && (a.g.C(b, c + "needkey", function (d) {
                  var e = new CustomEvent("encrypted");
                  e.initDataType = "cenc";
                  e.initData = Ib(d.initData);
                  a.h.dispatchEvent(e);
                }), a.g.C(b, c + "keymessage", function (d) {
                  var e = iv(a, d.sessionId);
                  e && (d = new Map().set("messageType", void 0 == e.keyStatuses.Eb() ? "licenserequest" : "licenserenewal").set("message", d.message), d = new S("message", d), e.h && (e.h.resolve(), e.h = null), e.dispatchEvent(d));
                }), a.g.C(b, c + "keyadded", function (d) {
                  if (d = iv(a, d.sessionId)) jv(d, "usable"), d.g && d.g.resolve(), d.g = null;
                }), a.g.C(b, c + "keyerror", function (d) {
                  var e = iv(a, d.sessionId);
                  e && e.handleError(d);
                }));
              }
              ev.prototype.createSession = function (a) {
                a = a || "temporary";
                if ("temporary" != a && "persistent-license" != a) throw new TypeError("Session type " + a + " is unsupported on this platform.");
                var b = this.h || document.createElement("video");
                b.src || (b.src = "about:blank");
                a = new kv(b, this.l, a);
                this.i.push(a);
                return a;
              };
              ev.prototype.setServerCertificate = function () {
                return Promise.resolve(!1);
              };
              function iv(a, b) {
                var c = a.j.get(b);
                return c ? c : (c = a.i.shift()) ? (c.sessionId = b, a.j.set(b, c), c) : null;
              }
              function kv(a, b, c) {
                Ue.call(this);
                this.j = a;
                this.m = !1;
                this.g = this.h = null;
                this.i = b;
                this.l = c;
                this.sessionId = "";
                this.expiration = NaN;
                this.closed = new lc();
                this.keyStatuses = new lv();
              }
              oa(kv, Ue);
              q = kv.prototype;
              q.handleError = function (a) {
                var b = Error("EME v0.1b key error"),
                  c = a.errorCode;
                c.systemCode = a.systemCode;
                b.errorCode = c;
                !a.sessionId && this.h ? (45 == a.systemCode && (b.message = "Unsupported session type."), this.h.reject(b), this.h = null) : a.sessionId && this.g ? (this.g.reject(b), this.g = null) : (b = a.systemCode, a.errorCode.code == MediaKeyError.MEDIA_KEYERR_OUTPUT ? jv(this, "output-restricted") : 1 == b ? jv(this, "expired") : jv(this, "internal-error"));
              };
              function mv(a, b, c) {
                if (a.m) return Promise.reject(Error("The session is already initialized."));
                a.m = !0;
                try {
                  if ("persistent-license" == a.l) {
                    if (c) var d = M(Gc("LOAD_SESSION|" + c));else {
                      var e = Gc("PERSISTENT|");
                      d = Oc(e, b);
                    }
                  } else d = M(b);
                } catch (g) {
                  return Promise.reject(g);
                }
                a.h = new lc();
                var f = gv("generateKeyRequest");
                try {
                  a.j[f](a.i, d);
                } catch (g) {
                  if ("InvalidStateError" != g.name) return a.h = null, Promise.reject(g);
                  new P(function () {
                    try {
                      a.j[f](a.i, d);
                    } catch (h) {
                      a.h.reject(h), a.h = null;
                    }
                  }).N(.01);
                }
                return a.h;
              }
              function nv(a, b, c) {
                if (a.g) a.g.then(function () {
                  return nv(a, b, c);
                }).catch(function () {
                  return nv(a, b, c);
                });else {
                  a.g = b;
                  if ("webkit-org.w3.clearkey" == a.i) {
                    var d = Cc(c);
                    var e = JSON.parse(d);
                    "oct" != e.keys[0].kty && (a.g.reject(Error("Response is not a valid JSON Web Key Set.")), a.g = null);
                    d = Lc(e.keys[0].k);
                    e = Lc(e.keys[0].kid);
                  } else d = M(c), e = null;
                  var f = gv("addKey");
                  try {
                    a.j[f](a.i, d, e, a.sessionId);
                  } catch (g) {
                    a.g.reject(g), a.g = null;
                  }
                }
              }
              function jv(a, b) {
                var c = a.keyStatuses;
                c.size = void 0 == b ? 0 : 1;
                c.g = b;
                b = new S("keystatuseschange");
                a.dispatchEvent(b);
              }
              q.generateRequest = function (a, b) {
                return mv(this, b, null);
              };
              q.load = function (a) {
                return "persistent-license" == this.l ? mv(this, null, a) : Promise.reject(Error("Not a persistent session."));
              };
              q.update = function (a) {
                var b = new lc();
                nv(this, b, a);
                return b;
              };
              q.close = function () {
                if ("persistent-license" != this.l) {
                  if (!this.sessionId) return this.closed.reject(Error("The session is not callable.")), this.closed;
                  var a = gv("cancelKeyRequest");
                  try {
                    this.j[a](this.i, this.sessionId);
                  } catch (b) {}
                }
                this.closed.resolve();
                return this.closed;
              };
              q.remove = function () {
                return "persistent-license" != this.l ? Promise.reject(Error("Not a persistent session.")) : this.close();
              };
              function lv() {
                this.size = 0;
                this.g = void 0;
              }
              q = lv.prototype;
              q.Eb = function () {
                return this.g;
              };
              q.forEach = function (a) {
                this.g && a(this.g, Qg.value());
              };
              q.get = function (a) {
                if (this.has(a)) return this.g;
              };
              q.has = function (a) {
                var b = Qg.value();
                return this.g && Gb(a, b) ? !0 : !1;
              };
              q.entries = function () {};
              q.keys = function () {};
              q.values = function () {};
              var bv = "";
              au(av);
              function ov() {}
              function pv() {
                if (window.HTMLVideoElement) {
                  var a = HTMLVideoElement.prototype;
                  a.requestPictureInPicture && document.exitPictureInPicture || !a.webkitSupportsPresentationMode || (document.pictureInPictureEnabled = !0, document.pictureInPictureElement = null, a.requestPictureInPicture = qv, Object.defineProperty(a, "disablePictureInPicture", {
                    get: rv,
                    set: sv,
                    enumerable: !0,
                    configurable: !0
                  }), document.exitPictureInPicture = tv, document.addEventListener("webkitpresentationmodechanged", uv, !0));
                }
              }
              function uv(a) {
                a = a.target;
                if ("picture-in-picture" == a.webkitPresentationMode) {
                  document.pictureInPictureElement = a;
                  var b = new Event("enterpictureinpicture");
                  a.dispatchEvent(b);
                } else document.pictureInPictureElement == a && (document.pictureInPictureElement = null), b = new Event("leavepictureinpicture"), a.dispatchEvent(b);
              }
              function qv() {
                return this.webkitSupportsPresentationMode("picture-in-picture") ? (this.webkitSetPresentationMode("picture-in-picture"), document.pictureInPictureElement = this, Promise.resolve()) : Promise.reject(Error("PiP not allowed by video element"));
              }
              function tv() {
                var a = document.pictureInPictureElement;
                return a ? (a.webkitSetPresentationMode("inline"), document.pictureInPictureElement = null, Promise.resolve()) : Promise.reject(Error("No picture in picture element found"));
              }
              function rv() {
                return this.hasAttribute("disablePictureInPicture") ? !0 : !this.webkitSupportsPresentationMode("picture-in-picture");
              }
              function sv(a) {
                a ? this.setAttribute("disablePictureInPicture", "") : this.removeAttribute("disablePictureInPicture");
              }
              $t.PiPWebkit = ov;
              ov.install = pv;
              au(pv);
              function vv() {}
              function wv() {
                window.crypto && ("randomUUID" in window.crypto || (window.crypto.randomUUID = xv));
              }
              function xv() {
                var a = URL.createObjectURL(new Blob()),
                  b = a.toString();
                URL.revokeObjectURL(a);
                return b.substr(b.lastIndexOf("/") + 1);
              }
              $t.RandomUUID = vv;
              vv.install = wv;
              au(wv);
              function yv() {}
              function zv() {
                navigator.storage && navigator.storage.estimate || !navigator.webkitTemporaryStorage || !navigator.webkitTemporaryStorage.queryUsageAndQuota || ("storage" in navigator || (navigator.storage = {}), navigator.storage.estimate = Av);
              }
              function Av() {
                return new Promise(function (a, b) {
                  navigator.webkitTemporaryStorage.queryUsageAndQuota(function (c, d) {
                    a({
                      usage: c,
                      quota: d
                    });
                  }, b);
                });
              }
              $t.StorageEstimate = yv;
              yv.install = zv;
              au(zv);
              function Bv() {}
              function Cv() {
                var a = Symbol.prototype;
                "description" in a || Object.defineProperty(a, "description", {
                  get: Dv
                });
              }
              function Dv() {
                var a = /\((.*)\)/.exec(this.toString());
                return a ? a[1] : void 0;
              }
              $t.Symbol = Bv;
              Bv.install = Cv;
              au(Cv);
              function Ev() {}
              function Fv() {
                if (window.HTMLMediaElement) {
                  var a = HTMLMediaElement.prototype.play;
                  HTMLMediaElement.prototype.play = function () {
                    var b = a.apply(this);
                    b && b.catch(function () {});
                    return b;
                  };
                }
              }
              $t.VideoPlayPromise = Ev;
              Ev.install = Fv;
              au(Fv);
              function Gv() {}
              function Hv() {
                if (window.HTMLVideoElement) {
                  var a = HTMLVideoElement.prototype;
                  !a.getVideoPlaybackQuality && ("webkitDroppedFrameCount" in a || vc()) && (a.getVideoPlaybackQuality = Iv);
                }
              }
              function Iv() {
                return {
                  droppedVideoFrames: this.webkitDroppedFrameCount,
                  totalVideoFrames: this.webkitDecodedFrameCount,
                  corruptedVideoFrames: 0,
                  creationTime: NaN,
                  totalFrameDelay: 0
                };
              }
              $t.VideoPlaybackQuality = Gv;
              Gv.install = Hv;
              au(Hv);
              function Jv() {}
              function Kv() {
                if (!window.VTTCue && window.TextTrackCue) {
                  var a = null,
                    b = TextTrackCue.length;
                  if (3 == b) a = Lv;else if (6 == b) a = Mv;else {
                    try {
                      var c = !!Lv(1, 2, "");
                    } catch (d) {
                      c = !1;
                    }
                    c && (a = Lv);
                  }
                  a && (window.VTTCue = function (d, e, f) {
                    return a(d, e, f);
                  });
                }
              }
              function Lv(a, b, c) {
                return new window.TextTrackCue(a, b, c);
              }
              function Mv(a, b, c) {
                return new window.TextTrackCue(a + "-" + b + "-" + c, a, b, c);
              }
              $t.VTTCue = Jv;
              Jv.install = Kv;
              au(Kv);
              function Nv() {}
              Nv.prototype.parseInit = function () {};
              Nv.prototype.setSequenceMode = function () {};
              Nv.prototype.parseMedia = function (a, b) {
                var c = null,
                  d = [];
                a = Cc(a).split(/\r?\n/);
                a = r(a);
                for (var e = a.next(); !e.done; e = a.next()) if ((e = e.value) && !/^\s+$/.test(e) && (e = Ov.exec(e))) {
                  var f = Pv.exec(e[1]);
                  f = 60 * parseInt(f[1], 10) + parseFloat(f[2].replace(",", "."));
                  e = new kb(f, b.segmentEnd ? b.segmentEnd : f + 2, e[2]);
                  c && (c.endTime = f, d.push(c));
                  c = e;
                }
                c && d.push(c);
                return d;
              };
              K("shaka.text.LrcTextParser", Nv);
              Nv.prototype.parseMedia = Nv.prototype.parseMedia;
              Nv.prototype.setSequenceMode = Nv.prototype.setSequenceMode;
              Nv.prototype.parseInit = Nv.prototype.parseInit;
              var Ov = /^\[(\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\](.*)/,
                Pv = /^(\d+):(\d{1,2}(?:[.,]\d{1,3})?)$/;
              fd["application/x-subtitle-lrc"] = function () {
                return new Nv();
              };
              function Qv() {}
              Qv.prototype.parseInit = function () {};
              Qv.prototype.setSequenceMode = function () {};
              Qv.prototype.parseMedia = function (a, b) {
                var c = Cc(a);
                a = [];
                if ("" == c) return a;
                var d = cg(c, "tt");
                if (!d) throw new O(2, 2, 2005, "Failed to parse TTML.");
                c = d.getElementsByTagName("body")[0];
                if (!c) return [];
                var e = Rf(d, Rv, "frameRate"),
                  f = Rf(d, Rv, "subFrameRate"),
                  g = Rf(d, Rv, "frameRateMultiplier"),
                  h = Rf(d, Rv, "tickRate"),
                  k = Rf(d, Rv, "cellResolution"),
                  l = d.getAttribute("xml:space") || "default",
                  m = Rf(d, Sv, "extent");
                if ("default" != l && "preserve" != l) throw new O(2, 2, 2005, "Invalid xml:space value: " + l);
                l = "default" == l;
                e = new Tv(e, f, g, h);
                k = k ? (k = /^(\d+) (\d+)$/.exec(k)) ? {
                  columns: parseInt(k[1], 10),
                  rows: parseInt(k[2], 10)
                } : null : null;
                f = (f = d.getElementsByTagName("metadata")[0]) ? Pf(f) : [];
                g = Array.from(d.getElementsByTagName("style"));
                d = Array.from(d.getElementsByTagName("region"));
                h = [];
                for (var n = r(d), p = n.next(); !p.done; p = n.next()) {
                  var t = p.value;
                  p = new mb();
                  var v = t.getAttribute("xml:id");
                  if (v) {
                    p.id = v;
                    var y = null;
                    m && (y = Uv.exec(m) || Vv.exec(m));
                    v = y ? Number(y[1]) : null;
                    y = y ? Number(y[2]) : null;
                    var w, x;
                    if (w = Wv(t, g, "extent")) w = (x = Uv.exec(w)) || Vv.exec(w), null != w && (p.width = Number(w[1]), p.height = Number(w[2]), x || (null != v && (p.width = 100 * p.width / v), null != y && (p.height = 100 * p.height / y)), p.widthUnits = x || null != v ? Db : 0, p.heightUnits = x || null != y ? Db : 0);
                    if (t = Wv(t, g, "origin")) w = (x = Uv.exec(t)) || Vv.exec(t), null != w && (p.viewportAnchorX = Number(w[1]), p.viewportAnchorY = Number(w[2]), x || (null != y && (p.viewportAnchorY = 100 * p.viewportAnchorY / y), null != v && (p.viewportAnchorX = 100 * p.viewportAnchorX / v)), p.viewportAnchorUnits = x || null != v ? Db : 0);
                  } else p = null;
                  p && h.push(p);
                }
                if (Mf(c, "p").length) throw new O(2, 2, 2001, "<p> can only be inside <div> in TTML");
                m = r(Mf(c, "div"));
                for (n = m.next(); !n.done; n = m.next()) if (Mf(n.value, "span").length) throw new O(2, 2, 2001, "<span> can only be inside <p> in TTML");
                if (b = Xv(c, b, e, f, g, d, h, l, k, null, !1)) b.backgroundColor || (b.backgroundColor = "transparent"), a.push(b);
                return a;
              };
              function Xv(a, b, c, d, e, f, g, h, k, l, m) {
                var n = a.parentNode;
                if (a.nodeType == Node.COMMENT_NODE) return null;
                if (a.nodeType == Node.TEXT_NODE) {
                  if (!m) return null;
                  var p = document.createElement("span");
                  p.textContent = a.textContent;
                } else p = a;
                for (var t = null, v = r(Yv), y = v.next(); !y.done && !(t = Zv(p, "backgroundImage", d, "#", y.value)[0]); y = v.next());
                v = m;
                if ("p" == a.nodeName || t) m = !0;
                h = "default" == (p.getAttribute("xml:space") || (h ? "default" : "preserve"));
                y = Array.from(p.childNodes).every(function (B) {
                  return B.nodeType == Node.TEXT_NODE;
                });
                a = [];
                if (!y) for (var w = r(p.childNodes), x = w.next(); !x.done; x = w.next()) (x = Xv(x.value, b, c, d, e, f, g, h, k, p, m)) && a.push(x);
                d = null != l;
                w = /\S/.test(p.textContent);
                var C = p.hasAttribute("begin") || p.hasAttribute("end") || p.hasAttribute("dur");
                if (!(C || w || "br" == p.tagName || 0 != a.length || d && !h)) return null;
                x = $v(p, c);
                w = x.start;
                for (x = x.end; n && n.nodeType == Node.ELEMENT_NODE && "tt" != n.tagName;) x = aw(n, c, w, x), w = x.start, x = x.end, n = n.parentNode;
                null == w && (w = 0);
                w += b.periodStart;
                x = null == x ? Infinity : x + b.periodStart;
                w = Math.max(w, b.segmentStart);
                x = Math.min(x, b.segmentEnd);
                if (!C && 0 < a.length) for (w = Infinity, x = 0, b = r(a), c = b.next(); !c.done; c = b.next()) c = c.value, w = Math.min(w, c.startTime), x = Math.max(x, c.endTime);
                if ("br" == p.tagName) return e = new kb(w, x, ""), e.lineBreak = !0, e;
                b = "";
                y && (b = p.textContent, h && (b = b.trim(), b = b.replace(/\s+/g, " ")));
                b = new kb(w, x, b);
                b.nestedCues = a;
                m || (b.isContainer = !0);
                k && (b.cellResolution = k);
                k = Zv(p, "region", f, "")[0];
                if (p.hasAttribute("region") && k && k.getAttribute("xml:id")) {
                  var z = k.getAttribute("xml:id");
                  b.region = g.filter(function (B) {
                    return B.id == z;
                  })[0];
                }
                g = k;
                l && d && !p.getAttribute("region") && !p.getAttribute("style") && (g = Zv(l, "region", f, "")[0]);
                bw(b, p, g, t, e, v, 0 == a.length);
                return b;
              }
              function bw(a, b, c, d, e, f, g) {
                f = f || g;
                "rtl" == cw(b, c, e, "direction", f) && (a.direction = "rtl");
                g = cw(b, c, e, "writingMode", f);
                "tb" == g || "tblr" == g ? a.writingMode = "vertical-lr" : "tbrl" == g ? a.writingMode = "vertical-rl" : "rltb" == g || "rl" == g ? a.direction = "rtl" : g && (a.direction = lb);
                (g = cw(b, c, e, "textAlign", !0)) ? (a.positionAlign = dw[g], a.lineAlign = ew[g], a.textAlign = xb[g.toUpperCase()]) : a.textAlign = ob;
                if (g = cw(b, c, e, "displayAlign", !0)) a.displayAlign = yb[g.toUpperCase()];
                if (g = cw(b, c, e, "color", f)) a.color = g;
                if (g = cw(b, c, e, "backgroundColor", f)) a.backgroundColor = g;
                if (g = cw(b, c, e, "border", f)) a.border = g;
                if (g = cw(b, c, e, "fontFamily", f)) switch (g) {
                  case "monospaceSerif":
                    a.fontFamily = "Courier New,Liberation Mono,Courier,monospace";
                    break;
                  case "proportionalSansSerif":
                    a.fontFamily = "Arial,Helvetica,Liberation Sans,sans-serif";
                    break;
                  case "sansSerif":
                    a.fontFamily = "sans-serif";
                    break;
                  case "monospaceSansSerif":
                    a.fontFamily = "Consolas,monospace";
                    break;
                  case "proportionalSerif":
                    a.fontFamily = "serif";
                    break;
                  default:
                    a.fontFamily = g;
                }
                (g = cw(b, c, e, "fontWeight", f)) && "bold" == g && (a.fontWeight = 700);
                g = cw(b, c, e, "wrapOption", f);
                a.wrapLine = g && "noWrap" == g ? !1 : !0;
                (g = cw(b, c, e, "lineHeight", f)) && g.match(fw) && (a.lineHeight = g);
                (g = cw(b, c, e, "fontSize", f)) && (g.match(fw) || g.match(gw)) && (a.fontSize = g);
                if (g = cw(b, c, e, "fontStyle", f)) a.fontStyle = Cb[g.toUpperCase()];
                if (d) {
                  g = d.getAttribute("imageType") || d.getAttribute("imagetype");
                  var h = d.getAttribute("encoding");
                  d = d.textContent.trim();
                  "PNG" == g && "Base64" == h && d && (a.backgroundImage = "data:image/png;base64," + d);
                }
                if (d = cw(b, c, e, "textOutline", f)) d = d.split(" "), d[0].match(fw) ? a.textStrokeColor = a.color : (a.textStrokeColor = d[0], d.shift()), d[0] && d[0].match(fw) ? a.textStrokeWidth = d[0] : a.textStrokeColor = "";
                (d = cw(b, c, e, "letterSpacing", f)) && d.match(fw) && (a.letterSpacing = d);
                (d = cw(b, c, e, "linePadding", f)) && d.match(fw) && (a.linePadding = d);
                if (f = cw(b, c, e, "opacity", f)) a.opacity = parseFloat(f);
                (c = Wv(c, e, "textDecoration")) && hw(a, c);
                (b = iw(b, e, "textDecoration")) && hw(a, b);
              }
              function hw(a, b) {
                b = r(b.split(" "));
                for (var c = b.next(); !c.done; c = b.next()) switch (c.value) {
                  case "underline":
                    a.textDecoration.includes("underline") || a.textDecoration.push("underline");
                    break;
                  case "noUnderline":
                    a.textDecoration.includes("underline") && hb(a.textDecoration, "underline");
                    break;
                  case "lineThrough":
                    a.textDecoration.includes("lineThrough") || a.textDecoration.push("lineThrough");
                    break;
                  case "noLineThrough":
                    a.textDecoration.includes("lineThrough") && hb(a.textDecoration, "lineThrough");
                    break;
                  case "overline":
                    a.textDecoration.includes("overline") || a.textDecoration.push("overline");
                    break;
                  case "noOverline":
                    a.textDecoration.includes("overline") && hb(a.textDecoration, "overline");
                }
              }
              function cw(a, b, c, d, e) {
                e = void 0 === e ? !0 : e;
                return (a = iw(a, c, d)) ? a : e ? Wv(b, c, d) : null;
              }
              function Wv(a, b, c) {
                if (!a) return null;
                var d = Rf(a, Sv, c);
                return d ? d : jw(a, b, c);
              }
              function iw(a, b, c) {
                var d = Rf(a, Sv, c);
                return d ? d : jw(a, b, c);
              }
              function jw(a, b, c) {
                a = Zv(a, "style", b, "");
                for (var d = null, e = 0; e < a.length; e++) {
                  var f = Qf(a[e], "urn:ebu:tt:style", c);
                  f || (f = Rf(a[e], Sv, c));
                  f || (f = iw(a[e], b, c));
                  f && (d = f);
                }
                return d;
              }
              function Zv(a, b, c, d, e) {
                var f = [];
                if (!a || 1 > c.length) return f;
                var g = a;
                for (a = null; g && !(a = e ? Qf(g, e, b) : g.getAttribute(b)) && (g = g.parentNode, g instanceof Element););
                if (b = a) for (b = r(b.split(" ")), e = b.next(); !e.done; e = b.next()) for (e = e.value, a = r(c), g = a.next(); !g.done; g = a.next()) if (g = g.value, d + g.getAttribute("xml:id") == e) {
                  f.push(g);
                  break;
                }
                return f;
              }
              function aw(a, b, c, d) {
                a = $v(a, b);
                null == c ? c = a.start : null != a.start && (c += a.start);
                null == d ? d = a.end : null != a.start && (d += a.start);
                return {
                  start: c,
                  end: d
                };
              }
              function $v(a, b) {
                var c = kw(a.getAttribute("begin"), b),
                  d = kw(a.getAttribute("end"), b);
                a = kw(a.getAttribute("dur"), b);
                null == d && null != a && (d = c + a);
                return {
                  start: c,
                  end: d
                };
              }
              function kw(a, b) {
                var c = null;
                if (lw.test(a)) {
                  a = lw.exec(a);
                  c = Number(a[1]);
                  var d = Number(a[2]),
                    e = Number(a[3]),
                    f = Number(a[4]);
                  f += (Number(a[5]) || 0) / b.h;
                  e += f / b.frameRate;
                  c = e + 60 * d + 3600 * c;
                } else if (mw.test(a)) c = nw(mw, a);else if (ow.test(a)) c = nw(ow, a);else if (pw.test(a)) a = pw.exec(a), c = Number(a[1]) / b.frameRate;else if (qw.test(a)) a = qw.exec(a), c = Number(a[1]) / b.g;else if (rw.test(a)) c = nw(rw, a);else if (a) throw new O(2, 2, 2001, "Could not parse cue time range in TTML");
                return c;
              }
              function nw(a, b) {
                a = a.exec(b);
                return null == a || "" == a[0] ? null : (Number(a[4]) || 0) / 1E3 + (Number(a[3]) || 0) + 60 * (Number(a[2]) || 0) + 3600 * (Number(a[1]) || 0);
              }
              K("shaka.text.TtmlTextParser", Qv);
              Qv.prototype.parseMedia = Qv.prototype.parseMedia;
              Qv.prototype.setSequenceMode = Qv.prototype.setSequenceMode;
              Qv.prototype.parseInit = Qv.prototype.parseInit;
              function Tv(a, b, c, d) {
                this.frameRate = Number(a) || 30;
                this.h = Number(b) || 1;
                this.g = Number(d);
                0 == this.g && (this.g = a ? this.frameRate * this.h : 1);
                c && (a = /^(\d+) (\d+)$/g.exec(c)) && (this.frameRate *= Number(a[1]) / Number(a[2]));
              }
              var Uv = /^(\d{1,2}(?:\.\d+)?|100(?:\.0+)?)% (\d{1,2}(?:\.\d+)?|100(?:\.0+)?)%$/,
                gw = /^(\d{1,2}(?:\.\d+)?|100)%$/,
                fw = /^(\d+px|\d+em|\d*\.?\d+c)$/,
                Vv = /^(\d+)px (\d+)px$/,
                lw = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                mw = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/,
                ow = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/,
                pw = /^(\d*(?:\.\d*)?)f$/,
                qw = /^(\d*(?:\.\d*)?)t$/,
                rw = RegExp("^(?:(\\d*(?:\\.\\d*)?)h)?(?:(\\d*(?:\\.\\d*)?)m)?(?:(\\d*(?:\\.\\d*)?)s)?(?:(\\d*(?:\\.\\d*)?)ms)?$"),
                ew = {
                  left: sb,
                  center: "center",
                  right: "end",
                  start: sb,
                  end: "end"
                },
                dw = {
                  left: "line-left",
                  center: "center",
                  right: "line-right"
                },
                Rv = ["http://www.w3.org/ns/ttml#parameter", "http://www.w3.org/2006/10/ttaf1#parameter"],
                Sv = ["http://www.w3.org/ns/ttml#styling", "http://www.w3.org/2006/10/ttaf1#styling"],
                Yv = ["http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt", "http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt"];
              fd["application/ttml+xml"] = function () {
                return new Qv();
              };
              function sw() {
                this.g = new Qv();
              }
              sw.prototype.parseInit = function (a) {
                var b = !1;
                new zf().box("moov", Ef).box("trak", Ef).box("mdia", Ef).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("stpp", function (c) {
                  b = !0;
                  c.parser.stop();
                }).parse(a);
                if (!b) throw new O(2, 2, 2007);
              };
              sw.prototype.setSequenceMode = function () {};
              sw.prototype.parseMedia = function (a, b) {
                var c = this,
                  d = !1,
                  e = [];
                new zf().box("mdat", If(function (f) {
                  d = !0;
                  e = e.concat(c.g.parseMedia(f, b));
                })).parse(a, !1);
                if (!d) throw new O(2, 2, 2007);
                return e;
              };
              K("shaka.text.Mp4TtmlParser", sw);
              sw.prototype.parseMedia = sw.prototype.parseMedia;
              sw.prototype.setSequenceMode = sw.prototype.setSequenceMode;
              sw.prototype.parseInit = sw.prototype.parseInit;
              fd['application/mp4; codecs="stpp"'] = function () {
                return new sw();
              };
              fd['application/mp4; codecs="stpp.ttml"'] = function () {
                return new sw();
              };
              fd['application/mp4; codecs="stpp.ttml.im1t"'] = function () {
                return new sw();
              };
              fd['application/mp4; codecs="stpp.TTML.im1t"'] = function () {
                return new sw();
              };
              function tw() {
                this.g = !1;
              }
              tw.prototype.parseInit = function () {};
              tw.prototype.setSequenceMode = function (a) {
                this.g = a;
              };
              tw.prototype.parseMedia = function (a, b) {
                a = Cc(a);
                a = a.replace(/\r\n|\r(?=[^\n]|$)/gm, "\n");
                var c = a.split(/\n{2,}/m);
                if (!/^WEBVTT($|[ \t\n])/m.test(c[0])) throw new O(2, 2, 2E3);
                a = b.vttOffset;
                if (c[0].includes("X-TIMESTAMP-MAP") && this.g) {
                  var d = c[0].match(/LOCAL:((?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{3}))/m),
                    e = c[0].match(/MPEGTS:(\d+)/m);
                  if (d && e) {
                    a = uw(new Mq(d[1]));
                    if (null == a) throw new O(2, 2, 2E3);
                    e = Number(e[1]);
                    for (d = b.segmentStart - b.periodStart; 95443.7176888889 <= d;) d -= 95443.7176888889, e += 8589934592;
                    a = b.periodStart + e / 9E4 - a;
                  }
                }
                b = [];
                e = r(c[0].split("\n"));
                for (d = e.next(); !d.done; d = e.next()) if (d = d.value, /^Region:/.test(d)) {
                  d = new Mq(d);
                  var f = new mb();
                  Pq(d);
                  Nq(d);
                  for (var g = Pq(d); g;) {
                    var h = f,
                      k = g;
                    (g = /^id=(.*)$/.exec(k)) ? h.id = g[1] : (g = /^width=(\d{1,2}|100)%$/.exec(k)) ? h.width = Number(g[1]) : (g = /^lines=(\d+)$/.exec(k)) ? (h.height = Number(g[1]), h.heightUnits = 2) : (g = /^regionanchor=(\d{1,2}|100)%,(\d{1,2}|100)%$/.exec(k)) ? (h.regionAnchorX = Number(g[1]), h.regionAnchorY = Number(g[2])) : (g = /^viewportanchor=(\d{1,2}|100)%,(\d{1,2}|100)%$/.exec(k)) ? (h.viewportAnchorX = Number(g[1]), h.viewportAnchorY = Number(g[2])) : /^scroll=up$/.exec(k) && (h.scroll = "up");
                    Nq(d);
                    g = Pq(d);
                  }
                  b.push(f);
                }
                e = new Map();
                vw(e);
                d = [];
                c = r(c.slice(1));
                for (f = c.next(); !f.done; f = c.next()) {
                  f = f.value.split("\n");
                  if ((1 != f.length || f[0]) && !/^NOTE($|[ \t])/.test(f[0]) && "STYLE" == f[0]) {
                    h = [];
                    g = -1;
                    for (k = 1; k < f.length; k++) f[k].includes("::cue") && (h.push([]), g = h.length - 1), -1 != g && (h[g].push(f[k]), f[k].includes("}") && (g = -1));
                    h = r(h);
                    for (g = h.next(); !g.done; g = h.next()) {
                      var l = g.value;
                      g = "global";
                      (k = l[0].match(/\((.*)\)/)) && (g = k.pop());
                      k = l.slice(1, -1);
                      l[0].includes("}") && (l = /\{(.*?)\}/.exec(l[0])) && (k = l[1].split(";"));
                      (l = e.get(g)) || (l = new kb(0, 0, ""));
                      for (var m = !1, n = 0; n < k.length; n++) {
                        var p = /^\s*([^:]+):\s*(.*)/.exec(k[n]);
                        if (p) {
                          var t = p[2].trim().replace(";", "");
                          switch (p[1].trim()) {
                            case "background-color":
                            case "background":
                              m = !0;
                              l.backgroundColor = t;
                              break;
                            case "color":
                              m = !0;
                              l.color = t;
                              break;
                            case "font-family":
                              m = !0;
                              l.fontFamily = t;
                              break;
                            case "font-size":
                              m = !0;
                              l.fontSize = t;
                              break;
                            case "font-weight":
                              if (700 <= parseInt(t, 10) || "bold" == t) m = !0, l.fontWeight = 700;
                              break;
                            case "font-style":
                              switch (t) {
                                case "normal":
                                  m = !0;
                                  l.fontStyle = vb;
                                  break;
                                case "italic":
                                  m = !0;
                                  l.fontStyle = "italic";
                                  break;
                                case "oblique":
                                  m = !0, l.fontStyle = "oblique";
                              }
                              break;
                            case "opacity":
                              m = !0;
                              l.opacity = parseFloat(t);
                              break;
                            case "text-shadow":
                              m = !0;
                              l.textShadow = t;
                              break;
                            case "white-space":
                              m = !0, l.wrapLine = "noWrap" != t;
                          }
                        }
                      }
                      m && e.set(g, l);
                    }
                  }
                  m = a;
                  if (1 == f.length && !f[0] || /^NOTE($|[ \t])/.test(f[0]) || "STYLE" == f[0] || "REGION" == f[0]) f = null;else {
                    h = null;
                    f[0].includes("--\x3e") || (h = f[0], f.splice(0, 1));
                    g = new Mq(f[0]);
                    k = uw(g);
                    n = Oq(g, /[ \t]+--\x3e[ \t]+/g);
                    l = uw(g);
                    if (null == k || null == n || null == l) throw new O(2, 2, 2001, "Could not parse cue time range in WebVTT");
                    k += m;
                    l += m;
                    m = f.slice(1).join("\n").trim();
                    e.has("global") ? (f = e.get("global").clone(), f.startTime = k, f.endTime = l, f.payload = "") : f = new kb(k, l, "");
                    ww(m, f, e);
                    Nq(g);
                    for (k = Pq(g); k;) xw(f, k, b), Nq(g), k = Pq(g);
                    null != h && (f.id = h);
                  }
                  f && d.push(f);
                }
                return d;
              };
              function vw(a) {
                for (var b = r(Object.entries(Ab)), c = b.next(); !c.done; c = b.next()) {
                  var d = r(c.value);
                  c = d.next().value;
                  d = d.next().value;
                  var e = new kb(0, 0, "");
                  e.color = d;
                  a.set("." + c, e);
                }
                b = r(Object.entries(Bb));
                for (c = b.next(); !c.done; c = b.next()) d = r(c.value), c = d.next().value, d = d.next().value, e = new kb(0, 0, ""), e.backgroundColor = d, a.set("." + c, e);
              }
              function ww(a, b, c) {
                0 === c.size && vw(c);
                a: {
                  var d = a;
                  a = [];
                  for (var e = -1, f = "", g = 0; g < d.length; g++) if ("/" === d[g] && 0 < g && "<" === d[g - 1]) {
                    var h = d.indexOf(">", g);
                    if (h <= g) {
                      a = d;
                      break a;
                    }
                    if ((h = d.substring(g + 1, h)) && "c" === h) {
                      var k = a.pop();
                      k ? k === h ? (f += "/" + h + ">", g += h.length + 1) : k.startsWith("c.") ? (g += h.length + 1, f += "/" + k + ">") : f += d[g] : f += d[g];
                    } else f += d[g];
                  } else "<" === d[g] ? (e = g + 1, "c" != d[e] && (e = -1)) : ">" === d[g] && 0 < e && (a.push(d.substr(e, g - e)), e = -1), f += d[g];
                  a = f;
                }
                d = [];
                f = -1;
                for (e = 0; e < a.length; e++) "<" === a[e] ? f = e + 1 : ">" === a[e] && 0 < f && (f = a.substr(f, e - f), f.match(yw) && d.push(f), f = -1);
                d = r(d);
                for (e = d.next(); !e.done; e = d.next()) e = e.value, a = a.replace("<" + e + ">", '<div time="' + e + '">'), a += "</div>";
                a: {
                  e = a;
                  f = [];
                  g = -1;
                  d = "";
                  a = !1;
                  for (h = 0; h < e.length; h++) if ("/" === e[h]) {
                    k = e.indexOf(">", h);
                    if (-1 === k) {
                      a = e;
                      break a;
                    }
                    if ((k = e.substring(h + 1, k)) && "v" == k) {
                      a = !0;
                      var l = null;
                      f.length && (l = f[f.length - 1]);
                      if (l) {
                        if (l === k) d += "/" + k + ">";else {
                          if (!l.startsWith("v")) {
                            d += e[h];
                            continue;
                          }
                          d += "/" + l + ">";
                        }
                        h += k.length + 1;
                      } else d += e[h];
                    } else d += e[h];
                  } else "<" === e[h] ? (g = h + 1, "v" != e[g] && (g = -1)) : ">" === e[h] && 0 < g && (f.push(e.substr(g, h - g)), g = -1), d += e[h];
                  e = r(f);
                  for (f = e.next(); !f.done; f = e.next()) f = f.value, g = f.replace(" ", ".voice-"), d = d.replace("<" + f + ">", "<" + g + ">"), d = d.replace("</" + f + ">", "</" + g + ">"), a || (d += "</" + g + ">");
                  a = d;
                }
                if (e = cg("<span>" + a + "</span>", "span")) {
                  d = [];
                  e = e.childNodes;
                  if (1 == e.length && (f = e[0], f.nodeType == Node.TEXT_NODE || f.nodeType == Node.CDATA_SECTION_NODE)) {
                    b.payload = zw(a);
                    return;
                  }
                  a = r(e);
                  for (e = a.next(); !e.done; e = a.next()) Aw(e.value, b, d, c);
                  b.nestedCues = d;
                } else b.payload = zw(a);
              }
              function Bw(a, b) {
                return a && 0 < a.length ? a : b;
              }
              function Aw(a, b, c, d) {
                var e = b.clone();
                if (a.nodeType === Node.ELEMENT_NODE && a.nodeName) for (var f = r(a.nodeName.split(/(?=[ .])+/g)), g = f.next(); !g.done; g = f.next()) {
                  var h = g = g.value;
                  if (h.startsWith(".voice-")) {
                    var k = h.split("-").pop();
                    h = 'v[voice="' + k + '"]';
                    d.has(h) || (h = "v[voice=" + k + "]");
                  }
                  d.has(h) && (h = d.get(h)) && (e.backgroundColor = Bw(h.backgroundColor, e.backgroundColor), e.color = Bw(h.color, e.color), e.fontFamily = Bw(h.fontFamily, e.fontFamily), e.fontSize = Bw(h.fontSize, e.fontSize), e.fontWeight = h.fontWeight, e.fontStyle = h.fontStyle, e.opacity = h.opacity, e.wrapLine = h.wrapLine);
                  switch (g) {
                    case "br":
                      g = b.clone();
                      g.lineBreak = !0;
                      c.push(g);
                      break;
                    case "b":
                      e.fontWeight = 700;
                      break;
                    case "i":
                      e.fontStyle = "italic";
                      break;
                    case "u":
                      e.textDecoration.push("underline");
                      break;
                    case "div":
                      if (g = a.getAttribute("time")) if (g = uw(new Mq(g))) e.startTime = g;
                  }
                }
                if (Tf(a)) for (f = !0, d = r(a.textContent.split("\n")), a = d.next(); !a.done; a = d.next()) a = a.value, f || (f = b.clone(), f.lineBreak = !0, c.push(f)), 0 < a.length && (f = e.clone(), f.payload = zw(a), c.push(f)), f = !1;else for (b = r(a.childNodes), a = b.next(); !a.done; a = b.next()) Aw(a.value, e, c, d);
              }
              function xw(a, b, c) {
                var d;
                if (d = /^align:(start|middle|center|end|left|right)$/.exec(b)) b = d[1], "middle" == b ? a.textAlign = ob : a.textAlign = xb[b.toUpperCase()];else if (d = /^vertical:(lr|rl)$/.exec(b)) a.writingMode = "lr" == d[1] ? "vertical-lr" : "vertical-rl";else if (d = /^size:([\d.]+)%$/.exec(b)) a.size = Number(d[1]);else if (d = /^position:([\d.]+)%(?:,(line-left|line-right|center|start|end))?$/.exec(b)) a.position = Number(d[1]), d[2] && (b = d[2], a.positionAlign = "line-left" == b || "start" == b ? "line-left" : "line-right" == b || "end" == b ? "line-right" : "center");else if (d = /^region:(.*)$/.exec(b)) {
                  if (b = Cw(c, d[1])) a.region = b;
                } else if (c = /^line:([\d.]+)%(?:,(start|end|center))?$/.exec(b)) a.lineInterpretation = 1, a.line = Number(c[1]), c[2] && (a.lineAlign = zb[c[2].toUpperCase()]);else if (c = /^line:(-?\d+)(?:,(start|end|center))?$/.exec(b)) a.lineInterpretation = rb, a.line = Number(c[1]), c[2] && (a.lineAlign = zb[c[2].toUpperCase()]);
              }
              function Cw(a, b) {
                a = a.filter(function (c) {
                  return c.id == b;
                });
                return a.length ? a[0] : null;
              }
              function uw(a) {
                a = Oq(a, yw);
                if (null == a) return null;
                var b = Number(a[2]),
                  c = Number(a[3]);
                return 59 < b || 59 < c ? null : Number(a[4]) / 1E3 + c + 60 * b + 3600 * (Number(a[1]) || 0);
              }
              function zw(a) {
                var b = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'",
                    "&nbsp;": "\u00a0",
                    "&lrm;": "\u200e",
                    "&rlm;": "\u200f"
                  },
                  c = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g,
                  d = RegExp(c.source);
                return a && d.test(a) ? a.replace(c, function (e) {
                  return b[e] || "'";
                }) : a || "";
              }
              K("shaka.text.VttTextParser", tw);
              tw.prototype.parseMedia = tw.prototype.parseMedia;
              tw.prototype.setSequenceMode = tw.prototype.setSequenceMode;
              tw.prototype.parseInit = tw.prototype.parseInit;
              var yw = /(?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{2,3})/g;
              fd["text/vtt"] = function () {
                return new tw();
              };
              fd['text/vtt; codecs="vtt"'] = function () {
                return new tw();
              };
              fd['text/vtt; codecs="wvtt"'] = function () {
                return new tw();
              };
              function Dw() {
                this.g = null;
              }
              Dw.prototype.parseInit = function (a) {
                var b = this,
                  c = !1;
                new zf().box("moov", Ef).box("trak", Ef).box("mdia", Ef).P("mdhd", function (d) {
                  d = fi(d.reader, d.version);
                  b.g = d.timescale;
                }).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("wvtt", function () {
                  c = !0;
                }).parse(a);
                if (!this.g) throw new O(2, 2, 2008);
                if (!c) throw new O(2, 2, 2008);
              };
              Dw.prototype.setSequenceMode = function () {};
              Dw.prototype.parseMedia = function (a, b) {
                if (!this.g) throw new O(2, 2, 2008);
                var c = 0,
                  d = [],
                  e,
                  f = [],
                  g = !1,
                  h = !1,
                  k = !1,
                  l = null;
                new zf().box("moof", Ef).box("traf", Ef).P("tfdt", function (z) {
                  g = !0;
                  c = ei(z.reader, z.version).we;
                }).P("tfhd", function (z) {
                  l = di(z.reader, z.flags).Ce;
                }).P("trun", function (z) {
                  h = !0;
                  d = gi(z.reader, z.version, z.flags).Re;
                }).box("mdat", If(function (z) {
                  k = !0;
                  e = z;
                })).parse(a, !1);
                if (!k && !g && !h) throw new O(2, 2, 2008);
                a = c;
                for (var m = new wf(e, 0), n = r(d), p = n.next(); !p.done; p = n.next()) {
                  p = p.value;
                  var t = p.ee || l,
                    v = p.ed ? c + p.ed : a;
                  a = v + (t || 0);
                  var y = 0;
                  do {
                    var w = m.K();
                    y += w;
                    var x = m.K(),
                      C = null;
                    "vttc" == Df(x) ? 8 < w && (C = m.Za(w - 8)) : m.skip(w - 8);
                    t && C && (w = Ew(C, b.periodStart + v / this.g, b.periodStart + a / this.g), f.push(w));
                  } while (p.sampleSize && y < p.sampleSize);
                }
                return f.filter(dc);
              };
              function Ew(a, b, c) {
                var d, e, f;
                new zf().box("payl", If(function (g) {
                  d = Cc(g);
                })).box("iden", If(function (g) {
                  e = Cc(g);
                })).box("sttg", If(function (g) {
                  f = Cc(g);
                })).parse(a);
                return d ? Fw(d, e, f, b, c) : null;
              }
              function Fw(a, b, c, d, e) {
                d = new kb(d, e, "");
                ww(a, d, new Map());
                b && (d.id = b);
                if (c) for (a = new Mq(c), b = Pq(a); b;) xw(d, b, []), Nq(a), b = Pq(a);
                return d;
              }
              K("shaka.text.Mp4VttParser", Dw);
              Dw.prototype.parseMedia = Dw.prototype.parseMedia;
              Dw.prototype.setSequenceMode = Dw.prototype.setSequenceMode;
              Dw.prototype.parseInit = Dw.prototype.parseInit;
              fd['application/mp4; codecs="wvtt"'] = function () {
                return new Dw();
              };
              function Gw() {}
              Gw.prototype.parseInit = function () {};
              Gw.prototype.setSequenceMode = function () {};
              Gw.prototype.parseMedia = function (a) {
                var b = Cc(a).replace(/\r+/g, "");
                b = b.trim();
                a = [];
                if ("" == b) return a;
                b = r(b.split("\n\n"));
                for (var c = b.next(); !c.done; c = b.next()) {
                  c = c.value.split("\n");
                  var d = new Mq(c[0]),
                    e = Hw(d),
                    f = Oq(d, /,/g);
                  d = Hw(d);
                  if (null == e || null == f || null == d) throw new O(2, 2, 2001, "Could not parse cue time range in SubViewer");
                  a.push(new kb(e, d, c.slice(1).join("\n").trim()));
                }
                return a;
              };
              function Hw(a) {
                a = Oq(a, /(?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{2,3})/g);
                if (null == a) return null;
                var b = Number(a[2]),
                  c = Number(a[3]);
                return 59 < b || 59 < c ? null : Number(a[4]) / 1E3 + c + 60 * b + 3600 * (Number(a[1]) || 0);
              }
              K("shaka.text.SbvTextParser", Gw);
              Gw.prototype.parseMedia = Gw.prototype.parseMedia;
              Gw.prototype.setSequenceMode = Gw.prototype.setSequenceMode;
              Gw.prototype.parseInit = Gw.prototype.parseInit;
              fd["text/x-subviewer"] = function () {
                return new Gw();
              };
              function Iw() {
                this.g = new tw();
              }
              Iw.prototype.parseInit = function () {};
              Iw.prototype.setSequenceMode = function () {};
              Iw.prototype.parseMedia = function (a, b) {
                a = Cc(a);
                a = Jw(a);
                a = M(Gc(a));
                return this.g.parseMedia(a, b);
              };
              function Jw(a) {
                var b = "WEBVTT\n\n";
                if ("" == a) return b;
                a = a.replace(/\r+/g, "");
                a = a.trim();
                a = r(a.split("\n\n"));
                for (var c = a.next(); !c.done; c = a.next()) c = c.value.split(/\n/), c[0].match(/\d+/) && c.shift(), c[0] = c[0].replace(/,/g, "."), b += c.join("\n") + "\n\n";
                return b;
              }
              K("shaka.text.SrtTextParser", Iw);
              Iw.srt2webvtt = Jw;
              Iw.prototype.parseMedia = Iw.prototype.parseMedia;
              Iw.prototype.setSequenceMode = Iw.prototype.setSequenceMode;
              Iw.prototype.parseInit = Iw.prototype.parseInit;
              fd["text/srt"] = function () {
                return new Iw();
              };
              function Kw() {}
              Kw.prototype.parseInit = function () {};
              Kw.prototype.setSequenceMode = function () {};
              Kw.prototype.parseMedia = function (a) {
                var b = "",
                  c = "";
                a = Cc(a).split(/\r?\n\s*\r?\n/);
                a = r(a);
                for (var d = a.next(); !d.done; d = a.next()) {
                  var e = Lw.exec(d.value);
                  e && (d = e[1], e = e[2], "V4 Styles" == d || "V4+ Styles" == d ? b = e : "Events" == d && (c = e));
                }
                a = [];
                d = null;
                b = r(b.split(/\r?\n/));
                for (var f = b.next(); !f.done; f = b.next()) if (e = f.value, !/^\s*;/.test(e) && (f = Mw.exec(e))) if (e = f[1].trim(), f = f[2].trim(), "Format" == e) d = f.split(Nw);else if ("Style" == e) {
                  e = f.split(Nw);
                  f = {};
                  for (var g = 0; g < d.length && g < e.length; g++) f[d[g]] = e[g];
                  a.push(f);
                }
                d = [];
                b = null;
                e = {};
                c = r(c.split(/\r?\n/));
                for (f = c.next(); !f.done; e = {
                  vd: e.vd
                }, f = c.next()) if (f = f.value, !/^\s*;/.test(f) && (g = Mw.exec(f))) if (f = g[1].trim(), g = g[2].trim(), "Format" == f) b = g.split(Nw);else if ("Dialogue" == f) {
                  g = g.split(Nw);
                  f = {};
                  for (var h = 0; h < b.length && h < g.length; h++) f[b[h]] = g[h];
                  h = Ow(f.Start);
                  var k = Ow(f.End);
                  g = new kb(h, k, g.slice(b.length - 1).join(",").replace(/\\N/g, "\n").replace(/\{[^}]+\}/g, ""));
                  e.vd = f.Style;
                  (f = a.find(function (l) {
                    return function (m) {
                      return m.Name == l.vd;
                    };
                  }(e))) && Pw(g, f);
                  d.push(g);
                }
                return d;
              };
              function Pw(a, b) {
                var c = b.Fontname;
                c && (a.fontFamily = c);
                if (c = b.Fontsize) a.fontSize = c + "px";
                if (c = b.PrimaryColour) if (c = Qw(c)) a.color = c;
                if (c = b.BackColour) if (c = Qw(c)) a.backgroundColor = c;
                b.Bold && (a.fontWeight = 700);
                b.Italic && (a.fontStyle = "italic");
                b.Underline && a.textDecoration.push("underline");
                if (c = b.Spacing) a.letterSpacing = c + "px";
                if (c = b.Alignment) switch (parseInt(c, 10)) {
                  case 1:
                    a.displayAlign = tb;
                    a.textAlign = "start";
                    break;
                  case 2:
                    a.displayAlign = tb;
                    a.textAlign = ob;
                    break;
                  case 3:
                    a.displayAlign = tb;
                    a.textAlign = "end";
                    break;
                  case 5:
                    a.displayAlign = "before";
                    a.textAlign = "start";
                    break;
                  case 6:
                    a.displayAlign = "before";
                    a.textAlign = ob;
                    break;
                  case 7:
                    a.displayAlign = "before";
                    a.textAlign = "end";
                    break;
                  case 9:
                    a.displayAlign = "center";
                    a.textAlign = "start";
                    break;
                  case 10:
                    a.displayAlign = "center";
                    a.textAlign = ob;
                    break;
                  case 11:
                    a.displayAlign = "center", a.textAlign = "end";
                }
                if (b = b.AlphaLevel) a.opacity = parseFloat(b);
              }
              function Qw(a) {
                a = parseInt(a.replace("&H", ""), 16);
                return 0 <= a ? "rgba(" + (a & 255) + "," + (a >> 8 & 255) + "," + (a >> 16 & 255) + "," + (a >> 24 & 255 ^ 255) / 255 + ")" : null;
              }
              function Ow(a) {
                a = Rw.exec(a);
                return 3600 * (a[1] ? parseInt(a[1].replace(":", ""), 10) : 0) + 60 * parseInt(a[2], 10) + parseFloat(a[3]);
              }
              K("shaka.text.SsaTextParser", Kw);
              Kw.prototype.parseMedia = Kw.prototype.parseMedia;
              Kw.prototype.setSequenceMode = Kw.prototype.setSequenceMode;
              Kw.prototype.parseInit = Kw.prototype.parseInit;
              var Lw = /^\s*\[([^\]]+)\]\r?\n([\s\S]*)/,
                Mw = /^\s*([^:]+):\s*(.*)/,
                Nw = /\s*,\s*/,
                Rw = /^(\d+:)?(\d{1,2}):(\d{1,2}(?:[.]\d{1,3})?)?$/;
              fd["text/x-ssa"] = function () {
                return new Kw();
              }; /*
                 @license
                 EME Encryption Scheme Polyfill
                 Copyright 2019 Google LLC
                 SPDX-License-Identifier: Apache-2.0
                 */
              function Sw() {}
              var Tw;
              function Uw() {
                Tw ? console.debug("EmeEncryptionSchemePolyfill: Already installed.") : navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration ? (Tw = navigator.requestMediaKeySystemAccess, console.debug("EmeEncryptionSchemePolyfill: Waiting to detect encryptionScheme support."), navigator.requestMediaKeySystemAccess = Vw) : console.debug("EmeEncryptionSchemePolyfill: EME not found");
              }
              function Vw(a, b) {
                var c = this,
                  d;
                return G(function (e) {
                  if (1 == e.g) return console.assert(c == navigator, 'bad "this" for requestMediaKeySystemAccess'), u(e, Tw.call(c, a, b), 2);
                  d = e.h;
                  if (Ww(d)) return console.debug("EmeEncryptionSchemePolyfill: Native encryptionScheme support found."), navigator.requestMediaKeySystemAccess = Tw, e.return(d);
                  console.debug("EmeEncryptionSchemePolyfill: No native encryptionScheme support found. Patching encryptionScheme support.");
                  navigator.requestMediaKeySystemAccess = Xw;
                  return e.return(Xw.call(c, a, b));
                });
              }
              function Xw(a, b) {
                var c = this,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l,
                  m,
                  n,
                  p;
                return G(function (t) {
                  if (1 == t.g) {
                    console.assert(c == navigator, 'bad "this" for requestMediaKeySystemAccess');
                    d = Yw(a);
                    e = [];
                    f = r(b);
                    for (g = f.next(); !g.done; g = f.next()) h = g.value, k = Zw(h.videoCapabilities, d), l = Zw(h.audioCapabilities, d), h.videoCapabilities && h.videoCapabilities.length && !k.length || h.audioCapabilities && h.audioCapabilities.length && !l.length || (m = Object.assign({}, h), m.videoCapabilities = k, m.audioCapabilities = l, e.push(m));
                    if (!e.length) throw n = Error("Unsupported keySystem or supportedConfigurations."), n.name = "NotSupportedError", n.code = DOMException.NOT_SUPPORTED_ERR, n;
                    return u(t, Tw.call(c, a, e), 2);
                  }
                  p = t.h;
                  return t.return(new $w(p, d));
                });
              }
              function Zw(a, b) {
                return a ? a.filter(function (c) {
                  return !c.encryptionScheme || c.encryptionScheme == b;
                }) : a;
              }
              K("EmeEncryptionSchemePolyfill", Sw);
              Sw.install = Uw;
              function ax() {}
              var bx;
              function cx() {
                bx ? console.debug("McEncryptionSchemePolyfill: Already installed.") : navigator.mediaCapabilities ? (bx = navigator.mediaCapabilities.decodingInfo, console.debug("McEncryptionSchemePolyfill: Waiting to detect encryptionScheme support."), navigator.mediaCapabilities.decodingInfo = dx) : console.debug("McEncryptionSchemePolyfill: MediaCapabilities not found");
              }
              function dx(a) {
                var b = this,
                  c,
                  d,
                  e;
                return G(function (f) {
                  switch (f.g) {
                    case 1:
                      return console.assert(b == navigator.mediaCapabilities, 'bad "this" for decodingInfo'), u(f, bx.call(b, a), 2);
                    case 2:
                      c = f.h;
                      if (!a.keySystemConfiguration) return f.return(c);
                      if ((d = c.keySystemAccess) && Ww(d)) return console.debug("McEncryptionSchemePolyfill: Native encryptionScheme support found."), navigator.mediaCapabilities.decodingInfo = bx, f.return(c);
                      console.debug("McEncryptionSchemePolyfill: No native encryptionScheme support found. Patching encryptionScheme support.");
                      navigator.mediaCapabilities.decodingInfo = ex;
                      if (d) {
                        f.A(3);
                        break;
                      }
                      e = c;
                      return u(f, fx(a), 4);
                    case 4:
                      return e.keySystemAccess = f.h, f.return(c);
                    case 3:
                      return f.return(ex.call(b, a));
                  }
                });
              }
              function ex(a) {
                var b = this,
                  c,
                  d,
                  e,
                  f,
                  g,
                  h,
                  k,
                  l;
                return G(function (m) {
                  switch (m.g) {
                    case 1:
                      return console.assert(b == navigator.mediaCapabilities, 'bad "this" for decodingInfo'), c = null, a.keySystemConfiguration && (d = a.keySystemConfiguration, e = d.keySystem, f = d.audio && d.audio.encryptionScheme, g = d.video && d.video.encryptionScheme, c = Yw(e), h = {
                        powerEfficient: !1,
                        smooth: !1,
                        supported: !1,
                        keySystemAccess: null,
                        configuration: a
                      }, f && f != c || g && g != c) ? m.return(h) : u(m, bx.call(b, a), 2);
                    case 2:
                      k = m.h;
                      if (k.keySystemAccess) {
                        k.keySystemAccess = new $w(k.keySystemAccess, c);
                        m.A(3);
                        break;
                      }
                      if (!a.keySystemConfiguration) {
                        m.A(3);
                        break;
                      }
                      l = k;
                      return u(m, fx(a), 5);
                    case 5:
                      l.keySystemAccess = m.h;
                    case 3:
                      return m.return(k);
                  }
                });
              }
              function fx(a) {
                var b, c;
                return G(function (d) {
                  if (1 == d.g) {
                    var e = a.keySystemConfiguration,
                      f = [],
                      g = [];
                    e.audio && f.push({
                      robustness: e.audio.robustness || "",
                      contentType: a.audio.contentType
                    });
                    e.video && g.push({
                      robustness: e.video.robustness || "",
                      contentType: a.video.contentType
                    });
                    e = {
                      initDataTypes: e.initDataType ? [e.initDataType] : [],
                      distinctiveIdentifier: e.distinctiveIdentifier,
                      persistentState: e.persistentState,
                      sessionTypes: e.sessionTypes
                    };
                    f.length && (e.audioCapabilities = f);
                    g.length && (e.videoCapabilities = g);
                    b = e;
                    return u(d, navigator.requestMediaKeySystemAccess(a.keySystemConfiguration.keySystem, [b]), 2);
                  }
                  c = d.h;
                  return d.return(c);
                });
              }
              K("McEncryptionSchemePolyfill", ax);
              ax.install = cx;
              function $w(a, b) {
                this.h = a;
                this.g = b;
                this.keySystem = a.keySystem;
              }
              $w.prototype.getConfiguration = function () {
                var a = this.h.getConfiguration();
                if (a.videoCapabilities) for (var b = r(a.videoCapabilities), c = b.next(); !c.done; c = b.next()) c.value.encryptionScheme = this.g;
                if (a.audioCapabilities) for (b = r(a.audioCapabilities), c = b.next(); !c.done; c = b.next()) c.value.encryptionScheme = this.g;
                return a;
              };
              $w.prototype.createMediaKeys = function () {
                return this.h.createMediaKeys();
              };
              function Yw(a) {
                if (a.startsWith("com.widevine") || a.startsWith("com.microsoft") || a.startsWith("com.chromecast") || a.startsWith("com.adobe") || a.startsWith("org.w3")) return "cenc";
                if (a.startsWith("com.apple")) return "cbcs-1-9";
                console.warn("EmeEncryptionSchemePolyfill: Unknown key system:", a, "Please contribute!");
                return null;
              }
              function Ww(a) {
                a = a.getConfiguration();
                var b = a.audioCapabilities && a.audioCapabilities[0];
                return (a = a.videoCapabilities && a.videoCapabilities[0] || b) && void 0 !== a.encryptionScheme ? !0 : !1;
              }
              function gx() {}
              function ku() {
                Uw();
                cx();
              }
              K("EncryptionSchemePolyfills", gx);
              gx.install = ku;
              "undefined" !== typeof module && module.exports && (module.exports = gx);
            }).call(exportTo, innerGlobal, innerGlobal, undefined);
            for (var k in exportTo.shaka) exports[k] = exportTo.shaka[k];
          })();
        })(shakaPlayer_compiled);
        var shaka = /*@__PURE__*/getDefaultExportFromCjs(shakaPlayer_compiled);
        class POCVideoPlayer extends lightning.Component {
          constructor() {
            var _this6;
            super(...arguments);
            _this6 = this;
            this.videoUrl = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4";
            this.index = 1;
            this.contentId = "";
            this._isPlaying = true;
            /**
             * 
             * video Player functions
             * 
             */
            // Note: this is in fact the default loader function
            this._loadPlayback = /*#__PURE__*/function () {
              var _ref38 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(url, videoEl) {
                return _regeneratorRuntime().wrap(function _callee10$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      _this6._setupShakaPlayer(videoEl);
                      _context12.next = 3;
                      return _this6._player.load(url);
                    case 3:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee10);
              }));
              return function (_x8, _x9) {
                return _ref38.apply(this, arguments);
              };
            }();
            // Note: this is in fact the default unloader function
            this._unloadPlayback = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
              return _regeneratorRuntime().wrap(function _callee11$(_context13) {
                while (1) switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return _this6._player.unload();
                  case 2:
                  case "end":
                    return _context13.stop();
                }
              }, _callee11);
            }));
          }
          /**
           * This function is responsible for the creation and return of the UI template. This function 
           * takes  no parameters and returns the template.
           * 
           * @returns Template for the Application
           * 
           */
          static _template() {
            return {
              Wrapper: {
                alpha: 1,
                BackButton: {
                  x: 40,
                  y: 40,
                  zIndex: 99,
                  type: BackButton
                },
                PlayPause: {
                  type: PlayPauseButton
                }
              }
            };
          }
          set params(args) {
            var id = args.id;
            this.contentId = id;
          }
          // when the playe is shown in the screen and active for the first time 
          _firstActive() {
            VideoPlayer.consumer(this);
            VideoPlayer.loader(this._loadPlayback);
            VideoPlayer.unloader(this._unloadPlayback);
          }
          // initializing the component
          _init() {}
          _active() {
            VideoPlayer.open(this.videoUrl);
          }
          _inactive() {
            VideoPlayer.close();
          }
          // handling up button click
          _handleUp() {
            if (this.index > 0) {
              this.index -= 1;
            }
          }
          // handling down button click
          _handleDown() {
            if (this.index < 1) {
              this.index += 1;
            }
          }
          // handling okay button click
          _handleEnter() {
            if (this.index === 0) {
              Router.navigate(`content/railItem/${this.contentId}`);
            } else if (this.index === 1) {
              var button = this.tag("PlayPause");
              button.isPlaying = !button.isPlaying;
              button.isPlaying ? VideoPlayer.play() : VideoPlayer.pause();
            }
          }
          _getFocused() {
            return this.tag("Wrapper").children[this.index];
          }
          // shaka player
          _setupShakaPlayer(videoEl) {
            videoEl.autoplay = true;
            this._player = new shaka.Player(videoEl);
            console.log(this._player);
          }
        }
        class GridItem extends lightning.Component {
          constructor() {
            super(...arguments);
            this.data = {};
          }
          /**
           * This function is responsible for the creation and return of the UI template. This
           * function takes  no parameters and returns the template of the Rail Item component.
           *
           * @returns Template for the Rail Item Component.
           *
           */
          static _template() {
            return {
              rect: true,
              color: theme.colors.primary,
              shader: {
                type: lightning.shaders.RoundedRectangle,
                radius: 20
              },
              Image: {
                shader: {
                  type: lightning.shaders.RoundedRectangle,
                  radius: 20
                }
              },
              Label: {
                x: 10,
                y: 435,
                w: _w15 => _w15,
                color: theme.colors.accentGrey.light,
                text: {
                  fontSize: 30
                }
              }
            };
          }
          /**
           * Setter for setting the values for the item property.
           *
           * @Param The value that needs to be setted to the item property.
           *
           */
          set item(obj) {
            var label = obj.label,
              src = obj.src,
              data = obj.data;
            this.data = data;
            this.patch({
              Image: {
                src
              },
              Label: {
                text: label === null || label === void 0 ? void 0 : label.toString()
              }
            });
          }
          /**
          * This function overrides the default behaviour of keypress 'Enter'.
          * This functions checks the index to see the focused element and decides
          * the route to navigate.
          */
          _handleEnter() {
            Router.navigate(`content/gridItem/${this.data.uid}`, {
              contentData: this.data,
              from: "Grid"
            });
          }
          /**
           * This function overrides the default behavior of the component when come in focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it comes to the focus.
           *
           */
          _focus() {
            this.patch({
              smooth: {
                color: theme.colors.secondary,
                scale: 1.1
              },
              Label: {
                smooth: {
                  color: theme.colors.white
                }
              },
              Rectangle: {
                color: theme.colors.yellow,
                x: 10,
                y: _y4 => _y4 + 72,
                w: _w16 => _w16 - 20,
                h: 5,
                rect: true
              }
            });
          }
          /**
           * This function overrides the default behavior of the component when goes out of focus.
           * We can add all the changes / updates that needs to be made to the component when
           * it goes out of the focus.
           *
           */
          _unfocus() {
            this.patch({
              smooth: {
                color: theme.colors.primary,
                scale: 1
              },
              Label: {
                smooth: {
                  color: theme.colors.accentGrey.light
                }
              },
              Rectangle: void 0
            });
          }
        }
        class GridLayout extends lightning.Component {
          constructor() {
            super(...arguments);
            this.index = 1;
            this.data = [];
            this.dataLength = 0;
            this.intervalSub = 0;
            this.isLoading = true;
          }
          static _template() {
            return {
              w: 1920,
              h: 1080,
              color: theme.colors.primaryLight,
              rect: true,
              shader: {
                x: 100,
                y: -100,
                pivot: 0.5,
                type: lightning.shaders.RadialGradient,
                outerColor: theme.colors.primaryLight,
                innerColor: theme.colors.dark,
                radius: 800
              },
              BackButton: {
                x: 40,
                y: 40,
                shader: null,
                type: BackButton
              },
              Content: {
                Grid: {
                  x: 110,
                  y: 200,
                  columns: 5,
                  spacing: 160,
                  crossSpacing: 50,
                  itemType: GridItem,
                  type: Grid
                }
              }
            };
          }
          _init() {
            this.setLongRail();
          }
          setLongRail() {
            var _this7 = this;
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
              var rail, i, _this7$data$i, _this7$data$i2, _this7$data$i2$images, label, img_src;
              return _regeneratorRuntime().wrap(function _callee12$(_context14) {
                while (1) switch (_context14.prev = _context14.next) {
                  case 0:
                    _this7.isLoading = true;
                    _context14.next = 3;
                    return Storage.get("longData");
                  case 3:
                    _this7.data = _context14.sent;
                    _this7.dataLength = _this7.data.length;
                    rail = [];
                    for (i = 0; i < _this7.dataLength; i++) {
                      label = (_this7$data$i = _this7.data[i]) === null || _this7$data$i === void 0 ? void 0 : _this7$data$i.title;
                      img_src = (_this7$data$i2 = _this7.data[i]) === null || _this7$data$i2 === void 0 ? void 0 : (_this7$data$i2$images = _this7$data$i2.images.find(img => img.width === 288)) === null || _this7$data$i2$images === void 0 ? void 0 : _this7$data$i2$images.url;
                      rail.push({
                        w: 288,
                        h: 432,
                        item: {
                          label,
                          src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg",
                          data: _this7.data[i]
                        }
                      });
                    }
                    _this7.tag("Grid").add(rail.map(gridItem => {
                      return gridItem;
                    }));
                    _this7.isLoading = false;
                  case 9:
                  case "end":
                    return _context14.stop();
                }
              }, _callee12);
            }))();
          }
          /**
           * 
           * Network intensive Testing
           * 
           */
          // override _active() {
          //     let axiosRequester: AxiosRequester = new AxiosRequester();
          //     this.intervalSub = setInterval(() => {
          //         for (let i = 0; i < 100; i++) {
          //             for (let index = 0; index < 10; index++) {
          //                 const timestamp = new Date().getTime();
          //                 axiosRequester.fetch(endpoint[index]! + `timestamp=${timestamp}`).then((response) => { });
          //             }
          //         }
          //     }, 1000);
          // }
          // override _inactive() {
          //     clearInterval(this.intervalSub);
          // }
          _getFocused() {
            if (this.index === 0) {
              return this.tag("BackButton");
            }
            return this.tag("Grid");
          }
          _handleUp() {
            if (this.index > 0) {
              this.index -= 1;
            }
          }
          _handleDown() {
            if (this.index < 1) {
              this.index += 1;
            }
          }
          _handleEnter() {
            if (this.index === 0) {
              Router.navigate("home");
            }
          }
        }
        var routes = {
          root: "home",
          routes: [{
            path: "home",
            component: Home
          }, {
            path: "search",
            component: Search
          }, {
            path: "grid",
            component: GridLayout
          }, {
            path: "settings",
            component: Home
          }, {
            path: "content/:from/:id",
            component: ContentDetails,
            options: {
              reuseInstance: false
            }
          }, {
            path: "player/:id",
            component: POCVideoPlayer
          }]
        };
        class App extends Router.App {
          // setting up the router for the application
          _setup() {
            Router.startRouter(routes, this);
          }
          static getFonts() {
            return [{
              family: "Saira Regular",
              url: Utils.proxyUrl("fonts/Saira-VariableFont_wdth,wght.ttf"),
              descriptors: {
                weight: "1 1000"
              }
            }
            // {
            //   family: "Saira Italics",
            //   url: Utils.asset("fonts/Saira-Italic-VariableFont_wdth,wght.ttf"),
            //   descriptors: { weight: "1 1000" },
            // },
            ];
          }
        }

        var app = Launch(App, {
          stage: {
            pauseRafLoopOnIdle: true,
            fontSharp: true
          },
          debug: true,
          enablePointer: true,
          keys: {
            38: "Up",
            40: "Down",
            37: "Left",
            39: "Right",
            13: "Enter",
            8: "Back",
            27: "Exit"
          }
        }, {
          /* Platform settings */
        });
        var canvas = app.stage.getCanvas();
        document.body.appendChild(canvas);
      }
    };
  });
})();
//# sourceMappingURL=index-legacy-2bd3e6a9.js.map
