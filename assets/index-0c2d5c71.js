function __vite_legacy_guard() {
  import.meta.url;
  import("_").catch(() => 1);
  async function* g() {
  }
  ;
}
;
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const settings = {};
const subscribers = {};
const initSettings = (appSettings, platformSettings) => {
  settings["app"] = appSettings;
  settings["platform"] = platformSettings;
  settings["user"] = {};
};
const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach((subscriber) => subscriber(value));
};
const dotGrab = (obj = {}, key) => {
  if (obj === null)
    return void 0;
  const keys = key.split(".");
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== void 0 ? obj[keys[i]] : {};
  }
  return typeof obj === "object" && obj !== null ? Object.keys(obj).length ? obj : void 0 : obj;
};
const Settings$1 = {
  get(type, key, fallback = void 0) {
    const val = dotGrab(settings[type], key);
    return val !== void 0 ? val : fallback;
  },
  has(type, key) {
    return !!this.get(type, key);
  },
  set(key, value) {
    settings["user"][key] = value;
    publish(key, value);
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || [];
    subscribers[key].push(callback);
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex((cb) => cb === callback);
      index > -1 && subscribers[key].splice(index, 1);
    } else {
      if (key in subscribers) {
        subscribers[key] = [];
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key];
    }
  }
};
const prepLog = (type, args) => {
  const colors2 = {
    Info: "green",
    Debug: "gray",
    Warn: "orange",
    Error: "red"
  };
  args = Array.from(args);
  return [
    "%c" + (args.length > 1 && typeof args[0] === "string" ? args.shift() : type),
    "background-color: " + colors2[type] + "; color: white; padding: 2px 4px; border-radius: 2px",
    args
  ];
};
const Log$1 = {
  info() {
    Settings$1.get("platform", "log") && console.log.apply(console, prepLog("Info", arguments));
  },
  debug() {
    Settings$1.get("platform", "log") && console.debug.apply(console, prepLog("Debug", arguments));
  },
  error() {
    Settings$1.get("platform", "log") && console.error.apply(console, prepLog("Error", arguments));
  },
  warn() {
    Settings$1.get("platform", "log") && console.warn.apply(console, prepLog("Warn", arguments));
  }
};
class StageUtils {
  static mergeNumbers(v1, v2, p) {
    return v1 * p + v2 * (1 - p);
  }
  static rgb(r, g, b) {
    return (r << 16) + (g << 8) + b + 255 * 16777216;
  }
  static rgba(r, g, b, a) {
    return (r << 16) + (g << 8) + b + (a * 255 | 0) * 16777216;
  }
  static getRgbString(color) {
    let r = (color / 65536 | 0) % 256;
    let g = (color / 256 | 0) % 256;
    let b = color % 256;
    return "rgb(" + r + "," + g + "," + b + ")";
  }
  static getRgbaString(color) {
    let r = (color / 65536 | 0) % 256;
    let g = (color / 256 | 0) % 256;
    let b = color % 256;
    let a = (color / 16777216 | 0) / 255;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(4) + ")";
  }
  static getRgbaStringFromArray(color) {
    let r = Math.floor(color[0] * 255);
    let g = Math.floor(color[1] * 255);
    let b = Math.floor(color[2] * 255);
    let a = Math.floor(color[3] * 255) / 255;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(4) + ")";
  }
  static getRgbaComponentsNormalized(argb) {
    let r = (argb / 65536 | 0) % 256;
    let g = (argb / 256 | 0) % 256;
    let b = argb % 256;
    let a = argb / 16777216 | 0;
    return [r / 255, g / 255, b / 255, a / 255];
  }
  static getRgbComponentsNormalized(argb) {
    let r = (argb / 65536 | 0) % 256;
    let g = (argb / 256 | 0) % 256;
    let b = argb % 256;
    return [r / 255, g / 255, b / 255];
  }
  static getRgbaComponents(argb) {
    let r = (argb / 65536 | 0) % 256;
    let g = (argb / 256 | 0) % 256;
    let b = argb % 256;
    let a = argb / 16777216 | 0;
    return [r, g, b, a];
  }
  static getArgbNumber(rgba) {
    rgba[0] = Math.max(0, Math.min(255, rgba[0]));
    rgba[1] = Math.max(0, Math.min(255, rgba[1]));
    rgba[2] = Math.max(0, Math.min(255, rgba[2]));
    rgba[3] = Math.max(0, Math.min(255, rgba[3]));
    let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
    if (v < 0) {
      v = 4294967295 + v + 1;
    }
    return v;
  }
  static mergeColors(c1, c2, p) {
    let r1 = (c1 / 65536 | 0) % 256;
    let g1 = (c1 / 256 | 0) % 256;
    let b1 = c1 % 256;
    let a1 = c1 / 16777216 | 0;
    let r2 = (c2 / 65536 | 0) % 256;
    let g2 = (c2 / 256 | 0) % 256;
    let b2 = c2 % 256;
    let a2 = c2 / 16777216 | 0;
    let r = r1 * p + r2 * (1 - p);
    let g = g1 * p + g2 * (1 - p);
    let b = b1 * p + b2 * (1 - p);
    let a = a1 * p + a2 * (1 - p);
    return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
  }
  static mergeMultiColors(c, p) {
    let r = 0, g = 0, b = 0, a = 0, t = 0;
    let n = c.length;
    for (let i = 0; i < n; i++) {
      let r1 = (c[i] / 65536 | 0) % 256;
      let g1 = (c[i] / 256 | 0) % 256;
      let b1 = c[i] % 256;
      let a1 = c[i] / 16777216 | 0;
      r += r1 * p[i];
      g += g1 * p[i];
      b += b1 * p[i];
      a += a1 * p[i];
      t += p[i];
    }
    t = 1 / t;
    return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
  }
  static mergeMultiColorsEqual(c) {
    let r = 0, g = 0, b = 0, a = 0, t = 0;
    let n = c.length;
    for (let i = 0; i < n; i++) {
      let r1 = (c[i] / 65536 | 0) % 256;
      let g1 = (c[i] / 256 | 0) % 256;
      let b1 = c[i] % 256;
      let a1 = c[i] / 16777216 | 0;
      r += r1;
      g += g1;
      b += b1;
      a += a1;
      t += 1;
    }
    t = 1 / t;
    return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
  }
  static mergeColorAlpha(c, alpha) {
    let a = (c / 16777216 | 0) * alpha | 0;
    return ((c >> 16 & 255) * a / 255 & 255) + ((c & 65280) * a / 255 & 65280) + (((c & 255) << 16) * a / 255 & 16711680) + (a << 24);
  }
  static rad(deg) {
    return deg * (Math.PI / 180);
  }
  static getTimingBezier(a, b, c, d) {
    let xc = 3 * a;
    let xb = 3 * (c - a) - xc;
    let xa = 1 - xc - xb;
    let yc = 3 * b;
    let yb = 3 * (d - b) - yc;
    let ya = 1 - yc - yb;
    return function(time) {
      if (time >= 1) {
        return 1;
      }
      if (time <= 0) {
        return 0;
      }
      let t = 0.5, cbx, cbxd, dx;
      for (let it = 0; it < 20; it++) {
        cbx = t * (t * (t * xa + xb) + xc);
        dx = time - cbx;
        if (dx > -1e-8 && dx < 1e-8) {
          return t * (t * (t * ya + yb) + yc);
        }
        cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
        if (cbxd > 1e-10 && cbxd < 1e-10) {
          break;
        }
        t += dx / cbxd;
      }
      let minT = 0;
      let maxT = 1;
      for (let it = 0; it < 20; it++) {
        t = 0.5 * (minT + maxT);
        cbx = t * (t * (t * xa + xb) + xc);
        dx = time - cbx;
        if (dx > -1e-8 && dx < 1e-8) {
          return t * (t * (t * ya + yb) + yc);
        }
        if (dx < 0) {
          maxT = t;
        } else {
          minT = t;
        }
      }
    };
  }
  static getTimingFunction(str) {
    switch (str) {
      case "linear":
        return function(time) {
          return time;
        };
      case "ease":
        return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1);
      case "ease-in":
        return StageUtils.getTimingBezier(0.42, 0, 1, 1);
      case "ease-out":
        return StageUtils.getTimingBezier(0, 0, 0.58, 1);
      case "ease-in-out":
        return StageUtils.getTimingBezier(0.42, 0, 0.58, 1);
      case "step-start":
        return function() {
          return 1;
        };
      case "step-end":
        return function(time) {
          return time === 1 ? 1 : 0;
        };
      default:
        let s = "cubic-bezier(";
        if (str && str.indexOf(s) === 0) {
          let parts = str.substr(s.length, str.length - s.length - 1).split(",");
          if (parts.length !== 4) {
            console.warn("[Lightning] Unknown timing function: " + str);
            return function(time) {
              return time;
            };
          }
          let a = parseFloat(parts[0]);
          let b = parseFloat(parts[1]);
          let c = parseFloat(parts[2]);
          let d = parseFloat(parts[3]);
          if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
            console.warn("[Lightning] Unknown timing function: " + str);
            return function(time) {
              return time;
            };
          }
          return StageUtils.getTimingBezier(a, b, c, d);
        } else {
          console.warn("[Lightning] Unknown timing function: " + str);
          return function(time) {
            return time;
          };
        }
    }
  }
}
let Utils$2 = class Utils {
  static isFunction(value) {
    return typeof value === "function";
  }
  static isNumber(value) {
    return typeof value === "number";
  }
  static isInteger(value) {
    return typeof value === "number" && value % 1 === 0;
  }
  static isBoolean(value) {
    return value === true || value === false;
  }
  static isString(value) {
    return typeof value === "string";
  }
  static clone(v) {
    if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
      return Utils.getDeepClone(v);
    } else {
      return v;
    }
  }
  static cloneObjShallow(obj) {
    let keys = Object.keys(obj);
    let clone = {};
    for (let i = 0; i < keys.length; i++) {
      clone[keys[i]] = obj[keys[i]];
    }
    return clone;
  }
  static merge(obj1, obj2) {
    let keys = Object.keys(obj2);
    for (let i = 0; i < keys.length; i++) {
      obj1[keys[i]] = obj2[keys[i]];
    }
    return obj1;
  }
  static isObject(value) {
    let type = typeof value;
    return !!value && (type === "object" || type === "function");
  }
  static isPlainObject(value) {
    let type = typeof value;
    return !!value && type === "object";
  }
  static isObjectLiteral(value) {
    return typeof value === "object" && value && value.constructor === Object;
  }
  static getArrayIndex(index, arr) {
    return Utils.getModuloIndex(index, arr.length);
  }
  static getModuloIndex(index, len) {
    if (len === 0)
      return index;
    while (index < 0) {
      index += Math.ceil(-index / len) * len;
    }
    index = index % len;
    return index;
  }
  static getDeepClone(obj) {
    let i, c;
    if (Utils.isFunction(obj)) {
      return obj;
    }
    if (Array.isArray(obj)) {
      c = [];
      let keys = Object.keys(obj);
      for (i = 0; i < keys.length; i++) {
        c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
      }
      return c;
    } else if (Utils.isObject(obj)) {
      c = {};
      let keys = Object.keys(obj);
      for (i = 0; i < keys.length; i++) {
        c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
      }
      return c;
    } else {
      return obj;
    }
  }
  static equalValues(v1, v2) {
    if (typeof v1 !== typeof v2)
      return false;
    if (Utils.isObjectLiteral(v1)) {
      return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
    } else if (Array.isArray(v1)) {
      return Array.isArray(v2) && Utils.equalArrays(v1, v2);
    } else {
      return v1 === v2;
    }
  }
  static equalObjectLiterals(obj1, obj2) {
    let keys1 = Object.keys(obj1);
    let keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (let i = 0, n = keys1.length; i < n; i++) {
      const k1 = keys1[i];
      const k2 = keys2[i];
      if (k1 !== k2) {
        return false;
      }
      const v1 = obj1[k1];
      const v2 = obj2[k2];
      if (!Utils.equalValues(v1, v2)) {
        return false;
      }
    }
    return true;
  }
  static equalArrays(v1, v2) {
    if (v1.length !== v2.length) {
      return false;
    }
    for (let i = 0, n = v1.length; i < n; i++) {
      if (!this.equalValues(v1[i], v2[i])) {
        return false;
      }
    }
    return true;
  }
  static setToArray(s) {
    let result = [];
    s.forEach(function(value) {
      result.push(value);
    });
    return result;
  }
  static iteratorToArray(iterator) {
    let result = [];
    let iteratorResult = iterator.next();
    while (!iteratorResult.done) {
      result.push(iteratorResult.value);
      iteratorResult = iterator.next();
    }
    return result;
  }
  static isUcChar(charcode) {
    return charcode >= 65 && charcode <= 90;
  }
};
Utils$2.isWeb = typeof window !== "undefined" && typeof sparkscene === "undefined";
Utils$2.isWPE = Utils$2.isWeb && navigator.userAgent.indexOf("WPE") !== -1;
Utils$2.isSpark = typeof sparkscene !== "undefined";
Utils$2.isNode = typeof window === "undefined" || Utils$2.isSpark;
Utils$2.isPS4 = Utils$2.isWeb && navigator.userAgent.indexOf("PlayStation 4") !== -1;
Utils$2.isZiggo = Utils$2.isWeb && (navigator.userAgent.indexOf("EOSSTB") !== -1 || navigator.userAgent.indexOf("HZNSTB") !== -1);
class Base {
  static defaultSetter(obj, name2, value) {
    obj[name2] = value;
  }
  static patchObject(obj, settings2) {
    if (!Utils$2.isObjectLiteral(settings2)) {
      console.error("[Lightning] Settings must be object literal");
    } else {
      let names = Object.keys(settings2);
      for (let i = 0, n = names.length; i < n; i++) {
        let name2 = names[i];
        this.patchObjectProperty(obj, name2, settings2[name2]);
      }
    }
  }
  static patchObjectProperty(obj, name2, value) {
    let setter = obj.setSetting || Base.defaultSetter;
    if (name2.charAt(0) === "_") {
      if (name2 !== "__create") {
        console.error("[Lightning] Patch of private property '" + name2 + "' is not allowed");
      }
    } else if (name2 !== "type") {
      if (Utils$2.isFunction(value) && value.__local) {
        value = value.__local(obj);
      }
      setter(obj, name2, value);
    }
  }
  static local(func) {
    func.__local = true;
  }
}
class SpacingCalculator {
  static getSpacing(mode, numberOfItems, remainingSpace) {
    const itemGaps = numberOfItems - 1;
    let spacePerGap;
    let spacingBefore, spacingBetween;
    switch (mode) {
      case "flex-start":
        spacingBefore = 0;
        spacingBetween = 0;
        break;
      case "flex-end":
        spacingBefore = remainingSpace;
        spacingBetween = 0;
        break;
      case "center":
        spacingBefore = remainingSpace / 2;
        spacingBetween = 0;
        break;
      case "space-between":
        spacingBefore = 0;
        spacingBetween = Math.max(0, remainingSpace) / itemGaps;
        break;
      case "space-around":
        if (remainingSpace < 0) {
          return this.getSpacing("center", numberOfItems, remainingSpace);
        } else {
          spacePerGap = remainingSpace / (itemGaps + 1);
          spacingBefore = 0.5 * spacePerGap;
          spacingBetween = spacePerGap;
        }
        break;
      case "space-evenly":
        if (remainingSpace < 0) {
          return this.getSpacing("center", numberOfItems, remainingSpace);
        } else {
          spacePerGap = remainingSpace / (itemGaps + 2);
          spacingBefore = spacePerGap;
          spacingBetween = spacePerGap;
        }
        break;
      case "stretch":
        spacingBefore = 0;
        spacingBetween = 0;
        break;
      default:
        throw new Error("Unknown mode: " + mode);
    }
    return { spacingBefore, spacingBetween };
  }
}
class ContentAligner {
  constructor(layout) {
    this._layout = layout;
    this._totalCrossAxisSize = 0;
  }
  get _lines() {
    return this._layout._lines;
  }
  init() {
    this._totalCrossAxisSize = this._getTotalCrossAxisSize();
  }
  align() {
    const crossAxisSize = this._layout.crossAxisSize;
    const remainingSpace = crossAxisSize - this._totalCrossAxisSize;
    const { spacingBefore, spacingBetween } = this._getSpacing(remainingSpace);
    const lines = this._lines;
    const mode = this._layout._flexContainer.alignContent;
    let growSize = 0;
    if (mode === "stretch" && lines.length && remainingSpace > 0) {
      growSize = remainingSpace / lines.length;
    }
    let currentPos = spacingBefore;
    for (let i = 0, n = lines.length; i < n; i++) {
      const crossAxisLayoutOffset = currentPos;
      const aligner = lines[i].createItemAligner();
      let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;
      aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
      aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);
      aligner.align();
      if (aligner.recursiveResizeOccured) {
        lines[i].setItemPositions();
      }
      currentPos += finalCrossAxisLayoutSize;
      currentPos += spacingBetween;
    }
  }
  get totalCrossAxisSize() {
    return this._totalCrossAxisSize;
  }
  _getTotalCrossAxisSize() {
    const lines = this._lines;
    let total = 0;
    for (let i = 0, n = lines.length; i < n; i++) {
      const line = lines[i];
      total += line.crossAxisLayoutSize;
    }
    return total;
  }
  _getSpacing(remainingSpace) {
    const mode = this._layout._flexContainer.alignContent;
    const numberOfItems = this._lines.length;
    return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
  }
}
class FlexUtils {
  static getParentAxisSizeWithPadding(item, horizontal) {
    const target = item.target;
    const parent = target.getParent();
    if (!parent) {
      return 0;
    } else {
      const flexParent = item.flexParent;
      if (flexParent) {
        return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
      } else {
        return horizontal ? parent.w : parent.h;
      }
    }
  }
  static getRelAxisSize(item, horizontal) {
    if (horizontal) {
      if (item.funcW) {
        if (this._allowRelAxisSizeFunction(item, true)) {
          return item.funcW(this.getParentAxisSizeWithPadding(item, true));
        } else {
          return 0;
        }
      } else {
        return item.originalWidth;
      }
    } else {
      if (item.funcH) {
        if (this._allowRelAxisSizeFunction(item, false)) {
          return item.funcH(this.getParentAxisSizeWithPadding(item, false));
        } else {
          return 0;
        }
      } else {
        return item.originalHeight;
      }
    }
  }
  static _allowRelAxisSizeFunction(item, horizontal) {
    const flexParent = item.flexParent;
    if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
      return false;
    }
    return true;
  }
  static isZeroAxisSize(item, horizontal) {
    if (horizontal) {
      return !item.originalWidth && !item.funcW;
    } else {
      return !item.originalHeight && !item.funcH;
    }
  }
  static getAxisLayoutPos(item, horizontal) {
    return horizontal ? item.x : item.y;
  }
  static getAxisLayoutSize(item, horizontal) {
    return horizontal ? item.w : item.h;
  }
  static setAxisLayoutPos(item, horizontal, pos) {
    if (horizontal) {
      item.x = pos;
    } else {
      item.y = pos;
    }
  }
  static setAxisLayoutSize(item, horizontal, size) {
    if (horizontal) {
      item.w = size;
    } else {
      item.h = size;
    }
  }
  static getAxisMinSize(item, horizontal) {
    let minSize = this.getPlainAxisMinSize(item, horizontal);
    let flexItemMinSize = 0;
    if (item.isFlexItemEnabled()) {
      flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
    }
    const hasLimitedMinSize = flexItemMinSize > 0;
    if (hasLimitedMinSize) {
      minSize = Math.max(minSize, flexItemMinSize);
    }
    return minSize;
  }
  static getPlainAxisMinSize(item, horizontal) {
    if (item.isFlexEnabled()) {
      return item._flex._layout.getAxisMinSize(horizontal);
    } else {
      const isShrinkable = item.flexItem.shrink !== 0;
      if (isShrinkable) {
        return 0;
      } else {
        return this.getRelAxisSize(item, horizontal);
      }
    }
  }
  static resizeAxis(item, horizontal, size) {
    if (item.isFlexEnabled()) {
      const isMainAxis = item._flex._horizontal === horizontal;
      if (isMainAxis) {
        item._flex._layout.resizeMainAxis(size);
      } else {
        item._flex._layout.resizeCrossAxis(size);
      }
    } else {
      this.setAxisLayoutSize(item, horizontal, size);
    }
  }
  static getPaddingOffset(item, horizontal) {
    if (item.isFlexEnabled()) {
      const flex = item._flex;
      if (horizontal) {
        return flex.paddingLeft;
      } else {
        return flex.paddingTop;
      }
    } else {
      return 0;
    }
  }
  static getTotalPadding(item, horizontal) {
    if (item.isFlexEnabled()) {
      const flex = item._flex;
      if (horizontal) {
        return flex.paddingRight + flex.paddingLeft;
      } else {
        return flex.paddingTop + flex.paddingBottom;
      }
    } else {
      return 0;
    }
  }
  static getMarginOffset(item, horizontal) {
    const flexItem = item.flexItem;
    if (flexItem) {
      if (horizontal) {
        return flexItem.marginLeft;
      } else {
        return flexItem.marginTop;
      }
    } else {
      return 0;
    }
  }
  static getTotalMargin(item, horizontal) {
    const flexItem = item.flexItem;
    if (flexItem) {
      if (horizontal) {
        return flexItem.marginRight + flexItem.marginLeft;
      } else {
        return flexItem.marginTop + flexItem.marginBottom;
      }
    } else {
      return 0;
    }
  }
}
class SizeShrinker {
  constructor(line) {
    this._line = line;
    this._amountRemaining = 0;
    this._shrunkSize = 0;
  }
  shrink(amount) {
    this._shrunkSize = 0;
    this._amountRemaining = amount;
    let totalShrinkAmount = this._getTotalShrinkAmount();
    if (totalShrinkAmount) {
      const items = this._line.items;
      do {
        let amountPerShrink = this._amountRemaining / totalShrinkAmount;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
          const item = items[i];
          const flexItem = item.flexItem;
          const shrinkAmount = flexItem.shrink;
          const isShrinkableItem = shrinkAmount > 0;
          if (isShrinkableItem) {
            let shrink = shrinkAmount * amountPerShrink;
            const minSize = flexItem._getMainAxisMinSize();
            const size = flexItem._getMainAxisLayoutSize();
            if (size > minSize) {
              const maxShrink = size - minSize;
              const isFullyShrunk = shrink >= maxShrink;
              if (isFullyShrunk) {
                shrink = maxShrink;
                totalShrinkAmount -= shrinkAmount;
              }
              const finalSize = size - shrink;
              flexItem._resizeMainAxis(finalSize);
              this._shrunkSize += shrink;
              this._amountRemaining -= shrink;
              if (Math.abs(this._amountRemaining) < 1e-5) {
                return;
              }
            }
          }
        }
      } while (totalShrinkAmount && Math.abs(this._amountRemaining) > 1e-5);
    }
  }
  _getTotalShrinkAmount() {
    let total = 0;
    const items = this._line.items;
    for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
      const item = items[i];
      const flexItem = item.flexItem;
      if (flexItem.shrink) {
        const minSize = flexItem._getMainAxisMinSize();
        const size = flexItem._getMainAxisLayoutSize();
        if (size > minSize) {
          total += flexItem.shrink;
        }
      }
    }
    return total;
  }
  getShrunkSize() {
    return this._shrunkSize;
  }
}
class SizeGrower {
  constructor(line) {
    this._line = line;
    this._amountRemaining = 0;
    this._grownSize = 0;
  }
  grow(amount) {
    this._grownSize = 0;
    this._amountRemaining = amount;
    let totalGrowAmount = this._getTotalGrowAmount();
    if (totalGrowAmount) {
      const items = this._line.items;
      do {
        let amountPerGrow = this._amountRemaining / totalGrowAmount;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
          const item = items[i];
          const flexItem = item.flexItem;
          const growAmount = flexItem.grow;
          const isGrowableItem = growAmount > 0;
          if (isGrowableItem) {
            let grow = growAmount * amountPerGrow;
            const maxSize = flexItem._getMainAxisMaxSizeSetting();
            const size = flexItem._getMainAxisLayoutSize();
            if (maxSize > 0) {
              if (size >= maxSize) {
                grow = 0;
              } else {
                const maxGrow = maxSize - size;
                const isFullyGrown = grow >= maxGrow;
                if (isFullyGrown) {
                  grow = maxGrow;
                  totalGrowAmount -= growAmount;
                }
              }
            }
            if (grow > 0) {
              const finalSize = size + grow;
              flexItem._resizeMainAxis(finalSize);
              this._grownSize += grow;
              this._amountRemaining -= grow;
              if (Math.abs(this._amountRemaining) < 1e-5) {
                return;
              }
            }
          }
        }
      } while (totalGrowAmount && Math.abs(this._amountRemaining) > 1e-5);
    }
  }
  _getTotalGrowAmount() {
    let total = 0;
    const items = this._line.items;
    for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
      const item = items[i];
      const flexItem = item.flexItem;
      if (flexItem.grow) {
        const maxSize = flexItem._getMainAxisMaxSizeSetting();
        const size = flexItem._getMainAxisLayoutSize();
        if (maxSize === 0 || size < maxSize) {
          total += flexItem.grow;
        }
      }
    }
    return total;
  }
  getGrownSize() {
    return this._grownSize;
  }
}
class ItemPositioner {
  constructor(lineLayout) {
    this._line = lineLayout;
  }
  get _layout() {
    return this._line._layout;
  }
  position() {
    const { spacingBefore, spacingBetween } = this._getSpacing();
    let currentPos = spacingBefore;
    const items = this._line.items;
    for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
      const item = items[i];
      item.flexItem._setMainAxisLayoutPos(currentPos);
      currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
      currentPos += spacingBetween;
    }
  }
  _getSpacing() {
    const remainingSpace = this._line._availableSpace;
    let mode = this._layout._flexContainer.justifyContent;
    const numberOfItems = this._line.numberOfItems;
    return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
  }
}
class ItemAligner {
  constructor(line) {
    this._line = line;
    this._crossAxisLayoutSize = 0;
    this._crossAxisLayoutOffset = 0;
    this._alignItemsSetting = null;
    this._recursiveResizeOccured = false;
    this._isCrossAxisFitToContents = false;
  }
  get _layout() {
    return this._line._layout;
  }
  get _flexContainer() {
    return this._layout._flexContainer;
  }
  setCrossAxisLayoutSize(size) {
    this._crossAxisLayoutSize = size;
  }
  setCrossAxisLayoutOffset(offset) {
    this._crossAxisLayoutOffset = offset;
  }
  align() {
    this._alignItemsSetting = this._flexContainer.alignItems;
    this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);
    this._recursiveResizeOccured = false;
    const items = this._line.items;
    for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
      const item = items[i];
      this._alignItem(item);
    }
  }
  get recursiveResizeOccured() {
    return this._recursiveResizeOccured;
  }
  _alignItem(item) {
    const flexItem = item.flexItem;
    let align = flexItem.alignSelf || this._alignItemsSetting;
    if (align === "stretch" && this._preventStretch(flexItem)) {
      align = "flex-start";
    }
    if (align !== "stretch" && !this._isCrossAxisFitToContents) {
      if (flexItem._hasRelCrossAxisSize()) {
        flexItem._resetCrossAxisLayoutSize();
      }
    }
    switch (align) {
      case "flex-start":
        this._alignItemFlexStart(flexItem);
        break;
      case "flex-end":
        this._alignItemFlexEnd(flexItem);
        break;
      case "center":
        this._alignItemFlexCenter(flexItem);
        break;
      case "stretch":
        this._alignItemStretch(flexItem);
        break;
    }
  }
  _alignItemFlexStart(flexItem) {
    flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
  }
  _alignItemFlexEnd(flexItem) {
    const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
    flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
  }
  _alignItemFlexCenter(flexItem) {
    const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
    const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
    flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
  }
  _alignItemStretch(flexItem) {
    flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
    const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
    let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();
    const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
    if (crossAxisMinSizeSetting > 0) {
      size = Math.max(size, crossAxisMinSizeSetting);
    }
    const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
    const crossAxisMaxSizeSettingEnabled = crossAxisMaxSizeSetting > 0;
    if (crossAxisMaxSizeSettingEnabled) {
      size = Math.min(size, crossAxisMaxSizeSetting);
    }
    flexItem._resizeCrossAxis(size);
    const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();
    const recursiveResize = mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize;
    if (recursiveResize) {
      this._recursiveResizeOccured = true;
    }
  }
  _preventStretch(flexItem) {
    const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
    const forceStretch = flexItem.alignSelf === "stretch";
    return hasFixedCrossAxisSize && !forceStretch;
  }
}
class LineLayout {
  constructor(layout, startIndex, endIndex, availableSpace) {
    this._layout = layout;
    this.items = layout.items;
    this.startIndex = startIndex;
    this.endIndex = endIndex;
    this._availableSpace = availableSpace;
  }
  performLayout() {
    this._setItemSizes();
    this.setItemPositions();
    this._calcLayoutInfo();
  }
  _setItemSizes() {
    if (this._availableSpace > 0) {
      this._growItemSizes(this._availableSpace);
    } else if (this._availableSpace < 0) {
      this._shrinkItemSizes(-this._availableSpace);
    }
  }
  _growItemSizes(amount) {
    const grower = new SizeGrower(this);
    grower.grow(amount);
    this._availableSpace -= grower.getGrownSize();
  }
  _shrinkItemSizes(amount) {
    const shrinker = new SizeShrinker(this);
    shrinker.shrink(amount);
    this._availableSpace += shrinker.getShrunkSize();
  }
  setItemPositions() {
    const positioner = new ItemPositioner(this);
    positioner.position();
  }
  createItemAligner() {
    return new ItemAligner(this);
  }
  _calcLayoutInfo() {
    this._calcCrossAxisMaxLayoutSize();
  }
  getMainAxisMinSize() {
    let mainAxisMinSize = 0;
    for (let i = this.startIndex; i <= this.endIndex; i++) {
      const item = this.items[i];
      mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
    }
    return mainAxisMinSize;
  }
  get numberOfItems() {
    return this.endIndex - this.startIndex + 1;
  }
  get crossAxisLayoutSize() {
    const noSpecifiedCrossAxisSize = this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis;
    const shouldFitToContents = this._layout.isWrapping() || noSpecifiedCrossAxisSize;
    if (shouldFitToContents) {
      return this._crossAxisMaxLayoutSize;
    } else {
      return this._layout.crossAxisSize;
    }
  }
  _calcCrossAxisMaxLayoutSize() {
    this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
  }
  _getCrossAxisMaxLayoutSize() {
    let crossAxisMaxSize = 0;
    for (let i = this.startIndex; i <= this.endIndex; i++) {
      const item = this.items[i];
      crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
    }
    return crossAxisMaxSize;
  }
}
class LineLayouter {
  constructor(layout) {
    this._layout = layout;
    this._mainAxisMinSize = -1;
    this._crossAxisMinSize = -1;
    this._mainAxisContentSize = 0;
  }
  get lines() {
    return this._lines;
  }
  get mainAxisMinSize() {
    if (this._mainAxisMinSize === -1) {
      this._mainAxisMinSize = this._getMainAxisMinSize();
    }
    return this._mainAxisMinSize;
  }
  get crossAxisMinSize() {
    if (this._crossAxisMinSize === -1) {
      this._crossAxisMinSize = this._getCrossAxisMinSize();
    }
    return this._crossAxisMinSize;
  }
  get mainAxisContentSize() {
    return this._mainAxisContentSize;
  }
  layoutLines() {
    this._setup();
    const items = this._layout.items;
    const wrap = this._layout.isWrapping();
    let startIndex = 0;
    let i;
    const n = items.length;
    for (i = 0; i < n; i++) {
      const item = items[i];
      this._layoutFlexItem(item);
      const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
      if (wrap && i > startIndex) {
        const isOverflowing = this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize;
        if (isOverflowing) {
          this._layoutLine(startIndex, i - 1);
          this._curMainAxisPos = 0;
          startIndex = i;
        }
      }
      this._addToMainAxisPos(itemMainAxisSize);
    }
    if (startIndex < i) {
      this._layoutLine(startIndex, i - 1);
    }
  }
  _layoutFlexItem(item) {
    if (item.isFlexEnabled()) {
      item.flexLayout.updateTreeLayout();
    } else {
      item.flexItem._resetLayoutSize();
    }
  }
  _setup() {
    this._mainAxisSize = this._layout.mainAxisSize;
    this._curMainAxisPos = 0;
    this._maxMainAxisPos = 0;
    this._lines = [];
    this._mainAxisMinSize = -1;
    this._crossAxisMinSize = -1;
    this._mainAxisContentSize = 0;
  }
  _addToMainAxisPos(itemMainAxisSize) {
    this._curMainAxisPos += itemMainAxisSize;
    if (this._curMainAxisPos > this._maxMainAxisPos) {
      this._maxMainAxisPos = this._curMainAxisPos;
    }
  }
  _layoutLine(startIndex, endIndex) {
    const availableSpace = this._getAvailableMainAxisLayoutSpace();
    const line = new LineLayout(this._layout, startIndex, endIndex, availableSpace);
    line.performLayout();
    this._lines.push(line);
    if (this._mainAxisContentSize === 0 || this._curMainAxisPos > this._mainAxisContentSize) {
      this._mainAxisContentSize = this._curMainAxisPos;
    }
  }
  _getAvailableMainAxisLayoutSpace() {
    if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
      return 0;
    } else {
      return this._mainAxisSize - this._curMainAxisPos;
    }
  }
  _getCrossAxisMinSize() {
    let crossAxisMinSize = 0;
    const items = this._layout.items;
    for (let i = 0, n = items.length; i < n; i++) {
      const item = items[i];
      const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
      crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
    }
    return crossAxisMinSize;
  }
  _getMainAxisMinSize() {
    if (this._lines.length === 1) {
      return this._lines[0].getMainAxisMinSize();
    } else {
      return this._layout.mainAxisSize;
    }
  }
}
class ItemCoordinatesUpdater {
  constructor(layout) {
    this._layout = layout;
    this._isReverse = this._flexContainer._reverse;
    this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
    this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
  }
  get _flexContainer() {
    return this._layout._flexContainer;
  }
  finalize() {
    const parentFlex = this._layout.getParentFlexContainer();
    if (parentFlex) {
      const updater = new ItemCoordinatesUpdater(parentFlex._layout);
      updater._finalizeItemAndChildren(this._flexContainer.item);
    } else {
      this._finalizeRoot();
      this._finalizeItems();
    }
  }
  _finalizeRoot() {
    const item = this._flexContainer.item;
    let x = FlexUtils.getAxisLayoutPos(item, true);
    let y = FlexUtils.getAxisLayoutPos(item, false);
    let w = FlexUtils.getAxisLayoutSize(item, true);
    let h = FlexUtils.getAxisLayoutSize(item, false);
    w += this._layout._getHorizontalPadding();
    h += this._layout._getVerticalPadding();
    item.clearRecalcFlag();
    item.setLayout(x, y, w, h);
  }
  _finalizeItems() {
    const items = this._layout.items;
    for (let i = 0, n = items.length; i < n; i++) {
      const item = items[i];
      const validCache = this._validateItemCache(item);
      this._finalizeItem(item);
      if (!validCache) {
        this._finalizeItemChildren(item);
      }
    }
  }
  _validateItemCache(item) {
    if (item.recalc === 0) {
      if (item.isFlexEnabled()) {
        const layout = item._flex._layout;
        const dimensionsMatchPreviousResult = item.w === item.target.w && item.h === item.target.h;
        if (dimensionsMatchPreviousResult) {
          return true;
        } else {
          const crossAxisSize = layout.crossAxisSize;
          layout.performResizeMainAxis(layout.mainAxisSize);
          layout.performResizeCrossAxis(crossAxisSize);
        }
      }
    }
    return false;
  }
  _finalizeItemAndChildren(item) {
    this._finalizeItem(item);
    this._finalizeItemChildren(item);
  }
  _finalizeItem(item) {
    if (this._isReverse) {
      this._reverseMainAxisLayoutPos(item);
    }
    let x = FlexUtils.getAxisLayoutPos(item, true);
    let y = FlexUtils.getAxisLayoutPos(item, false);
    let w = FlexUtils.getAxisLayoutSize(item, true);
    let h = FlexUtils.getAxisLayoutSize(item, false);
    x += this._horizontalPaddingOffset;
    y += this._verticalPaddingOffset;
    const flex = item.flex;
    if (flex) {
      w += item._flex._layout._getHorizontalPadding();
      h += item._flex._layout._getVerticalPadding();
    }
    const flexItem = item.flexItem;
    if (flexItem) {
      x += flexItem._getHorizontalMarginOffset();
      y += flexItem._getVerticalMarginOffset();
    }
    item.clearRecalcFlag();
    item.setLayout(x, y, w, h);
  }
  _finalizeItemChildren(item) {
    const flex = item._flex;
    if (flex) {
      const updater = new ItemCoordinatesUpdater(flex._layout);
      updater._finalizeItems();
    }
  }
  _reverseMainAxisLayoutPos(item) {
    const endPos = item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
    const reversedPos = this._layout.mainAxisSize - endPos;
    item.flexItem._setMainAxisLayoutPos(reversedPos);
  }
}
class FlexLayout {
  constructor(flexContainer) {
    this._flexContainer = flexContainer;
    this._lineLayouter = new LineLayouter(this);
    this._resizingMainAxis = false;
    this._resizingCrossAxis = false;
    this._cachedMainAxisSizeAfterLayout = 0;
    this._cachedCrossAxisSizeAfterLayout = 0;
    this._shrunk = false;
  }
  get shrunk() {
    return this._shrunk;
  }
  get recalc() {
    return this.item.recalc;
  }
  layoutTree() {
    const isSubTree = this.item.flexParent !== null;
    if (isSubTree) {
      this._updateSubTreeLayout();
    } else {
      this.updateTreeLayout();
    }
    this.updateItemCoords();
  }
  updateTreeLayout() {
    if (this.recalc) {
      this._performUpdateLayoutTree();
    } else {
      this._performUpdateLayoutTreeFromCache();
    }
  }
  _performUpdateLayoutTree() {
    this._setInitialAxisSizes();
    this._layoutAxes();
    this._refreshLayoutCache();
  }
  _refreshLayoutCache() {
    this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
    this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
  }
  _performUpdateLayoutTreeFromCache() {
    const sizeMightHaveChanged = this.item.funcW || this.item.funcH;
    if (sizeMightHaveChanged) {
      this.item.enableLocalRecalcFlag();
      this._performUpdateLayoutTree();
    } else {
      this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
      this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
    }
  }
  updateItemCoords() {
    const updater = new ItemCoordinatesUpdater(this);
    updater.finalize();
  }
  _updateSubTreeLayout() {
    const crossAxisSize = this.crossAxisSize;
    this._layoutMainAxis();
    this.performResizeCrossAxis(crossAxisSize);
  }
  _setInitialAxisSizes() {
    if (this.item.isFlexItemEnabled()) {
      this.item.flexItem._resetLayoutSize();
    } else {
      this.mainAxisSize = this._getMainAxisBasis();
      this.crossAxisSize = this._getCrossAxisBasis();
    }
    this._resizingMainAxis = false;
    this._resizingCrossAxis = false;
    this._shrunk = false;
  }
  _layoutAxes() {
    this._layoutMainAxis();
    this._layoutCrossAxis();
  }
  /**
   * @pre mainAxisSize should exclude padding.
   */
  _layoutMainAxis() {
    this._layoutLines();
    this._fitMainAxisSizeToContents();
  }
  _layoutLines() {
    this._lineLayouter.layoutLines();
  }
  get _lines() {
    return this._lineLayouter.lines;
  }
  _fitMainAxisSizeToContents() {
    if (!this._resizingMainAxis) {
      if (this.isMainAxisFitToContents()) {
        this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
      }
    }
  }
  /**
   * @pre crossAxisSize should exclude padding.
   */
  _layoutCrossAxis() {
    const aligner = new ContentAligner(this);
    aligner.init();
    this._totalCrossAxisSize = aligner.totalCrossAxisSize;
    this._fitCrossAxisSizeToContents();
    aligner.align();
  }
  _fitCrossAxisSizeToContents() {
    if (!this._resizingCrossAxis) {
      if (this.isCrossAxisFitToContents()) {
        this.crossAxisSize = this._totalCrossAxisSize;
      }
    }
  }
  isWrapping() {
    return this._flexContainer.wrap;
  }
  isAxisFitToContents(horizontal) {
    if (this._horizontal === horizontal) {
      return this.isMainAxisFitToContents();
    } else {
      return this.isCrossAxisFitToContents();
    }
  }
  isMainAxisFitToContents() {
    return !this.isWrapping() && !this._hasFixedMainAxisBasis();
  }
  isCrossAxisFitToContents() {
    return !this._hasFixedCrossAxisBasis();
  }
  _hasFixedMainAxisBasis() {
    return !FlexUtils.isZeroAxisSize(this.item, this._horizontal);
  }
  _hasFixedCrossAxisBasis() {
    return !FlexUtils.isZeroAxisSize(this.item, !this._horizontal);
  }
  getAxisMinSize(horizontal) {
    if (this._horizontal === horizontal) {
      return this._getMainAxisMinSize();
    } else {
      return this._getCrossAxisMinSize();
    }
  }
  _getMainAxisMinSize() {
    return this._lineLayouter.mainAxisMinSize;
  }
  _getCrossAxisMinSize() {
    return this._lineLayouter.crossAxisMinSize;
  }
  resizeMainAxis(size) {
    if (this.mainAxisSize !== size) {
      if (this.recalc > 0) {
        this.performResizeMainAxis(size);
      } else {
        if (this._checkValidCacheMainAxisResize()) {
          this.mainAxisSize = size;
          this._fitCrossAxisSizeToContents();
        } else {
          this.item.enableLocalRecalcFlag();
          this.performResizeMainAxis(size);
        }
      }
    }
  }
  _checkValidCacheMainAxisResize(size) {
    const isFinalMainAxisSize = size === this.targetMainAxisSize;
    if (isFinalMainAxisSize) {
      return true;
    }
    const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
    if (canIgnoreCacheMiss) {
      return true;
    }
    return false;
  }
  performResizeMainAxis(size) {
    const isShrinking = size < this.mainAxisSize;
    this._shrunk = isShrinking;
    this.mainAxisSize = size;
    this._resizingMainAxis = true;
    this._layoutAxes();
    this._resizingMainAxis = false;
  }
  resizeCrossAxis(size) {
    if (this.crossAxisSize !== size) {
      if (this.recalc > 0) {
        this.performResizeCrossAxis(size);
      } else {
        this.crossAxisSize = size;
      }
    }
  }
  performResizeCrossAxis(size) {
    this.crossAxisSize = size;
    this._resizingCrossAxis = true;
    this._layoutCrossAxis();
    this._resizingCrossAxis = false;
  }
  get targetMainAxisSize() {
    return this._horizontal ? this.item.target.w : this.item.target.h;
  }
  get targetCrossAxisSize() {
    return this._horizontal ? this.item.target.h : this.item.target.w;
  }
  getParentFlexContainer() {
    return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
  }
  _getHorizontalPadding() {
    return FlexUtils.getTotalPadding(this.item, true);
  }
  _getVerticalPadding() {
    return FlexUtils.getTotalPadding(this.item, false);
  }
  _getHorizontalPaddingOffset() {
    return FlexUtils.getPaddingOffset(this.item, true);
  }
  _getVerticalPaddingOffset() {
    return FlexUtils.getPaddingOffset(this.item, false);
  }
  _getMainAxisBasis() {
    return FlexUtils.getRelAxisSize(this.item, this._horizontal);
  }
  _getCrossAxisBasis() {
    return FlexUtils.getRelAxisSize(this.item, !this._horizontal);
  }
  get _horizontal() {
    return this._flexContainer._horizontal;
  }
  get _reverse() {
    return this._flexContainer._reverse;
  }
  get item() {
    return this._flexContainer.item;
  }
  get items() {
    return this.item.items;
  }
  get resizingMainAxis() {
    return this._resizingMainAxis;
  }
  get resizingCrossAxis() {
    return this._resizingCrossAxis;
  }
  get numberOfItems() {
    return this.items.length;
  }
  get mainAxisSize() {
    return FlexUtils.getAxisLayoutSize(this.item, this._horizontal);
  }
  get crossAxisSize() {
    return FlexUtils.getAxisLayoutSize(this.item, !this._horizontal);
  }
  set mainAxisSize(v) {
    FlexUtils.setAxisLayoutSize(this.item, this._horizontal, v);
  }
  set crossAxisSize(v) {
    FlexUtils.setAxisLayoutSize(this.item, !this._horizontal, v);
  }
}
class FlexContainer {
  constructor(item) {
    this._item = item;
    this._layout = new FlexLayout(this);
    this._horizontal = true;
    this._reverse = false;
    this._wrap = false;
    this._alignItems = "stretch";
    this._justifyContent = "flex-start";
    this._alignContent = "flex-start";
    this._paddingLeft = 0;
    this._paddingTop = 0;
    this._paddingRight = 0;
    this._paddingBottom = 0;
  }
  get item() {
    return this._item;
  }
  _changedDimensions() {
    this._item.changedDimensions();
  }
  _changedContents() {
    this._item.changedContents();
  }
  get direction() {
    return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
  }
  set direction(f) {
    if (this.direction === f)
      return;
    this._horizontal = f === "row" || f === "row-reverse";
    this._reverse = f === "row-reverse" || f === "column-reverse";
    this._changedContents();
  }
  set wrap(v) {
    this._wrap = v;
    this._changedContents();
  }
  get wrap() {
    return this._wrap;
  }
  get alignItems() {
    return this._alignItems;
  }
  set alignItems(v) {
    if (this._alignItems === v)
      return;
    if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
      throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
    }
    this._alignItems = v;
    this._changedContents();
  }
  get alignContent() {
    return this._alignContent;
  }
  set alignContent(v) {
    if (this._alignContent === v)
      return;
    if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
      throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
    }
    this._alignContent = v;
    this._changedContents();
  }
  get justifyContent() {
    return this._justifyContent;
  }
  set justifyContent(v) {
    if (this._justifyContent === v)
      return;
    if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
      throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
    }
    this._justifyContent = v;
    this._changedContents();
  }
  set padding(v) {
    this.paddingLeft = v;
    this.paddingTop = v;
    this.paddingRight = v;
    this.paddingBottom = v;
  }
  get padding() {
    return this.paddingLeft;
  }
  set paddingLeft(v) {
    this._paddingLeft = v;
    this._changedDimensions();
  }
  get paddingLeft() {
    return this._paddingLeft;
  }
  set paddingTop(v) {
    this._paddingTop = v;
    this._changedDimensions();
  }
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingRight(v) {
    this._paddingRight = v;
    this._changedDimensions();
  }
  get paddingRight() {
    return this._paddingRight;
  }
  set paddingBottom(v) {
    this._paddingBottom = v;
    this._changedDimensions();
  }
  get paddingBottom() {
    return this._paddingBottom;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
}
FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];
class FlexItem {
  constructor(item) {
    this._ctr = null;
    this._item = item;
    this._grow = 0;
    this._shrink = FlexItem.SHRINK_AUTO;
    this._alignSelf = void 0;
    this._minWidth = 0;
    this._minHeight = 0;
    this._maxWidth = 0;
    this._maxHeight = 0;
    this._marginLeft = 0;
    this._marginTop = 0;
    this._marginRight = 0;
    this._marginBottom = 0;
  }
  get item() {
    return this._item;
  }
  get grow() {
    return this._grow;
  }
  set grow(v) {
    if (this._grow === v)
      return;
    this._grow = parseInt(v) || 0;
    this._changed();
  }
  get shrink() {
    if (this._shrink === FlexItem.SHRINK_AUTO) {
      return this._getDefaultShrink();
    }
    return this._shrink;
  }
  _getDefaultShrink() {
    if (this.item.isFlexEnabled()) {
      return 1;
    } else {
      return 0;
    }
  }
  set shrink(v) {
    if (this._shrink === v)
      return;
    this._shrink = parseInt(v) || 0;
    this._changed();
  }
  get alignSelf() {
    return this._alignSelf;
  }
  set alignSelf(v) {
    if (this._alignSelf === v)
      return;
    if (v === void 0) {
      this._alignSelf = void 0;
    } else {
      if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
        throw new Error("Unknown alignSelf, options: " + FlexContainer.ALIGN_ITEMS.join(","));
      }
      this._alignSelf = v;
    }
    this._changed();
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v) {
    this._minWidth = Math.max(0, v);
    this._item.changedDimensions(true, false);
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v) {
    this._minHeight = Math.max(0, v);
    this._item.changedDimensions(false, true);
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v) {
    this._maxWidth = Math.max(0, v);
    this._item.changedDimensions(true, false);
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v) {
    this._maxHeight = Math.max(0, v);
    this._item.changedDimensions(false, true);
  }
  /**
   * @note margins behave slightly different than in HTML with regard to shrinking.
   * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
   */
  set margin(v) {
    this.marginLeft = v;
    this.marginTop = v;
    this.marginRight = v;
    this.marginBottom = v;
  }
  get margin() {
    return this.marginLeft;
  }
  set marginLeft(v) {
    this._marginLeft = v;
    this._changed();
  }
  get marginLeft() {
    return this._marginLeft;
  }
  set marginTop(v) {
    this._marginTop = v;
    this._changed();
  }
  get marginTop() {
    return this._marginTop;
  }
  set marginRight(v) {
    this._marginRight = v;
    this._changed();
  }
  get marginRight() {
    return this._marginRight;
  }
  set marginBottom(v) {
    this._marginBottom = v;
    this._changed();
  }
  get marginBottom() {
    return this._marginBottom;
  }
  _changed() {
    if (this.ctr)
      this.ctr._changedContents();
  }
  set ctr(v) {
    this._ctr = v;
  }
  get ctr() {
    return this._ctr;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
  _resetLayoutSize() {
    this._resetHorizontalAxisLayoutSize();
    this._resetVerticalAxisLayoutSize();
  }
  _resetCrossAxisLayoutSize() {
    if (this.ctr._horizontal) {
      this._resetVerticalAxisLayoutSize();
    } else {
      this._resetHorizontalAxisLayoutSize();
    }
  }
  _resetHorizontalAxisLayoutSize() {
    let w = FlexUtils.getRelAxisSize(this.item, true);
    if (this._minWidth) {
      w = Math.max(this._minWidth, w);
    }
    if (this._maxWidth) {
      w = Math.min(this._maxWidth, w);
    }
    FlexUtils.setAxisLayoutSize(this.item, true, w);
  }
  _resetVerticalAxisLayoutSize() {
    let h = FlexUtils.getRelAxisSize(this.item, false);
    if (this._minHeight) {
      h = Math.max(this._minHeight, h);
    }
    if (this._maxHeight) {
      h = Math.min(this._maxHeight, h);
    }
    FlexUtils.setAxisLayoutSize(this.item, false, h);
  }
  _getCrossAxisMinSizeSetting() {
    return this._getMinSizeSetting(!this.ctr._horizontal);
  }
  _getCrossAxisMaxSizeSetting() {
    return this._getMaxSizeSetting(!this.ctr._horizontal);
  }
  _getMainAxisMaxSizeSetting() {
    return this._getMaxSizeSetting(this.ctr._horizontal);
  }
  _getMinSizeSetting(horizontal) {
    if (horizontal) {
      return this._minWidth;
    } else {
      return this._minHeight;
    }
  }
  _getMaxSizeSetting(horizontal) {
    if (horizontal) {
      return this._maxWidth;
    } else {
      return this._maxHeight;
    }
  }
  _getMainAxisMinSize() {
    return FlexUtils.getAxisMinSize(this.item, this.ctr._horizontal);
  }
  _getCrossAxisMinSize() {
    return FlexUtils.getAxisMinSize(this.item, !this.ctr._horizontal);
  }
  _getMainAxisLayoutSize() {
    return FlexUtils.getAxisLayoutSize(this.item, this.ctr._horizontal);
  }
  _getMainAxisLayoutPos() {
    return FlexUtils.getAxisLayoutPos(this.item, this.ctr._horizontal);
  }
  _setMainAxisLayoutPos(pos) {
    return FlexUtils.setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
  }
  _setCrossAxisLayoutPos(pos) {
    return FlexUtils.setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
  }
  _getCrossAxisLayoutSize() {
    return FlexUtils.getAxisLayoutSize(this.item, !this.ctr._horizontal);
  }
  _resizeCrossAxis(size) {
    return FlexUtils.resizeAxis(this.item, !this.ctr._horizontal, size);
  }
  _resizeMainAxis(size) {
    return FlexUtils.resizeAxis(this.item, this.ctr._horizontal, size);
  }
  _getMainAxisPadding() {
    return FlexUtils.getTotalPadding(this.item, this.ctr._horizontal);
  }
  _getCrossAxisPadding() {
    return FlexUtils.getTotalPadding(this.item, !this.ctr._horizontal);
  }
  _getMainAxisMargin() {
    return FlexUtils.getTotalMargin(this.item, this.ctr._horizontal);
  }
  _getCrossAxisMargin() {
    return FlexUtils.getTotalMargin(this.item, !this.ctr._horizontal);
  }
  _getHorizontalMarginOffset() {
    return FlexUtils.getMarginOffset(this.item, true);
  }
  _getVerticalMarginOffset() {
    return FlexUtils.getMarginOffset(this.item, false);
  }
  _getMainAxisMinSizeWithPaddingAndMargin() {
    return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
  }
  _getCrossAxisMinSizeWithPaddingAndMargin() {
    return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
  }
  _getMainAxisLayoutSizeWithPaddingAndMargin() {
    return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
  }
  _getCrossAxisLayoutSizeWithPaddingAndMargin() {
    return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
  }
  _hasFixedCrossAxisSize() {
    return !FlexUtils.isZeroAxisSize(this.item, !this.ctr._horizontal);
  }
  _hasRelCrossAxisSize() {
    return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
  }
}
FlexItem.SHRINK_AUTO = -1;
class FlexTarget {
  constructor(target) {
    this._target = target;
    this._recalc = 0;
    this._enabled = false;
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this._originalX = 0;
    this._originalY = 0;
    this._originalWidth = 0;
    this._originalHeight = 0;
    this._flex = null;
    this._flexItem = null;
    this._flexItemDisabled = false;
    this._items = null;
  }
  get flexLayout() {
    return this.flex ? this.flex._layout : null;
  }
  layoutFlexTree() {
    if (this.isFlexEnabled() && this.isChanged()) {
      this.flexLayout.layoutTree();
    }
  }
  get target() {
    return this._target;
  }
  get flex() {
    return this._flex;
  }
  set flex(v) {
    if (!v) {
      if (this.isFlexEnabled()) {
        this._disableFlex();
      }
    } else {
      if (!this.isFlexEnabled()) {
        this._enableFlex();
      }
      this._flex.patch(v);
    }
  }
  get flexItem() {
    if (this._flexItemDisabled) {
      return false;
    }
    this._ensureFlexItem();
    return this._flexItem;
  }
  set flexItem(v) {
    if (v === false) {
      if (!this._flexItemDisabled) {
        const parent = this.flexParent;
        this._flexItemDisabled = true;
        this._checkEnabled();
        if (parent) {
          parent._clearFlexItemsCache();
          parent.changedContents();
        }
      }
    } else {
      this._ensureFlexItem();
      this._flexItem.patch(v);
      if (this._flexItemDisabled) {
        this._flexItemDisabled = false;
        this._checkEnabled();
        const parent = this.flexParent;
        if (parent) {
          parent._clearFlexItemsCache();
          parent.changedContents();
        }
      }
    }
  }
  _enableFlex() {
    this._flex = new FlexContainer(this);
    this._checkEnabled();
    this.changedDimensions();
    this._enableChildrenAsFlexItems();
  }
  _disableFlex() {
    this.changedDimensions();
    this._flex = null;
    this._checkEnabled();
    this._disableChildrenAsFlexItems();
  }
  _enableChildrenAsFlexItems() {
    const children = this._target._children;
    if (children) {
      for (let i = 0, n = children.length; i < n; i++) {
        const child = children[i];
        child.layout._enableFlexItem();
      }
    }
  }
  _disableChildrenAsFlexItems() {
    const children = this._target._children;
    if (children) {
      for (let i = 0, n = children.length; i < n; i++) {
        const child = children[i];
        child.layout._disableFlexItem();
      }
    }
  }
  _enableFlexItem() {
    this._ensureFlexItem();
    const flexParent = this._target._parent._layout;
    this._flexItem.ctr = flexParent._flex;
    flexParent.changedContents();
    this._checkEnabled();
  }
  _disableFlexItem() {
    if (this._flexItem) {
      this._flexItem.ctr = null;
    }
    this._checkEnabled();
    this._resetOffsets();
  }
  _resetOffsets() {
    this.x = 0;
    this.y = 0;
  }
  _ensureFlexItem() {
    if (!this._flexItem) {
      this._flexItem = new FlexItem(this);
    }
  }
  _checkEnabled() {
    const enabled = this.isEnabled();
    if (this._enabled !== enabled) {
      if (enabled) {
        this._enable();
      } else {
        this._disable();
      }
      this._enabled = enabled;
    }
  }
  _enable() {
    this._setupTargetForFlex();
    this._target.enableFlexLayout();
  }
  _disable() {
    this._restoreTargetToNonFlex();
    this._target.disableFlexLayout();
  }
  isEnabled() {
    return this.isFlexEnabled() || this.isFlexItemEnabled();
  }
  isFlexEnabled() {
    return this._flex !== null;
  }
  isFlexItemEnabled() {
    return this.flexParent !== null;
  }
  _restoreTargetToNonFlex() {
    const target = this._target;
    target.x = this._originalX;
    target.y = this._originalY;
    target.setDimensions(this._originalWidth, this._originalHeight);
  }
  _setupTargetForFlex() {
    const target = this._target;
    this._originalX = target._x;
    this._originalY = target._y;
    this._originalWidth = target._w;
    this._originalHeight = target._h;
  }
  setParent(from, to) {
    if (from && from.isFlexContainer()) {
      from._layout._changedChildren();
    }
    if (to && to.isFlexContainer()) {
      this._enableFlexItem();
      to._layout._changedChildren();
    }
    this._checkEnabled();
  }
  get flexParent() {
    if (this._flexItemDisabled) {
      return null;
    }
    const parent = this._target._parent;
    if (parent && parent.isFlexContainer()) {
      return parent._layout;
    }
    return null;
  }
  setVisible(v) {
    const parent = this.flexParent;
    if (parent) {
      parent._changedChildren();
    }
  }
  get items() {
    if (!this._items) {
      this._items = this._getFlexItems();
    }
    return this._items;
  }
  _getFlexItems() {
    const items = [];
    const children = this._target._children;
    if (children) {
      for (let i = 0, n = children.length; i < n; i++) {
        const item = children[i];
        if (item.visible) {
          if (item.isFlexItem()) {
            items.push(item.layout);
          }
        }
      }
    }
    return items;
  }
  _changedChildren() {
    this._clearFlexItemsCache();
    this.changedContents();
  }
  _clearFlexItemsCache() {
    this._items = null;
  }
  setLayout(x, y, w, h) {
    let originalX = this._originalX;
    let originalY = this._originalY;
    if (this.funcX) {
      originalX = this.funcX(FlexUtils.getParentAxisSizeWithPadding(this, true));
    }
    if (this.funcY) {
      originalY = this.funcY(FlexUtils.getParentAxisSizeWithPadding(this, false));
    }
    if (this.isFlexItemEnabled()) {
      this.target.setLayout(x + originalX, y + originalY, w, h);
    } else {
      this.target.setLayout(originalX, originalY, w, h);
    }
  }
  changedDimensions(changeWidth = true, changeHeight = true) {
    this._updateRecalc(changeWidth, changeHeight);
  }
  changedContents() {
    this._updateRecalc();
  }
  forceLayout() {
    this._updateRecalc();
  }
  isChanged() {
    return this._recalc > 0;
  }
  _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
    if (this.isFlexEnabled()) {
      const layout = this._flex._layout;
      changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
      changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
    }
    const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
    const newRecalcFlags = this.getNewRecalcFlags(recalc);
    this._recalc |= recalc;
    if (newRecalcFlags > 1) {
      if (this.flexParent) {
        this.flexParent._updateRecalcBottomUp(recalc);
      } else {
        this._target.triggerLayout();
      }
    } else {
      this._target.triggerLayout();
    }
  }
  getNewRecalcFlags(flags) {
    return 7 - this._recalc & flags;
  }
  _updateRecalcBottomUp(childRecalc) {
    const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
    const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
    this._recalc |= newRecalc;
    if (newRecalcFlags > 1) {
      const flexParent = this.flexParent;
      if (flexParent) {
        flexParent._updateRecalcBottomUp(newRecalc);
      } else {
        this._target.triggerLayout();
      }
    } else {
      this._target.triggerLayout();
    }
  }
  _getRecalcFromChangedChildRecalc(childRecalc) {
    const layout = this._flex._layout;
    const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
    const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;
    const crossAxisDimensionsChangedInChild = childRecalc & crossAxisRecalcFlag;
    if (!crossAxisDimensionsChangedInChild) {
      const mainAxisDimensionsChangedInChild = childRecalc & mainAxisRecalcFlag;
      if (mainAxisDimensionsChangedInChild) {
        const mainAxisIsWrapping = layout.isWrapping();
        if (mainAxisIsWrapping) {
          const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
          if (crossAxisIsFitToContents) {
            childRecalc += crossAxisRecalcFlag;
          }
        }
      }
    }
    let isWidthDynamic = layout.isAxisFitToContents(true);
    let isHeightDynamic = layout.isAxisFitToContents(false);
    if (layout.shrunk) {
      if (layout._horizontal) {
        isWidthDynamic = true;
      } else {
        isHeightDynamic = true;
      }
    }
    const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);
    const combinedRecalc = childRecalc & localRecalc;
    return combinedRecalc;
  }
  get recalc() {
    return this._recalc;
  }
  clearRecalcFlag() {
    this._recalc = 0;
  }
  enableLocalRecalcFlag() {
    this._recalc = 1;
  }
  get originalX() {
    return this._originalX;
  }
  setOriginalXWithoutUpdatingLayout(v) {
    this._originalX = v;
  }
  get originalY() {
    return this._originalY;
  }
  setOriginalYWithoutUpdatingLayout(v) {
    this._originalY = v;
  }
  get originalWidth() {
    return this._originalWidth;
  }
  set originalWidth(v) {
    if (this._originalWidth !== v) {
      this._originalWidth = v;
      this.changedDimensions(true, false);
    }
  }
  get originalHeight() {
    return this._originalHeight;
  }
  set originalHeight(v) {
    if (this._originalHeight !== v) {
      this._originalHeight = v;
      this.changedDimensions(false, true);
    }
  }
  get funcX() {
    return this._target.funcX;
  }
  get funcY() {
    return this._target.funcY;
  }
  get funcW() {
    return this._target.funcW;
  }
  get funcH() {
    return this._target.funcH;
  }
}
class TextureSource {
  constructor(manager, loader2 = null) {
    this.id = TextureSource.id++;
    this.manager = manager;
    this.stage = manager.stage;
    this.textures = /* @__PURE__ */ new Set();
    this._activeTextureCount = 0;
    this.loader = loader2;
    this.lookupId = null;
    this._cancelCb = null;
    this.loadingSince = 0;
    this.w = 0;
    this.h = 0;
    this._nativeTexture = null;
    this.permanent = false;
    this.renderInfo = null;
    this._isResultTexture = !this.loader;
    this._loadError = null;
    this._imageRef = null;
    this._hasAlpha = false;
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  get loadError() {
    return this._loadError;
  }
  addTexture(v) {
    if (!this.textures.has(v)) {
      this.textures.add(v);
    }
  }
  removeTexture(v) {
    this.textures.delete(v);
  }
  incActiveTextureCount() {
    this._activeTextureCount++;
    if (this._activeTextureCount === 1) {
      this.becomesUsed();
    }
  }
  decActiveTextureCount() {
    this._activeTextureCount--;
    if (this._activeTextureCount === 0) {
      this.becomesUnused();
    }
  }
  get isResultTexture() {
    return this._isResultTexture;
  }
  set isResultTexture(v) {
    this._isResultTexture = v;
  }
  forEachEnabledElement(cb) {
    this.textures.forEach((texture) => {
      texture.elements.forEach(cb);
    });
  }
  hasEnabledElements() {
    return this.textures.size > 0;
  }
  forEachActiveElement(cb) {
    this.textures.forEach((texture) => {
      texture.elements.forEach((element) => {
        if (element.active) {
          cb(element);
        }
      });
    });
  }
  getRenderWidth() {
    return this.w;
  }
  getRenderHeight() {
    return this.h;
  }
  allowCleanup() {
    return !this.permanent && !this.isUsed();
  }
  becomesUsed() {
    this.load();
  }
  becomesUnused() {
    this.cancel();
  }
  cancel() {
    if (this.isLoading()) {
      if (this._cancelCb) {
        this._cancelCb(this);
        this._cancelCb = null;
      }
      this.loadingSince = 0;
    }
  }
  isLoaded() {
    return !!this._nativeTexture;
  }
  isLoading() {
    return this.loadingSince > 0;
  }
  isError() {
    return !!this._loadError;
  }
  reload() {
    this.free();
    if (this.isUsed()) {
      this.load();
    }
  }
  load(forceSync = false) {
    if (this.isResultTexture) {
      return;
    }
    if (!this._nativeTexture && !this.isLoading()) {
      this.loadingSince = (/* @__PURE__ */ new Date()).getTime();
      this._cancelCb = this.loader((err, options) => {
        if (this.isLoading()) {
          this._cancelCb = null;
          if (this.manager.stage.destroyed) {
            return;
          }
          if (err) {
            this.onError(err);
          } else if (options && options.source) {
            if (!this.stage.isUpdatingFrame() && !forceSync && options.throttle !== false) {
              const textureThrottler = this.stage.textureThrottler;
              this._cancelCb = textureThrottler.genericCancelCb;
              textureThrottler.add(this, options);
            } else {
              this.processLoadedSource(options);
            }
          }
        }
      }, this);
    }
  }
  processLoadedSource(options) {
    this.loadingSince = 0;
    this.setSource(options);
  }
  setSource(options) {
    const source = options.source;
    this._hasAlpha = options ? options.hasAlpha || false : false;
    this.w = source.width || options && options.w || 0;
    this.h = source.height || options && options.h || 0;
    if (options && options.renderInfo) {
      this.renderInfo = options.renderInfo;
    }
    this.permanent = !!options.permanent;
    if (options && options.imageRef)
      this._imageRef = options.imageRef;
    if (options && options.flipTextureY) {
      this._flipTextureY = options.flipTextureY;
    } else {
      this._flipTextureY = false;
    }
    if (this._isNativeTexture(source)) {
      this._nativeTexture = source;
      this.w = this.w || source.w;
      this.h = this.h || source.h;
      this.permanent = options.hasOwnProperty("permanent") ? options.permanent : true;
    } else {
      this.manager.uploadTextureSource(this, options);
    }
    this._loadError = null;
    this.onLoad();
  }
  isUsed() {
    return this._activeTextureCount > 0;
  }
  onLoad() {
    if (this.isUsed()) {
      this.textures.forEach((texture) => {
        texture.onLoad();
      });
    }
  }
  forceRenderUpdate() {
    if (this._nativeTexture) {
      this._nativeTexture.update = this.stage.frameCounter;
    }
    this.forEachActiveElement(function(element) {
      element.forceRenderUpdate();
    });
  }
  forceUpdateRenderCoords() {
    this.forEachActiveElement(function(element) {
      element._updateTextureCoords();
    });
  }
  get nativeTexture() {
    return this._nativeTexture;
  }
  clearNativeTexture() {
    this._nativeTexture = null;
    this._imageRef = null;
  }
  /**
   * Used for result textures.
   */
  replaceNativeTexture(newNativeTexture, w, h) {
    let prevNativeTexture = this._nativeTexture;
    this._nativeTexture = newNativeTexture;
    this.w = w;
    this.h = h;
    if (!prevNativeTexture && this._nativeTexture) {
      this.forEachActiveElement((element) => element.onTextureSourceLoaded());
    }
    if (!this._nativeTexture) {
      this.forEachActiveElement((element) => element._setDisplayedTexture(null));
    }
    this.forEachEnabledElement((element) => element._updateDimensions());
  }
  onError(e) {
    this._loadError = e;
    this.loadingSince = 0;
    console.error("[Lightning] texture load error", e, this.lookupId);
    this.forEachActiveElement((element) => element.onTextureSourceLoadError(e));
  }
  free() {
    if (this.isLoaded()) {
      this.manager.freeTextureSource(this);
    }
  }
  _isNativeTexture(source) {
    if (Utils$2.isNode) {
      return source.constructor.name === "WebGLTexture";
    }
    if ("WebGLTexture" in window) {
      return source instanceof WebGLTexture;
    }
    return false;
  }
}
TextureSource.prototype.isTextureSource = true;
TextureSource.id = 1;
class ElementTexturizer {
  constructor(elementCore) {
    this._element = elementCore.element;
    this._core = elementCore;
    this.ctx = this._core.ctx;
    this._enabled = false;
    this.lazy = false;
    this._colorize = false;
    this._renderTexture = null;
    this._renderTextureReused = false;
    this._resultTextureSource = null;
    this._renderOffscreen = false;
    this.empty = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    this._enabled = v;
    this._core.updateRenderToTextureEnabled();
  }
  get renderOffscreen() {
    return this._renderOffscreen;
  }
  set renderOffscreen(v) {
    this._renderOffscreen = v;
    this._core.setHasRenderUpdates(1);
    this._core._setRecalc(6);
  }
  get colorize() {
    return this._colorize;
  }
  set colorize(v) {
    if (this._colorize !== v) {
      this._colorize = v;
      this._core.setHasRenderUpdates(1);
    }
  }
  _getTextureSource() {
    if (!this._resultTextureSource) {
      this._resultTextureSource = new TextureSource(this._element.stage.textureManager);
      this.updateResultTexture();
    }
    return this._resultTextureSource;
  }
  hasResultTexture() {
    return !!this._resultTextureSource;
  }
  resultTextureInUse() {
    return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
  }
  updateResultTexture() {
    let resultTexture = this.getResultTexture();
    if (this._resultTextureSource) {
      if (this._resultTextureSource.nativeTexture !== resultTexture) {
        let w = resultTexture ? resultTexture.w : 0;
        let h = resultTexture ? resultTexture.h : 0;
        this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
      }
      this._resultTextureSource.forEachEnabledElement((element) => {
        element._updateDimensions();
        element.core.setHasRenderUpdates(3);
      });
    }
  }
  mustRenderToTexture() {
    if (this._enabled && !this.lazy) {
      return true;
    } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
      return true;
    }
    return false;
  }
  deactivate() {
    this.release();
  }
  get renderTextureReused() {
    return this._renderTextureReused;
  }
  release() {
    this.releaseRenderTexture();
  }
  releaseRenderTexture() {
    if (this._renderTexture) {
      if (!this._renderTextureReused) {
        this.ctx.releaseRenderTexture(this._renderTexture);
      }
      this._renderTexture = null;
      this._renderTextureReused = false;
      this.updateResultTexture();
    }
  }
  // Reuses the specified texture as the render texture (in ancestor).
  reuseTextureAsRenderTexture(nativeTexture) {
    if (this._renderTexture !== nativeTexture) {
      this.releaseRenderTexture();
      this._renderTexture = nativeTexture;
      this._renderTextureReused = true;
    }
  }
  hasRenderTexture() {
    return !!this._renderTexture;
  }
  getRenderTexture() {
    if (!this._renderTexture) {
      this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
      this._renderTextureReused = false;
    }
    return this._renderTexture;
  }
  getResultTexture() {
    return this._renderTexture;
  }
}
class ElementCore {
  constructor(element) {
    this._element = element;
    this.ctx = element.stage.ctx;
    this._recalc = 0;
    this._parent = null;
    this._onUpdate = null;
    this._pRecalc = 0;
    this._worldContext = new ElementCoreContext();
    this._hasUpdates = false;
    this._localAlpha = 1;
    this._onAfterCalcs = null;
    this._onAfterUpdate = null;
    this._localPx = 0;
    this._localPy = 0;
    this._localTa = 1;
    this._localTb = 0;
    this._localTc = 0;
    this._localTd = 1;
    this._isComplex = false;
    this._dimsUnknown = false;
    this._clipping = false;
    this._zSort = false;
    this._outOfBounds = 0;
    this._displayedTextureSource = null;
    this._zContextUsage = 0;
    this._children = null;
    this._hasRenderUpdates = 0;
    this._zIndexedChildren = null;
    this._renderContext = this._worldContext;
    this.renderState = this.ctx.renderState;
    this._scissor = null;
    this._shaderOwner = null;
    this._updateTreeOrder = 0;
    this._colorUl = this._colorUr = this._colorBl = this._colorBr = 4294967295;
    this._x = 0;
    this._y = 0;
    this._w = 0;
    this._h = 0;
    this._optFlags = 0;
    this._funcX = null;
    this._funcY = null;
    this._funcW = null;
    this._funcH = null;
    this._scaleX = 1;
    this._scaleY = 1;
    this._pivotX = 0.5;
    this._pivotY = 0.5;
    this._mountX = 0;
    this._mountY = 0;
    this._rotation = 0;
    this._alpha = 1;
    this._visible = true;
    this._ulx = 0;
    this._uly = 0;
    this._brx = 1;
    this._bry = 1;
    this._zIndex = 0;
    this._forceZIndexContext = false;
    this._zParent = null;
    this._isRoot = false;
    this._zIndexResort = false;
    this._shader = null;
    this._renderToTextureEnabled = false;
    this._texturizer = null;
    this._useRenderToTexture = false;
    this._boundsMargin = null;
    this._recBoundsMargin = null;
    this._withinBoundsMargin = false;
    this._viewport = null;
    this._clipbox = true;
    this.render = this._renderSimple;
    this._layout = null;
  }
  get offsetX() {
    if (this._funcX) {
      return this._funcX;
    } else {
      if (this.hasFlexLayout()) {
        return this._layout.originalX;
      } else {
        return this._x;
      }
    }
  }
  set offsetX(v) {
    if (Utils$2.isFunction(v)) {
      this.funcX = v;
    } else {
      this._disableFuncX();
      if (this.hasFlexLayout()) {
        this.x += v - this._layout.originalX;
        this._layout.setOriginalXWithoutUpdatingLayout(v);
      } else {
        this.x = v;
      }
    }
  }
  get x() {
    return this._x;
  }
  set x(v) {
    if (v !== this._x) {
      this._updateLocalTranslateDelta(v - this._x, 0);
      this._x = v;
    }
  }
  get funcX() {
    return this._optFlags & 1 ? this._funcX : null;
  }
  set funcX(v) {
    if (this._funcX !== v) {
      this._optFlags |= 1;
      this._funcX = v;
      if (this.hasFlexLayout()) {
        this._layout.setOriginalXWithoutUpdatingLayout(0);
        this.layout.forceLayout();
      } else {
        this._x = 0;
        this._triggerRecalcTranslate();
      }
    }
  }
  _disableFuncX() {
    this._optFlags = this._optFlags & 65535 - 1;
    this._funcX = null;
  }
  get offsetY() {
    if (this._funcY) {
      return this._funcY;
    } else {
      if (this.hasFlexLayout()) {
        return this._layout.originalY;
      } else {
        return this._y;
      }
    }
  }
  set offsetY(v) {
    if (Utils$2.isFunction(v)) {
      this.funcY = v;
    } else {
      this._disableFuncY();
      if (this.hasFlexLayout()) {
        this.y += v - this._layout.originalY;
        this._layout.setOriginalYWithoutUpdatingLayout(v);
      } else {
        this.y = v;
      }
    }
  }
  get y() {
    return this._y;
  }
  set y(v) {
    if (v !== this._y) {
      this._updateLocalTranslateDelta(0, v - this._y);
      this._y = v;
    }
  }
  get funcY() {
    return this._optFlags & 2 ? this._funcY : null;
  }
  set funcY(v) {
    if (this._funcY !== v) {
      this._optFlags |= 2;
      this._funcY = v;
      if (this.hasFlexLayout()) {
        this._layout.setOriginalYWithoutUpdatingLayout(0);
        this.layout.forceLayout();
      } else {
        this._y = 0;
        this._triggerRecalcTranslate();
      }
    }
  }
  _disableFuncY() {
    this._optFlags = this._optFlags & 65535 - 2;
    this._funcY = null;
  }
  get funcW() {
    return this._optFlags & 4 ? this._funcW : null;
  }
  set funcW(v) {
    if (this._funcW !== v) {
      this._optFlags |= 4;
      this._funcW = v;
      if (this.hasFlexLayout()) {
        this._layout._originalWidth = 0;
        this.layout.changedDimensions(true, false);
      } else {
        this._w = 0;
        this._triggerRecalcTranslate();
      }
    }
  }
  disableFuncW() {
    this._optFlags = this._optFlags & 65535 - 4;
    this._funcW = null;
  }
  get funcH() {
    return this._optFlags & 8 ? this._funcH : null;
  }
  set funcH(v) {
    if (this._funcH !== v) {
      this._optFlags |= 8;
      this._funcH = v;
      if (this.hasFlexLayout()) {
        this._layout._originalHeight = 0;
        this.layout.changedDimensions(false, true);
      } else {
        this._h = 0;
        this._triggerRecalcTranslate();
      }
    }
  }
  disableFuncH() {
    this._optFlags = this._optFlags & 65535 - 8;
    this._funcH = null;
  }
  get w() {
    return this._w;
  }
  getRenderWidth() {
    if (this.hasFlexLayout()) {
      return this._layout.originalWidth;
    } else {
      return this._w;
    }
  }
  get h() {
    return this._h;
  }
  getRenderHeight() {
    if (this.hasFlexLayout()) {
      return this._layout.originalHeight;
    } else {
      return this._h;
    }
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(v) {
    if (this._scaleX !== v) {
      this._scaleX = v;
      this._updateLocalTransform();
    }
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(v) {
    if (this._scaleY !== v) {
      this._scaleY = v;
      this._updateLocalTransform();
    }
  }
  get scale() {
    return this.scaleX;
  }
  set scale(v) {
    if (this._scaleX !== v || this._scaleY !== v) {
      this._scaleX = v;
      this._scaleY = v;
      this._updateLocalTransform();
    }
  }
  get pivotX() {
    return this._pivotX;
  }
  set pivotX(v) {
    if (this._pivotX !== v) {
      this._pivotX = v;
      this._updateLocalTranslate();
    }
  }
  get pivotY() {
    return this._pivotY;
  }
  set pivotY(v) {
    if (this._pivotY !== v) {
      this._pivotY = v;
      this._updateLocalTranslate();
    }
  }
  get pivot() {
    return this._pivotX;
  }
  set pivot(v) {
    if (this._pivotX !== v || this._pivotY !== v) {
      this._pivotX = v;
      this._pivotY = v;
      this._updateLocalTranslate();
    }
  }
  get mountX() {
    return this._mountX;
  }
  set mountX(v) {
    if (this._mountX !== v) {
      this._mountX = v;
      this._updateLocalTranslate();
    }
  }
  get mountY() {
    return this._mountY;
  }
  set mountY(v) {
    if (this._mountY !== v) {
      this._mountY = v;
      this._updateLocalTranslate();
    }
  }
  get mount() {
    return this._mountX;
  }
  set mount(v) {
    if (this._mountX !== v || this._mountY !== v) {
      this._mountX = v;
      this._mountY = v;
      this._updateLocalTranslate();
    }
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(v) {
    if (this._rotation !== v) {
      this._rotation = v;
      this._updateLocalTransform();
    }
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(v) {
    v = v > 1 ? 1 : v < 1e-14 ? 0 : v;
    if (this._alpha !== v) {
      let prev = this._alpha;
      this._alpha = v;
      this._updateLocalAlpha();
      if (prev === 0 !== (v === 0)) {
        this._element._updateEnabledFlag();
      }
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    if (this._visible !== v) {
      this._visible = v;
      this._updateLocalAlpha();
      this._element._updateEnabledFlag();
      if (this.hasFlexLayout()) {
        this.layout.setVisible(v);
      }
    }
  }
  _updateLocalTransform() {
    if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
      let _sr = Math.sin(this._rotation);
      let _cr = Math.cos(this._rotation);
      this._setLocalTransform(
        _cr * this._scaleX,
        -_sr * this._scaleY,
        _sr * this._scaleX,
        _cr * this._scaleY
      );
    } else {
      this._setLocalTransform(
        this._scaleX,
        0,
        0,
        this._scaleY
      );
    }
    this._updateLocalTranslate();
  }
  _updateLocalTranslate() {
    this._recalcLocalTranslate();
    this._triggerRecalcTranslate();
  }
  _recalcLocalTranslate() {
    let pivotXMul = this._pivotX * this._w;
    let pivotYMul = this._pivotY * this._h;
    let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
    let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
    px -= this._mountX * this._w;
    py -= this._mountY * this._h;
    this._localPx = px;
    this._localPy = py;
  }
  _updateLocalTranslateDelta(dx, dy) {
    this._addLocalTranslate(dx, dy);
  }
  _updateLocalAlpha() {
    this._setLocalAlpha(this._visible ? this._alpha : 0);
  }
  /**
   * @param {number} type
   * 0: no updates
   * 1: re-invoke shader
   * 3: re-create render texture and re-invoke shader
   */
  setHasRenderUpdates(type) {
    if (this._worldContext.alpha) {
      let p = this;
      p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
      while ((p = p._parent) && p._hasRenderUpdates !== 3) {
        p._hasRenderUpdates = 3;
      }
    }
  }
  /**
   * @param {Number} type
   *   1: alpha
   *   2: translate
   *   4: transform
   * 128: becomes visible
   * 256: flex layout updated
   */
  _setRecalc(type) {
    this._recalc |= type;
    this._setHasUpdates();
    if (this._parent) {
      this._parent.setHasRenderUpdates(3);
    }
  }
  _setHasUpdates() {
    let p = this;
    while (p && !p._hasUpdates) {
      p._hasUpdates = true;
      p = p._parent;
    }
  }
  getParent() {
    return this._parent;
  }
  setParent(parent) {
    if (parent !== this._parent) {
      let prevIsZContext = this.isZContext();
      let prevParent = this._parent;
      this._parent = parent;
      if (this._layout || parent && parent.isFlexContainer()) {
        this.layout.setParent(prevParent, parent);
      }
      if (prevParent) {
        prevParent.setHasRenderUpdates(3);
      }
      this._setRecalc(1 + 2 + 4);
      if (this._parent) {
        this._parent._setHasUpdates();
      }
      if (this._zIndex === 0) {
        this.setZParent(parent);
      } else {
        this.setZParent(parent ? parent.findZContext() : null);
      }
      if (prevIsZContext !== this.isZContext()) {
        if (!this.isZContext()) {
          this.disableZContext();
        } else {
          this.enableZContext(prevParent.findZContext());
        }
      }
      this._zIndexResort = true;
      if (this._zParent) {
        this._zParent.enableZSort();
      }
      if (!this._shader) {
        let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
        if (newShaderOwner !== this._shaderOwner) {
          this.setHasRenderUpdates(1);
          this._setShaderOwnerRecursive(newShaderOwner);
        }
      }
    }
  }
  enableZSort(force = false) {
    if (!this._zSort && this._zContextUsage > 0) {
      this._zSort = true;
      if (force) {
        this.ctx.forceZSort(this);
      }
    }
  }
  addChildAt(index, child) {
    if (!this._children)
      this._children = [];
    this._children.splice(index, 0, child);
    child.setParent(this);
  }
  setChildAt(index, child) {
    if (!this._children)
      this._children = [];
    this._children[index].setParent(null);
    this._children[index] = child;
    child.setParent(this);
  }
  removeChildAt(index) {
    let child = this._children[index];
    this._children.splice(index, 1);
    child.setParent(null);
  }
  removeChildren() {
    if (this._children) {
      for (let i = 0, n = this._children.length; i < n; i++) {
        this._children[i].setParent(null);
      }
      this._children.splice(0);
      if (this._zIndexedChildren) {
        this._zIndexedChildren.splice(0);
      }
    }
  }
  syncChildren(removed, added, order) {
    this._children = order;
    for (let i = 0, n = removed.length; i < n; i++) {
      removed[i].setParent(null);
    }
    for (let i = 0, n = added.length; i < n; i++) {
      added[i].setParent(this);
    }
  }
  moveChild(fromIndex, toIndex) {
    let c = this._children[fromIndex];
    this._children.splice(fromIndex, 1);
    this._children.splice(toIndex, 0, c);
    this._zIndexResort = true;
    if (this._zParent) {
      this._zParent.enableZSort();
    }
  }
  _setLocalTransform(a, b, c, d) {
    this._setRecalc(4);
    this._localTa = a;
    this._localTb = b;
    this._localTc = c;
    this._localTd = d;
    this._isComplex = b !== 0 || c !== 0 || a < 0 || d < 0;
  }
  _addLocalTranslate(dx, dy) {
    this._localPx += dx;
    this._localPy += dy;
    this._triggerRecalcTranslate();
  }
  _setLocalAlpha(a) {
    if (!this._worldContext.alpha && (this._parent && this._parent._worldContext.alpha && a)) {
      this._setRecalc(1 + 128);
    } else {
      this._setRecalc(1);
    }
    if (a < 1e-14) {
      a = 0;
    }
    this._localAlpha = a;
  }
  setDimensions(w, h, isEstimate = this._dimsUnknown) {
    this._dimsUnknown = isEstimate;
    if (this.hasFlexLayout()) {
      this._layout.originalWidth = w;
      this._layout.originalHeight = h;
    } else {
      if (this._w !== w || this._h !== h) {
        this._updateDimensions(w, h);
        return true;
      }
    }
    return false;
  }
  _updateDimensions(w, h) {
    if (this._w !== w || this._h !== h) {
      this._w = w;
      this._h = h;
      this._triggerRecalcTranslate();
      if (this._texturizer) {
        this._texturizer.releaseRenderTexture();
        this._texturizer.updateResultTexture();
      }
      this._updateLocalTranslate();
    }
  }
  setTextureCoords(ulx, uly, brx, bry) {
    this.setHasRenderUpdates(3);
    this._ulx = ulx;
    this._uly = uly;
    this._brx = brx;
    this._bry = bry;
  }
  get displayedTextureSource() {
    return this._displayedTextureSource;
  }
  setDisplayedTextureSource(textureSource) {
    this.setHasRenderUpdates(3);
    this._displayedTextureSource = textureSource;
  }
  get isRoot() {
    return this._isRoot;
  }
  setAsRoot() {
    this._parent = new ElementCore(this._element);
    this._parent._hasRenderUpdates = 3;
    this._parent._hasUpdates = true;
    this._isRoot = true;
    this.ctx.root = this;
    this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
    this._parent._scissor = this._parent._viewport;
    this._parent._recBoundsMargin = null;
    this._setRecalc(1 + 2 + 4);
  }
  isAncestorOf(c) {
    let p = c;
    while (p = p._parent) {
      if (this === p) {
        return true;
      }
    }
    return false;
  }
  isZContext() {
    return this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent;
  }
  findZContext() {
    if (this.isZContext()) {
      return this;
    } else {
      return this._parent.findZContext();
    }
  }
  setZParent(newZParent) {
    if (this._zParent !== newZParent) {
      if (this._zParent !== null) {
        if (this._zIndex !== 0) {
          this._zParent.decZContextUsage();
        }
        this._zParent.enableZSort();
      }
      if (newZParent !== null) {
        let hadZContextUsage = newZParent._zContextUsage > 0;
        if (this._zIndex !== 0) {
          newZParent.incZContextUsage();
        }
        if (newZParent._zContextUsage > 0) {
          if (!hadZContextUsage && this._parent === newZParent)
            ;
          else {
            newZParent._zIndexedChildren.push(this);
          }
          newZParent.enableZSort();
        }
      }
      this._zParent = newZParent;
      this._zIndexResort = true;
    }
  }
  incZContextUsage() {
    this._zContextUsage++;
    if (this._zContextUsage === 1) {
      if (!this._zIndexedChildren) {
        this._zIndexedChildren = [];
      }
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._zIndexedChildren.push(this._children[i]);
        }
        this._zSort = false;
      }
    }
  }
  decZContextUsage() {
    this._zContextUsage--;
    if (this._zContextUsage === 0) {
      this._zSort = false;
      this._zIndexedChildren.splice(0);
    }
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(zIndex) {
    if (this._zIndex !== zIndex) {
      this.setHasRenderUpdates(1);
      let newZParent = this._zParent;
      let prevIsZContext = this.isZContext();
      if (zIndex === 0 && this._zIndex !== 0) {
        if (this._parent === this._zParent) {
          if (this._zParent) {
            this._zParent.decZContextUsage();
          }
        } else {
          newZParent = this._parent;
        }
      } else if (zIndex !== 0 && this._zIndex === 0) {
        newZParent = this._parent ? this._parent.findZContext() : null;
        if (newZParent === this._zParent) {
          if (this._zParent) {
            this._zParent.incZContextUsage();
            this._zParent.enableZSort();
          }
        }
      } else if (zIndex !== this._zIndex) {
        if (this._zParent && this._zParent._zContextUsage) {
          this._zParent.enableZSort();
        }
      }
      if (newZParent !== this._zParent) {
        this.setZParent(null);
      }
      this._zIndex = zIndex;
      if (newZParent !== this._zParent) {
        this.setZParent(newZParent);
      }
      if (prevIsZContext !== this.isZContext()) {
        if (!this.isZContext()) {
          this.disableZContext();
        } else {
          this.enableZContext(this._parent.findZContext());
        }
      }
      this._zIndexResort = true;
      if (this._zParent) {
        this._zParent.enableZSort();
      }
    }
  }
  get forceZIndexContext() {
    return this._forceZIndexContext;
  }
  set forceZIndexContext(v) {
    this.setHasRenderUpdates(1);
    let prevIsZContext = this.isZContext();
    this._forceZIndexContext = v;
    if (prevIsZContext !== this.isZContext()) {
      if (!this.isZContext()) {
        this.disableZContext();
      } else {
        this.enableZContext(this._parent.findZContext());
      }
    }
  }
  enableZContext(prevZContext) {
    if (prevZContext && prevZContext._zContextUsage > 0) {
      const results = this._getZIndexedDescs();
      results.forEach((c) => {
        if (this.isAncestorOf(c) && c._zIndex !== 0) {
          c.setZParent(this);
        }
      });
    }
  }
  _getZIndexedDescs() {
    const results = [];
    if (this._children) {
      for (let i = 0, n = this._children.length; i < n; i++) {
        this._children[i]._getZIndexedDescsRec(results);
      }
    }
    return results;
  }
  _getZIndexedDescsRec(results) {
    if (this._zIndex) {
      results.push(this);
    } else if (this._children && !this.isZContext()) {
      for (let i = 0, n = this._children.length; i < n; i++) {
        this._children[i]._getZIndexedDescsRec(results);
      }
    }
  }
  disableZContext() {
    if (this._zContextUsage > 0) {
      let newZParent = this._parent.findZContext();
      if (this._zSort) {
        this.sortZIndexedChildren();
      }
      this._zIndexedChildren.slice().forEach(function(c) {
        if (c._zIndex !== 0) {
          c.setZParent(newZParent);
        }
      });
    }
  }
  get colorUl() {
    return this._colorUl;
  }
  set colorUl(color) {
    if (this._colorUl !== color) {
      this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
      this._colorUl = color;
    }
  }
  get colorUr() {
    return this._colorUr;
  }
  set colorUr(color) {
    if (this._colorUr !== color) {
      this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
      this._colorUr = color;
    }
  }
  get colorBl() {
    return this._colorBl;
  }
  set colorBl(color) {
    if (this._colorBl !== color) {
      this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
      this._colorBl = color;
    }
  }
  get colorBr() {
    return this._colorBr;
  }
  set colorBr(color) {
    if (this._colorBr !== color) {
      this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
      this._colorBr = color;
    }
  }
  set onUpdate(f) {
    this._onUpdate = f;
    this._setRecalc(7);
  }
  set onAfterUpdate(f) {
    this._onAfterUpdate = f;
    this._setRecalc(7);
  }
  set onAfterCalcs(f) {
    this._onAfterCalcs = f;
    this._setRecalc(7);
  }
  get shader() {
    return this._shader;
  }
  set shader(v) {
    this.setHasRenderUpdates(1);
    let prevShader = this._shader;
    this._shader = v;
    if (!v && prevShader) {
      let newShaderOwner = this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null;
      this._setShaderOwnerRecursive(newShaderOwner);
    } else if (v) {
      this._setShaderOwnerRecursive(this);
    }
  }
  get activeShader() {
    return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
  }
  get activeShaderOwner() {
    return this._shaderOwner;
  }
  get clipping() {
    return this._clipping;
  }
  set clipping(v) {
    if (this._clipping !== v) {
      this._clipping = v;
      this._setRecalc(1 + 2);
    }
  }
  get clipbox() {
    return this._clipbox;
  }
  set clipbox(v) {
    this._clipbox = v;
  }
  _setShaderOwnerRecursive(elementCore) {
    this._shaderOwner = elementCore;
    if (this._children && !this._renderToTextureEnabled) {
      for (let i = 0, n = this._children.length; i < n; i++) {
        let c = this._children[i];
        if (!c._shader) {
          c._setShaderOwnerRecursive(elementCore);
          c._hasRenderUpdates = 3;
        }
      }
    }
  }
  _setShaderOwnerChildrenRecursive(elementCore) {
    if (this._children) {
      for (let i = 0, n = this._children.length; i < n; i++) {
        let c = this._children[i];
        if (!c._shader) {
          c._setShaderOwnerRecursive(elementCore);
          c._hasRenderUpdates = 3;
        }
      }
    }
  }
  _hasRenderContext() {
    return this._renderContext !== this._worldContext;
  }
  get renderContext() {
    return this._renderContext;
  }
  updateRenderToTextureEnabled() {
    let v = this.texturizer._enabled;
    if (v) {
      this._enableRenderToTexture();
    } else {
      this._disableRenderToTexture();
      this._texturizer.releaseRenderTexture();
    }
  }
  _enableRenderToTexture() {
    if (!this._renderToTextureEnabled) {
      let prevIsZContext = this.isZContext();
      this._renderToTextureEnabled = true;
      this._renderContext = new ElementCoreContext();
      this._setShaderOwnerChildrenRecursive(null);
      if (!prevIsZContext) {
        this.enableZContext(this._parent ? this._parent.findZContext() : null);
      }
      this.setHasRenderUpdates(3);
      this._setRecalc(7);
      this.render = this._renderAdvanced;
    }
  }
  _disableRenderToTexture() {
    if (this._renderToTextureEnabled) {
      this._renderToTextureEnabled = false;
      this._setShaderOwnerChildrenRecursive(this._shaderOwner);
      this._renderContext = this._worldContext;
      if (!this.isZContext()) {
        this.disableZContext();
      }
      this._setRecalc(7);
      this.setHasRenderUpdates(3);
      this.render = this._renderSimple;
    }
  }
  isWhite() {
    return this._colorUl === 4294967295 && this._colorUr === 4294967295 && this._colorBl === 4294967295 && this._colorBr === 4294967295;
  }
  hasSimpleTexCoords() {
    return this._ulx === 0 && this._uly === 0 && this._brx === 1 && this._bry === 1;
  }
  _stashTexCoords() {
    this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
    this._ulx = 0;
    this._uly = 0;
    this._brx = 1;
    this._bry = 1;
  }
  _unstashTexCoords() {
    this._ulx = this._stashedTexCoords[0];
    this._uly = this._stashedTexCoords[1];
    this._brx = this._stashedTexCoords[2];
    this._bry = this._stashedTexCoords[3];
    this._stashedTexCoords = null;
  }
  _stashColors() {
    this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
    this._colorUl = 4294967295;
    this._colorUr = 4294967295;
    this._colorBr = 4294967295;
    this._colorBl = 4294967295;
  }
  _unstashColors() {
    this._colorUl = this._stashedColors[0];
    this._colorUr = this._stashedColors[1];
    this._colorBr = this._stashedColors[2];
    this._colorBl = this._stashedColors[3];
    this._stashedColors = null;
  }
  isVisible() {
    return this._localAlpha > 1e-14;
  }
  get outOfBounds() {
    return this._outOfBounds;
  }
  set boundsMargin(v) {
    this._boundsMargin = v ? v.slice() : null;
    this._triggerRecalcTranslate();
  }
  get boundsMargin() {
    return this._boundsMargin;
  }
  update() {
    this._recalc |= this._parent._pRecalc;
    if (this._layout && this._layout.isEnabled()) {
      if (this._recalc & 256) {
        this._layout.layoutFlexTree();
      }
    } else if (this._recalc & 2 && this._optFlags) {
      this._applyRelativeDimFuncs();
    }
    if (this._onUpdate) {
      this._hasUpdates = true;
      this._onUpdate(this.element, this);
    }
    const pw = this._parent._worldContext;
    let w = this._worldContext;
    const visible = pw.alpha && this._localAlpha;
    if (this._hasUpdates || this._recalc && visible || w.alpha && !visible) {
      let recalc = this._recalc;
      if (recalc & 1) {
        if (!w.alpha && visible) {
          this._hasRenderUpdates = 3;
        }
        w.alpha = pw.alpha * this._localAlpha;
        if (w.alpha < 1e-14) {
          w.alpha = 0;
        }
      }
      if (recalc & 6) {
        w.px = pw.px + this._localPx * pw.ta;
        w.py = pw.py + this._localPy * pw.td;
        if (pw.tb !== 0)
          w.px += this._localPy * pw.tb;
        if (pw.tc !== 0)
          w.py += this._localPx * pw.tc;
      }
      if (recalc & 4) {
        w.ta = this._localTa * pw.ta;
        w.tb = this._localTd * pw.tb;
        w.tc = this._localTa * pw.tc;
        w.td = this._localTd * pw.td;
        if (this._isComplex) {
          w.ta += this._localTc * pw.tb;
          w.tb += this._localTb * pw.ta;
          w.tc += this._localTc * pw.td;
          w.td += this._localTb * pw.tc;
        }
      }
      const pr = this._parent._renderContext;
      if (this._parent._hasRenderContext()) {
        const init2 = this._renderContext === this._worldContext;
        if (init2) {
          this._renderContext = new ElementCoreContext();
        }
        const r2 = this._renderContext;
        if (init2 || recalc & 1) {
          r2.alpha = pr.alpha * this._localAlpha;
          if (r2.alpha < 1e-14) {
            r2.alpha = 0;
          }
        }
        if (init2 || recalc & 6) {
          r2.px = pr.px + this._localPx * pr.ta;
          r2.py = pr.py + this._localPy * pr.td;
          if (pr.tb !== 0)
            r2.px += this._localPy * pr.tb;
          if (pr.tc !== 0)
            r2.py += this._localPx * pr.tc;
        }
        if (init2) {
          recalc |= 2;
        }
        if (init2 || recalc & 4) {
          r2.ta = this._localTa * pr.ta;
          r2.tb = this._localTd * pr.tb;
          r2.tc = this._localTa * pr.tc;
          r2.td = this._localTd * pr.td;
          if (this._isComplex) {
            r2.ta += this._localTc * pr.tb;
            r2.tb += this._localTb * pr.ta;
            r2.tc += this._localTc * pr.td;
            r2.td += this._localTb * pr.tc;
          }
        }
      } else {
        this._renderContext = this._worldContext;
      }
      if (this.ctx.updateTreeOrder === -1) {
        this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
      } else {
        this._updateTreeOrder = this.ctx.updateTreeOrder++;
      }
      const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
      if (this._useRenderToTexture !== useRenderToTexture) {
        this._recalc |= 2 + 4;
        recalc |= 2;
        if (!this._useRenderToTexture) {
          this._texturizer.release();
        }
      }
      this._useRenderToTexture = useRenderToTexture;
      const r = this._renderContext;
      const bboxW = this._dimsUnknown ? 2048 : this._w;
      const bboxH = this._dimsUnknown ? 2048 : this._h;
      let sx, sy, ex, ey;
      const rComplex = r.tb !== 0 || r.tc !== 0 || r.ta < 0 || r.td < 0;
      if (rComplex) {
        sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
        ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
        sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
        ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
      } else {
        sx = r.px;
        ex = r.px + r.ta * bboxW;
        sy = r.py;
        ey = r.py + r.td * bboxH;
      }
      if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
        const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
        const ny = this._x * pr.tc + this._y * pr.td + pr.py;
        if (nx < sx)
          sx = nx;
        if (ny < sy)
          sy = ny;
        if (nx > ex)
          ex = nx;
        if (ny > ey)
          ey = ny;
      }
      if (recalc & 6 || !this._scissor) {
        if (this._clipping && r.isSquare()) {
          const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
          if (area) {
            const lx = Math.max(area[0], sx);
            const ly = Math.max(area[1], sy);
            this._scissor = [
              lx,
              ly,
              Math.min(area[2] + area[0], ex) - lx,
              Math.min(area[3] + area[1], ey) - ly
            ];
          } else {
            this._scissor = [sx, sy, ex - sx, ey - sy];
          }
        } else {
          this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
        }
      }
      if (this._boundsMargin) {
        this._recBoundsMargin = this._boundsMargin;
      } else {
        this._recBoundsMargin = this._parent._recBoundsMargin;
      }
      if (this._onAfterCalcs) {
        if (this._onAfterCalcs(this.element)) {
          if (rComplex) {
            sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
            ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
            sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
          } else {
            sx = r.px;
            ex = r.px + r.ta * bboxW;
            sy = r.py;
            ey = r.py + r.td * bboxH;
          }
          if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
            const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
            const ny = this._x * pr.tc + this._y * pr.td + pr.py;
            if (nx < sx)
              sx = nx;
            if (ny < sy)
              sy = ny;
            if (nx > ex)
              ex = nx;
            if (ny > ey)
              ey = ny;
          }
        }
      }
      if (this._parent._outOfBounds === 2) {
        this._outOfBounds = 2;
        if (this._withinBoundsMargin) {
          this._withinBoundsMargin = false;
          this.element._disableWithinBoundsMargin();
        }
      } else {
        if (recalc & 6) {
          this._outOfBounds = 0;
          let withinMargin = true;
          if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
            if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
              this._outOfBounds = 2;
            } else {
              if (this._scissor[0] > ex || this._scissor[1] > ey || sx > this._scissor[0] + this._scissor[2] || sy > this._scissor[1] + this._scissor[3]) {
                this._outOfBounds = 1;
              }
              if (this._outOfBounds) {
                if (this._clipping || this._useRenderToTexture || this._clipbox && (bboxW && bboxH)) {
                  this._outOfBounds = 2;
                }
              }
            }
            withinMargin = this._outOfBounds === 0;
            if (!withinMargin) {
              if (this._recBoundsMargin) {
                withinMargin = !(ex < this._scissor[0] - this._recBoundsMargin[2] || ey < this._scissor[1] - this._recBoundsMargin[3] || sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0] || sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]);
              } else {
                withinMargin = !(ex < this._scissor[0] - 100 || ey < this._scissor[1] - 100 || sx > this._scissor[0] + this._scissor[2] + 100 || sy > this._scissor[1] + this._scissor[3] + 100);
              }
              if (withinMargin && this._outOfBounds === 2) {
                this._outOfBounds = 1;
              }
            }
          }
          if (this._withinBoundsMargin !== withinMargin) {
            this._withinBoundsMargin = withinMargin;
            if (this._withinBoundsMargin) {
              this._hasUpdates = true;
              const recalc2 = this._recalc;
              this._recalc = 0;
              this.element._enableWithinBoundsMargin();
              if (this._recalc) {
                return this.update();
              }
              this._recalc = recalc2;
            } else {
              this.element._disableWithinBoundsMargin();
            }
          }
        }
      }
      if (this._useRenderToTexture) {
        if (this._viewport) {
          this._viewport[2] = bboxW;
          this._viewport[3] = bboxH;
        } else {
          this._viewport = [0, 0, bboxW, bboxH];
        }
      }
      this._pRecalc = this._recalc & 135;
      this._recalc = 0;
      this._hasUpdates = false;
      if (this._outOfBounds < 2) {
        if (this._useRenderToTexture) {
          if (this._worldContext.isIdentity()) {
            this._renderContext = this._worldContext;
          } else {
            this._renderContext = ElementCoreContext.IDENTITY;
          }
        }
        if (this._children) {
          for (let i = 0, n = this._children.length; i < n; i++) {
            this._children[i].update();
          }
        }
        if (this._useRenderToTexture) {
          this._renderContext = r;
        }
      } else {
        if (this._children) {
          for (let i = 0, n = this._children.length; i < n; i++) {
            if (this._children[i]._hasUpdates) {
              this._children[i].update();
            } else {
              this._children[i]._recalc |= this._pRecalc;
              this._children[i].updateOutOfBounds();
            }
          }
        }
      }
      if (this._onAfterUpdate) {
        this._onAfterUpdate(this.element);
      }
    } else {
      if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
        this.ctx.updateTreeOrder = -1;
      } else {
        this.updateTreeOrder();
      }
    }
  }
  _applyRelativeDimFuncs() {
    if (this._optFlags & 1) {
      const x = this._funcX(this._parent.w);
      if (x !== this._x) {
        this._localPx += x - this._x;
        this._x = x;
      }
    }
    if (this._optFlags & 2) {
      const y = this._funcY(this._parent.h);
      if (y !== this._y) {
        this._localPy += y - this._y;
        this._y = y;
      }
    }
    let changedDims = false;
    if (this._optFlags & 4) {
      const w = this._funcW(this._parent.w);
      if (w !== this._w) {
        this._w = w;
        changedDims = true;
      }
    }
    if (this._optFlags & 8) {
      const h = this._funcH(this._parent.h);
      if (h !== this._h) {
        this._h = h;
        changedDims = true;
      }
    }
    if (changedDims) {
      this._recalcLocalTranslate();
      this.element.onDimensionsChanged(this._w, this._h);
    }
  }
  updateOutOfBounds() {
    if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {
      this._outOfBounds = 2;
      if (this._withinBoundsMargin) {
        this._withinBoundsMargin = false;
        this.element._disableWithinBoundsMargin();
      }
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._children[i].updateOutOfBounds();
        }
      }
    }
  }
  updateTreeOrder() {
    if (this._localAlpha && this._outOfBounds !== 2) {
      this._updateTreeOrder = this.ctx.updateTreeOrder++;
      if (this._children) {
        for (let i = 0, n = this._children.length; i < n; i++) {
          this._children[i].updateTreeOrder();
        }
      }
    }
  }
  _renderSimple() {
    this._hasRenderUpdates = 0;
    if (this._zSort) {
      this.sortZIndexedChildren();
    }
    if (this._outOfBounds < 2 && this._renderContext.alpha) {
      let renderState = this.renderState;
      if (this._outOfBounds === 0 && this._displayedTextureSource) {
        renderState.setShader(this.activeShader, this._shaderOwner);
        renderState.setScissor(this._scissor);
        this.renderState.addQuad(this);
      }
      if (this._children) {
        if (this._zContextUsage) {
          for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
            this._zIndexedChildren[i].render();
          }
        } else {
          for (let i = 0, n = this._children.length; i < n; i++) {
            if (this._children[i]._zIndex === 0) {
              this._children[i].render();
            }
          }
        }
      }
    }
  }
  _renderAdvanced() {
    const hasRenderUpdates = this._hasRenderUpdates;
    this._hasRenderUpdates = 0;
    if (this._zSort) {
      this.sortZIndexedChildren();
    }
    if (this._outOfBounds < 2 && this._renderContext.alpha) {
      let renderState = this.renderState;
      let mustRenderChildren = true;
      let renderTextureInfo;
      let prevRenderTextureInfo;
      if (this._useRenderToTexture) {
        if (this._w === 0 || this._h === 0) {
          return;
        } else if (!this._texturizer.hasRenderTexture() || hasRenderUpdates >= 3) {
          this.ctx.renderToTextureCount++;
          renderState.setShader(renderState.defaultShader, this);
          prevRenderTextureInfo = renderState.renderTextureInfo;
          renderTextureInfo = {
            nativeTexture: null,
            offset: 0,
            // Set by CoreRenderState.
            w: this._w,
            h: this._h,
            empty: true,
            cleared: false,
            ignore: false,
            cache: false
          };
          if (this._texturizer.hasResultTexture() || !renderState.isCachingTexturizer && hasRenderUpdates < 3) {
            renderTextureInfo.cache = true;
            renderState.isCachingTexturizer = true;
          }
          if (!this._texturizer.hasResultTexture()) {
            this._texturizer.releaseRenderTexture();
          }
          renderState.setRenderTextureInfo(renderTextureInfo);
          renderState.setScissor(null);
          if (this._displayedTextureSource) {
            let r = this._renderContext;
            this._renderContext = ElementCoreContext.IDENTITY;
            this.renderState.addQuad(this);
            this._renderContext = r;
          }
        } else {
          mustRenderChildren = false;
        }
      } else {
        if (this._outOfBounds === 0 && this._displayedTextureSource) {
          renderState.setShader(this.activeShader, this._shaderOwner);
          renderState.setScissor(this._scissor);
          this.renderState.addQuad(this);
        }
      }
      if (mustRenderChildren && this._children) {
        if (this._zContextUsage) {
          for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
            this._zIndexedChildren[i].render();
          }
        } else {
          for (let i = 0, n = this._children.length; i < n; i++) {
            if (this._children[i]._zIndex === 0) {
              this._children[i].render();
            }
          }
        }
      }
      if (this._useRenderToTexture) {
        let updateResultTexture = false;
        if (mustRenderChildren) {
          renderState.finishedRenderTexture();
          this._texturizer.empty = renderTextureInfo.empty;
          if (renderTextureInfo.empty) {
            this._texturizer.releaseRenderTexture();
          } else if (renderTextureInfo.nativeTexture) {
            this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);
            renderTextureInfo.ignore = true;
          } else {
            if (this._texturizer.renderTextureReused) {
              this._texturizer.releaseRenderTexture();
            }
            renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
          }
          renderState.setRenderTextureInfo(prevRenderTextureInfo);
          updateResultTexture = true;
        }
        if (!this._texturizer.empty) {
          let resultTexture = this._texturizer.getResultTexture();
          if (updateResultTexture) {
            if (resultTexture) {
              resultTexture.update = renderState.stage.frameCounter;
            }
            this._texturizer.updateResultTexture();
          }
          if (!this._texturizer.renderOffscreen) {
            renderState.setShader(this.activeShader, this._shaderOwner);
            renderState.setScissor(this._scissor);
            const cache = !renderTextureInfo || renderTextureInfo.cache;
            renderState.setTexturizer(this._texturizer, cache);
            this._stashTexCoords();
            if (!this._texturizer.colorize)
              this._stashColors();
            this.renderState.addQuad(this, true);
            if (!this._texturizer.colorize)
              this._unstashColors();
            this._unstashTexCoords();
            renderState.setTexturizer(null);
          }
        }
      }
      if (renderTextureInfo && renderTextureInfo.cache) {
        renderState.isCachingTexturizer = false;
      }
    }
  }
  get zSort() {
    return this._zSort;
  }
  sortZIndexedChildren() {
    const n = this._zIndexedChildren.length;
    let ptr = 0;
    const a = this._zIndexedChildren;
    const b = [];
    for (let i = 0; i < n; i++) {
      if (a[i]._zParent === this) {
        if (a[i]._zIndexResort) {
          b.push(a[i]);
        } else {
          if (ptr !== i) {
            a[ptr] = a[i];
          }
          ptr++;
        }
      }
    }
    const m = b.length;
    if (m) {
      for (let j = 0; j < m; j++) {
        b[j]._zIndexResort = false;
      }
      b.sort(ElementCore.sortZIndexedChildren);
      const n2 = ptr;
      if (!n2) {
        ptr = 0;
        let j = 0;
        do {
          a[ptr++] = b[j++];
        } while (j < m);
        if (a.length > ptr) {
          a.splice(ptr);
        }
      } else {
        ptr = 0;
        let i = 0;
        let j = 0;
        const mergeResult = [];
        do {
          const v = a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex;
          const add = v > 0 ? b[j++] : a[i++];
          if (ptr === 0 || mergeResult[ptr - 1] !== add) {
            mergeResult[ptr++] = add;
          }
          if (i >= n2) {
            do {
              const add2 = b[j++];
              if (ptr === 0 || mergeResult[ptr - 1] !== add2) {
                mergeResult[ptr++] = add2;
              }
            } while (j < m);
            break;
          } else if (j >= m) {
            do {
              const add2 = a[i++];
              if (ptr === 0 || mergeResult[ptr - 1] !== add2) {
                mergeResult[ptr++] = add2;
              }
            } while (i < n2);
            break;
          }
        } while (true);
        this._zIndexedChildren = mergeResult;
      }
    } else {
      if (a.length > ptr) {
        a.splice(ptr);
      }
    }
    this._zSort = false;
  }
  get localTa() {
    return this._localTa;
  }
  get localTb() {
    return this._localTb;
  }
  get localTc() {
    return this._localTc;
  }
  get localTd() {
    return this._localTd;
  }
  get element() {
    return this._element;
  }
  get renderUpdates() {
    return this._hasRenderUpdates;
  }
  get texturizer() {
    if (!this._texturizer) {
      this._texturizer = new ElementTexturizer(this);
    }
    return this._texturizer;
  }
  getCornerPoints() {
    let w = this._worldContext;
    return [
      w.px,
      w.py,
      w.px + this._w * w.ta,
      w.py + this._w * w.tc,
      w.px + this._w * w.ta + this._h * w.tb,
      w.py + this._w * w.tc + this._h * w.td,
      w.px + this._h * w.tb,
      w.py + this._h * w.td
    ];
  }
  getRenderTextureCoords(relX, relY) {
    let r = this._renderContext;
    return [
      r.px + r.ta * relX + r.tb * relY,
      r.py + r.tc * relX + r.td * relY
    ];
  }
  getAbsoluteCoords(relX, relY) {
    let w = this._renderContext;
    return [
      w.px + w.ta * relX + w.tb * relY,
      w.py + w.tc * relX + w.td * relY
    ];
  }
  collectAtCoord(x, y, children) {
    if (this._renderContext.alpha === 0) {
      return;
    }
    if (this.inBound(x, y)) {
      if (this._scissor) {
        if (this.inScissor()) {
          children.push(this);
        }
      } else {
        children.push(this);
      }
    }
    if (this._children) {
      const j = this._children.length;
      for (let i = 0; i < j; i++) {
        this._children[i].collectAtCoord(x, y, children);
      }
    }
    return children.sort(ElementCore.sortZIndexedChildren);
  }
  inBound(tx, ty) {
    const c = this.getCornerPoints();
    return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
  }
  inScissor() {
    const sc = this._scissor;
    const c = this.getCornerPoints();
    return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
  }
  get layout() {
    this._ensureLayout();
    return this._layout;
  }
  get flex() {
    return this._layout ? this._layout.flex : null;
  }
  set flex(v) {
    this.layout.flex = v;
  }
  get flexItem() {
    return this._layout ? this._layout.flexItem : null;
  }
  set flexItem(v) {
    this.layout.flexItem = v;
  }
  isFlexItem() {
    return !!this._layout && this._layout.isFlexItemEnabled();
  }
  isFlexContainer() {
    return !!this._layout && this._layout.isFlexEnabled();
  }
  enableFlexLayout() {
    this._ensureLayout();
  }
  _ensureLayout() {
    if (!this._layout) {
      this._layout = new FlexTarget(this);
    }
  }
  disableFlexLayout() {
    this._triggerRecalcTranslate();
  }
  hasFlexLayout() {
    return this._layout && this._layout.isEnabled();
  }
  setLayout(x, y, w, h) {
    this.x = x;
    this.y = y;
    this._updateDimensions(w, h);
  }
  triggerLayout() {
    this._setRecalc(256);
  }
  _triggerRecalcTranslate() {
    this._setRecalc(2);
  }
}
class ElementCoreContext {
  constructor() {
    this.alpha = 1;
    this.px = 0;
    this.py = 0;
    this.ta = 1;
    this.tb = 0;
    this.tc = 0;
    this.td = 1;
  }
  isIdentity() {
    return this.alpha === 1 && this.px === 0 && this.py === 0 && this.ta === 1 && this.tb === 0 && this.tc === 0 && this.td === 1;
  }
  isSquare() {
    return this.tb === 0 && this.tc === 0;
  }
}
ElementCoreContext.IDENTITY = new ElementCoreContext();
ElementCore.sortZIndexedChildren = function(a, b) {
  return a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex;
};
class EventEmitter {
  constructor() {
    this._hasEventListeners = false;
  }
  on(name2, listener) {
    if (!this._hasEventListeners) {
      this._eventFunction = {};
      this._eventListeners = {};
      this._hasEventListeners = true;
    }
    const current = this._eventFunction[name2];
    if (!current) {
      this._eventFunction[name2] = listener;
    } else {
      if (this._eventFunction[name2] !== EventEmitter.combiner) {
        this._eventListeners[name2] = [this._eventFunction[name2], listener];
        this._eventFunction[name2] = EventEmitter.combiner;
      } else {
        this._eventListeners[name2].push(listener);
      }
    }
  }
  once(name2, listener) {
    const wrapper = (arg1, arg2, arg3) => {
      listener(arg1, arg2, arg3);
      this.off(name2, wrapper);
    };
    wrapper.__originalFunc = listener;
    this.on(name2, wrapper);
  }
  has(name2, listener) {
    if (this._hasEventListeners) {
      const current = this._eventFunction[name2];
      if (current) {
        if (current === EventEmitter.combiner) {
          const listeners = this._eventListeners[name2];
          for (const l of listeners) {
            if (l === listener || l.__originalFunc == listener) {
              return true;
            }
          }
        } else if (this._eventFunction[name2] === listener || this._eventFunction[name2].__originalFunc === listener) {
          return true;
        }
      }
    }
    return false;
  }
  off(name2, listener) {
    if (this._hasEventListeners) {
      const current = this._eventFunction[name2];
      if (current) {
        if (current === EventEmitter.combiner) {
          const listeners = this._eventListeners[name2];
          let index = listeners.indexOf(listener);
          if (index >= 0) {
            listeners.splice(index, 1);
          }
          index = listeners.map((l) => l.__originalFunc).indexOf(listener);
          if (index >= 0) {
            listeners.splice(index, 1);
          }
          if (listeners.length === 1) {
            this._eventFunction[name2] = listeners[0];
            this._eventListeners[name2] = void 0;
          }
        } else if (this._eventFunction[name2] === listener || this._eventFunction[name2].__originalFunc === listener) {
          this._eventFunction[name2] = void 0;
        }
      }
    }
  }
  removeListener(name2, listener) {
    this.off(name2, listener);
  }
  emit(name2, arg1, arg2, arg3) {
    if (this._hasEventListeners) {
      const func = this._eventFunction[name2];
      if (func) {
        if (func === EventEmitter.combiner) {
          func(this, name2, arg1, arg2, arg3);
        } else {
          func(arg1, arg2, arg3);
        }
      }
    }
  }
  listenerCount(name2) {
    if (this._hasEventListeners) {
      const func = this._eventFunction[name2];
      if (func) {
        if (func === EventEmitter.combiner) {
          return this._eventListeners[name2].length;
        } else {
          return 1;
        }
      }
    }
    return 0;
  }
  removeAllListeners(name2) {
    if (this._hasEventListeners) {
      delete this._eventFunction[name2];
      delete this._eventListeners[name2];
    }
  }
}
EventEmitter.combiner = function(object, name2, arg1, arg2, arg3) {
  const listeners = object._eventListeners[name2];
  if (listeners) {
    for (const listener of [...listeners]) {
      listener(arg1, arg2, arg3);
    }
  }
};
EventEmitter.addAsMixin = function(cls) {
  cls.prototype.on = EventEmitter.prototype.on;
  cls.prototype.once = EventEmitter.prototype.once;
  cls.prototype.has = EventEmitter.prototype.has;
  cls.prototype.off = EventEmitter.prototype.off;
  cls.prototype.removeListener = EventEmitter.prototype.removeListener;
  cls.prototype.emit = EventEmitter.prototype.emit;
  cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
  cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
};
class Shader {
  constructor(coreContext) {
    this._initialized = false;
    this.ctx = coreContext;
    this._elements = /* @__PURE__ */ new Set();
  }
  static create(stage2, v) {
    let shader;
    if (Utils$2.isObjectLiteral(v)) {
      if (v.type) {
        shader = stage2.renderer.createShader(stage2.ctx, v);
      } else {
        shader = this.shader;
      }
      if (shader) {
        Base.patchObject(shader, v);
      }
    } else if (v === null) {
      shader = stage2.ctx.renderState.defaultShader;
    } else if (v === void 0) {
      shader = null;
    } else {
      if (v.isShader) {
        if (!stage2.renderer.isValidShaderType(v.constructor)) {
          console.error("[Lightning] Invalid shader type");
          v = null;
        }
        shader = v;
      } else {
        console.error("[Lightning] Please specify a shader type.");
        return;
      }
    }
    return shader;
  }
  static getWebGL() {
    return void 0;
  }
  static getC2d() {
    return void 0;
  }
  addElement(elementCore) {
    this._elements.add(elementCore);
  }
  removeElement(elementCore) {
    this._elements.delete(elementCore);
    if (!this._elements) {
      this.cleanup();
    }
  }
  redraw() {
    this._elements.forEach((elementCore) => {
      elementCore.setHasRenderUpdates(2);
    });
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
  useDefault() {
    return false;
  }
  addEmpty() {
    return false;
  }
  cleanup() {
  }
  get isShader() {
    return true;
  }
}
class Texture {
  /**
   * @param {Stage} stage
   */
  constructor(stage2) {
    this.stage = stage2;
    this.manager = this.stage.textureManager;
    this.id = Texture.id++;
    this.elements = /* @__PURE__ */ new Set();
    this._activeCount = 0;
    this._source = null;
    this._resizeMode = null;
    this._x = 0;
    this._y = 0;
    this._w = 0;
    this._h = 0;
    this._precision = 1;
    this.mw = 0;
    this.mh = 0;
    this.clipping = false;
    this._mustUpdate = true;
  }
  get source() {
    if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
      this._performUpdateSource(true);
      this.stage.removeUpdateSourceTexture(this);
    }
    return this._source;
  }
  addElement(v) {
    if (!this.elements.has(v)) {
      this.elements.add(v);
      if (this.elements.size === 1) {
        if (this._source) {
          this._source.addTexture(this);
        }
      }
      if (v.active) {
        this.incActiveCount();
      }
    }
  }
  removeElement(v) {
    if (this.elements.delete(v)) {
      if (this.elements.size === 0) {
        if (this._source) {
          this._source.removeTexture(this);
        }
      }
      if (v.active) {
        this.decActiveCount();
      }
    }
  }
  incActiveCount() {
    const source = this.source;
    if (source) {
      this._checkForNewerReusableTextureSource();
    }
    this._activeCount++;
    if (this._activeCount === 1) {
      this.becomesUsed();
    }
  }
  decActiveCount() {
    this.source;
    this._activeCount--;
    if (!this._activeCount) {
      this.becomesUnused();
    }
  }
  becomesUsed() {
    if (this.source) {
      this.source.incActiveTextureCount();
    }
  }
  onLoad() {
    if (this._resizeMode) {
      this._applyResizeMode();
    }
    this.elements.forEach((element) => {
      if (element.active) {
        element.onTextureSourceLoaded();
      }
    });
  }
  _checkForNewerReusableTextureSource() {
    const source = this.source;
    if (!source.isLoaded()) {
      const reusable = this._getReusableTextureSource();
      if (reusable && reusable.isLoaded() && reusable !== source) {
        this._replaceTextureSource(reusable);
      }
    } else {
      if (this._resizeMode) {
        this._applyResizeMode();
      }
    }
  }
  becomesUnused() {
    if (this.source) {
      this.source.decActiveTextureCount();
    }
  }
  isUsed() {
    return this._activeCount > 0;
  }
  /**
   * Returns the lookup id for the current texture settings, to be able to reuse it.
   * @returns {string|null}
   */
  _getLookupId() {
    return null;
  }
  /**
   * Generates a loader function that is able to generate the texture for the current settings of this texture.
   * It should return a function that receives a single callback argument.
   * That callback should be called with the following arguments:
   *   - err
   *   - options: object
   *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
   *     - w: Number
   *     - h: Number
   *     - permanent: Boolean
   *     - hasAlpha: boolean
   *     - permultiplyAlpha: boolean
   *     - flipBlueRed: boolean
   *     - renderInfo: object
   * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
   * to stop fetching an image when it is no longer in element, for example.
   */
  _getSourceLoader() {
    throw new Error("Texture.generate must be implemented.");
  }
  get isValid() {
    return this._getIsValid();
  }
  /**
   * If texture is not 'valid', no source can be created for it.
   * @returns {boolean}
   */
  _getIsValid() {
    return true;
  }
  /**
   * This must be called when the texture source must be re-generated.
   */
  _changed() {
    if (this.isUsed()) {
      this._updateSource();
    } else {
      this._mustUpdate = true;
    }
  }
  _updateSource() {
    this.stage.addUpdateSourceTexture(this);
  }
  _performUpdateSource(force = false) {
    if (force || this.isUsed()) {
      this._mustUpdate = false;
      let source = this._getTextureSource();
      this._replaceTextureSource(source);
    }
  }
  _getTextureSource() {
    let source = null;
    if (this._getIsValid()) {
      const lookupId = this._getLookupId();
      source = this._getReusableTextureSource(lookupId);
      if (!source) {
        source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
      }
    }
    return source;
  }
  _getReusableTextureSource(lookupId = this._getLookupId()) {
    if (this._getIsValid()) {
      if (lookupId) {
        return this.manager.getReusableTextureSource(lookupId);
      }
    }
    return null;
  }
  _replaceTextureSource(newSource = null) {
    let oldSource = this._source;
    this._source = newSource;
    if (this.elements.size) {
      if (oldSource) {
        if (this._activeCount) {
          oldSource.decActiveTextureCount();
        }
        oldSource.removeTexture(this);
        if (this["text"] && !oldSource.isUsed()) {
          this.manager.freeTextureSource(oldSource);
        }
      }
      if (newSource) {
        newSource.addTexture(this);
        if (this._activeCount) {
          newSource.incActiveTextureCount();
        }
      }
    }
    if (this.isUsed()) {
      if (newSource) {
        if (newSource.isLoaded()) {
          if (this._resizeMode) {
            this._applyResizeMode();
          }
          this.elements.forEach((element) => {
            if (element.active) {
              element._setDisplayedTexture(this);
            }
          });
        } else {
          const loadError = newSource.loadError;
          if (loadError) {
            this.elements.forEach((element) => {
              if (element.active) {
                element.onTextureSourceLoadError(loadError);
              }
            });
          }
        }
      } else {
        this.elements.forEach((element) => {
          if (element.active) {
            element._setDisplayedTexture(null);
          }
        });
      }
    }
  }
  load() {
    if (this.source) {
      if (!this.isLoaded()) {
        this.source.load(true);
      }
    }
  }
  isLoaded() {
    return this._source && this._source.isLoaded();
  }
  get loadError() {
    return this._source && this._source.loadError;
  }
  free() {
    if (this._source) {
      this._source.free();
    }
  }
  set resizeMode({ type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5 }) {
    this._resizeMode = { type, w, h, clipX, clipY };
    if (this.isLoaded()) {
      this._applyResizeMode();
    }
  }
  get resizeMode() {
    return this._resizeMode;
  }
  _clearResizeMode() {
    this._resizeMode = null;
  }
  _applyResizeMode() {
    if (this._resizeMode.type === "cover") {
      this._applyResizeCover();
    } else if (this._resizeMode.type === "contain") {
      this._applyResizeContain();
    }
    this._updatePrecision();
    this._updateClipping();
  }
  _applyResizeCover() {
    const scaleX = this._resizeMode.w / this._source.w;
    const scaleY = this._resizeMode.h / this._source.h;
    let scale = Math.max(scaleX, scaleY);
    if (!scale)
      return;
    this._precision = 1 / scale;
    if (scaleX && scaleX < scale) {
      const desiredSize = this._precision * this._resizeMode.w;
      const choppedOffPixels = this._source.w - desiredSize;
      this._x = choppedOffPixels * this._resizeMode.clipX;
      this._w = this._source.w - choppedOffPixels;
    }
    if (scaleY && scaleY < scale) {
      const desiredSize = this._precision * this._resizeMode.h;
      const choppedOffPixels = this._source.h - desiredSize;
      this._y = choppedOffPixels * this._resizeMode.clipY;
      this._h = this._source.h - choppedOffPixels;
    }
  }
  _applyResizeContain() {
    const scaleX = this._resizeMode.w / this._source.w;
    const scaleY = this._resizeMode.h / this._source.h;
    let scale = scaleX;
    if (!scale || scaleY < scale) {
      scale = scaleY;
    }
    if (!scale)
      return;
    this._precision = 1 / scale;
  }
  enableClipping(x, y, w, h) {
    this._clearResizeMode();
    x *= this._precision;
    y *= this._precision;
    w *= this._precision;
    h *= this._precision;
    if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
      this._x = x;
      this._y = y;
      this._w = w;
      this._h = h;
      this._updateClipping(true);
    }
  }
  disableClipping() {
    this._clearResizeMode();
    if (this._x || this._y || this._w || this._h) {
      this._x = 0;
      this._y = 0;
      this._w = 0;
      this._h = 0;
      this._updateClipping();
    }
  }
  _updateClipping() {
    this.clipping = !!(this._x || this._y || this._w || this._h);
    let self2 = this;
    this.elements.forEach(function(element) {
      if (element.displayedTexture === self2) {
        element.onDisplayedTextureClippingChanged();
      }
    });
  }
  _updatePrecision() {
    let self2 = this;
    this.elements.forEach(function(element) {
      if (element.displayedTexture === self2) {
        element.onPrecisionChanged();
      }
    });
  }
  getNonDefaults() {
    let nonDefaults = {};
    nonDefaults["type"] = this.constructor.name;
    if (this.x !== 0)
      nonDefaults["x"] = this.x;
    if (this.y !== 0)
      nonDefaults["y"] = this.y;
    if (this.w !== 0)
      nonDefaults["w"] = this.w;
    if (this.h !== 0)
      nonDefaults["h"] = this.h;
    if (this.precision !== 1)
      nonDefaults["precision"] = this.precision;
    return nonDefaults;
  }
  get px() {
    return this._x;
  }
  get py() {
    return this._y;
  }
  get pw() {
    return this._w;
  }
  get ph() {
    return this._h;
  }
  get x() {
    return this._x / this._precision;
  }
  set x(v) {
    this._clearResizeMode();
    v = v * this._precision;
    if (this._x !== v) {
      this._x = v;
      this._updateClipping();
    }
  }
  get y() {
    return this._y / this._precision;
  }
  set y(v) {
    this._clearResizeMode();
    v = v * this._precision;
    if (this._y !== v) {
      this._y = v;
      this._updateClipping();
    }
  }
  get w() {
    return this._w / this._precision;
  }
  set w(v) {
    this._clearResizeMode();
    v = v * this._precision;
    if (this._w !== v) {
      this._w = v;
      this._updateClipping();
    }
  }
  get h() {
    return this._h / this._precision;
  }
  set h(v) {
    this._clearResizeMode();
    v = v * this._precision;
    if (this._h !== v) {
      this._h = v;
      this._updateClipping();
    }
  }
  get precision() {
    return this._precision;
  }
  set precision(v) {
    this._clearResizeMode();
    if (this._precision !== v) {
      this._precision = v;
      this._updatePrecision();
    }
  }
  isAutosizeTexture() {
    return true;
  }
  getRenderWidth() {
    if (!this.isAutosizeTexture()) {
      return 0;
    }
    return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
  }
  getRenderHeight() {
    if (!this.isAutosizeTexture()) {
      return 0;
    }
    return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
}
Texture.prototype.isTexture = true;
Texture.id = 0;
class ImageTexture extends Texture {
  constructor(stage2) {
    super(stage2);
    this._src = void 0;
    this._hasAlpha = false;
  }
  get src() {
    return this._src;
  }
  set src(v) {
    if (this._src !== v) {
      this._src = v;
      this._changed();
    }
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  set hasAlpha(v) {
    if (this._hasAlpha !== v) {
      this._hasAlpha = v;
      this._changed();
    }
  }
  _getIsValid() {
    return !!this._src;
  }
  _getLookupId() {
    return this._src;
  }
  _getSourceLoader() {
    let src = this._src;
    let hasAlpha = this._hasAlpha;
    if (this.stage.getOption("srcBasePath")) {
      var fc = src.charCodeAt(0);
      if (src.indexOf("//") === -1 && (fc >= 65 && fc <= 90 || fc >= 97 && fc <= 122 || fc == 46)) {
        src = this.stage.getOption("srcBasePath") + src;
      }
    }
    return (cb) => {
      return this.stage.platform.loadSrcTexture({ src, hasAlpha }, cb);
    };
  }
  getNonDefaults() {
    const obj = super.getNonDefaults();
    if (this._src) {
      obj.src = this._src;
    }
    return obj;
  }
}
function getFontSetting(fontFace, fontStyle, fontSize, precision2, defaultFontFace) {
  let ff = fontFace;
  if (!Array.isArray(ff)) {
    ff = [ff];
  }
  let ffs = [];
  for (let i = 0, n = ff.length; i < n; i++) {
    let curFf = ff[i];
    if (curFf === null) {
      curFf = defaultFontFace;
    }
    if (curFf === "serif" || curFf === "sans-serif") {
      ffs.push(curFf);
    } else {
      ffs.push(`"${curFf}"`);
    }
  }
  return `${fontStyle} ${fontSize * precision2}px ${ffs.join(",")}`;
}
class TextTextureRenderer {
  constructor(stage2, canvas2, settings2) {
    this._stage = stage2;
    this._canvas = canvas2;
    this._context = this._canvas.getContext("2d");
    this._settings = settings2;
  }
  getPrecision() {
    return this._settings.precision;
  }
  setFontProperties() {
    this._context.font = getFontSetting(
      this._settings.fontFace,
      this._settings.fontStyle,
      this._settings.fontSize,
      this.getPrecision(),
      this._stage.getOption("defaultFontFace")
    );
    this._context.textBaseline = this._settings.textBaseline;
  }
  _load() {
    if (Utils$2.isWeb && document.fonts) {
      const fontSetting = getFontSetting(
        this._settings.fontFace,
        this._settings.fontStyle,
        this._settings.fontSize,
        this.getPrecision(),
        this._stage.getOption("defaultFontFace")
      );
      try {
        if (!document.fonts.check(fontSetting, this._settings.text)) {
          return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
            console.warn("[Lightning] Font load error", err, fontSetting);
          }).then(() => {
            if (!document.fonts.check(fontSetting, this._settings.text)) {
              console.warn("[Lightning] Font not found", fontSetting);
            }
          });
        }
      } catch (e) {
        console.warn("[Lightning] Can't check font loading for " + fontSetting);
      }
    }
  }
  draw() {
    const loadPromise = this._load();
    if (!loadPromise) {
      return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
    } else {
      return loadPromise.then(() => {
        return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
      });
    }
  }
  _calculateRenderInfo() {
    let renderInfo = {};
    const precision2 = this.getPrecision();
    const paddingLeft = this._settings.paddingLeft * precision2;
    const paddingRight = this._settings.paddingRight * precision2;
    const fontSize = this._settings.fontSize * precision2;
    let offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision2;
    let lineHeight = this._settings.lineHeight * precision2;
    const w = this._settings.w * precision2;
    const h = this._settings.h * precision2;
    let wordWrapWidth = this._settings.wordWrapWidth * precision2;
    const cutSx = this._settings.cutSx * precision2;
    const cutEx = this._settings.cutEx * precision2;
    const cutSy = this._settings.cutSy * precision2;
    const cutEy = this._settings.cutEy * precision2;
    const letterSpacing = (this._settings.letterSpacing || 0) * precision2;
    const textIndent = this._settings.textIndent * precision2;
    this.setFontProperties();
    let width = w || 2048 / this.getPrecision();
    let innerWidth = width - paddingLeft;
    if (innerWidth < 10) {
      width += 10 - innerWidth;
      innerWidth = 10;
    }
    if (!wordWrapWidth) {
      wordWrapWidth = innerWidth;
    }
    if (this._settings.textOverflow && !this._settings.wordWrap) {
      let suffix;
      switch (this._settings.textOverflow) {
        case "clip":
          suffix = "";
          break;
        case "ellipsis":
          suffix = this._settings.maxLinesSuffix;
          break;
        default:
          suffix = this._settings.textOverflow;
      }
      this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
    }
    let linesInfo;
    if (this._settings.wordWrap) {
      linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
    } else {
      linesInfo = { l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: [] };
      let n = linesInfo.l.length;
      for (let i = 0; i < n - 1; i++) {
        linesInfo.n.push(i);
      }
    }
    let lines = linesInfo.l;
    if (this._settings.maxLines && lines.length > this._settings.maxLines) {
      let usedLines = lines.slice(0, this._settings.maxLines);
      let otherLines = null;
      if (this._settings.maxLinesSuffix) {
        let w2 = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
        let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w2, letterSpacing, textIndent);
        usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
        otherLines = [al.l.length > 1 ? al.l[1] : ""];
      } else {
        otherLines = [""];
      }
      let i, n = lines.length;
      let j = 0;
      let m = linesInfo.n.length;
      for (i = this._settings.maxLines; i < n; i++) {
        otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
        if (i + 1 < m && linesInfo.n[i + 1]) {
          j++;
        }
      }
      renderInfo.remainingText = otherLines.join("\n");
      renderInfo.moreTextLines = true;
      lines = usedLines;
    } else {
      renderInfo.moreTextLines = false;
      renderInfo.remainingText = "";
    }
    let maxLineWidth = 0;
    let lineWidths = [];
    for (let i = 0; i < lines.length; i++) {
      let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
      lineWidths.push(lineWidth);
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    renderInfo.lineWidths = lineWidths;
    if (!w) {
      width = maxLineWidth + paddingLeft + paddingRight;
      innerWidth = maxLineWidth;
    }
    lineHeight = lineHeight || fontSize;
    let height;
    if (h) {
      height = h;
    } else {
      const baselineOffset = this._settings.textBaseline != "bottom" ? 0.5 * fontSize : 0;
      height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
    }
    if (offsetY === null) {
      offsetY = fontSize;
    }
    renderInfo.w = width;
    renderInfo.h = height;
    renderInfo.lines = lines;
    renderInfo.precision = precision2;
    if (!width) {
      width = 1;
    }
    if (!height) {
      height = 1;
    }
    if (cutSx || cutEx) {
      width = Math.min(width, cutEx - cutSx);
    }
    if (cutSy || cutEy) {
      height = Math.min(height, cutEy - cutSy);
    }
    renderInfo.width = width;
    renderInfo.innerWidth = innerWidth;
    renderInfo.height = height;
    renderInfo.fontSize = fontSize;
    renderInfo.cutSx = cutSx;
    renderInfo.cutSy = cutSy;
    renderInfo.cutEx = cutEx;
    renderInfo.cutEy = cutEy;
    renderInfo.lineHeight = lineHeight;
    renderInfo.lineWidths = lineWidths;
    renderInfo.offsetY = offsetY;
    renderInfo.paddingLeft = paddingLeft;
    renderInfo.paddingRight = paddingRight;
    renderInfo.letterSpacing = letterSpacing;
    renderInfo.textIndent = textIndent;
    return renderInfo;
  }
  _draw() {
    const renderInfo = this._calculateRenderInfo();
    const precision2 = this.getPrecision();
    this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption("textRenderIssueMargin"));
    this._canvas.height = Math.ceil(renderInfo.height);
    this.setFontProperties();
    if (renderInfo.fontSize >= 128) {
      this._context.globalAlpha = 0.01;
      this._context.fillRect(0, 0, 0.01, 0.01);
      this._context.globalAlpha = 1;
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
    }
    let linePositionX;
    let linePositionY;
    let drawLines = [];
    for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
      linePositionX = i === 0 ? renderInfo.textIndent : 0;
      linePositionY = i * renderInfo.lineHeight + renderInfo.offsetY;
      if (this._settings.verticalAlign == "middle") {
        linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
      } else if (this._settings.verticalAlign == "bottom") {
        linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
      }
      if (this._settings.textAlign === "right") {
        linePositionX += renderInfo.innerWidth - renderInfo.lineWidths[i];
      } else if (this._settings.textAlign === "center") {
        linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2;
      }
      linePositionX += renderInfo.paddingLeft;
      drawLines.push({ text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i] });
    }
    if (this._settings.highlight) {
      let color = this._settings.highlightColor || 0;
      let hlHeight = this._settings.highlightHeight * precision2 || renderInfo.fontSize * 1.5;
      const offset = this._settings.highlightOffset * precision2;
      const hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision2 : renderInfo.paddingLeft;
      const hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision2 : renderInfo.paddingRight;
      this._context.fillStyle = StageUtils.getRgbaString(color);
      for (let i = 0; i < drawLines.length; i++) {
        let drawLine = drawLines[i];
        this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
      }
    }
    let prevShadowSettings = null;
    if (this._settings.shadow) {
      prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
      this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
      this._context.shadowOffsetX = this._settings.shadowOffsetX * precision2;
      this._context.shadowOffsetY = this._settings.shadowOffsetY * precision2;
      this._context.shadowBlur = this._settings.shadowBlur * precision2;
    }
    this._context.fillStyle = StageUtils.getRgbaString(this._settings.textColor);
    for (let i = 0, n = drawLines.length; i < n; i++) {
      let drawLine = drawLines[i];
      if (renderInfo.letterSpacing === 0) {
        this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
      } else {
        const textSplit = drawLine.text.split("");
        let x = drawLine.x;
        for (let i2 = 0, j = textSplit.length; i2 < j; i2++) {
          this._context.fillText(textSplit[i2], x, drawLine.y);
          x += this.measureText(textSplit[i2], renderInfo.letterSpacing);
        }
      }
    }
    if (prevShadowSettings) {
      this._context.shadowColor = prevShadowSettings[0];
      this._context.shadowOffsetX = prevShadowSettings[1];
      this._context.shadowOffsetY = prevShadowSettings[2];
      this._context.shadowBlur = prevShadowSettings[3];
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
    }
    this.renderInfo = renderInfo;
  }
  wrapWord(word, wordWrapWidth, suffix) {
    const suffixWidth = this._context.measureText(suffix).width;
    const wordLen = word.length;
    const wordWidth = this._context.measureText(word).width;
    if (wordWidth <= wordWrapWidth) {
      return word;
    }
    let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
    let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
    if (truncWordWidth > wordWrapWidth) {
      while (cutoffIndex > 0) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth > wordWrapWidth) {
          cutoffIndex -= 1;
        } else {
          break;
        }
      }
    } else {
      while (cutoffIndex < wordLen) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth < wordWrapWidth) {
          cutoffIndex += 1;
        } else {
          cutoffIndex -= 1;
          break;
        }
      }
    }
    return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   */
  wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
    let lines = text.split(/\r?\n/g);
    let allLines = [];
    let realNewlines = [];
    for (let i = 0; i < lines.length; i++) {
      let resultLines = [];
      let result = "";
      let spaceLeft = wordWrapWidth - indent;
      let words = lines[i].split(" ");
      for (let j = 0; j < words.length; j++) {
        const wordWidth = this.measureText(words[j], letterSpacing);
        const wordWidthWithSpace = wordWidth + this.measureText(" ", letterSpacing);
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            resultLines.push(result);
            result = "";
          }
          result += words[j];
          spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += " " + words[j];
        }
      }
      resultLines.push(result);
      result = "";
      allLines = allLines.concat(resultLines);
      if (i < lines.length - 1) {
        realNewlines.push(allLines.length);
      }
    }
    return { l: allLines, n: realNewlines };
  }
  measureText(word, space = 0) {
    if (!space) {
      return this._context.measureText(word).width;
    }
    return word.split("").reduce((acc, char) => {
      return acc + this._context.measureText(char).width + space;
    }, 0);
  }
}
class TextTextureRendererAdvanced {
  constructor(stage2, canvas2, settings2) {
    this._stage = stage2;
    this._canvas = canvas2;
    this._context = this._canvas.getContext("2d");
    this._settings = settings2;
  }
  getPrecision() {
    return this._settings.precision;
  }
  setFontProperties() {
    const font = getFontSetting(
      this._settings.fontFace,
      this._settings.fontStyle,
      this._settings.fontSize,
      this.getPrecision(),
      this._stage.getOption("defaultFontFace")
    );
    this._context.font = font;
    this._context.textBaseline = this._settings.textBaseline;
    return font;
  }
  _load() {
    if (Utils$2.isWeb && document.fonts) {
      const fontSetting = getFontSetting(
        this._settings.fontFace,
        this._settings.fontStyle,
        this._settings.fontSize,
        this.getPrecision(),
        this._stage.getOption("defaultFontFace")
      );
      try {
        if (!document.fonts.check(fontSetting, this._settings.text)) {
          return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
            console.warn("Font load error", err, fontSetting);
          }).then(() => {
            if (!document.fonts.check(fontSetting, this._settings.text)) {
              console.warn("Font not found", fontSetting);
            }
          });
        }
      } catch (e) {
        console.warn("Can't check font loading for " + fontSetting);
      }
    }
  }
  draw() {
    const loadPromise = this._load();
    if (!loadPromise) {
      return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
    } else {
      return loadPromise.then(() => {
        return Utils$2.isSpark ? this._stage.platform.drawText(this) : this._draw();
      });
    }
  }
  _calculateRenderInfo() {
    let renderInfo = {};
    const precision2 = this.getPrecision();
    const paddingLeft = this._settings.paddingLeft * precision2;
    const paddingRight = this._settings.paddingRight * precision2;
    const fontSize = this._settings.fontSize * precision2;
    const lineHeight = this._settings.lineHeight * precision2 || fontSize;
    const w = this._settings.w != 0 ? this._settings.w * precision2 : 2048 / precision2;
    const wordWrapWidth = this._settings.wordWrapWidth * precision2;
    const cutSx = this._settings.cutSx * precision2;
    const cutEx = this._settings.cutEx * precision2;
    const cutSy = this._settings.cutSy * precision2;
    const cutEy = this._settings.cutEy * precision2;
    const letterSpacing = this._settings.letterSpacing || 0;
    renderInfo.baseFont = this.setFontProperties();
    renderInfo.w = w;
    renderInfo.width = w;
    renderInfo.text = this._settings.text;
    renderInfo.precision = precision2;
    renderInfo.fontSize = fontSize;
    renderInfo.fontBaselineRatio = this._settings.fontBaselineRatio;
    renderInfo.lineHeight = lineHeight;
    renderInfo.letterSpacing = letterSpacing;
    renderInfo.textAlign = this._settings.textAlign;
    renderInfo.textColor = this._settings.textColor;
    renderInfo.verticalAlign = this._settings.verticalAlign;
    renderInfo.highlight = this._settings.highlight;
    renderInfo.highlightColor = this._settings.highlightColor;
    renderInfo.highlightHeight = this._settings.highlightHeight;
    renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
    renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
    renderInfo.highlightOffset = this._settings.highlightOffset;
    renderInfo.paddingLeft = this._settings.paddingLeft;
    renderInfo.paddingRight = this._settings.paddingRight;
    renderInfo.maxLines = this._settings.maxLines;
    renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
    renderInfo.textOverflow = this._settings.textOverflow;
    renderInfo.wordWrap = this._settings.wordWrap;
    renderInfo.wordWrapWidth = wordWrapWidth;
    renderInfo.shadow = this._settings.shadow;
    renderInfo.shadowColor = this._settings.shadowColor;
    renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
    renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
    renderInfo.shadowBlur = this._settings.shadowBlur;
    renderInfo.cutSx = cutSx;
    renderInfo.cutEx = cutEx;
    renderInfo.cutSy = cutSy;
    renderInfo.cutEy = cutEy;
    renderInfo.textIndent = this._settings.textIndent * precision2;
    renderInfo.wordBreak = this._settings.wordBreak;
    let text = renderInfo.text;
    let wrapWidth = renderInfo.wordWrap ? renderInfo.wordWrapWidth || renderInfo.width : renderInfo.width;
    if (renderInfo.textOverflow && !renderInfo.wordWrap) {
      let suffix;
      switch (this._settings.textOverflow) {
        case "clip":
          suffix = "";
          break;
        case "ellipsis":
          suffix = this._settings.maxLinesSuffix;
          break;
        default:
          suffix = this._settings.textOverflow;
      }
      text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
    }
    text = this.tokenize(text);
    text = this.parse(text);
    text = this.measure(text, letterSpacing, renderInfo.baseFont);
    if (renderInfo.textIndent) {
      text = this.indent(text, renderInfo.textIndent);
    }
    if (renderInfo.wordBreak) {
      text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), []);
      this.resetFontStyle();
    }
    let x = paddingLeft;
    let lineNo = 0;
    for (const t of text) {
      if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == "\n") {
        x = paddingLeft;
        lineNo += 1;
      }
      t.lineNo = lineNo;
      if (t.text == "\n") {
        continue;
      }
      t.x = x;
      x += t.width;
    }
    renderInfo.lineNum = lineNo + 1;
    if (this._settings.h) {
      renderInfo.h = this._settings.h;
    } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
      renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
    } else {
      renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
    }
    const baselineOffsetInPx = renderInfo.fontBaselineRatio * renderInfo.fontSize;
    let vaOffset = 0;
    if (renderInfo.verticalAlign == "top" && this._context.textBaseline == "alphabetic") {
      vaOffset = -baselineOffsetInPx;
    } else if (renderInfo.verticalAlign == "middle") {
      vaOffset = (renderInfo.lineHeight - renderInfo.fontSize - baselineOffsetInPx) / 2;
    } else if (this._settings.verticalAlign == "bottom") {
      vaOffset = renderInfo.lineHeight - renderInfo.fontSize;
    }
    renderInfo.lines = [];
    for (let i = 0; i < renderInfo.lineNum; i++) {
      renderInfo.lines[i] = {
        width: 0,
        x: 0,
        y: renderInfo.lineHeight * i + vaOffset,
        text: []
      };
    }
    for (let t of text) {
      renderInfo.lines[t.lineNo].text.push(t);
    }
    for (const l of renderInfo.lines) {
      if (l.text.length == 0) {
        continue;
      }
      const firstWord = l.text[0].text;
      const lastWord = l.text[l.text.length - 1].text;
      if (firstWord == "\n") {
        l.text.shift();
      }
      if (lastWord == " " || lastWord == "\n") {
        l.text.pop();
      }
    }
    for (let l of renderInfo.lines) {
      l.width = l.text.reduce((acc, t) => acc + t.width, 0);
    }
    renderInfo.width = this._settings.w != 0 ? this._settings.w * precision2 : Math.max(...renderInfo.lines.map((l) => l.width)) + paddingRight;
    renderInfo.w = renderInfo.width;
    if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
      const index = renderInfo.maxLines - 1;
      let lastLineText = text.filter((t) => t.lineNo == index);
      let suffix = renderInfo.maxLinesSuffix;
      suffix = this.tokenize(suffix);
      suffix = this.parse(suffix);
      suffix = this.measure(suffix, renderInfo.letterSpacing, renderInfo.baseFont);
      for (const s of suffix) {
        s.lineNo = index;
        s.x = 0;
        lastLineText.push(s);
      }
      const spl = suffix.length + 1;
      let _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
      while (_w > renderInfo.width || lastLineText[lastLineText.length - spl].text == " ") {
        lastLineText.splice(lastLineText.length - spl, 1);
        _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
        if (lastLineText.length < spl) {
          break;
        }
      }
      this.alignLine(lastLineText, lastLineText[0].x);
      renderInfo.lines[index].text = lastLineText;
      renderInfo.lines[index].width = _w;
    }
    if (renderInfo.textAlign == "center") {
      for (let l of renderInfo.lines) {
        l.x = (renderInfo.width - l.width - paddingLeft) / 2;
      }
    } else if (renderInfo.textAlign == "right") {
      for (let l of renderInfo.lines) {
        l.x = renderInfo.width - l.width - paddingLeft;
      }
    }
    return renderInfo;
  }
  _draw() {
    const renderInfo = this._calculateRenderInfo();
    const precision2 = this.getPrecision();
    const paddingLeft = renderInfo.paddingLeft * precision2;
    let canvasWidth = renderInfo.w || renderInfo.width;
    if (renderInfo.cutSx || renderInfo.cutEx) {
      canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
    }
    let canvasHeight = renderInfo.h;
    if (renderInfo.cutSy || renderInfo.cutEy) {
      canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
    }
    this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption("textRenderIssueMargin"));
    this._canvas.height = Math.ceil(canvasHeight);
    this.setFontProperties();
    if (renderInfo.fontSize >= 128) {
      this._context.globalAlpha = 0.01;
      this._context.fillRect(0, 0, 0.01, 0.01);
      this._context.globalAlpha = 1;
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
    }
    if (renderInfo.highlight) {
      const hlColor = renderInfo.highlightColor || 0;
      const hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision2 : renderInfo.fontSize * 1.5;
      const hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision2 : 0;
      const hlPaddingLeft = renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision2 : renderInfo.paddingLeft;
      const hlPaddingRight = renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision2 : renderInfo.paddingRight;
      this._context.fillStyle = StageUtils.getRgbaString(hlColor);
      const lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum;
      for (let i = 0; i < lineNum; i++) {
        const l = renderInfo.lines[i];
        this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
      }
    }
    let prevShadowSettings = null;
    if (this._settings.shadow) {
      prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
      this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
      this._context.shadowOffsetX = this._settings.shadowOffsetX * precision2;
      this._context.shadowOffsetY = this._settings.shadowOffsetY * precision2;
      this._context.shadowBlur = this._settings.shadowBlur * precision2;
    }
    const defaultColor = StageUtils.getRgbaString(this._settings.textColor);
    let currentColor = defaultColor;
    this._context.fillStyle = defaultColor;
    for (const line of renderInfo.lines) {
      for (const t of line.text) {
        let lx = 0;
        if (t.text == "\n") {
          continue;
        }
        if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
          continue;
        }
        if (t.color != currentColor) {
          currentColor = t.color;
          this._context.fillStyle = currentColor;
        }
        this._context.font = t.fontStyle;
        if (t.letters) {
          for (let l of t.letters) {
            const _x = renderInfo.lines[t.lineNo].x + t.x + lx;
            this._context.fillText(l.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
            lx += l.width;
          }
        } else {
          const _x = renderInfo.lines[t.lineNo].x + t.x;
          this._context.fillText(t.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
        }
      }
    }
    if (prevShadowSettings) {
      this._context.shadowColor = prevShadowSettings[0];
      this._context.shadowOffsetX = prevShadowSettings[1];
      this._context.shadowOffsetY = prevShadowSettings[2];
      this._context.shadowBlur = prevShadowSettings[3];
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
    }
    renderInfo.lines = renderInfo.lines.map((l) => l.text.reduce((acc, v) => acc + v.text, ""));
    if (renderInfo.maxLines) {
      renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
    }
    this.renderInfo = renderInfo;
  }
  measureText(word, space = 0) {
    if (!space) {
      return this._context.measureText(word).width;
    }
    return word.split("").reduce((acc, char) => {
      return acc + this._context.measureText(char).width + space;
    }, 0);
  }
  tokenize(text) {
    const re = / |\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g;
    const delimeters = text.match(re) || [];
    const words = text.split(re) || [];
    let final = [];
    for (let i = 0; i < words.length; i++) {
      final.push(words[i], delimeters[i]);
    }
    final.pop();
    return final.filter((word) => word != "");
  }
  parse(tokens) {
    let italic = 0;
    let bold = 0;
    let colorStack = [StageUtils.getRgbaString(this._settings.textColor)];
    let color = 0;
    const colorRegexp = /<color=(0[xX][0-9a-fA-F]{8})>/;
    return tokens.map((t) => {
      if (t == "<i>") {
        italic += 1;
        t = "";
      } else if (t == "</i>" && italic > 0) {
        italic -= 1;
        t = "";
      } else if (t == "<b>") {
        bold += 1;
        t = "";
      } else if (t == "</b>" && bold > 0) {
        bold -= 1;
        t = "";
      } else if (t == "</color>") {
        if (colorStack.length > 1) {
          color -= 1;
          colorStack.pop();
        }
        t = "";
      } else if (colorRegexp.test(t)) {
        const matched = colorRegexp.exec(t);
        colorStack.push(
          StageUtils.getRgbaString(parseInt(matched[1]))
        );
        color += 1;
        t = "";
      }
      return {
        text: t,
        italic,
        bold,
        color: colorStack[color]
      };
    }).filter((o) => o.text != "");
  }
  applyFontStyle(word, baseFont) {
    let font = baseFont;
    if (word.bold) {
      font = "bold " + font;
    }
    if (word.italic) {
      font = "italic " + font;
    }
    this._context.font = font;
    word.fontStyle = font;
  }
  resetFontStyle(baseFont) {
    this._context.font = baseFont;
  }
  measure(parsed, letterSpacing = 0, baseFont) {
    for (const p of parsed) {
      this.applyFontStyle(p, baseFont);
      p.width = this.measureText(p.text, letterSpacing);
      if (letterSpacing > 0) {
        p.letters = p.text.split("").map((l) => {
          return { text: l };
        });
        for (let l of p.letters) {
          l.width = this.measureText(l.text, letterSpacing);
        }
      }
    }
    this.resetFontStyle(baseFont);
    return parsed;
  }
  indent(parsed, textIndent) {
    parsed.splice(0, 0, { text: "", width: textIndent });
    return parsed;
  }
  wrapWord(word, wordWrapWidth, suffix) {
    const suffixWidth = this._context.measureText(suffix).width;
    const wordLen = word.length;
    const wordWidth = this._context.measureText(word).width;
    if (wordWidth <= wordWrapWidth) {
      return word;
    }
    let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
    let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
    if (truncWordWidth > wordWrapWidth) {
      while (cutoffIndex > 0) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth > wordWrapWidth) {
          cutoffIndex -= 1;
        } else {
          break;
        }
      }
    } else {
      while (cutoffIndex < wordLen) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth < wordWrapWidth) {
          cutoffIndex += 1;
        } else {
          cutoffIndex -= 1;
          break;
        }
      }
    }
    return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
  }
  _getBreakIndex(word, width) {
    const wordLen = word.length;
    const wordWidth = this.measureText(word);
    if (wordWidth <= width) {
      return { breakIndex: word.length, truncWordWidth: wordWidth };
    }
    let breakIndex = Math.floor(width * wordLen / wordWidth);
    let truncWordWidth = this.measureText(word.substring(0, breakIndex));
    if (truncWordWidth > width) {
      while (breakIndex > 0) {
        truncWordWidth = this.measureText(word.substring(0, breakIndex));
        if (truncWordWidth > width) {
          breakIndex -= 1;
        } else {
          break;
        }
      }
    } else {
      while (breakIndex < wordLen) {
        truncWordWidth = this.measureText(word.substring(0, breakIndex));
        if (truncWordWidth < width) {
          breakIndex += 1;
        } else {
          breakIndex -= 1;
          truncWordWidth = this.measureText(word.substring(0, breakIndex));
          break;
        }
      }
    }
    return { breakIndex, truncWordWidth };
  }
  wordBreak(word, width, baseFont) {
    if (!word.text) {
      return word;
    }
    this.applyFontStyle(word, baseFont);
    const parts = [];
    let text = word.text;
    if (!word.letters) {
      while (true) {
        const { breakIndex, truncWordWidth } = this._getBreakIndex(text, width);
        parts.push({ ...word });
        parts[parts.length - 1].text = text.slice(0, breakIndex);
        parts[parts.length - 1].width = truncWordWidth;
        if (breakIndex === text.length) {
          break;
        }
        text = text.slice(breakIndex);
      }
    } else {
      let totalWidth = 0;
      let letters = [];
      let breakIndex = 0;
      for (const l of word.letters) {
        if (totalWidth + l.width >= width) {
          parts.push({ ...word });
          parts[parts.length - 1].text = text.slice(0, breakIndex);
          parts[parts.length - 1].width = totalWidth;
          parts[parts.length - 1].letters = letters;
          text = text.slice(breakIndex);
          totalWidth = 0;
          letters = [];
          breakIndex = 0;
        } else {
          breakIndex += 1;
          letters.push(l);
          totalWidth += l.width;
        }
      }
      if (totalWidth > 0) {
        parts.push({ ...word });
        parts[parts.length - 1].text = text.slice(0, breakIndex);
        parts[parts.length - 1].width = totalWidth;
        parts[parts.length - 1].letters = letters;
      }
    }
    return parts;
  }
  alignLine(parsed, initialX = 0) {
    let prevWidth = 0;
    let prevX = initialX;
    for (const word of parsed) {
      if (word.text == "\n") {
        continue;
      }
      word.x = prevX + prevWidth;
      prevX = word.x;
      prevWidth = word.width;
    }
  }
}
class TextTexture extends Texture {
  constructor(stage2) {
    super(stage2);
    this._precision = this.stage.getOption("precision");
  }
  static renderer(stage2, canvas2, settings2) {
    if (this.advancedRenderer) {
      return new TextTextureRendererAdvanced(stage2, canvas2, settings2);
    } else {
      return new TextTextureRenderer(stage2, canvas2, settings2);
    }
  }
  get text() {
    return this._text;
  }
  set text(v) {
    if (this._text !== v) {
      this._text = "" + v;
      this._changed();
    }
  }
  get w() {
    return this._w;
  }
  set w(v) {
    if (this._w !== v) {
      this._w = v;
      this._changed();
    }
  }
  get h() {
    return this._h;
  }
  set h(v) {
    if (this._h !== v) {
      this._h = v;
      this._changed();
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(v) {
    if (this._fontStyle !== v) {
      this._fontStyle = v;
      this._changed();
    }
  }
  get fontBaselineRatio() {
    return this._fontBaselineRatio;
  }
  set fontBaselineRatio(v) {
    if (this._fontBaselineRatio !== v) {
      this._fontBaselineRatio = v;
      this._changed();
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(v) {
    if (this._fontSize !== v) {
      this._fontSize = v;
      this._changed();
    }
  }
  get fontFace() {
    return this._fontFace;
  }
  set fontFace(v) {
    if (this._fontFace !== v) {
      this._fontFace = v;
      this._changed();
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(v) {
    if (this._wordWrap !== v) {
      this._wordWrap = v;
      this._changed();
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(v) {
    if (this._wordWrapWidth !== v) {
      this._wordWrapWidth = v;
      this._changed();
    }
  }
  get wordBreak() {
    return this._wordBreak;
  }
  set wordBreak(v) {
    if (this._wordBreak !== v) {
      this._wordBreak = v;
      this._changed();
    }
  }
  get textOverflow() {
    return this._textOverflow;
  }
  set textOverflow(v) {
    if (v != this._textOverflow) {
      this._textOverflow = v;
      this._changed();
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(v) {
    if (this._lineHeight !== v) {
      this._lineHeight = v;
      this._changed();
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(v) {
    if (this._textBaseline !== v) {
      this._textBaseline = v;
      this._changed();
    }
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(v) {
    if (this._textAlign !== v) {
      this._textAlign = v;
      this._changed();
    }
  }
  get verticalAlign() {
    return this._verticalAlign;
  }
  set verticalAlign(v) {
    if (this._verticalAlign !== v) {
      this._verticalAlign = v;
      this._changed();
    }
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(v) {
    if (this._offsetY !== v) {
      this._offsetY = v;
      this._changed();
    }
  }
  get maxLines() {
    return this._maxLines;
  }
  set maxLines(v) {
    if (this._maxLines !== v) {
      this._maxLines = v;
      this._changed();
    }
  }
  get maxLinesSuffix() {
    return this._maxLinesSuffix;
  }
  set maxLinesSuffix(v) {
    if (this._maxLinesSuffix !== v) {
      this._maxLinesSuffix = v;
      this._changed();
    }
  }
  get textColor() {
    return this._textColor;
  }
  set textColor(v) {
    if (this._textColor !== v) {
      this._textColor = v;
      this._changed();
    }
  }
  get paddingLeft() {
    return this._paddingLeft;
  }
  set paddingLeft(v) {
    if (this._paddingLeft !== v) {
      this._paddingLeft = v;
      this._changed();
    }
  }
  get paddingRight() {
    return this._paddingRight;
  }
  set paddingRight(v) {
    if (this._paddingRight !== v) {
      this._paddingRight = v;
      this._changed();
    }
  }
  get shadow() {
    return this._shadow;
  }
  set shadow(v) {
    if (this._shadow !== v) {
      this._shadow = v;
      this._changed();
    }
  }
  get shadowColor() {
    return this._shadowColor;
  }
  set shadowColor(v) {
    if (this._shadowColor !== v) {
      this._shadowColor = v;
      this._changed();
    }
  }
  get shadowOffsetX() {
    return this._shadowOffsetX;
  }
  set shadowOffsetX(v) {
    if (this._shadowOffsetX !== v) {
      this._shadowOffsetX = v;
      this._changed();
    }
  }
  get shadowOffsetY() {
    return this._shadowOffsetY;
  }
  set shadowOffsetY(v) {
    if (this._shadowOffsetY !== v) {
      this._shadowOffsetY = v;
      this._changed();
    }
  }
  get shadowBlur() {
    return this._shadowBlur;
  }
  set shadowBlur(v) {
    if (this._shadowBlur !== v) {
      this._shadowBlur = v;
      this._changed();
    }
  }
  get highlight() {
    return this._highlight;
  }
  set highlight(v) {
    if (this._highlight !== v) {
      this._highlight = v;
      this._changed();
    }
  }
  get highlightHeight() {
    return this._highlightHeight;
  }
  set highlightHeight(v) {
    if (this._highlightHeight !== v) {
      this._highlightHeight = v;
      this._changed();
    }
  }
  get highlightColor() {
    return this._highlightColor;
  }
  set highlightColor(v) {
    if (this._highlightColor !== v) {
      this._highlightColor = v;
      this._changed();
    }
  }
  get highlightOffset() {
    return this._highlightOffset;
  }
  set highlightOffset(v) {
    if (this._highlightOffset !== v) {
      this._highlightOffset = v;
      this._changed();
    }
  }
  get highlightPaddingLeft() {
    return this._highlightPaddingLeft;
  }
  set highlightPaddingLeft(v) {
    if (this._highlightPaddingLeft !== v) {
      this._highlightPaddingLeft = v;
      this._changed();
    }
  }
  get highlightPaddingRight() {
    return this._highlightPaddingRight;
  }
  set highlightPaddingRight(v) {
    if (this._highlightPaddingRight !== v) {
      this._highlightPaddingRight = v;
      this._changed();
    }
  }
  get cutSx() {
    return this._cutSx;
  }
  set cutSx(v) {
    if (this._cutSx !== v) {
      this._cutSx = v;
      this._changed();
    }
  }
  get cutEx() {
    return this._cutEx;
  }
  set cutEx(v) {
    if (this._cutEx !== v) {
      this._cutEx = v;
      this._changed();
    }
  }
  get cutSy() {
    return this._cutSy;
  }
  set cutSy(v) {
    if (this._cutSy !== v) {
      this._cutSy = v;
      this._changed();
    }
  }
  get cutEy() {
    return this._cutEy;
  }
  set cutEy(v) {
    if (this._cutEy !== v) {
      this._cutEy = v;
      this._changed();
    }
  }
  get advancedRenderer() {
    return this._advancedRenderer;
  }
  set advancedRenderer(v) {
    if (this._advancedRenderer !== v) {
      this._advancedRenderer = v;
      this._changed();
    }
  }
  set letterSpacing(v) {
    if (this._letterSpacing !== v) {
      this._letterSpacing = v;
      this._changed();
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set textIndent(v) {
    if (this._textIndent !== v) {
      this._textIndent = v;
      this._changed();
    }
  }
  get textIndent() {
    return this._textIndent;
  }
  get precision() {
    return super.precision;
  }
  set precision(v) {
    if (this.precision !== v) {
      super.precision = v;
      this._changed();
    }
  }
  _getIsValid() {
    return !!this.text;
  }
  _getLookupId() {
    let parts = [];
    if (this.w !== 0)
      parts.push("w " + this.w);
    if (this.h !== 0)
      parts.push("h " + this.h);
    if (this.fontStyle !== "normal")
      parts.push("fS" + this.fontStyle);
    if (this.fontSize !== 40)
      parts.push("fs" + this.fontSize);
    if (this.fontBaselineRatio !== 0)
      parts.push("fb" + this.fontBaselineRatio);
    if (this.fontFace !== null)
      parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
    if (this.wordWrap !== true)
      parts.push("wr" + (this.wordWrap ? 1 : 0));
    if (this.wordWrapWidth !== 0)
      parts.push("ww" + this.wordWrapWidth);
    if (this.wordBreak !== false)
      parts.push("wb" + this.wordBreak ? 1 : 0);
    if (this.textOverflow != "")
      parts.push("to" + this.textOverflow);
    if (this.lineHeight !== null)
      parts.push("lh" + this.lineHeight);
    if (this.textBaseline !== "alphabetic")
      parts.push("tb" + this.textBaseline);
    if (this.textAlign !== "left")
      parts.push("ta" + this.textAlign);
    if (this.verticalAlign !== "top")
      parts.push("va" + this.verticalAlign);
    if (this.offsetY !== null)
      parts.push("oy" + this.offsetY);
    if (this.maxLines !== 0)
      parts.push("ml" + this.maxLines);
    if (this.maxLinesSuffix !== "..")
      parts.push("ms" + this.maxLinesSuffix);
    parts.push("pc" + this.precision);
    if (this.textColor !== 4294967295)
      parts.push("co" + this.textColor.toString(16));
    if (this.paddingLeft !== 0)
      parts.push("pl" + this.paddingLeft);
    if (this.paddingRight !== 0)
      parts.push("pr" + this.paddingRight);
    if (this.shadow !== false)
      parts.push("sh" + (this.shadow ? 1 : 0));
    if (this.shadowColor !== 4278190080)
      parts.push("sc" + this.shadowColor.toString(16));
    if (this.shadowOffsetX !== 0)
      parts.push("sx" + this.shadowOffsetX);
    if (this.shadowOffsetY !== 0)
      parts.push("sy" + this.shadowOffsetY);
    if (this.shadowBlur !== 5)
      parts.push("sb" + this.shadowBlur);
    if (this.highlight !== false)
      parts.push("hL" + (this.highlight ? 1 : 0));
    if (this.highlightHeight !== 0)
      parts.push("hh" + this.highlightHeight);
    if (this.highlightColor !== 4278190080)
      parts.push("hc" + this.highlightColor.toString(16));
    if (this.highlightOffset !== null)
      parts.push("ho" + this.highlightOffset);
    if (this.highlightPaddingLeft !== null)
      parts.push("hl" + this.highlightPaddingLeft);
    if (this.highlightPaddingRight !== null)
      parts.push("hr" + this.highlightPaddingRight);
    if (this.letterSpacing !== null)
      parts.push("ls" + this.letterSpacing);
    if (this.textIndent !== null)
      parts.push("ti" + this.textIndent);
    if (this.cutSx)
      parts.push("csx" + this.cutSx);
    if (this.cutEx)
      parts.push("cex" + this.cutEx);
    if (this.cutSy)
      parts.push("csy" + this.cutSy);
    if (this.cutEy)
      parts.push("cey" + this.cutEy);
    if (this.advancedRenderer)
      parts.push("aR" + this.advancedRenderer ? 1 : 0);
    let id = "TX$" + parts.join("|") + ":" + this.text;
    return id;
  }
  _getSourceLoader() {
    const args = this.cloneArgs();
    const gl = this.stage.gl;
    return function(cb) {
      const canvas2 = this.stage.platform.getDrawingCanvas();
      const renderer = args.advancedRenderer ? new TextTextureRendererAdvanced(this.stage, canvas2, args) : new TextTextureRenderer(this.stage, canvas2, args);
      const p = renderer.draw();
      const texParams = {};
      const sharpCfg = this.stage.getOption("fontSharp");
      let sharpen = false;
      if (Utils$2.isBoolean(sharpCfg)) {
        sharpen = sharpCfg;
      } else if (Utils$2.isObject(sharpCfg)) {
        const precision2 = this.stage.getRenderPrecision();
        sharpen = precision2 <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
      }
      if (gl && sharpen) {
        texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
      }
      if (p) {
        p.then(() => {
          cb(null, Object.assign({
            renderInfo: renderer.renderInfo,
            throttle: false,
            texParams
          }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas2)));
        }).catch((err) => {
          cb(err);
        });
      } else {
        cb(null, Object.assign({
          renderInfo: renderer.renderInfo,
          throttle: false,
          texParams
        }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas2)));
      }
    };
  }
  getNonDefaults() {
    const nonDefaults = super.getNonDefaults();
    if (this.text !== "")
      nonDefaults["text"] = this.text;
    if (this.w !== 0)
      nonDefaults["w"] = this.w;
    if (this.h !== 0)
      nonDefaults["h"] = this.h;
    if (this.fontStyle !== "normal")
      nonDefaults["fontStyle"] = this.fontStyle;
    if (this.fontSize !== 40)
      nonDefaults["fontSize"] = this.fontSize;
    if (this.fontBaselineRatio !== 0)
      nonDefaults["fontBaselineRatio"] = this.fontBaselineRatio;
    if (this.fontFace !== null)
      nonDefaults["fontFace"] = this.fontFace;
    if (this.wordWrap !== true)
      nonDefaults["wordWrap"] = this.wordWrap;
    if (this.wordWrapWidth !== 0)
      nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
    if (this.wordBreak !== false)
      nonDefaults["wordBreak"] = this.wordBreak;
    if (this.textOverflow != "")
      nonDefaults["textOverflow"] = this.textOverflow;
    if (this.lineHeight !== null)
      nonDefaults["lineHeight"] = this.lineHeight;
    if (this.textBaseline !== "alphabetic")
      nonDefaults["textBaseline"] = this.textBaseline;
    if (this.textAlign !== "left")
      nonDefaults["textAlign"] = this.textAlign;
    if (this.verticalAlign !== "top")
      nonDefaults["verticalAlign"] = this.verticalAlign;
    if (this.offsetY !== null)
      nonDefaults["offsetY"] = this.offsetY;
    if (this.maxLines !== 0)
      nonDefaults["maxLines"] = this.maxLines;
    if (this.maxLinesSuffix !== "..")
      nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
    if (this.precision !== this.stage.getOption("precision"))
      nonDefaults["precision"] = this.precision;
    if (this.textColor !== 4294967295)
      nonDefaults["textColor"] = this.textColor;
    if (this.paddingLeft !== 0)
      nonDefaults["paddingLeft"] = this.paddingLeft;
    if (this.paddingRight !== 0)
      nonDefaults["paddingRight"] = this.paddingRight;
    if (this.shadow !== false)
      nonDefaults["shadow"] = this.shadow;
    if (this.shadowColor !== 4278190080)
      nonDefaults["shadowColor"] = this.shadowColor;
    if (this.shadowOffsetX !== 0)
      nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
    if (this.shadowOffsetY !== 0)
      nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
    if (this.shadowBlur !== 5)
      nonDefaults["shadowBlur"] = this.shadowBlur;
    if (this.highlight !== false)
      nonDefaults["highlight"] = this.highlight;
    if (this.highlightHeight !== 0)
      nonDefaults["highlightHeight"] = this.highlightHeight;
    if (this.highlightColor !== 4278190080)
      nonDefaults["highlightColor"] = this.highlightColor;
    if (this.highlightOffset !== 0)
      nonDefaults["highlightOffset"] = this.highlightOffset;
    if (this.highlightPaddingLeft !== 0)
      nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
    if (this.highlightPaddingRight !== 0)
      nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
    if (this.letterSpacing !== 0)
      nonDefaults["letterSpacing"] = this.letterSpacing;
    if (this.textIndent !== 0)
      nonDefaults["textIndent"] = this.textIndent;
    if (this.cutSx)
      nonDefaults["cutSx"] = this.cutSx;
    if (this.cutEx)
      nonDefaults["cutEx"] = this.cutEx;
    if (this.cutSy)
      nonDefaults["cutSy"] = this.cutSy;
    if (this.cutEy)
      nonDefaults["cutEy"] = this.cutEy;
    if (this.advancedRenderer)
      nonDefaults["renderer"] = this.advancedRenderer;
    return nonDefaults;
  }
  cloneArgs() {
    let obj = {};
    obj.text = this._text;
    obj.w = this._w;
    obj.h = this._h;
    obj.fontStyle = this._fontStyle;
    obj.fontSize = this._fontSize;
    obj.fontBaselineRatio = this._fontBaselineRatio;
    obj.fontFace = this._fontFace;
    obj.wordWrap = this._wordWrap;
    obj.wordWrapWidth = this._wordWrapWidth;
    obj.wordBreak = this._wordBreak;
    obj.textOverflow = this._textOverflow;
    obj.lineHeight = this._lineHeight;
    obj.textBaseline = this._textBaseline;
    obj.textAlign = this._textAlign;
    obj.verticalAlign = this._verticalAlign;
    obj.offsetY = this._offsetY;
    obj.maxLines = this._maxLines;
    obj.maxLinesSuffix = this._maxLinesSuffix;
    obj.precision = this._precision;
    obj.textColor = this._textColor;
    obj.paddingLeft = this._paddingLeft;
    obj.paddingRight = this._paddingRight;
    obj.shadow = this._shadow;
    obj.shadowColor = this._shadowColor;
    obj.shadowOffsetX = this._shadowOffsetX;
    obj.shadowOffsetY = this._shadowOffsetY;
    obj.shadowBlur = this._shadowBlur;
    obj.highlight = this._highlight;
    obj.highlightHeight = this._highlightHeight;
    obj.highlightColor = this._highlightColor;
    obj.highlightOffset = this._highlightOffset;
    obj.highlightPaddingLeft = this._highlightPaddingLeft;
    obj.highlightPaddingRight = this._highlightPaddingRight;
    obj.letterSpacing = this._letterSpacing;
    obj.textIndent = this._textIndent;
    obj.cutSx = this._cutSx;
    obj.cutEx = this._cutEx;
    obj.cutSy = this._cutSy;
    obj.cutEy = this._cutEy;
    obj.advancedRenderer = this._advancedRenderer;
    return obj;
  }
}
let proto = TextTexture.prototype;
proto._text = "";
proto._w = 0;
proto._h = 0;
proto._fontStyle = "normal";
proto._fontSize = 40;
proto._fontFace = null;
proto._wordWrap = true;
proto._wordWrapWidth = 0;
proto._wordBreak = false;
proto._textOverflow = "";
proto._lineHeight = null;
proto._textBaseline = "alphabetic";
proto._textAlign = "left";
proto._verticalAlign = "top";
proto._offsetY = null;
proto._maxLines = 0;
proto._maxLinesSuffix = "..";
proto._textColor = 4294967295;
proto._paddingLeft = 0;
proto._paddingRight = 0;
proto._shadow = false;
proto._shadowColor = 4278190080;
proto._shadowOffsetX = 0;
proto._shadowOffsetY = 0;
proto._shadowBlur = 5;
proto._highlight = false;
proto._highlightHeight = 0;
proto._highlightColor = 4278190080;
proto._highlightOffset = 0;
proto._highlightPaddingLeft = 0;
proto._highlightPaddingRight = 0;
proto._letterSpacing = 0;
proto._textIndent = 0;
proto._cutSx = 0;
proto._cutEx = 0;
proto._cutSy = 0;
proto._cutEy = 0;
proto._advancedRenderer = false;
proto._fontBaselineRatio = 0;
class SourceTexture extends Texture {
  constructor(stage2) {
    super(stage2);
    this._textureSource = void 0;
  }
  get textureSource() {
    return this._textureSource;
  }
  set textureSource(v) {
    if (v !== this._textureSource) {
      if (v.isResultTexture) {
        this._precision = this.stage.getRenderPrecision();
      }
      this._textureSource = v;
      this._changed();
    }
  }
  _getTextureSource() {
    return this._textureSource;
  }
}
class Transition extends EventEmitter {
  constructor(manager, settings2, element, property) {
    super();
    this.manager = manager;
    this._settings = settings2;
    this._element = element;
    this._getter = element.constructor.getGetter(property);
    this._setter = element.constructor.getSetter(property);
    this._merger = settings2.merger;
    if (!this._merger) {
      this._merger = element.constructor.getMerger(property);
    }
    this._startValue = this._getter(this._element);
    this._targetValue = this._startValue;
    this._p = 1;
    this._delayLeft = 0;
  }
  start(targetValue) {
    this._startValue = this._getter(this._element);
    if (!this.isAttached()) {
      this._targetValue = targetValue;
      this._p = 1;
      this._updateDrawValue();
    } else {
      if (targetValue === this._startValue) {
        this.reset(targetValue, 1);
      } else {
        this._targetValue = targetValue;
        this._p = 0;
        this._delayLeft = this._settings.delay;
        this.emit("start");
        this.add();
      }
    }
  }
  finish() {
    if (this._p < 1) {
      this._p = 1;
    }
  }
  stop() {
    this.emit("stop");
    this.manager.removeActive(this);
  }
  pause() {
    this.stop();
  }
  play() {
    this.manager.addActive(this);
  }
  reset(targetValue, p) {
    if (!this.isAttached()) {
      this._startValue = this._getter(this._element);
      this._targetValue = targetValue;
      this._p = 1;
      this._updateDrawValue();
    } else {
      this._startValue = this._getter(this._element);
      this._targetValue = targetValue;
      this._p = p;
      this.add();
    }
  }
  _updateDrawValue() {
    this._setter(this._element, this.getDrawValue());
  }
  add() {
    this.manager.addActive(this);
  }
  isAttached() {
    return this._element.attached;
  }
  isRunning() {
    return this._p < 1;
  }
  progress(dt) {
    if (!this.isAttached()) {
      this._p = 1;
    }
    if (this.p < 1) {
      if (this.delayLeft > 0) {
        this._delayLeft -= dt;
        if (this.delayLeft < 0) {
          dt = -this.delayLeft;
          this._delayLeft = 0;
          this.emit("delayEnd");
        } else {
          return;
        }
      }
      if (this._settings.duration == 0) {
        this._p = 1;
      } else {
        this._p += dt / this._settings.duration;
      }
      if (this._p >= 1) {
        this._p = 1;
      }
    }
    this._updateDrawValue();
    this.invokeListeners();
  }
  invokeListeners() {
    this.emit("progress", this.p);
    if (this.p === 1) {
      this.emit("finish");
    }
  }
  updateTargetValue(targetValue) {
    let t = this._settings.timingFunctionImpl(this.p);
    if (t === 1) {
      this._targetValue = targetValue;
    } else if (t === 0) {
      this._startValue = this._targetValue;
      this._targetValue = targetValue;
    } else {
      this._startValue = targetValue - (targetValue - this._targetValue) / (1 - t);
      this._targetValue = targetValue;
    }
  }
  getDrawValue() {
    if (this.p >= 1) {
      return this.targetValue;
    } else {
      let v = this._settings._timingFunctionImpl(this.p);
      return this._merger(this.targetValue, this.startValue, v);
    }
  }
  skipDelay() {
    this._delayLeft = 0;
  }
  get startValue() {
    return this._startValue;
  }
  get targetValue() {
    return this._targetValue;
  }
  get p() {
    return this._p;
  }
  get delayLeft() {
    return this._delayLeft;
  }
  get element() {
    return this._element;
  }
  get settings() {
    return this._settings;
  }
  set settings(v) {
    this._settings = v;
  }
}
Transition.prototype.isTransition = true;
class ObjectList {
  constructor() {
    this._items = [];
    this._refs = {};
  }
  get() {
    return this._items;
  }
  get first() {
    return this._items[0];
  }
  get last() {
    return this._items.length ? this._items[this._items.length - 1] : void 0;
  }
  add(item) {
    this.addAt(item, this._items.length);
  }
  addAt(item, index) {
    if (index >= 0 && index <= this._items.length) {
      let currentIndex = this._items.indexOf(item);
      if (currentIndex === index) {
        return item;
      }
      if (Utils$2.isObjectLiteral(item)) {
        const o = item;
        item = this.createItem(o);
        item.patch(o);
      }
      if (currentIndex != -1) {
        this.setAt(item, index);
      } else {
        if (item.ref) {
          this._refs[item.ref] = item;
        }
        this._items.splice(index, 0, item);
        this.onAdd(item, index);
      }
    } else {
      throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
    }
  }
  replaceByRef(item) {
    if (item.ref) {
      const existingItem = this.getByRef(item.ref);
      if (!existingItem) {
        throw new Error("replaceByRef: no item found with reference: " + item.ref);
      }
      this.replace(item, existingItem);
    } else {
      throw new Error("replaceByRef: no ref specified in item");
    }
    this.addAt(item, this._items.length);
  }
  replace(item, prevItem) {
    const index = this.getIndex(prevItem);
    if (index === -1) {
      throw new Error("replace: The previous item does not exist");
    }
    this.setAt(item, index);
  }
  setAt(item, index) {
    if (index >= 0 && index < this._items.length) {
      if (Utils$2.isObjectLiteral(item)) {
        const o = item;
        item = this.createItem(o);
        item.patch(o);
      }
      let currentIndex = this._items.indexOf(item);
      if (currentIndex != -1) {
        if (currentIndex !== index) {
          const fromIndex = currentIndex;
          if (fromIndex !== index) {
            this._items.splice(fromIndex, 1);
            this._items.splice(index, 0, item);
            this.onMove(item, fromIndex, index);
          }
        }
      } else {
        if (index < this._items.length) {
          if (this._items[index].ref) {
            this._refs[this._items[index].ref] = void 0;
          }
        }
        const prevItem = this._items[index];
        this._items[index] = item;
        if (item.ref) {
          this._refs[item.ref] = item;
        }
        this.onSet(item, index, prevItem);
      }
    } else {
      throw new Error("setAt: The index " + index + " is out of bounds " + this._items.length);
    }
  }
  getAt(index) {
    return this._items[index];
  }
  getIndex(item) {
    return this._items.indexOf(item);
  }
  remove(item) {
    let index = this._items.indexOf(item);
    if (index !== -1) {
      this.removeAt(index);
    }
  }
  removeAt(index) {
    if (index >= 0 && index < this._items.length) {
      const item = this._items[index];
      if (item.ref) {
        this._refs[item.ref] = void 0;
      }
      this._items.splice(index, 1);
      this.onRemove(item, index);
      return item;
    } else {
      throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
    }
  }
  clear() {
    let n = this._items.length;
    if (n) {
      let prev = this._items;
      this._items = [];
      this._refs = {};
      this.onSync(prev, [], []);
    }
  }
  a(o) {
    if (Utils$2.isObjectLiteral(o)) {
      let c = this.createItem(o);
      c.patch(o);
      this.add(c);
      return c;
    } else if (Array.isArray(o)) {
      for (let i = 0, n = o.length; i < n; i++) {
        this.a(o[i]);
      }
      return null;
    } else if (this.isItem(o)) {
      this.add(o);
      return o;
    }
  }
  get length() {
    return this._items.length;
  }
  _getRefs() {
    return this._refs;
  }
  getByRef(ref) {
    return this._refs[ref];
  }
  clearRef(ref) {
    delete this._refs[ref];
  }
  setRef(ref, child) {
    this._refs[ref] = child;
  }
  patch(settings2) {
    if (Utils$2.isObjectLiteral(settings2)) {
      this._setByObject(settings2);
    } else if (Array.isArray(settings2)) {
      this._setByArray(settings2);
    }
  }
  _setByObject(settings2) {
    let refs = this._getRefs();
    let crefs = Object.keys(settings2);
    for (let i = 0, n = crefs.length; i < n; i++) {
      let cref = crefs[i];
      let s = settings2[cref];
      let c = refs[cref];
      if (!c) {
        if (this.isItem(s)) {
          s.ref = cref;
          this.add(s);
        } else {
          c = this.createItem(s);
          c.ref = cref;
          c.patch(s);
          this.add(c);
        }
      } else {
        if (this.isItem(s)) {
          if (c !== s) {
            let idx = this.getIndex(c);
            s.ref = cref;
            this.setAt(s, idx);
          }
        } else {
          c.patch(s);
        }
      }
    }
  }
  _equalsArray(array) {
    let same = true;
    if (array.length === this._items.length) {
      for (let i = 0, n = this._items.length; i < n && same; i++) {
        same = same && this._items[i] === array[i];
      }
    } else {
      same = false;
    }
    return same;
  }
  _setByArray(array) {
    if (this._equalsArray(array)) {
      return;
    }
    for (let i = 0, n = this._items.length; i < n; i++) {
      this._items[i].marker = true;
    }
    let refs;
    let newItems = [];
    for (let i = 0, n = array.length; i < n; i++) {
      let s = array[i];
      if (this.isItem(s)) {
        s.marker = false;
        newItems.push(s);
      } else {
        let cref = s.ref;
        let c;
        if (cref) {
          if (!refs)
            refs = this._getRefs();
          c = refs[cref];
        }
        if (!c) {
          c = this.createItem(s);
        } else {
          c.marker = false;
        }
        if (Utils$2.isObjectLiteral(s)) {
          c.patch(s);
        }
        newItems.push(c);
      }
    }
    this._setItems(newItems);
  }
  _setItems(newItems) {
    let prevItems = this._items;
    this._items = newItems;
    let removed = prevItems.filter((item) => {
      let m = item.marker;
      delete item.marker;
      return m;
    });
    let added = newItems.filter((item) => prevItems.indexOf(item) === -1);
    if (removed.length || added.length) {
      this._refs = {};
      for (let i = 0, n = this._items.length; i < n; i++) {
        let ref = this._items[i].ref;
        if (ref) {
          this._refs[ref] = this._items[i];
        }
      }
    }
    this.onSync(removed, added, newItems);
  }
  sort(f) {
    const items = this._items.slice();
    items.sort(f);
    this._setByArray(items);
  }
  onAdd(item, index) {
  }
  onRemove(item, index) {
  }
  onSync(removed, added, order) {
  }
  onSet(item, index, prevItem) {
  }
  onMove(item, fromIndex, toIndex) {
  }
  createItem(object) {
    throw new Error("ObjectList.createItem must create and return a new object");
  }
  isItem(object) {
    return false;
  }
  forEach(f) {
    this.get().forEach(f);
  }
}
class ElementChildList extends ObjectList {
  constructor(element) {
    super();
    this._element = element;
  }
  _connectParent(item) {
    const prevParent = item.parent;
    if (prevParent && prevParent !== this._element) {
      const prevChildList = item.parent.childList;
      const index = prevChildList.getIndex(item);
      if (item.ref) {
        prevChildList._refs[item.ref] = void 0;
      }
      prevChildList._items.splice(index, 1);
      prevParent.core.removeChildAt(index);
    }
    item._setParent(this._element);
  }
  onAdd(item, index) {
    this._connectParent(item);
    this._element.core.addChildAt(index, item.core);
  }
  onRemove(item, index) {
    item._setParent(null);
    this._element.core.removeChildAt(index);
  }
  onSync(removed, added, order) {
    for (let i = 0, n = removed.length; i < n; i++) {
      removed[i]._setParent(null);
    }
    for (let i = 0, n = added.length; i < n; i++) {
      this._connectParent(added[i]);
    }
    let gc = (i) => i.core;
    this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
  }
  onSet(item, index, prevItem) {
    prevItem._setParent(null);
    this._connectParent(item);
    this._element.core.setChildAt(index, item.core);
  }
  onMove(item, fromIndex, toIndex) {
    this._element.core.moveChild(fromIndex, toIndex);
  }
  createItem(object) {
    if (object.type) {
      return new object.type(this._element.stage);
    } else {
      return this._element.stage.createElement();
    }
  }
  isItem(object) {
    return object.isElement;
  }
}
let Element$1 = class Element2 {
  constructor(stage2) {
    this.stage = stage2;
    this.__id = Element2.id++;
    this.__start();
    this._hasEventListeners = false;
    this.__core = new ElementCore(this);
    this.__ref = null;
    this.__attached = false;
    this.__enabled = false;
    this.__active = false;
    this.__parent = null;
    this.__texture = null;
    this.__displayedTexture = null;
    this.__tags = null;
    this.__treeTags = null;
    this.__tagRoot = false;
    this.__childList = null;
    this._w = 0;
    this._h = 0;
  }
  __start() {
  }
  get id() {
    return this.__id;
  }
  set ref(ref) {
    if (this.__ref !== ref) {
      const charcode = ref.charCodeAt(0);
      if (!Utils$2.isUcChar(charcode)) {
        this._throwError("Ref must start with an upper case character: " + ref);
      }
      if (this.__ref !== null) {
        this.removeTag(this.__ref);
        if (this.__parent) {
          this.__parent.__childList.clearRef(this.__ref);
        }
      }
      this.__ref = ref;
      if (this.__ref) {
        this._addTag(this.__ref);
        if (this.__parent) {
          this.__parent.__childList.setRef(this.__ref, this);
        }
      }
    }
  }
  get ref() {
    return this.__ref;
  }
  get core() {
    return this.__core;
  }
  setAsRoot() {
    this.__core.setAsRoot();
    this._updateAttachedFlag();
    this._updateEnabledFlag();
  }
  get isRoot() {
    return this.__core.isRoot;
  }
  _setParent(parent) {
    if (this.__parent === parent)
      return;
    if (this.__parent) {
      this._unsetTagsParent();
    }
    this.__parent = parent;
    if (parent) {
      this._setTagsParent();
    }
    this._updateAttachedFlag();
    this._updateEnabledFlag();
    this._updateCollision();
    if (this.isRoot && parent) {
      this._throwError("Root should not be added as a child! Results are unspecified!");
    }
  }
  getDepth() {
    let depth = 0;
    let p = this.__parent;
    while (p) {
      depth++;
      p = p.__parent;
    }
    return depth;
  }
  getAncestor(l) {
    let p = this;
    while (l > 0 && p.__parent) {
      p = p.__parent;
      l--;
    }
    return p;
  }
  getAncestors() {
    const a = [];
    let p = this;
    while (p) {
      a.push(p);
      p = p.__parent;
    }
    return a;
  }
  getAncestorAtDepth(depth) {
    let levels = this.getDepth() - depth;
    if (levels < 0) {
      return null;
    }
    return this.getAncestor(levels);
  }
  isAncestorOf(c) {
    let p = c;
    while (p = p.parent) {
      if (this === p) {
        return true;
      }
    }
    return false;
  }
  getSharedAncestor(c) {
    let o1 = this;
    let o2 = c;
    let l1 = o1.getDepth();
    let l2 = o2.getDepth();
    if (l1 > l2) {
      o1 = o1.getAncestor(l1 - l2);
    } else if (l2 > l1) {
      o2 = o2.getAncestor(l2 - l1);
    }
    do {
      if (o1 === o2) {
        return o1;
      }
      o1 = o1.__parent;
      o2 = o2.__parent;
    } while (o1 && o2);
    return null;
  }
  get attached() {
    return this.__attached;
  }
  get enabled() {
    return this.__enabled;
  }
  get active() {
    return this.__active;
  }
  _isAttached() {
    return this.__parent ? this.__parent.__attached : this.stage.root === this;
  }
  _isEnabled() {
    return this.__core.visible && this.__core.alpha > 0 && (this.__parent ? this.__parent.__enabled : this.stage.root === this);
  }
  _isActive() {
    return this._isEnabled() && this.withinBoundsMargin;
  }
  /**
   * Updates the 'attached' flag for this branch.
   */
  _updateAttachedFlag() {
    let newAttached = this._isAttached();
    if (this.__attached !== newAttached) {
      this.__attached = newAttached;
      if (newAttached) {
        this._onSetup();
      }
      let children = this._children.get();
      if (children) {
        let m = children.length;
        if (m > 0) {
          for (let i = 0; i < m; i++) {
            children[i]._updateAttachedFlag();
          }
        }
      }
      if (newAttached) {
        this._onAttach();
      } else {
        this._onDetach();
      }
    }
  }
  /**
   * Updates the 'enabled' flag for this branch.
   */
  _updateEnabledFlag() {
    let newEnabled = this._isEnabled();
    if (this.__enabled !== newEnabled) {
      if (newEnabled) {
        this._onEnabled();
        this._setEnabledFlag();
      } else {
        this._onDisabled();
        this._unsetEnabledFlag();
      }
      let children = this._children.get();
      if (children) {
        let m = children.length;
        if (m > 0) {
          for (let i = 0; i < m; i++) {
            children[i]._updateEnabledFlag();
          }
        }
      }
    }
  }
  _setEnabledFlag() {
    this.__enabled = true;
    this._updateDimensions();
    this._updateTextureCoords();
    if (this.__texture) {
      this.__texture.addElement(this);
    }
    if (this.withinBoundsMargin) {
      this._setActiveFlag();
    }
    if (this.__core.shader) {
      this.__core.shader.addElement(this.__core);
    }
  }
  _unsetEnabledFlag() {
    if (this.__active) {
      this._unsetActiveFlag();
    }
    if (this.__texture) {
      this.__texture.removeElement(this);
    }
    if (this.__core.shader) {
      this.__core.shader.removeElement(this.__core);
    }
    if (this._texturizer) {
      this.texturizer.filters.forEach((filter2) => filter2.removeElement(this.__core));
    }
    this.__enabled = false;
  }
  _setActiveFlag() {
    this.__active = true;
    if (this.__texture) {
      this.__texture.incActiveCount();
    }
    if (this.__texture) {
      this._enableTexture();
    }
    this._onActive();
  }
  _unsetActiveFlag() {
    if (this.__texture) {
      this.__texture.decActiveCount();
    }
    this.__active = false;
    if (this.__texture) {
      this._disableTexture();
    }
    if (this._hasTexturizer()) {
      this.texturizer.deactivate();
    }
    this._onInactive();
  }
  _onSetup() {
  }
  _onAttach() {
  }
  _onDetach() {
  }
  _onEnabled() {
  }
  _onDisabled() {
  }
  _onActive() {
  }
  _onInactive() {
  }
  _onResize() {
  }
  _getRenderWidth() {
    if (this._w) {
      return this._w;
    } else if (this.__displayedTexture) {
      return this.__displayedTexture.getRenderWidth();
    } else if (this.__texture) {
      return this.__texture.getRenderWidth();
    } else {
      return 0;
    }
  }
  _getRenderHeight() {
    if (this._h) {
      return this._h;
    } else if (this.__displayedTexture) {
      return this.__displayedTexture.getRenderHeight();
    } else if (this.__texture) {
      return this.__texture.getRenderHeight();
    } else {
      return 0;
    }
  }
  get renderWidth() {
    if (this.__enabled) {
      return this.__core.getRenderWidth();
    } else {
      return this._getRenderWidth();
    }
  }
  get renderHeight() {
    if (this.__enabled) {
      return this.__core.getRenderHeight();
    } else {
      return this._getRenderHeight();
    }
  }
  get finalX() {
    return this.__core.x;
  }
  get finalY() {
    return this.__core.y;
  }
  get finalW() {
    return this.__core.w;
  }
  get finalH() {
    return this.__core.h;
  }
  textureIsLoaded() {
    return this.__texture && this.__texture.isLoaded();
  }
  loadTexture() {
    if (this.__texture) {
      this.__texture.load();
      if (!this.__texture.isUsed() || !this._isEnabled()) {
        this._updateDimensions();
      }
    }
  }
  _enableTextureError() {
    const loadError = this.__texture.loadError;
    if (loadError) {
      this.emit("txError", loadError, this.__texture._source);
    }
  }
  _enableTexture() {
    if (this.__texture.isLoaded()) {
      this._setDisplayedTexture(this.__texture);
    } else {
      this._setDisplayedTexture(null);
      this._enableTextureError();
    }
  }
  _disableTexture() {
    this._setDisplayedTexture(null);
  }
  get texture() {
    return this.__texture;
  }
  set texture(v) {
    let texture;
    if (Utils$2.isObjectLiteral(v)) {
      if (v.type) {
        texture = new v.type(this.stage);
      } else {
        texture = this.texture;
      }
      if (texture) {
        Base.patchObject(texture, v);
      }
    } else if (!v) {
      texture = null;
    } else {
      if (v.isTexture) {
        texture = v;
      } else if (v.isTextureSource) {
        texture = new SourceTexture(this.stage);
        texture.textureSource = v;
      } else {
        console.error("[Lightning] Please specify a texture type.");
        return;
      }
    }
    const prevTexture = this.__texture;
    if (texture !== prevTexture) {
      this.__texture = texture;
      if (this.__texture) {
        if (this.__enabled) {
          this.__texture.addElement(this);
          if (this.withinBoundsMargin) {
            if (this.__texture.isLoaded()) {
              this._setDisplayedTexture(this.__texture);
            } else {
              this._enableTextureError();
            }
          }
        }
      } else {
        this._setDisplayedTexture(null);
      }
      if (prevTexture && prevTexture !== this.__displayedTexture) {
        prevTexture.removeElement(this);
      }
      this._updateDimensions();
    }
  }
  get displayedTexture() {
    return this.__displayedTexture;
  }
  _setDisplayedTexture(v) {
    let prevTexture = this.__displayedTexture;
    if (prevTexture && v !== prevTexture) {
      if (this.__texture !== prevTexture) {
        prevTexture.removeElement(this);
      }
    }
    const prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
    const sourceChanged = (v ? v._source : null) !== prevSource;
    this.__displayedTexture = v;
    this._updateDimensions();
    if (this.__displayedTexture) {
      if (sourceChanged) {
        this._updateTextureCoords();
        this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
      }
    } else {
      this.__core.setDisplayedTextureSource(null);
    }
    if (sourceChanged) {
      if (this.__displayedTexture) {
        this.emit("txLoaded", this.__displayedTexture);
      } else {
        this.emit("txUnloaded", this.__displayedTexture);
      }
    }
  }
  onTextureSourceLoaded() {
    if (this.active) {
      this._setDisplayedTexture(this.__texture);
    }
  }
  onTextureSourceLoadError(e) {
    this.emit("txError", e, this.__texture._source);
  }
  forceRenderUpdate() {
    this.__core.setHasRenderUpdates(3);
  }
  onDisplayedTextureClippingChanged() {
    this._updateDimensions();
    this._updateTextureCoords();
  }
  onPrecisionChanged() {
    this._updateDimensions();
  }
  onDimensionsChanged(w, h) {
    if (this.texture instanceof TextTexture) {
      this.texture.w = w;
      this.texture.h = h;
      this.w = w;
      this.h = h;
    }
  }
  _updateDimensions() {
    let w = this._getRenderWidth();
    let h = this._getRenderHeight();
    let unknownSize = false;
    if (!w || !h) {
      if (!this.__displayedTexture && this.__texture) {
        w = w || this.__texture.mw;
        h = h || this.__texture.mh;
        if ((!w || !h) && this.__texture.isAutosizeTexture()) {
          unknownSize = true;
        }
      }
    }
    if (this.__core.setDimensions(w, h, unknownSize)) {
      this._onResize();
    }
  }
  _updateTextureCoords() {
    if (this.displayedTexture && this.displayedTexture._source) {
      let displayedTexture = this.displayedTexture;
      let displayedTextureSource = this.displayedTexture._source;
      let tx1 = 0, ty1 = 0, tx2 = 1, ty2 = 1;
      if (displayedTexture.clipping) {
        let w = displayedTextureSource.getRenderWidth();
        let h = displayedTextureSource.getRenderHeight();
        let iw, ih, rw, rh;
        iw = 1 / w;
        ih = 1 / h;
        if (displayedTexture.pw) {
          rw = displayedTexture.pw * iw;
        } else {
          rw = (w - displayedTexture.px) * iw;
        }
        if (displayedTexture.ph) {
          rh = displayedTexture.ph * ih;
        } else {
          rh = (h - displayedTexture.py) * ih;
        }
        iw *= displayedTexture.px;
        ih *= displayedTexture.py;
        tx1 = iw;
        ty1 = ih;
        tx2 = tx2 * rw + iw;
        ty2 = ty2 * rh + ih;
        tx1 = Math.max(0, tx1);
        ty1 = Math.max(0, ty1);
        tx2 = Math.min(1, tx2);
        ty2 = Math.min(1, ty2);
      }
      if (displayedTextureSource._flipTextureY) {
        let tempty = ty2;
        ty2 = ty1;
        ty1 = tempty;
      }
      this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
    }
  }
  getCornerPoints() {
    return this.__core.getCornerPoints();
  }
  _unsetTagsParent() {
    if (this.__tags) {
      this.__tags.forEach((tag) => {
        let p = this;
        while (p = p.__parent) {
          let parentTreeTags = p.__treeTags.get(tag);
          parentTreeTags.delete(this);
          if (p.__tagRoot) {
            break;
          }
        }
      });
    }
    let tags = null;
    let n = 0;
    if (this.__treeTags) {
      if (!this.__tagRoot) {
        tags = Utils$2.iteratorToArray(this.__treeTags.keys());
        n = tags.length;
        if (n > 0) {
          for (let i = 0; i < n; i++) {
            let tagSet = this.__treeTags.get(tags[i]);
            let p = this;
            while (p = p.__parent) {
              let parentTreeTags = p.__treeTags.get(tags[i]);
              tagSet.forEach(function(comp) {
                parentTreeTags.delete(comp);
              });
              if (p.__tagRoot) {
                break;
              }
            }
          }
        }
      }
    }
  }
  _setTagsParent() {
    if (this.__tags) {
      this.__tags.forEach((tag) => {
        let p = this;
        while (p = p.__parent) {
          if (!p.__treeTags) {
            p.__treeTags = /* @__PURE__ */ new Map();
          }
          let s = p.__treeTags.get(tag);
          if (!s) {
            s = /* @__PURE__ */ new Set();
            p.__treeTags.set(tag, s);
          }
          s.add(this);
          if (p.__tagRoot) {
            break;
          }
        }
      });
    }
    if (this.__treeTags && this.__treeTags.size) {
      if (!this.__tagRoot) {
        this.__treeTags.forEach((tagSet, tag) => {
          let p = this;
          while (!p.__tagRoot && (p = p.__parent)) {
            if (p.__tagRoot)
              ;
            if (!p.__treeTags) {
              p.__treeTags = /* @__PURE__ */ new Map();
            }
            let s = p.__treeTags.get(tag);
            if (!s) {
              s = /* @__PURE__ */ new Set();
              p.__treeTags.set(tag, s);
            }
            tagSet.forEach(function(comp) {
              s.add(comp);
            });
          }
        });
      }
    }
  }
  _getByTag(tag) {
    if (!this.__treeTags) {
      return [];
    }
    let t = this.__treeTags.get(tag);
    return t ? Utils$2.setToArray(t) : [];
  }
  getTags() {
    return this.__tags ? this.__tags : [];
  }
  setTags(tags) {
    tags = tags.reduce((acc, tag) => {
      return acc.concat(tag.split(" "));
    }, []);
    if (this.__ref) {
      tags.push(this.__ref);
    }
    let i, n = tags.length;
    let removes = [];
    let adds = [];
    for (i = 0; i < n; i++) {
      if (!this.hasTag(tags[i])) {
        adds.push(tags[i]);
      }
    }
    let currentTags = this.tags || [];
    n = currentTags.length;
    for (i = 0; i < n; i++) {
      if (tags.indexOf(currentTags[i]) == -1) {
        removes.push(currentTags[i]);
      }
    }
    for (i = 0; i < removes.length; i++) {
      this.removeTag(removes[i]);
    }
    for (i = 0; i < adds.length; i++) {
      this.addTag(adds[i]);
    }
  }
  addTag(tag) {
    if (tag.indexOf(" ") === -1) {
      if (Utils$2.isUcChar(tag.charCodeAt(0))) {
        this._throwError("Tag may not start with an upper case character.");
      }
      this._addTag(tag);
    } else {
      const tags = tag.split(" ");
      for (let i = 0, m = tags.length; i < m; i++) {
        const tag2 = tags[i];
        if (Utils$2.isUcChar(tag2.charCodeAt(0))) {
          this._throwError("Tag may not start with an upper case character.");
        }
        this._addTag(tag2);
      }
    }
  }
  _addTag(tag) {
    if (!this.__tags) {
      this.__tags = [];
    }
    if (this.__tags.indexOf(tag) === -1) {
      this.__tags.push(tag);
      let p = this.__parent;
      if (p) {
        do {
          if (!p.__treeTags) {
            p.__treeTags = /* @__PURE__ */ new Map();
          }
          let s = p.__treeTags.get(tag);
          if (!s) {
            s = /* @__PURE__ */ new Set();
            p.__treeTags.set(tag, s);
          }
          s.add(this);
        } while (!p.__tagRoot && (p = p.__parent));
      }
    }
  }
  removeTag(tag) {
    let i = this.__tags.indexOf(tag);
    if (i !== -1) {
      this.__tags.splice(i, 1);
      let p = this.__parent;
      if (p) {
        do {
          let list = p.__treeTags.get(tag);
          if (list) {
            list.delete(this);
          }
        } while (!p.__tagRoot && (p = p.__parent));
      }
    }
  }
  hasTag(tag) {
    return this.__tags && this.__tags.indexOf(tag) !== -1;
  }
  /**
   * Returns one of the elements from the subtree that have this tag.
   * @param {string} tag
   * @returns {Element}
   */
  _tag(tag) {
    if (tag.indexOf(".") !== -1) {
      return this.mtag(tag)[0];
    } else {
      if (this.__treeTags) {
        let t = this.__treeTags.get(tag);
        if (t) {
          const item = t.values().next();
          return item ? item.value : void 0;
        }
      }
    }
  }
  get tag() {
    return this._tag;
  }
  set tag(t) {
    this.tags = t;
  }
  /**
   * Returns all elements from the subtree that have this tag.
   * @param {string} tag
   * @returns {Element[]}
   */
  mtag(tag) {
    let idx = tag.indexOf(".");
    if (idx >= 0) {
      let parts = tag.split(".");
      let res = this._getByTag(parts[0]);
      let level = 1;
      let c = parts.length;
      while (res.length && level < c) {
        let resn = [];
        for (let j = 0, n = res.length; j < n; j++) {
          resn = resn.concat(res[j]._getByTag(parts[level]));
        }
        res = resn;
        level++;
      }
      return res;
    } else {
      return this._getByTag(tag);
    }
  }
  stag(tag, settings2) {
    let t = this.mtag(tag);
    let n = t.length;
    for (let i = 0; i < n; i++) {
      Base.patchObject(t[i], settings2);
    }
  }
  get tagRoot() {
    return this.__tagRoot;
  }
  set tagRoot(v) {
    if (this.__tagRoot !== v) {
      if (!v) {
        this._setTagsParent();
      } else {
        this._unsetTagsParent();
      }
      this.__tagRoot = v;
    }
  }
  sel(path) {
    const results = this.select(path);
    if (results.length) {
      return results[0];
    } else {
      return void 0;
    }
  }
  select(path) {
    if (path.indexOf(",") !== -1) {
      let selectors = path.split(",");
      let res = [];
      for (let i = 0; i < selectors.length; i++) {
        res = res.concat(this._select(selectors[i]));
      }
      return res;
    } else {
      return this._select(path);
    }
  }
  _select(path) {
    if (path === "")
      return [this];
    let pointIdx = path.indexOf(".");
    let arrowIdx = path.indexOf(">");
    if (pointIdx === -1 && arrowIdx === -1) {
      return this.mtag(path);
    }
    let isRef;
    if (arrowIdx === 0) {
      isRef = true;
      path = path.substr(1);
    } else if (pointIdx === 0) {
      isRef = false;
      path = path.substr(1);
    } else {
      isRef = false;
    }
    return this._selectChilds(path, isRef);
  }
  _selectChilds(path, isRef) {
    const pointIdx = path.indexOf(".");
    const arrowIdx = path.indexOf(">");
    if (pointIdx === -1 && arrowIdx === -1) {
      if (isRef) {
        const ref = this.getByRef(path);
        return ref ? [ref] : [];
      } else {
        return this.mtag(path);
      }
    }
    if (arrowIdx === -1 || pointIdx !== -1 && pointIdx < arrowIdx) {
      let next;
      const str = path.substr(0, pointIdx);
      if (isRef) {
        const ref = this.getByRef(str);
        next = ref ? [ref] : [];
      } else {
        next = this.mtag(str);
      }
      let total = [];
      const subPath = path.substr(pointIdx + 1);
      for (let i = 0, n = next.length; i < n; i++) {
        total = total.concat(next[i]._selectChilds(subPath, false));
      }
      return total;
    } else {
      let next;
      const str = path.substr(0, arrowIdx);
      if (isRef) {
        const ref = this.getByRef(str);
        next = ref ? [ref] : [];
      } else {
        next = this.mtag(str);
      }
      let total = [];
      const subPath = path.substr(arrowIdx + 1);
      for (let i = 0, n = next.length; i < n; i++) {
        total = total.concat(next[i]._selectChilds(subPath, true));
      }
      return total;
    }
  }
  getByRef(ref) {
    return this.childList.getByRef(ref);
  }
  getLocationString() {
    let i;
    i = this.__parent ? this.__parent._children.getIndex(this) : "R";
    let localTags = this.getTags();
    let str = this.__parent ? this.__parent.getLocationString() : "";
    if (this.ref) {
      str += ":[" + i + "]" + this.ref;
    } else if (localTags.length) {
      str += ":[" + i + "]" + localTags.join(",");
    } else {
      str += ":[" + i + "]#" + this.id;
    }
    return str;
  }
  toString() {
    let obj = this.getSettings();
    return Element2.getPrettyString(obj, "");
  }
  static getPrettyString(obj, indent) {
    let children = obj.children;
    delete obj.children;
    let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
    let str = JSON.stringify(obj, function(k, v) {
      if (colorKeys.indexOf(k) !== -1) {
        return "COLOR[" + v.toString(16) + "]";
      }
      return v;
    });
    str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");
    if (children) {
      let childStr = "";
      if (Utils$2.isObjectLiteral(children)) {
        let refs = Object.keys(children);
        childStr = "";
        for (let i = 0, n = refs.length; i < n; i++) {
          childStr += `
${indent}  "${refs[i]}":`;
          delete children[refs[i]].ref;
          childStr += Element2.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
        }
        let isEmpty = str === "{}";
        str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
      } else {
        let n = children.length;
        childStr = "[";
        for (let i = 0; i < n; i++) {
          childStr += Element2.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
        }
        childStr += indent + "]}";
        let isEmpty = str === "{}";
        str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + '"children":\n' + indent + childStr + "}";
      }
    }
    return str;
  }
  getSettings() {
    let settings2 = this.getNonDefaults();
    let children = this._children.get();
    if (children) {
      let n = children.length;
      if (n) {
        const childArray = [];
        let missing = false;
        for (let i = 0; i < n; i++) {
          childArray.push(children[i].getSettings());
          missing = missing || !children[i].ref;
        }
        if (!missing) {
          settings2.children = {};
          childArray.forEach((child) => {
            settings2.children[child.ref] = child;
          });
        } else {
          settings2.children = childArray;
        }
      }
    }
    settings2.id = this.id;
    return settings2;
  }
  getNonDefaults() {
    let settings2 = {};
    if (this.constructor !== Element2) {
      settings2.type = this.constructor.name;
    }
    if (this.__ref) {
      settings2.ref = this.__ref;
    }
    if (this.__tags && this.__tags.length) {
      settings2.tags = this.__tags;
    }
    if (this.x !== 0)
      settings2.x = this.x;
    if (this.y !== 0)
      settings2.y = this.y;
    if (this.w !== 0)
      settings2.w = this.w;
    if (this.h !== 0)
      settings2.h = this.h;
    if (this.scaleX === this.scaleY) {
      if (this.scaleX !== 1)
        settings2.scale = this.scaleX;
    } else {
      if (this.scaleX !== 1)
        settings2.scaleX = this.scaleX;
      if (this.scaleY !== 1)
        settings2.scaleY = this.scaleY;
    }
    if (this.pivotX === this.pivotY) {
      if (this.pivotX !== 0.5)
        settings2.pivot = this.pivotX;
    } else {
      if (this.pivotX !== 0.5)
        settings2.pivotX = this.pivotX;
      if (this.pivotY !== 0.5)
        settings2.pivotY = this.pivotY;
    }
    if (this.mountX === this.mountY) {
      if (this.mountX !== 0)
        settings2.mount = this.mountX;
    } else {
      if (this.mountX !== 0)
        settings2.mountX = this.mountX;
      if (this.mountY !== 0)
        settings2.mountY = this.mountY;
    }
    if (this.alpha !== 1)
      settings2.alpha = this.alpha;
    if (!this.visible)
      settings2.visible = false;
    if (this.rotation !== 0)
      settings2.rotation = this.rotation;
    if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
      if (this.colorUl !== 4294967295)
        settings2.color = this.colorUl.toString(16);
    } else {
      if (this.colorUl !== 4294967295)
        settings2.colorUl = this.colorUl.toString(16);
      if (this.colorUr !== 4294967295)
        settings2.colorUr = this.colorUr.toString(16);
      if (this.colorBl !== 4294967295)
        settings2.colorBl = this.colorBl.toString(16);
      if (this.colorBr !== 4294967295)
        settings2.colorBr = this.colorBr.toString(16);
    }
    if (this.zIndex)
      settings2.zIndex = this.zIndex;
    if (this.forceZIndexContext)
      settings2.forceZIndexContext = true;
    if (this.clipping)
      settings2.clipping = this.clipping;
    if (!this.clipbox)
      settings2.clipbox = this.clipbox;
    if (this.__texture) {
      let tnd = this.__texture.getNonDefaults();
      if (Object.keys(tnd).length) {
        settings2.texture = tnd;
      }
    }
    if (this.shader && Utils$2.isFunction(this.shader.getNonDefaults)) {
      let tnd = this.shader.getNonDefaults();
      if (Object.keys(tnd).length) {
        settings2.shader = tnd;
      }
    }
    if (this._hasTexturizer()) {
      if (this.texturizer.enabled) {
        settings2.renderToTexture = this.texturizer.enabled;
      }
      if (this.texturizer.lazy) {
        settings2.renderToTextureLazy = this.texturizer.lazy;
      }
      if (this.texturizer.colorize) {
        settings2.colorizeResultTexture = this.texturizer.colorize;
      }
      if (this.texturizer.renderOffscreen) {
        settings2.renderOffscreen = this.texturizer.renderOffscreen;
      }
    }
    return settings2;
  }
  static getGetter(propertyPath) {
    let getter = Element2.PROP_GETTERS.get(propertyPath);
    if (!getter) {
      getter = new Function("obj", "return obj." + propertyPath);
      Element2.PROP_GETTERS.set(propertyPath, getter);
    }
    return getter;
  }
  static getSetter(propertyPath) {
    let setter = Element2.PROP_SETTERS.get(propertyPath);
    if (!setter) {
      setter = new Function("obj", "v", "obj." + propertyPath + " = v");
      Element2.PROP_SETTERS.set(propertyPath, setter);
    }
    return setter;
  }
  get withinBoundsMargin() {
    return this.__core._withinBoundsMargin;
  }
  _enableWithinBoundsMargin() {
    if (this.__enabled) {
      this._setActiveFlag();
    }
  }
  _disableWithinBoundsMargin() {
    if (this.__active) {
      this._unsetActiveFlag();
    }
  }
  set boundsMargin(v) {
    if (!Array.isArray(v) && v !== null) {
      throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
    }
    this.__core.boundsMargin = v;
  }
  get boundsMargin() {
    return this.__core.boundsMargin;
  }
  get x() {
    return this.__core.offsetX;
  }
  set x(v) {
    this.__core.offsetX = v;
  }
  get y() {
    return this.__core.offsetY;
  }
  set y(v) {
    this.__core.offsetY = v;
  }
  get w() {
    return this._w;
  }
  set w(v) {
    if (Utils$2.isFunction(v)) {
      this._w = 0;
      this.__core.funcW = v;
    } else {
      v = Math.max(v, 0);
      if (this._w !== v) {
        this.__core.disableFuncW();
        this._w = v;
        this._updateDimensions();
      }
    }
  }
  get h() {
    return this._h;
  }
  set h(v) {
    if (Utils$2.isFunction(v)) {
      this._h = 0;
      this.__core.funcH = v;
    } else {
      v = Math.max(v, 0);
      if (this._h !== v) {
        this.__core.disableFuncH();
        this._h = v;
        this._updateDimensions();
      }
    }
  }
  get collision() {
    return this._collision;
  }
  set collision(v) {
    this._collision = v;
  }
  _updateCollision() {
    if (this.collision && this.__parent && this.__parent.collision === void 0) {
      this.__parent.collision = 2;
    }
  }
  get scaleX() {
    return this.__core.scaleX;
  }
  set scaleX(v) {
    this.__core.scaleX = v;
  }
  get scaleY() {
    return this.__core.scaleY;
  }
  set scaleY(v) {
    this.__core.scaleY = v;
  }
  get scale() {
    return this.__core.scale;
  }
  set scale(v) {
    this.__core.scale = v;
  }
  get pivotX() {
    return this.__core.pivotX;
  }
  set pivotX(v) {
    this.__core.pivotX = v;
  }
  get pivotY() {
    return this.__core.pivotY;
  }
  set pivotY(v) {
    this.__core.pivotY = v;
  }
  get pivot() {
    return this.__core.pivot;
  }
  set pivot(v) {
    this.__core.pivot = v;
  }
  get mountX() {
    return this.__core.mountX;
  }
  set mountX(v) {
    this.__core.mountX = v;
  }
  get mountY() {
    return this.__core.mountY;
  }
  set mountY(v) {
    this.__core.mountY = v;
  }
  get mount() {
    return this.__core.mount;
  }
  set mount(v) {
    this.__core.mount = v;
  }
  get rotation() {
    return this.__core.rotation;
  }
  set rotation(v) {
    this.__core.rotation = v;
  }
  get alpha() {
    return this.__core.alpha;
  }
  set alpha(v) {
    this.__core.alpha = v;
  }
  get visible() {
    return this.__core.visible;
  }
  set visible(v) {
    this.__core.visible = v;
  }
  get colorUl() {
    return this.__core.colorUl;
  }
  set colorUl(v) {
    this.__core.colorUl = v;
  }
  get colorUr() {
    return this.__core.colorUr;
  }
  set colorUr(v) {
    this.__core.colorUr = v;
  }
  get colorBl() {
    return this.__core.colorBl;
  }
  set colorBl(v) {
    this.__core.colorBl = v;
  }
  get colorBr() {
    return this.__core.colorBr;
  }
  set colorBr(v) {
    this.__core.colorBr = v;
  }
  get color() {
    return this.__core.colorUl;
  }
  set color(v) {
    if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
      this.colorUl = v;
      this.colorUr = v;
      this.colorBl = v;
      this.colorBr = v;
    }
  }
  get colorTop() {
    return this.colorUl;
  }
  set colorTop(v) {
    if (this.colorUl !== v || this.colorUr !== v) {
      this.colorUl = v;
      this.colorUr = v;
    }
  }
  get colorBottom() {
    return this.colorBl;
  }
  set colorBottom(v) {
    if (this.colorBl !== v || this.colorBr !== v) {
      this.colorBl = v;
      this.colorBr = v;
    }
  }
  get colorLeft() {
    return this.colorUl;
  }
  set colorLeft(v) {
    if (this.colorUl !== v || this.colorBl !== v) {
      this.colorUl = v;
      this.colorBl = v;
    }
  }
  get colorRight() {
    return this.colorUr;
  }
  set colorRight(v) {
    if (this.colorUr !== v || this.colorBr !== v) {
      this.colorUr = v;
      this.colorBr = v;
    }
  }
  get zIndex() {
    return this.__core.zIndex;
  }
  set zIndex(v) {
    this.__core.zIndex = v;
  }
  get forceZIndexContext() {
    return this.__core.forceZIndexContext;
  }
  set forceZIndexContext(v) {
    this.__core.forceZIndexContext = v;
  }
  get clipping() {
    return this.__core.clipping;
  }
  set clipping(v) {
    this.__core.clipping = v;
  }
  get clipbox() {
    return this.__core.clipbox;
  }
  set clipbox(v) {
    this.__core.clipbox = v;
  }
  get tags() {
    return this.getTags();
  }
  set tags(v) {
    if (!Array.isArray(v))
      v = [v];
    this.setTags(v);
  }
  set t(v) {
    this.tags = v;
  }
  get _children() {
    if (!this.__childList) {
      this.__childList = new ElementChildList(this, false);
    }
    return this.__childList;
  }
  get childList() {
    if (!this._allowChildrenAccess()) {
      this._throwError("Direct access to children is not allowed in " + this.getLocationString());
    }
    return this._children;
  }
  hasChildren() {
    return this._allowChildrenAccess() && this.__childList && this.__childList.length > 0;
  }
  _allowChildrenAccess() {
    return true;
  }
  get children() {
    return this.childList.get();
  }
  set children(children) {
    this.childList.patch(children);
  }
  add(o) {
    return this.childList.a(o);
  }
  get p() {
    return this.__parent;
  }
  get parent() {
    return this.__parent;
  }
  get src() {
    if (this.texture && this.texture instanceof ImageTexture) {
      return this.texture._src;
    } else {
      return void 0;
    }
  }
  set src(v) {
    const texture = new ImageTexture(this.stage);
    texture.src = v;
    this.texture = texture;
  }
  set mw(v) {
    if (this.texture) {
      this.texture.mw = v;
      this._updateDimensions();
    } else {
      this._throwError("Please set mw after setting a texture.");
    }
  }
  set mh(v) {
    if (this.texture) {
      this.texture.mh = v;
      this._updateDimensions();
    } else {
      this._throwError("Please set mh after setting a texture.");
    }
  }
  get rect() {
    return this.texture === this.stage.rectangleTexture;
  }
  set rect(v) {
    if (v) {
      this.texture = this.stage.rectangleTexture;
    } else {
      this.texture = null;
    }
  }
  enableTextTexture() {
    if (!this.texture || !(this.texture instanceof TextTexture)) {
      this.texture = new TextTexture(this.stage);
      if (!this.texture.w && !this.texture.h) {
        this.texture.w = this.w;
        this.texture.h = this.h;
      }
    }
    return this.texture;
  }
  get text() {
    if (this.texture && this.texture instanceof TextTexture) {
      return this.texture;
    } else {
      return null;
    }
  }
  set text(v) {
    if (!this.texture || !(this.texture instanceof TextTexture)) {
      this.enableTextTexture();
    }
    if (Utils$2.isString(v)) {
      this.texture.text = v;
    } else {
      this.texture.patch(v);
    }
  }
  set onUpdate(f) {
    this.__core.onUpdate = f;
  }
  set onAfterCalcs(f) {
    this.__core.onAfterCalcs = f;
  }
  set onAfterUpdate(f) {
    this.__core.onAfterUpdate = f;
  }
  forceUpdate() {
    this.__core._setHasUpdates();
  }
  get shader() {
    return this.__core.shader;
  }
  set shader(v) {
    if (Utils$2.isObjectLiteral(v) && !v.type) {
      if (this.shader) {
        this.shader.patch(v);
      }
    } else {
      const shader = Shader.create(this.stage, v);
      if (this.__enabled && this.__core.shader) {
        this.__core.shader.removeElement(this.__core);
      }
      this.__core.shader = shader;
      if (this.__enabled && this.__core.shader) {
        this.__core.shader.addElement(this.__core);
      }
    }
  }
  _hasTexturizer() {
    return !!this.__core._texturizer;
  }
  get renderToTexture() {
    return this.rtt;
  }
  set renderToTexture(v) {
    this.rtt = v;
  }
  get rtt() {
    return this._hasTexturizer() && this.texturizer.enabled;
  }
  set rtt(v) {
    this.texturizer.enabled = v;
  }
  get rttLazy() {
    return this._hasTexturizer() && this.texturizer.lazy;
  }
  set rttLazy(v) {
    this.texturizer.lazy = v;
  }
  get renderOffscreen() {
    return this._hasTexturizer() && this.texturizer.renderOffscreen;
  }
  set renderOffscreen(v) {
    this.texturizer.renderOffscreen = v;
  }
  get colorizeResultTexture() {
    return this._hasTexturizer() && this.texturizer.colorize;
  }
  set colorizeResultTexture(v) {
    this.texturizer.colorize = v;
  }
  getTexture() {
    return this.texturizer._getTextureSource();
  }
  get texturizer() {
    return this.__core.texturizer;
  }
  patch(settings2) {
    let paths = Object.keys(settings2);
    for (let i = 0, n = paths.length; i < n; i++) {
      let path = paths[i];
      const v = settings2[path];
      const firstCharCode = path.charCodeAt(0);
      if (Utils$2.isUcChar(firstCharCode)) {
        const child = this.getByRef(path);
        if (!child) {
          if (v !== void 0) {
            let c;
            if (Utils$2.isObjectLiteral(v)) {
              c = this.childList.createItem(v);
              c.patch(v);
            } else if (Utils$2.isObject(v)) {
              c = v;
            }
            if (c.isElement) {
              c.ref = path;
            }
            this.childList.a(c);
          }
        } else {
          if (v === void 0) {
            if (child.parent) {
              child.parent.childList.remove(child);
            }
          } else if (Utils$2.isObjectLiteral(v)) {
            child.patch(v);
          } else if (v.isElement) {
            v.ref = path;
            this.childList.replace(v, child);
          } else {
            this._throwError("Unexpected value for path: " + path);
          }
        }
      } else {
        Base.patchObjectProperty(this, path, v);
      }
    }
  }
  _throwError(message) {
    throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
  }
  animation(settings2) {
    return this.stage.animations.createAnimation(this, settings2);
  }
  transition(property, settings2 = null) {
    if (settings2 === null) {
      return this._getTransition(property);
    } else {
      this._setTransition(property, settings2);
      return null;
    }
  }
  set transitions(object) {
    let keys = Object.keys(object);
    keys.forEach((property) => {
      this.transition(property, object[property]);
    });
  }
  set smooth(object) {
    let keys = Object.keys(object);
    keys.forEach((property) => {
      let value = object[property];
      if (Array.isArray(value)) {
        this.setSmooth(property, value[0], value[1]);
      } else {
        this.setSmooth(property, value);
      }
    });
  }
  fastForward(property) {
    if (this._transitions) {
      let t = this._transitions[property];
      if (t && t.isTransition) {
        t.finish();
      }
    }
  }
  _getTransition(property) {
    if (!this._transitions) {
      this._transitions = {};
    }
    let t = this._transitions[property];
    if (!t) {
      t = new Transition(this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
    } else if (t.isTransitionSettings) {
      t = new Transition(
        this.stage.transitions,
        t,
        this,
        property
      );
    }
    this._transitions[property] = t;
    return t;
  }
  _setTransition(property, settings2) {
    if (!settings2) {
      this._removeTransition(property);
    } else {
      if (Utils$2.isObjectLiteral(settings2)) {
        settings2 = this.stage.transitions.createSettings(settings2);
      }
      if (!this._transitions) {
        this._transitions = {};
      }
      let current = this._transitions[property];
      if (current && current.isTransition) {
        current.settings = settings2;
        return current;
      } else {
        this._transitions[property] = settings2;
      }
    }
  }
  _removeTransition(property) {
    if (this._transitions) {
      delete this._transitions[property];
    }
  }
  getSmooth(property, v) {
    let t = this._getTransition(property);
    if (t && t.isAttached()) {
      return t.targetValue;
    } else {
      return v;
    }
  }
  setSmooth(property, v, settings2) {
    if (settings2) {
      this._setTransition(property, settings2);
    }
    let t = this._getTransition(property);
    t.start(v);
    return t;
  }
  get flex() {
    return this.__core.flex;
  }
  set flex(v) {
    this.__core.flex = v;
  }
  get flexItem() {
    return this.__core.flexItem;
  }
  set flexItem(v) {
    this.__core.flexItem = v;
  }
  static isColorProperty(property) {
    return property.toLowerCase().indexOf("color") >= 0;
  }
  static getMerger(property) {
    if (Element2.isColorProperty(property)) {
      return StageUtils.mergeColors;
    } else {
      return StageUtils.mergeNumbers;
    }
  }
  toJSON() {
    const ref = [`${this.constructor.name}`];
    const tree = {};
    tree[ref] = {};
    if (this.hasChildren()) {
      Element2.collectChildren(tree[ref], this.__childList);
    } else {
      tree[ref] = { ...Element2.getProperties(this) };
    }
    return tree;
  }
  static collectChildren(tree, children) {
    const childList = children;
    for (let i = 0, j = childList.length; i < j; i++) {
      const element = childList.getAt(i);
      const ref = `${element.__ref || `Element-${element.id}`}`;
      const properties = this.getProperties(element);
      tree[ref] = { ...properties };
      if (element.hasChildren()) {
        tree[ref].children = {};
        this.collectChildren(
          tree[ref].children,
          element.__childList
        );
      }
    }
  }
  static getProperties(element) {
    const props = {};
    const list = [
      "alpha",
      "active",
      "attached",
      "boundsMargin",
      "color",
      "clipping",
      "enabled",
      "h",
      "id",
      "isComponent",
      "mount",
      "mountY",
      "mountX",
      "pivot",
      "pivotX",
      "pivotY",
      "ref",
      "renderOfScreen",
      "renderToTexture",
      "scale",
      "scaleX",
      "scaleY",
      "state",
      "tag",
      "visible",
      "w",
      "x",
      "y",
      "zIndex",
      "!!flex",
      "!!flexItem",
      "hasFocus()",
      "hasFinalFocus()"
    ];
    let n = list.length;
    while (n--) {
      let key = list[n];
      const getBoolean = /^!{2}/;
      const isFunction2 = /\(\)$/;
      if (getBoolean.test(key)) {
        key = key.substring(2, key.length);
        props[key] = !!element[key];
      } else if (isFunction2.test(key)) {
        key = key.substring(0, key.length - 2);
        if (typeof element[key] === "function") {
          props[key] = element[key]();
        }
      } else {
        props[key] = element[key];
      }
    }
    return { ...props, ...element.getNonDefaults() };
  }
};
EventEmitter.addAsMixin(Element$1);
Element$1.prototype.isElement = 1;
Element$1.id = 1;
Element$1.PROP_GETTERS = /* @__PURE__ */ new Map();
Element$1.PROP_SETTERS = /* @__PURE__ */ new Map();
class StateMachine {
  constructor() {
    StateMachine.setupStateMachine(this);
  }
  static setupStateMachine(target) {
    const targetConstructor = target.constructor;
    const router = StateMachine.create(targetConstructor);
    Object.setPrototypeOf(target, router.prototype);
    target.constructor = targetConstructor;
    target._initStateMachine();
  }
  /**
   * Creates a state machine implementation.
   * It extends the original type and should be used when creating new instances.
   * The original type is available as static property 'original', and it must be used when subclassing as follows:
   * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
   * @param {Class} type
   * @returns {StateMachine}
   */
  static create(type) {
    if (!type.hasOwnProperty("_sm")) {
      const stateMachineType = new StateMachineType(type);
      type._sm = stateMachineType;
    }
    return type._sm.router;
  }
  /**
   * Calls the specified method if it exists.
   * @param {string} event
   * @param {*...} args
   */
  fire(event, ...args) {
    if (this._hasMethod(event)) {
      return this[event](...args);
    }
  }
  /**
   * Returns the current state path (for example "Initialized.Loading").
   * @returns {string}
   * @protected
   */
  _getState() {
    return this._state.__path;
  }
  /**
   * Returns true iff statePath is (an ancestor of) currentStatePath.
   * @param {string} statePath
   * @param {string} currentStatePath
   * @returns {Boolean}
   * @protected
   */
  _inState(statePath, currentStatePath = this._state.__path) {
    const state2 = this._sm.getStateByPath(statePath);
    const currentState = this._sm.getStateByPath(currentStatePath);
    const level = state2.__level;
    const stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
    return stateAtLevel === state2;
  }
  /**
   * Returns true if the specified class member is defined for the currently set state.
   * @param {string} name
   * @returns {boolean}
   * @protected
   */
  _hasMember(name2) {
    return !!this.constructor.prototype[name2];
  }
  /**
   * Returns true if the specified class member is a method for the currently set state.
   * @param {string} name
   * @returns {boolean}
   * @protected
   */
  _hasMethod(name2) {
    const member = this.constructor.prototype[name2];
    return !!member && typeof member === "function";
  }
  /**
   * Switches to the specified state.
   * @param {string} statePath
   *   Substates are seperated by a underscores (for example "Initialized.Loading").
   * @param {*[]} [args]
   *   Args that are supplied in $enter and $exit events.
   * @protected
   */
  _setState(statePath, args) {
    const setStateId = ++this._setStateCounter;
    this._setStateId = setStateId;
    if (this._state.__path !== statePath) {
      let newState = this._sm._stateMap[statePath];
      if (!newState) {
        newState = this._sm.getStateByPath(statePath);
      }
      const prevState = this._state;
      const hasDifferentEnterMethod = newState.prototype.$enter !== this._state.prototype.$enter;
      const hasDifferentExitMethod = newState.prototype.$exit !== this._state.prototype.$exit;
      if (hasDifferentEnterMethod || hasDifferentExitMethod) {
        const sharedState = StateMachine._getSharedState(this._state, newState);
        const context = {
          newState: newState.__path,
          prevState: prevState.__path,
          sharedState: sharedState.__path
        };
        const sharedLevel = sharedState.__level;
        if (hasDifferentExitMethod) {
          const exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
          for (let i = 0, n = exitStates.length; i < n; i++) {
            this.__setState(exitStates[i]);
            this._callExit(this._state, args, context);
            const stateChangeOverridden = this._setStateId !== setStateId;
            if (stateChangeOverridden) {
              return;
            }
          }
        }
        if (hasDifferentEnterMethod) {
          const enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
          for (let i = 0, n = enterStates.length; i < n; i++) {
            this.__setState(enterStates[i]);
            this._callEnter(this._state, args, context);
            const stateChangeOverridden = this._setStateId !== setStateId;
            if (stateChangeOverridden) {
              return;
            }
          }
        }
      }
      this.__setState(newState);
      if (this._changedState) {
        const context = {
          newState: newState.__path,
          prevState: prevState.__path
        };
        if (args) {
          this._changedState(context, ...args);
        } else {
          this._changedState(context);
        }
      }
      if (this._onStateChange) {
        const context = {
          newState: newState.__path,
          prevState: prevState.__path
        };
        this._onStateChange(context);
      }
    }
  }
  _callEnter(state2, args = [], context) {
    const hasParent = !!state2.__parent;
    if (state2.prototype.$enter) {
      if (!hasParent || state2.__parent.prototype.$enter !== state2.prototype.$enter) {
        state2.prototype.$enter.apply(this, [context, ...args]);
      }
    }
  }
  _callExit(state2, args = [], context) {
    const hasParent = !!state2.__parent;
    if (state2.prototype.$exit) {
      if (!hasParent || state2.__parent.prototype.$exit !== state2.prototype.$exit) {
        state2.prototype.$exit.apply(this, [context, ...args]);
      }
    }
  }
  __setState(state2) {
    this._state = state2;
    this._stateIndex = state2.__index;
    this.constructor = state2;
  }
  _initStateMachine() {
    this._state = null;
    this._stateIndex = 0;
    this._setStateCounter = 0;
    this._sm = this._routedType._sm;
    this.__setState(this._sm.getStateByPath(""));
    const context = { newState: "", prevState: void 0, sharedState: void 0 };
    this._callEnter(this._state, [], context);
    this._onStateChange = void 0;
  }
  /**
   * Between multiple member names, select the one specified in the deepest state.
   * If multiple member names are specified in the same deepest state, the first one in the array is returned.
   * @param {string[]} memberNames
   * @returns {string|undefined}
   * @protected
   */
  _getMostSpecificHandledMember(memberNames) {
    let cur = this._state;
    do {
      for (let i = 0, n = memberNames.length; i < n; i++) {
        const memberName = memberNames[i];
        if (!cur.__parent) {
          if (cur.prototype[memberName]) {
            return memberName;
          }
        } else {
          const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
          if (this[alias]) {
            return memberName;
          }
        }
      }
      cur = cur.__parent;
    } while (cur);
  }
  static _getStatesUntilLevel(state2, level) {
    const states = [];
    while (state2.__level > level) {
      states.push(state2);
      state2 = state2.__parent;
    }
    return states;
  }
  static _getSharedState(state1, state2) {
    const state1Array = StateMachine._getAncestorStates(state1);
    const state2Array = StateMachine._getAncestorStates(state2);
    const n = Math.min(state1Array.length, state2Array.length);
    for (let i = 0; i < n; i++) {
      if (state1Array[i] !== state2Array[i]) {
        return state1Array[i - 1];
      }
    }
    return state1Array[n - 1];
  }
  static _getAncestorStates(state2) {
    const result = [];
    do {
      result.push(state2);
    } while (state2 = state2.__parent);
    return result.reverse();
  }
  static _getStateAtLevel(state2, level) {
    if (level > state2.__level) {
      return void 0;
    }
    while (level < state2.__level) {
      state2 = state2.__parent;
    }
    return state2;
  }
}
class StateMachineType {
  constructor(type) {
    this._type = type;
    this._router = null;
    this.init();
  }
  get router() {
    return this._router;
  }
  init() {
    this._router = this._createRouter();
    this._stateMap = this._getStateMap();
    this._addStateMemberDelegatorsToRouter();
  }
  _createRouter() {
    const type = this._type;
    const router = class StateMachineRouter extends type {
      constructor() {
        super(...arguments);
        if (!this.constructor.hasOwnProperty("_isRouter")) {
          throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
        }
      }
    };
    router._isRouter = true;
    router.prototype._routedType = type;
    router.original = type;
    this._mixinStateMachineMethods(router);
    return router;
  }
  _mixinStateMachineMethods(router) {
    const names = Object.getOwnPropertyNames(StateMachine.prototype);
    for (let i = 0, n = names.length; i < n; i++) {
      const name2 = names[i];
      if (name2 !== "constructor") {
        const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name2);
        Object.defineProperty(router.prototype, name2, descriptor);
      }
    }
  }
  _addStateMemberDelegatorsToRouter() {
    const members = this._getAllMemberNames();
    members.forEach((member) => {
      this._addMemberRouter(member);
    });
  }
  /**
   * @note We are generating code because it yields much better performance.
   */
  _addMemberRouter(member) {
    const statePaths = Object.keys(this._stateMap);
    const descriptors2 = [];
    const aliases = [];
    statePaths.forEach((statePath, index) => {
      const state2 = this._stateMap[statePath];
      const descriptor = this._getDescriptor(state2, member);
      if (descriptor) {
        descriptors2[index] = descriptor;
        const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
        aliases[index] = alias;
        if (!this._router.prototype.hasOwnProperty(alias)) {
          Object.defineProperty(this._router.prototype, alias, descriptor);
        }
      } else {
        descriptors2[index] = null;
        aliases[index] = null;
      }
    });
    let type = void 0;
    descriptors2.forEach((descriptor) => {
      if (descriptor) {
        const descType = this._getDescriptorType(descriptor);
        if (type && type !== descType) {
          console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
          return;
        }
        type = descType;
      }
    });
    switch (type) {
      case "method":
        this._addMethodRouter(member, descriptors2, aliases);
        break;
      case "getter":
        this._addGetterSetterRouters(member);
        break;
      case "property":
        console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!");
        break;
    }
  }
  _getDescriptor(state2, member, isValid = () => true) {
    let type = state2;
    let curState = state2;
    do {
      const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
      if (descriptor) {
        if (isValid(descriptor)) {
          descriptor._source = curState;
          return descriptor;
        }
      }
      type = Object.getPrototypeOf(type);
      if (type && type.hasOwnProperty("__state")) {
        curState = type;
      }
    } while (type && type.prototype);
    return void 0;
  }
  _getDescriptorType(descriptor) {
    if (descriptor.get || descriptor.set) {
      return "getter";
    } else {
      if (typeof descriptor.value === "function") {
        return "method";
      } else {
        return "property";
      }
    }
  }
  static _supportsSpread() {
    if (this.__supportsSpread === void 0) {
      this.__supportsSpread = false;
      try {
        const func = new Function("return [].concat(...arguments);");
        func();
        this.__supportsSpread = true;
      } catch (e) {
      }
    }
    return this.__supportsSpread;
  }
  _addMethodRouter(member, descriptors2, aliases) {
    const code = [
      // The line ensures that, while debugging, your IDE won't open many tabs.
      "//@ sourceURL=StateMachineRouter.js",
      "var i = this._stateIndex;"
    ];
    let cur = aliases[0];
    const supportsSpread = StateMachineType._supportsSpread();
    for (let i = 1, n = aliases.length; i < n; i++) {
      const alias = aliases[i];
      if (alias !== cur) {
        if (cur) {
          if (supportsSpread) {
            code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
          } else {
            code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
          }
        } else {
          code.push(`if (i < ${i}) return ; else`);
        }
      }
      cur = alias;
    }
    if (cur) {
      if (supportsSpread) {
        code.push(`return this["${cur}"](...arguments);`);
      } else {
        code.push(`return this["${cur}"].apply(this, arguments);`);
      }
    } else {
      code.push(`;`);
    }
    const functionBody = code.join("\n");
    const router = new Function([], functionBody);
    const descriptor = { value: router };
    Object.defineProperty(this._router.prototype, member, descriptor);
  }
  _addGetterSetterRouters(member) {
    const getter = this._getGetterRouter(member);
    const setter = this._getSetterRouter(member);
    const descriptor = {
      get: getter,
      set: setter
    };
    Object.defineProperty(this._router.prototype, member, descriptor);
  }
  _getGetterRouter(member) {
    const statePaths = Object.keys(this._stateMap);
    const aliases = [];
    statePaths.forEach((statePath, index) => {
      const state2 = this._stateMap[statePath];
      const descriptor = this._getDescriptor(state2, member, (descriptor2) => descriptor2.get);
      if (descriptor) {
        const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
        aliases[index] = alias;
        if (!this._router.prototype.hasOwnProperty(alias)) {
          Object.defineProperty(this._router.prototype, alias, descriptor);
        }
      } else {
        aliases[index] = null;
      }
    });
    const code = [
      // The line ensures that, while debugging, your IDE won't open many tabs.
      "//@ sourceURL=StateMachineRouter.js",
      "var i = this._stateIndex;"
    ];
    let cur = aliases[0];
    for (let i = 1, n = aliases.length; i < n; i++) {
      const alias = aliases[i];
      if (alias !== cur) {
        if (cur) {
          code.push(`if (i < ${i}) return this["${cur}"]; else`);
        } else {
          code.push(`if (i < ${i}) return ; else`);
        }
      }
      cur = alias;
    }
    if (cur) {
      code.push(`return this["${cur}"];`);
    } else {
      code.push(`;`);
    }
    const functionBody = code.join("\n");
    const router = new Function([], functionBody);
    return router;
  }
  _getSetterRouter(member) {
    const statePaths = Object.keys(this._stateMap);
    const aliases = [];
    statePaths.forEach((statePath, index) => {
      const state2 = this._stateMap[statePath];
      const descriptor = this._getDescriptor(state2, member, (descriptor2) => descriptor2.set);
      if (descriptor) {
        const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
        aliases[index] = alias;
        if (!this._router.prototype.hasOwnProperty(alias)) {
          Object.defineProperty(this._router.prototype, alias, descriptor);
        }
      } else {
        aliases[index] = null;
      }
    });
    const code = [
      // The line ensures that, while debugging, your IDE won't open many tabs.
      "//@ sourceURL=StateMachineRouter.js",
      "var i = this._stateIndex;"
    ];
    let cur = aliases[0];
    for (let i = 1, n = aliases.length; i < n; i++) {
      const alias = aliases[i];
      if (alias !== cur) {
        if (cur) {
          code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
        } else {
          code.push(`if (i < ${i}) ; else`);
        }
      }
      cur = alias;
    }
    if (cur) {
      code.push(`this["${cur}"] = arg;`);
    } else {
      code.push(`;`);
    }
    const functionBody = code.join("\n");
    const router = new Function(["arg"], functionBody);
    return router;
  }
  static getStateMemberAlias(path, member) {
    return "$" + (path ? path + "." : "") + member;
  }
  _getAllMemberNames() {
    const stateMap = this._stateMap;
    const map = Object.keys(stateMap);
    let members = /* @__PURE__ */ new Set();
    map.forEach((statePath) => {
      if (statePath === "") {
        return;
      }
      const state2 = stateMap[statePath];
      const names = this._getStateMemberNames(state2);
      names.forEach((name2) => {
        members.add(name2);
      });
    });
    return [...members];
  }
  _getStateMemberNames(state2) {
    let type = state2;
    let members = /* @__PURE__ */ new Set();
    const isRoot = this._type === state2;
    do {
      const names = this._getStateMemberNamesForType(type);
      names.forEach((name2) => {
        members.add(name2);
      });
      type = Object.getPrototypeOf(type);
    } while (type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));
    return members;
  }
  _getStateMemberNamesForType(type) {
    const memberNames = Object.getOwnPropertyNames(type.prototype);
    return memberNames.filter((memberName) => {
      return memberName !== "constructor" && !StateMachineType._isStateLocalMember(memberName);
    });
  }
  static _isStateLocalMember(memberName) {
    return memberName === "$enter" || memberName === "$exit";
  }
  getStateByPath(statePath) {
    if (this._stateMap[statePath]) {
      return this._stateMap[statePath];
    }
    const parts = statePath.split(".");
    while (parts.pop()) {
      const statePath2 = parts.join(".");
      if (this._stateMap[statePath2]) {
        return this._stateMap[statePath2];
      }
    }
  }
  _getStateMap() {
    if (!this._stateMap) {
      this._stateMap = this._createStateMap();
    }
    return this._stateMap;
  }
  _createStateMap() {
    const stateMap = {};
    this._addState(this._type, null, "", stateMap);
    return stateMap;
  }
  _addState(state2, parentState, name2, stateMap) {
    state2.__state = true;
    state2.__name = name2;
    this._addStaticStateProperty(state2, parentState);
    const parentPath = parentState ? parentState.__path : "";
    let path = (parentPath ? parentPath + "." : "") + name2;
    state2.__path = path;
    state2.__level = parentState ? parentState.__level + 1 : 0;
    state2.__parent = parentState;
    state2.__index = Object.keys(stateMap).length;
    stateMap[path] = state2;
    const states = state2._states;
    if (states) {
      const isInheritedFromParent = parentState && parentState._states === states;
      if (!isInheritedFromParent) {
        const subStates = state2._states();
        subStates.forEach((subState) => {
          const stateName = StateMachineType._getStateName(subState);
          this._addState(subState, state2, stateName, stateMap);
        });
      }
    }
  }
  static _getStateName(state2) {
    const name2 = state2.name;
    const index = name2.indexOf("$");
    if (index > 0) {
      return name2.substr(0, index);
    }
    return name2;
  }
  _addStaticStateProperty(state2, parentState) {
    if (parentState) {
      const isClassStateLevel = parentState && !parentState.__parent;
      if (isClassStateLevel) {
        this._router[state2.__name] = state2;
      } else {
        parentState[state2.__name] = state2;
      }
    }
  }
}
class Component extends Element$1 {
  constructor(stage2, properties) {
    super(stage2);
    this.tagRoot = true;
    if (Utils$2.isObjectLiteral(properties)) {
      Object.assign(this, properties);
    }
    this.__initialized = false;
    this.__firstActive = false;
    this.__firstEnable = false;
    this.__signals = void 0;
    this.__passSignals = void 0;
    this.__construct();
    const func = this.constructor.getTemplateFunc(this);
    func.f(this, func.a);
    this._build();
  }
  __start() {
    StateMachine.setupStateMachine(this);
    this._onStateChange = Component.prototype.__onStateChange;
  }
  get state() {
    return this._getState();
  }
  __onStateChange() {
    if (this.application) {
      this.application.updateFocusPath();
    }
  }
  _refocus() {
    if (this.application) {
      this.application.updateFocusPath();
    }
  }
  static bindProp(name2, func = null) {
    return { __propertyBinding: true, __name: name2, __func: func };
  }
  __bindProperty(propObj, targetObj, targetProp) {
    const obj = targetObj;
    const prop = targetProp;
    const propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];
    for (let i = 0; i < propDependencies.length; i++) {
      const propName = propDependencies[i];
      const func = propObj.__func ? propObj.__func : (context) => context[propName];
      if (!this.hasOwnProperty(propName)) {
        this[`__prop_bindings_${propName}`] = [{ __obj: obj, __prop: prop, __func: func }];
        Object.defineProperty(this, propName, {
          set: (value) => {
            this[`__prop_${propName}`] = value;
            for (const { __obj, __prop, __func } of this[`__prop_bindings_${propName}`]) {
              __obj[__prop] = __func(this);
            }
          },
          get: () => this[`__prop_${propName}`]
        });
      } else {
        this[`__prop_bindings_${propName}`].push({ __obj: obj, __prop: prop, __func: func });
      }
    }
  }
  /**
   * Returns a high-performance template patcher.
   */
  static getTemplateFunc(ctx) {
    const name2 = "_templateFunc";
    const hasName = "__has" + name2;
    if (this[hasName] !== this) {
      this[hasName] = this;
      this[name2] = this.parseTemplate(this._template(ctx));
    }
    return this[name2];
  }
  static parseTemplate(obj) {
    const context = {
      loc: [],
      store: [],
      rid: 0
    };
    this.parseTemplateRec(obj, context, "element");
    const code = context.loc.join(";\n");
    const f = new Function("element", "store", code);
    return { f, a: context.store };
  }
  static parseTemplateRec(obj, context, cursor) {
    const store = context.store;
    const loc = context.loc;
    const keys = Object.keys(obj);
    keys.forEach((key) => {
      let value = obj[key];
      if (Utils$2.isUcChar(key.charCodeAt(0))) {
        if (Utils$2.isObjectLiteral(value)) {
          const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
          let type = value.type ? value.type : Element$1;
          if (type === Element$1) {
            loc.push(`var ${childCursor} = element.stage.createElement()`);
          } else {
            store.push(type);
            loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
          }
          loc.push(`${childCursor}.ref = "${key}"`);
          context.rid++;
          this.parseTemplateRec(value, context, childCursor);
          loc.push(`${cursor}.childList.add(${childCursor})`);
        } else if (Utils$2.isObject(value)) {
          store.push(value);
          loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
        }
      } else {
        if (key === "text") {
          const propKey = cursor + "__text";
          loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
          if (value.__propertyBinding === true) {
            store.push(value);
            loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
          } else {
            this.parseTemplatePropRec(value, context, propKey);
          }
        } else if (key === "shader" && Utils$2.isObjectLiteral(value)) {
          const shaderCursor = `${cursor}["shader"]`;
          store.push(value);
          loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
          this.parsePropertyBindings(value, context, shaderCursor);
        } else if (key === "texture" && Utils$2.isObjectLiteral(value)) {
          const propKey = cursor + "__texture";
          const type = value.type;
          if (type) {
            store.push(type);
            loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
            this.parseTemplatePropRec(value, context, propKey);
            loc.push(`${cursor}["${key}"] = ${propKey}`);
          } else {
            loc.push(`${propKey} = ${cursor}.texture`);
            this.parseTemplatePropRec(value, context, propKey);
          }
        } else if (Utils$2.isObjectLiteral(value) && value.__propertyBinding === true) {
          store.push(value);
          loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
        } else {
          if (Utils$2.isNumber(value)) {
            loc.push(`${cursor}["${key}"] = ${value}`);
          } else if (Utils$2.isBoolean(value)) {
            loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
          } else if (Utils$2.isObject(value) || Array.isArray(value)) {
            store.push(value);
            loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
          } else {
            loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
          }
        }
      }
    });
  }
  static parseTemplatePropRec(obj, context, cursor) {
    const store = context.store;
    const loc = context.loc;
    const keys = Object.keys(obj);
    keys.forEach((key) => {
      if (key !== "type") {
        const value = obj[key];
        if (Utils$2.isNumber(value)) {
          loc.push(`${cursor}["${key}"] = ${value}`);
        } else if (Utils$2.isBoolean(value)) {
          loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
        } else if (Utils$2.isObject(value) && value.__propertyBinding === true) {
          store.push(value);
          loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
        } else if (Utils$2.isObject(value) || Array.isArray(value)) {
          store.push(value);
          loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
        } else {
          loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
        }
      }
    });
  }
  static parsePropertyBindings(obj, context, cursor) {
    const store = context.store;
    const loc = context.loc;
    const keys = Object.keys(obj);
    keys.forEach((key) => {
      if (key !== "type") {
        const value = obj[key];
        if (Utils$2.isObjectLiteral(value) && value.__propertyBinding === true) {
          store.push(value);
          loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
        }
      }
    });
  }
  _onSetup() {
    if (!this.__initialized) {
      this._setup();
    }
  }
  _setup() {
  }
  _onAttach() {
    if (!this.__initialized) {
      this.__init();
      this.__initialized = true;
    }
    this._attach();
  }
  _attach() {
  }
  _onDetach() {
    this._detach();
  }
  _detach() {
  }
  _onEnabled() {
    if (!this.__firstEnable) {
      this._firstEnable();
      this.__firstEnable = true;
    }
    this._enable();
  }
  _firstEnable() {
  }
  _enable() {
  }
  _onDisabled() {
    this._disable();
  }
  _disable() {
  }
  _onActive() {
    if (!this.__firstActive) {
      this._firstActive();
      this.__firstActive = true;
    }
    this._active();
  }
  _firstActive() {
  }
  _active() {
  }
  _onInactive() {
    this._inactive();
  }
  _inactive() {
  }
  get application() {
    return this.stage.application;
  }
  __construct() {
    this._construct();
  }
  _construct() {
  }
  _build() {
  }
  __init() {
    this._init();
  }
  _init() {
  }
  _focus(newTarget, prevTarget) {
  }
  _unfocus(newTarget) {
  }
  _focusChange(target, newTarget) {
  }
  _getFocused() {
    return this;
  }
  _setFocusSettings(settings2) {
  }
  _handleFocusSettings(settings2) {
  }
  static _template() {
    return {};
  }
  hasFinalFocus() {
    let path = this.application._focusPath;
    return path && path.length && path[path.length - 1] === this;
  }
  hasFocus() {
    let path = this.application._focusPath;
    return path && path.indexOf(this) >= 0;
  }
  get cparent() {
    return Component.getParent(this);
  }
  seekAncestorByType(type) {
    let c = this.cparent;
    while (c) {
      if (c.constructor === type) {
        return c;
      }
      c = c.cparent;
    }
  }
  getSharedAncestorComponent(element) {
    let ancestor = this.getSharedAncestor(element);
    while (ancestor && !ancestor.isComponent) {
      ancestor = ancestor.parent;
    }
    return ancestor;
  }
  get signals() {
    return this.__signals;
  }
  set signals(v) {
    if (!Utils$2.isObjectLiteral(v)) {
      this._throwError("Signals: specify an object with signal-to-fire mappings");
    }
    this.__signals = v;
  }
  set alterSignals(v) {
    if (!Utils$2.isObjectLiteral(v)) {
      this._throwError("Signals: specify an object with signal-to-fire mappings");
    }
    if (!this.__signals) {
      this.__signals = {};
    }
    for (let key in v) {
      const d = v[key];
      if (d === void 0) {
        delete this.__signals[key];
      } else {
        this.__signals[key] = v;
      }
    }
  }
  get passSignals() {
    return this.__passSignals || {};
  }
  set passSignals(v) {
    this.__passSignals = Object.assign(this.__passSignals || {}, v);
  }
  set alterPassSignals(v) {
    if (!Utils$2.isObjectLiteral(v)) {
      this._throwError("Signals: specify an object with signal-to-fire mappings");
    }
    if (!this.__passSignals) {
      this.__passSignals = {};
    }
    for (let key in v) {
      const d = v[key];
      if (d === void 0) {
        delete this.__passSignals[key];
      } else {
        this.__passSignals[key] = v;
      }
    }
  }
  /**
   * Signals the parent of the specified event.
   * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
   * @param {string} event
   * @param {...*} args
   */
  signal(event, ...args) {
    return this._signal(event, args);
  }
  _signal(event, args) {
    const signalParent = this._getParentSignalHandler();
    if (signalParent) {
      if (this.__signals) {
        let fireEvent = this.__signals[event];
        if (fireEvent === false) {
          return;
        }
        if (fireEvent) {
          if (fireEvent === true) {
            fireEvent = event;
          }
          if (Utils$2.isFunction(fireEvent)) {
            return fireEvent(...args);
          }
          if (signalParent._hasMethod(fireEvent)) {
            return signalParent[fireEvent](...args);
          }
        }
      }
      let passSignal = this.__passSignals && this.__passSignals[event];
      if (passSignal) {
        if (passSignal && passSignal !== true) {
          event = passSignal;
        }
        return signalParent._signal(event, args);
      }
    }
  }
  _getParentSignalHandler() {
    return this.cparent ? this.cparent._getSignalHandler() : null;
  }
  _getSignalHandler() {
    if (this._signalProxy) {
      return this.cparent ? this.cparent._getSignalHandler() : null;
    }
    return this;
  }
  get _signalProxy() {
    return false;
  }
  fireAncestors(name2, ...args) {
    if (!name2.startsWith("$")) {
      throw new Error("Ancestor event name must be prefixed by dollar sign.");
    }
    const parent = this._getParentSignalHandler();
    if (parent) {
      return parent._doFireAncestors(name2, args);
    }
  }
  _doFireAncestors(name2, args) {
    if (this._hasMethod(name2)) {
      return this.fire(name2, ...args);
    } else {
      const signalParent = this._getParentSignalHandler();
      if (signalParent) {
        return signalParent._doFireAncestors(name2, args);
      }
    }
  }
  static collectSubComponents(subs, element) {
    if (element.hasChildren()) {
      const childList = element.__childList;
      for (let i = 0, n = childList.length; i < n; i++) {
        const child = childList.getAt(i);
        if (child.isComponent) {
          subs.push(child);
        } else {
          Component.collectSubComponents(subs, child);
        }
      }
    }
  }
  static getComponent(element) {
    let parent = element;
    while (parent && !parent.isComponent) {
      parent = parent.parent;
    }
    return parent;
  }
  static getParent(element) {
    return Component.getComponent(element.parent);
  }
}
Component.prototype.isComponent = true;
class CoreQuadList {
  constructor(ctx) {
    this.ctx = ctx;
    this.quadTextures = [];
    this.quadElements = [];
  }
  get length() {
    return this.quadTextures.length;
  }
  reset() {
    this.quadTextures = [];
    this.quadElements = [];
    this.dataLength = 0;
  }
  getElement(index) {
    return this.quadElements[index]._element;
  }
  getElementCore(index) {
    return this.quadElements[index];
  }
  getTexture(index) {
    return this.quadTextures[index];
  }
  getTextureWidth(index) {
    let nativeTexture = this.quadTextures[index];
    if (nativeTexture.w) {
      return nativeTexture.w;
    } else {
      return this.quadElements[index]._displayedTextureSource.w;
    }
  }
  getTextureHeight(index) {
    let nativeTexture = this.quadTextures[index];
    if (nativeTexture.h) {
      return nativeTexture.h;
    } else {
      return this.quadElements[index]._displayedTextureSource.h;
    }
  }
}
class WebGLCoreQuadList extends CoreQuadList {
  constructor(ctx) {
    super(ctx);
    const byteSize = ctx.stage.getOption("bufferMemory");
    this.dataLength = 0;
    this.data = new ArrayBuffer(byteSize);
    this.floats = new Float32Array(this.data);
    this.uints = new Uint32Array(this.data);
  }
  getAttribsDataByteOffset(index) {
    return index * 80;
  }
  getQuadContents() {
    let floats = this.floats;
    let uints = this.uints;
    let lines = [];
    for (let i = 1; i <= this.length; i++) {
      let str = "entry " + i + ": ";
      for (let j = 0; j < 4; j++) {
        let b = i * 20 + j * 4;
        str += floats[b] + "," + floats[b + 1] + ":" + floats[b + 2] + "," + floats[b + 3] + "[" + uints[b + 4].toString(16) + "] ";
      }
      lines.push(str);
    }
    return lines;
  }
}
class CoreQuadOperation {
  constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
    this.ctx = ctx;
    this.shader = shader;
    this.shaderOwner = shaderOwner;
    this.renderTextureInfo = renderTextureInfo;
    this.scissor = scissor;
    this.index = index;
    this.length = 0;
  }
  get quads() {
    return this.ctx.renderState.quads;
  }
  getTexture(index) {
    return this.quads.getTexture(this.index + index);
  }
  getElementCore(index) {
    return this.quads.getElementCore(this.index + index);
  }
  getElement(index) {
    return this.quads.getElement(this.index + index);
  }
  getElementWidth(index) {
    return this.getElement(index).renderWidth;
  }
  getElementHeight(index) {
    return this.getElement(index).renderHeight;
  }
  getTextureWidth(index) {
    return this.quads.getTextureWidth(this.index + index);
  }
  getTextureHeight(index) {
    return this.quads.getTextureHeight(this.index + index);
  }
  getRenderWidth() {
    if (this.renderTextureInfo) {
      return this.renderTextureInfo.w;
    } else {
      return this.ctx.stage.w;
    }
  }
  getRenderHeight() {
    if (this.renderTextureInfo) {
      return this.renderTextureInfo.h;
    } else {
      return this.ctx.stage.h;
    }
  }
}
class WebGLCoreQuadOperation extends CoreQuadOperation {
  constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
    super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    this.extraAttribsDataByteOffset = 0;
  }
  getAttribsDataByteOffset(index) {
    return this.quads.getAttribsDataByteOffset(this.index + index);
  }
  /**
   * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
   * @param x
   * @param y
   * @return {number[]}
   */
  getNormalRenderTextureCoords(x, y) {
    let coords = this.shaderOwner.getRenderTextureCoords(x, y);
    coords[0] /= this.getRenderWidth();
    coords[1] /= this.getRenderHeight();
    coords[0] = coords[0] * 2 - 1;
    coords[1] = 1 - coords[1] * 2;
    return coords;
  }
  getProjection() {
    if (this.renderTextureInfo === null) {
      return this.ctx.renderExec._projection;
    } else {
      return this.renderTextureInfo.nativeTexture.projection;
    }
  }
}
class CoreRenderExecutor {
  constructor(ctx) {
    this.ctx = ctx;
    this.renderState = ctx.renderState;
    this.gl = this.ctx.stage.gl;
  }
  destroy() {
  }
  _reset() {
    this._bindRenderTexture(null);
    this._setScissor(null);
    this._clearRenderTexture();
  }
  execute() {
    this._reset();
    let qops = this.renderState.quadOperations;
    let i = 0, n = qops.length;
    while (i < n) {
      this._processQuadOperation(qops[i]);
      i++;
    }
  }
  _processQuadOperation(quadOperation) {
    if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
      return;
    }
    this._setupQuadOperation(quadOperation);
    this._execQuadOperation(quadOperation);
  }
  _setupQuadOperation(quadOperation) {
  }
  _execQuadOperation(op) {
    let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;
    if (this._renderTexture !== nativeTexture) {
      this._bindRenderTexture(nativeTexture);
    }
    if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
      this._setScissor(null);
      this._clearRenderTexture();
      op.renderTextureInfo.cleared = true;
      this._setScissor(op.scissor);
    } else {
      this._setScissor(op.scissor);
    }
    this._renderQuadOperation(op);
  }
  _renderQuadOperation(op) {
  }
  _bindRenderTexture(renderTexture) {
    this._renderTexture = renderTexture;
  }
  _clearRenderTexture(renderTexture) {
  }
  _setScissor(area) {
  }
}
class WebGLCoreRenderExecutor extends CoreRenderExecutor {
  constructor(ctx) {
    super(ctx);
    this.gl = this.ctx.stage.gl;
    this.init();
  }
  init() {
    let gl = this.gl;
    this._attribsBuffer = gl.createBuffer();
    let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);
    let allIndices = new Uint16Array(maxQuads * 6);
    for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
      allIndices[i] = j;
      allIndices[i + 1] = j + 1;
      allIndices[i + 2] = j + 2;
      allIndices[i + 3] = j;
      allIndices[i + 4] = j + 2;
      allIndices[i + 5] = j + 3;
    }
    this._quadsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);
    this._projection = new Float32Array([2 / this.ctx.stage.coordsWidth, -2 / this.ctx.stage.coordsHeight]);
  }
  destroy() {
    super.destroy();
    this.gl.deleteBuffer(this._attribsBuffer);
    this.gl.deleteBuffer(this._quadsBuffer);
  }
  _reset() {
    super._reset();
    let gl = this.gl;
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.BLEND);
    gl.disable(gl.DEPTH_TEST);
    this._stopShaderProgram();
    this._setupBuffers();
  }
  _setupBuffers() {
    let gl = this.gl;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
    let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
  }
  _setupQuadOperation(quadOperation) {
    super._setupQuadOperation(quadOperation);
    this._useShaderProgram(quadOperation.shader, quadOperation);
  }
  _renderQuadOperation(op) {
    let shader = op.shader;
    if (op.length || op.shader.addEmpty()) {
      shader.beforeDraw(op);
      shader.draw(op);
      shader.afterDraw(op);
    }
  }
  /**
   * @param {WebGLShader} shader;
   * @param {CoreQuadOperation} operation;
   */
  _useShaderProgram(shader, operation) {
    if (!shader.hasSameProgram(this._currentShaderProgram)) {
      if (this._currentShaderProgram) {
        this._currentShaderProgram.stopProgram();
      }
      shader.useProgram();
      this._currentShaderProgram = shader;
    }
    shader.setupUniforms(operation);
  }
  _stopShaderProgram() {
    if (this._currentShaderProgram) {
      this._currentShaderProgram.stopProgram();
      this._currentShaderProgram = null;
    }
  }
  _bindRenderTexture(renderTexture) {
    super._bindRenderTexture(renderTexture);
    let gl = this.gl;
    if (!this._renderTexture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, this.ctx.stage.w, this.ctx.stage.h);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
      gl.viewport(0, 0, this._renderTexture.w, this._renderTexture.h);
    }
  }
  _clearRenderTexture() {
    super._clearRenderTexture();
    let gl = this.gl;
    if (!this._renderTexture) {
      let glClearColor = this.ctx.stage.getClearColor();
      if (glClearColor) {
        gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    } else {
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
  }
  _setScissor(area) {
    super._setScissor(area);
    if (this._scissor === area) {
      return;
    }
    this._scissor = area;
    let gl = this.gl;
    if (!area) {
      gl.disable(gl.SCISSOR_TEST);
    } else {
      gl.enable(gl.SCISSOR_TEST);
      let precision2 = this.ctx.stage.getRenderPrecision();
      let y = area[1];
      if (this._renderTexture === null) {
        y = this.ctx.stage.h / precision2 - (area[1] + area[3]);
      }
      gl.scissor(Math.round(area[0] * precision2), Math.round(y * precision2), Math.round(area[2] * precision2), Math.round(area[3] * precision2));
    }
  }
}
class CoreRenderState {
  constructor(ctx) {
    this.ctx = ctx;
    this.stage = ctx.stage;
    this.defaultShader = this.stage.renderer.getDefaultShader(ctx);
    this.renderer = ctx.stage.renderer;
    this.quads = this.renderer.createCoreQuadList(ctx);
  }
  reset() {
    this._renderTextureInfo = null;
    this._scissor = null;
    this._shader = null;
    this._shaderOwner = null;
    this._realShader = null;
    this._check = false;
    this.quadOperations = [];
    this._texturizer = null;
    this._texturizerTemporary = false;
    this._quadOperation = null;
    this.quads.reset();
    this._temporaryTexturizers = [];
    this._isCachingTexturizer = false;
  }
  get length() {
    return this.quads.quadTextures.length;
  }
  setShader(shader, owner) {
    if (this._shaderOwner !== owner || this._realShader !== shader) {
      this._realShader = shader;
      if (shader.useDefault()) {
        shader = this.defaultShader;
      }
      if (this._shader !== shader || this._shaderOwner !== owner) {
        this._shader = shader;
        this._shaderOwner = owner;
        this._check = true;
      }
    }
  }
  get renderTextureInfo() {
    return this._renderTextureInfo;
  }
  setScissor(area) {
    if (this._scissor !== area) {
      if (area) {
        this._scissor = area;
      } else {
        this._scissor = null;
      }
      this._check = true;
    }
  }
  getScissor() {
    return this._scissor;
  }
  setRenderTextureInfo(renderTextureInfo) {
    if (this._renderTextureInfo !== renderTextureInfo) {
      this._renderTextureInfo = renderTextureInfo;
      this._scissor = null;
      this._check = true;
    }
  }
  /**
   * Sets the texturizer to be drawn during subsequent addQuads.
   * @param {ElementTexturizer} texturizer
   */
  setTexturizer(texturizer, cache = false) {
    this._texturizer = texturizer;
    this._cacheTexturizer = cache;
  }
  set isCachingTexturizer(v) {
    this._isCachingTexturizer = v;
  }
  get isCachingTexturizer() {
    return this._isCachingTexturizer;
  }
  addQuad(elementCore) {
    if (!this._quadOperation) {
      this._createQuadOperation();
    } else if (this._check && this._hasChanges()) {
      this._finishQuadOperation();
      this._check = false;
    }
    let nativeTexture = null;
    if (this._texturizer) {
      nativeTexture = this._texturizer.getResultTexture();
      if (!this._cacheTexturizer) {
        this._temporaryTexturizers.push(this._texturizer);
      }
    }
    if (!nativeTexture) {
      nativeTexture = elementCore._displayedTextureSource.nativeTexture;
    }
    if (this._renderTextureInfo) {
      if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
        this._renderTextureInfo.nativeTexture = nativeTexture;
        this._renderTextureInfo.offset = this.length;
      } else {
        this._renderTextureInfo.nativeTexture = null;
      }
      this._renderTextureInfo.empty = false;
    }
    this.quads.quadTextures.push(nativeTexture);
    this.quads.quadElements.push(elementCore);
    this._quadOperation.length++;
    this.renderer.addQuad(this, this.quads, this.length - 1);
  }
  finishedRenderTexture() {
    if (this._renderTextureInfo.nativeTexture) {
      if (!this._isRenderTextureReusable()) {
        this._renderTextureInfo.nativeTexture = null;
      }
    }
  }
  _isRenderTextureReusable() {
    const offset = this._renderTextureInfo.offset;
    return this.quads.quadTextures[offset].w === this._renderTextureInfo.w && this.quads.quadTextures[offset].h === this._renderTextureInfo.h && this.renderer.isRenderTextureReusable(this, this._renderTextureInfo);
  }
  _hasChanges() {
    let q = this._quadOperation;
    if (this._shader !== q.shader)
      return true;
    if (this._shaderOwner !== q.shaderOwner)
      return true;
    if (this._renderTextureInfo !== q.renderTextureInfo)
      return true;
    if (this._scissor !== q.scissor) {
      if (this._scissor[0] !== q.scissor[0] || this._scissor[1] !== q.scissor[1] || this._scissor[2] !== q.scissor[2] || this._scissor[3] !== q.scissor[3]) {
        return true;
      }
    }
    return false;
  }
  _finishQuadOperation(create = true) {
    if (this._quadOperation) {
      if (this._quadOperation.length || this._shader.addEmpty()) {
        if (!this._quadOperation.scissor || this._quadOperation.scissor[2] > 0 && this._quadOperation.scissor[3] > 0) {
          this.quadOperations.push(this._quadOperation);
        }
      }
      if (this._temporaryTexturizers.length) {
        for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
          this._temporaryTexturizers[i].releaseRenderTexture();
        }
        this._temporaryTexturizers = [];
      }
      this._quadOperation = null;
    }
    if (create) {
      this._createQuadOperation();
    }
  }
  _createQuadOperation() {
    this._quadOperation = this.renderer.createCoreQuadOperation(
      this.ctx,
      this._shader,
      this._shaderOwner,
      this._renderTextureInfo,
      this._scissor,
      this.length
    );
    this._check = false;
  }
  finish() {
    if (this._quadOperation) {
      this._finishQuadOperation(false);
    }
    this.renderer.finishRenderState(this);
  }
}
class WebGLShaderProgram {
  constructor(vertexShaderSource, fragmentShaderSource) {
    this.vertexShaderSource = vertexShaderSource;
    this.fragmentShaderSource = fragmentShaderSource;
    this._program = null;
    this._uniformLocations = /* @__PURE__ */ new Map();
    this._attributeLocations = /* @__PURE__ */ new Map();
    this._currentUniformValues = {};
  }
  compile(gl) {
    if (this._program)
      return;
    this.gl = gl;
    this._program = gl.createProgram();
    let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
    let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
    gl.attachShader(this._program, glVertShader);
    gl.attachShader(this._program, glFragShader);
    gl.linkProgram(this._program);
    if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
      console.error("[Lightning] Error: Could not initialize shader.");
      console.error("[Lightning] gl.VALIDATE_STATUS", gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
      console.error("[Lightning] gl.getError()", gl.getError());
      if (gl.getProgramInfoLog(this._program) !== "") {
        console.warn("[Lightning] Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(this._program));
      }
      gl.deleteProgram(this._program);
      this._program = null;
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
  }
  _glCompile(type, src) {
    let shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, src);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error("[Lightning]", this.constructor.name, "Type: " + (type === this.gl.VERTEX_SHADER ? "vertex shader" : "fragment shader"));
      console.error("[Lightning]", this.gl.getShaderInfoLog(shader));
      let idx = 0;
      console.error("[Lightning]", "========== source ==========\n" + src.split("\n").map((line) => "" + ++idx + ": " + line).join("\n"));
      return null;
    }
    return shader;
  }
  getUniformLocation(name2) {
    let location2 = this._uniformLocations.get(name2);
    if (location2 === void 0) {
      location2 = this.gl.getUniformLocation(this._program, name2);
      this._uniformLocations.set(name2, location2);
    }
    return location2;
  }
  getAttribLocation(name2) {
    let location2 = this._attributeLocations.get(name2);
    if (location2 === void 0) {
      location2 = this.gl.getAttribLocation(this._program, name2);
      this._attributeLocations.set(name2, location2);
    }
    return location2;
  }
  destroy() {
    if (this._program) {
      this.gl.deleteProgram(this._program);
      this._program = null;
    }
  }
  get glProgram() {
    return this._program;
  }
  get compiled() {
    return !!this._program;
  }
  _valueEquals(v1, v2) {
    if (v1.length && v2.length) {
      for (let i = 0, n = v1.length; i < n; i++) {
        if (v1[i] !== v2[i])
          return false;
      }
      return true;
    } else {
      return v1 === v2;
    }
  }
  _valueClone(v) {
    if (v.length) {
      return v.slice(0);
    } else {
      return v;
    }
  }
  setUniformValue(name2, value, glFunction) {
    let v = this._currentUniformValues[name2];
    if (v === void 0 || !this._valueEquals(v, value)) {
      let clonedValue = this._valueClone(value);
      this._currentUniformValues[name2] = clonedValue;
      let loc = this.getUniformLocation(name2);
      if (loc) {
        let isMatrix = glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv;
        if (isMatrix) {
          glFunction.call(this.gl, loc, false, clonedValue);
        } else {
          glFunction.call(this.gl, loc, clonedValue);
        }
      }
    }
  }
}
class WebGLShader extends Shader {
  constructor(ctx) {
    super(ctx);
    const stage2 = ctx.stage;
    this._program = stage2.renderer.shaderPrograms.get(this.constructor);
    if (!this._program) {
      this._program = new WebGLShaderProgram(this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);
      stage2.renderer.shaderPrograms.set(this.constructor, this._program);
    }
    this.gl = stage2.gl;
  }
  get glProgram() {
    return this._program.glProgram;
  }
  _init() {
    if (!this._initialized) {
      this.initialize();
      this._initialized = true;
    }
  }
  initialize() {
    this._program.compile(this.gl);
  }
  get initialized() {
    return this._initialized;
  }
  _uniform(name2) {
    return this._program.getUniformLocation(name2);
  }
  _attrib(name2) {
    return this._program.getAttribLocation(name2);
  }
  _setUniform(name2, value, glFunction) {
    this._program.setUniformValue(name2, value, glFunction);
  }
  useProgram() {
    this._init();
    this.gl.useProgram(this.glProgram);
    this.beforeUsage();
    this.enableAttribs();
  }
  stopProgram() {
    this.afterUsage();
    this.disableAttribs();
  }
  hasSameProgram(other) {
    return other && (other === this || other._program === this._program);
  }
  beforeUsage() {
  }
  afterUsage() {
  }
  enableAttribs() {
  }
  disableAttribs() {
  }
  getExtraAttribBytesPerVertex() {
    return 0;
  }
  getVertexAttribPointerOffset(operation) {
    return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
  }
  setExtraAttribsInBuffer(operation) {
  }
  setupUniforms(operation) {
  }
  _getProjection(operation) {
    return operation.getProjection();
  }
  getFlipY(operation) {
    return this._getProjection(operation)[1] < 0;
  }
  beforeDraw(operation) {
  }
  draw(operation) {
  }
  afterDraw(operation) {
  }
  cleanup() {
    this._initialized = false;
  }
}
let DefaultShader$1 = class DefaultShader extends WebGLShader {
  enableAttribs() {
    let gl = this.gl;
    gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
    gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
    if (this._attrib("aTextureCoord") !== -1) {
      gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
      gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
    }
    if (this._attrib("aColor") !== -1) {
      gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
      gl.enableVertexAttribArray(this._attrib("aColor"));
    }
  }
  disableAttribs() {
    let gl = this.gl;
    gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
    if (this._attrib("aTextureCoord") !== -1) {
      gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
    }
    if (this._attrib("aColor") !== -1) {
      gl.disableVertexAttribArray(this._attrib("aColor"));
    }
  }
  setupUniforms(operation) {
    this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
  }
  draw(operation) {
    let gl = this.gl;
    let length = operation.length;
    if (length) {
      let glTexture = operation.getTexture(0);
      let pos = 0;
      for (let i = 0; i < length; i++) {
        let tx = operation.getTexture(i);
        if (glTexture !== tx) {
          gl.bindTexture(gl.TEXTURE_2D, glTexture);
          gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
          glTexture = tx;
          pos = i;
        }
      }
      if (pos < length) {
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
      }
    }
  }
};
DefaultShader$1.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
DefaultShader$1.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;
class Renderer {
  constructor(stage2) {
    this.stage = stage2;
    this._defaultShader = void 0;
  }
  gc(aggressive) {
  }
  destroy() {
  }
  getDefaultShader(ctx = this.stage.ctx) {
    if (!this._defaultShader) {
      this._defaultShader = this._createDefaultShader(ctx);
    }
    return this._defaultShader;
  }
  _createDefaultShader(ctx) {
  }
  isValidShaderType(shaderType) {
    return shaderType.prototype instanceof this._getShaderBaseType();
  }
  createShader(ctx, settings2) {
    const shaderType = settings2.type;
    if (!this.isValidShaderType(shaderType)) {
      const convertedShaderType = this._getShaderAlternative(shaderType);
      if (!convertedShaderType) {
        console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
        return this._createDefaultShader(ctx);
      }
      return new convertedShaderType(ctx);
    } else {
      const shader = new shaderType(ctx);
      Base.patchObject(this, settings2);
      return shader;
    }
  }
  _getShaderBaseType() {
  }
  _getShaderAlternative(shaderType) {
    return this.getDefaultShader();
  }
  copyRenderTexture(renderTexture, nativeTexture, options) {
    console.warn("[Lightning] copyRenderTexture not supported by renderer");
  }
}
class WebGLRenderer extends Renderer {
  constructor(stage2) {
    super(stage2);
    this.shaderPrograms = /* @__PURE__ */ new Map();
    this._compressedTextureExtensions = {
      astc: stage2.gl.getExtension("WEBGL_compressed_texture_astc"),
      etc1: stage2.gl.getExtension("WEBGL_compressed_texture_etc1"),
      s3tc: stage2.gl.getExtension("WEBGL_compressed_texture_s3tc"),
      pvrtc: stage2.gl.getExtension("WEBGL_compressed_texture_pvrtc")
    };
  }
  getCompressedTextureExtensions() {
    return this._compressedTextureExtensions;
  }
  destroy() {
    this.shaderPrograms.forEach((shaderProgram) => shaderProgram.destroy());
  }
  _createDefaultShader(ctx) {
    return new DefaultShader$1(ctx);
  }
  _getShaderBaseType() {
    return WebGLShader;
  }
  _getShaderAlternative(shaderType) {
    return shaderType.getWebGL && shaderType.getWebGL();
  }
  createCoreQuadList(ctx) {
    return new WebGLCoreQuadList(ctx);
  }
  createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
    return new WebGLCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
  }
  createCoreRenderExecutor(ctx) {
    return new WebGLCoreRenderExecutor(ctx);
  }
  createCoreRenderState(ctx) {
    return new CoreRenderState(ctx);
  }
  createRenderTexture(w, h, pw, ph) {
    const gl = this.stage.gl;
    const glTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    glTexture.params = {};
    glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
    glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
    glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
    glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
    glTexture.options = { format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE };
    glTexture.framebuffer = gl.createFramebuffer();
    glTexture.projection = new Float32Array([2 / w, 2 / h]);
    gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
    return glTexture;
  }
  freeRenderTexture(glTexture) {
    let gl = this.stage.gl;
    gl.deleteFramebuffer(glTexture.framebuffer);
    gl.deleteTexture(glTexture);
  }
  _getBytesPerPixel(fmt, type) {
    const gl = this.stage.gl;
    if (fmt === gl.RGBA) {
      switch (type) {
        case gl.UNSIGNED_BYTE:
          return 4;
        case gl.UNSIGNED_SHORT_4_4_4_4:
          return 2;
        case gl.UNSIGNED_SHORT_5_5_5_1:
          return 2;
        default:
          throw new Error("Invalid type specified for GL_RGBA format");
      }
    } else if (fmt === gl.RGB) {
      switch (type) {
        case gl.UNSIGNED_BYTE:
          return 3;
        case gl.UNSIGNED_BYTE_5_6_5:
          return 2;
        default:
          throw new Error("Invalid type specified for GL_RGB format");
      }
    } else {
      throw new Error("Invalid format specified in call to _getBytesPerPixel()");
    }
  }
  uploadTextureSource(textureSource, options) {
    const gl = this.stage.gl;
    const source = options.source;
    let compressed = false;
    if (options.renderInfo) {
      compressed = options.renderInfo.compressed || false;
    }
    const format = {
      premultiplyAlpha: true,
      hasAlpha: true
    };
    if (options && options.hasOwnProperty("premultiplyAlpha")) {
      format.premultiplyAlpha = options.premultiplyAlpha;
    }
    if (options && options.hasOwnProperty("flipBlueRed")) {
      format.flipBlueRed = options.flipBlueRed;
    }
    if (options && options.hasOwnProperty("hasAlpha")) {
      format.hasAlpha = options.hasAlpha;
    }
    if (!format.hasAlpha) {
      format.premultiplyAlpha = false;
    }
    format.texParams = options.texParams || {};
    format.texOptions = options.texOptions || {};
    let glTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);
    if (Utils$2.isNode) {
      gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
    }
    const texParams = format.texParams;
    if (!texParams[gl.TEXTURE_MAG_FILTER])
      texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
    if (!texParams[gl.TEXTURE_MIN_FILTER])
      texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
    if (!texParams[gl.TEXTURE_WRAP_S])
      texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
    if (!texParams[gl.TEXTURE_WRAP_T])
      texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
    Object.keys(texParams).forEach((key) => {
      const value = texParams[key];
      gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
    });
    if (compressed) {
      this.stage.platform.uploadCompressedGlTexture(gl, textureSource, source);
      return glTexture;
    }
    const texOptions = format.texOptions;
    texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
    texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
    texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
    if (options && options.imageRef) {
      texOptions.imageRef = options.imageRef;
    }
    this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);
    glTexture.params = Utils$2.cloneObjShallow(texParams);
    glTexture.options = Utils$2.cloneObjShallow(texOptions);
    glTexture.bytesPerPixel = this._getBytesPerPixel(texOptions.format, texOptions.type);
    return glTexture;
  }
  freeTextureSource(textureSource) {
    this.stage.gl.deleteTexture(textureSource.nativeTexture);
  }
  addQuad(renderState, quads, index) {
    let offset = index * 20;
    const elementCore = quads.quadElements[index];
    let r = elementCore._renderContext;
    let floats = renderState.quads.floats;
    let uints = renderState.quads.uints;
    const mca = StageUtils.mergeColorAlpha;
    if (r.tb !== 0 || r.tc !== 0) {
      floats[offset++] = r.px;
      floats[offset++] = r.py;
      floats[offset++] = elementCore._ulx;
      floats[offset++] = elementCore._uly;
      uints[offset++] = mca(elementCore._colorUl, r.alpha);
      floats[offset++] = r.px + elementCore._w * r.ta;
      floats[offset++] = r.py + elementCore._w * r.tc;
      floats[offset++] = elementCore._brx;
      floats[offset++] = elementCore._uly;
      uints[offset++] = mca(elementCore._colorUr, r.alpha);
      floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
      floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
      floats[offset++] = elementCore._brx;
      floats[offset++] = elementCore._bry;
      uints[offset++] = mca(elementCore._colorBr, r.alpha);
      floats[offset++] = r.px + elementCore._h * r.tb;
      floats[offset++] = r.py + elementCore._h * r.td;
      floats[offset++] = elementCore._ulx;
      floats[offset++] = elementCore._bry;
      uints[offset] = mca(elementCore._colorBl, r.alpha);
    } else {
      let cx = r.px + elementCore._w * r.ta;
      let cy = r.py + elementCore._h * r.td;
      floats[offset++] = r.px;
      floats[offset++] = r.py;
      floats[offset++] = elementCore._ulx;
      floats[offset++] = elementCore._uly;
      uints[offset++] = mca(elementCore._colorUl, r.alpha);
      floats[offset++] = cx;
      floats[offset++] = r.py;
      floats[offset++] = elementCore._brx;
      floats[offset++] = elementCore._uly;
      uints[offset++] = mca(elementCore._colorUr, r.alpha);
      floats[offset++] = cx;
      floats[offset++] = cy;
      floats[offset++] = elementCore._brx;
      floats[offset++] = elementCore._bry;
      uints[offset++] = mca(elementCore._colorBr, r.alpha);
      floats[offset++] = r.px;
      floats[offset++] = cy;
      floats[offset++] = elementCore._ulx;
      floats[offset++] = elementCore._bry;
      uints[offset] = mca(elementCore._colorBl, r.alpha);
    }
  }
  isRenderTextureReusable(renderState, renderTextureInfo) {
    let offset = renderState._renderTextureInfo.offset * 80 / 4;
    let floats = renderState.quads.floats;
    let uints = renderState.quads.uints;
    return floats[offset] === 0 && floats[offset + 1] === 0 && floats[offset + 2] === 0 && floats[offset + 3] === 0 && uints[offset + 4] === 4294967295 && floats[offset + 5] === renderTextureInfo.w && floats[offset + 6] === 0 && floats[offset + 7] === 1 && floats[offset + 8] === 0 && uints[offset + 9] === 4294967295 && floats[offset + 10] === renderTextureInfo.w && floats[offset + 11] === renderTextureInfo.h && floats[offset + 12] === 1 && floats[offset + 13] === 1 && uints[offset + 14] === 4294967295 && floats[offset + 15] === 0 && floats[offset + 16] === renderTextureInfo.h && floats[offset + 17] === 0 && floats[offset + 18] === 1 && uints[offset + 19] === 4294967295;
  }
  finishRenderState(renderState) {
    let offset = renderState.length * 80;
    for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
      renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
      let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
      offset += extra;
      if (extra) {
        renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
      }
    }
    renderState.quads.dataLength = offset;
  }
  copyRenderTexture(renderTexture, nativeTexture, options) {
    const gl = this.stage.gl;
    gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
    const precision2 = renderTexture.precision;
    gl.copyTexSubImage2D(
      gl.TEXTURE_2D,
      0,
      precision2 * (options.sx || 0),
      precision2 * (options.sy || 0),
      precision2 * (options.x || 0),
      precision2 * (options.y || 0),
      precision2 * (options.w || renderTexture.ow),
      precision2 * (options.h || renderTexture.oh)
    );
  }
}
class C2dCoreQuadList extends CoreQuadList {
  constructor(ctx) {
    super(ctx);
    this.renderContexts = [];
    this.modes = [];
  }
  setRenderContext(index, v) {
    this.renderContexts[index] = v;
  }
  setSimpleTc(index, v) {
    if (v) {
      this.modes[index] |= 1;
    } else {
      this.modes[index] -= this.modes[index] & 1;
    }
  }
  setWhite(index, v) {
    if (v) {
      this.modes[index] |= 2;
    } else {
      this.modes[index] -= this.modes[index] & 2;
    }
  }
  getRenderContext(index) {
    return this.renderContexts[index];
  }
  getSimpleTc(index) {
    return this.modes[index] & 1;
  }
  getWhite(index) {
    return this.modes[index] & 2;
  }
}
class C2dCoreQuadOperation extends CoreQuadOperation {
  getRenderContext(index) {
    return this.quads.getRenderContext(this.index + index);
  }
  getSimpleTc(index) {
    return this.quads.getSimpleTc(this.index + index);
  }
  getWhite(index) {
    return this.quads.getWhite(this.index + index);
  }
}
class C2dCoreRenderExecutor extends CoreRenderExecutor {
  init() {
    this._mainRenderTexture = this.ctx.stage.getCanvas();
  }
  _renderQuadOperation(op) {
    let shader = op.shader;
    if (op.length || op.shader.addEmpty()) {
      const target = this._renderTexture || this._mainRenderTexture;
      shader.beforeDraw(op, target);
      shader.draw(op, target);
      shader.afterDraw(op, target);
    }
  }
  _clearRenderTexture() {
    const ctx = this._getContext();
    let clearColor = [0, 0, 0, 0];
    if (this._mainRenderTexture.ctx === ctx) {
      clearColor = this.ctx.stage.getClearColor();
    }
    const renderTexture = ctx.canvas;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
      ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
    } else {
      ctx.fillStyle = StageUtils.getRgbaStringFromArray(clearColor);
      ctx.globalCompositeOperation = "copy";
      ctx.beginPath();
      ctx.rect(0, 0, renderTexture.width, renderTexture.height);
      ctx.closePath();
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }
  }
  _getContext() {
    if (this._renderTexture) {
      return this._renderTexture.ctx;
    } else {
      return this._mainRenderTexture.ctx;
    }
  }
  _restoreContext() {
    const ctx = this._getContext();
    ctx.restore();
    ctx.save();
    ctx._scissor = null;
  }
  _setScissor(area) {
    const ctx = this._getContext();
    if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
      this._restoreContext();
      let precision2 = this.ctx.stage.getRenderPrecision();
      if (area) {
        ctx.beginPath();
        ctx.rect(Math.round(area[0] * precision2), Math.round(area[1] * precision2), Math.round(area[2] * precision2), Math.round(area[3] * precision2));
        ctx.closePath();
        ctx.clip();
      }
      ctx._scissor = area;
    }
  }
  static _equalScissorAreas(canvas2, area, current) {
    if (!area) {
      area = [0, 0, canvas2.width, canvas2.height];
    }
    if (!current) {
      current = [0, 0, canvas2.width, canvas2.height];
    }
    return Utils$2.equalValues(area, current);
  }
}
class C2dShader extends Shader {
  beforeDraw(operation) {
  }
  draw(operation) {
  }
  afterDraw(operation) {
  }
}
class DefaultShader2 extends C2dShader {
  constructor(ctx) {
    super(ctx);
    this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
    this._tintManager = this.ctx.stage.renderer.tintManager;
  }
  draw(operation, target) {
    const ctx = target.ctx;
    let length = operation.length;
    for (let i = 0; i < length; i++) {
      const tx = operation.getTexture(i);
      const vc = operation.getElementCore(i);
      const rc = operation.getRenderContext(i);
      const white = operation.getWhite(i);
      const stc = operation.getSimpleTc(i);
      const precision2 = this.ctx.stage.getRenderPrecision();
      ctx.setTransform(rc.ta * precision2, rc.tc * precision2, rc.tb * precision2, rc.td * precision2, rc.px * precision2, rc.py * precision2);
      const rect = tx === this._rectangleTexture;
      const info = { operation, target, index: i, rect };
      if (rect) {
        if (white) {
          ctx.fillStyle = "white";
        } else {
          this._setColorGradient(ctx, vc);
        }
        ctx.globalAlpha = rc.alpha;
        this._beforeDrawEl(info);
        ctx.fillRect(0, 0, vc.w, vc.h);
        this._afterDrawEl(info);
        ctx.globalAlpha = 1;
      } else {
        ctx.globalAlpha = rc.alpha;
        this._beforeDrawEl(info);
        const sourceX = stc ? 0 : vc._ulx * tx.w;
        const sourceY = stc ? 0 : vc._uly * tx.h;
        const sourceW = (stc ? 1 : vc._brx - vc._ulx) * tx.w;
        const sourceH = (stc ? 1 : vc._bry - vc._uly) * tx.h;
        let colorize = !white;
        if (colorize) {
          let color = vc._colorUl;
          if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
            color = StageUtils.mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
          }
          const alpha = (color / 16777216 | 0) / 255;
          ctx.globalAlpha *= alpha;
          const rgb = color & 16777215;
          const tintTexture = this._tintManager.getTintTexture(tx, rgb);
          ctx.fillStyle = "white";
          ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
        } else {
          ctx.fillStyle = "white";
          ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
        }
        this._afterDrawEl(info);
        ctx.globalAlpha = 1;
      }
    }
  }
  _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
    let color = vc._colorUl;
    let gradient;
    if (vc._colorUl === vc._colorUr) {
      if (vc._colorBl === vc._colorBr) {
        if (vc._colorUl === vc.colorBl)
          ;
        else {
          gradient = ctx.createLinearGradient(0, 0, 0, h);
          if (transparency) {
            gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
            gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBl));
          } else {
            gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
            gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBl));
          }
        }
      }
    } else {
      if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
        gradient = ctx.createLinearGradient(0, 0, w, 0);
        if (transparency) {
          gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
          gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBr));
        } else {
          gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
          gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBr));
        }
      }
    }
    if (gradient) {
      ctx.fillStyle = gradient;
    } else {
      ctx.fillStyle = transparency ? StageUtils.getRgbaString(color) : StageUtils.getRgbString(color);
    }
  }
  _beforeDrawEl(info) {
  }
  _afterDrawEl(info) {
  }
}
class C2dTextureTintManager {
  constructor(stage2) {
    this.stage = stage2;
    this._usedMemory = 0;
    this._cachedNativeTextures = /* @__PURE__ */ new Set();
  }
  destroy() {
    this.gc(true);
  }
  _addMemoryUsage(delta) {
    this._usedMemory += delta;
    this.stage.addMemoryUsage(delta);
  }
  delete(nativeTexture) {
    if (this._hasCache(nativeTexture)) {
      const cache = this._getCache(nativeTexture);
      const prevMemUsage = cache.memoryUsage;
      cache.clear();
      this._cachedNativeTextures.delete(nativeTexture);
      this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
    }
  }
  getTintTexture(nativeTexture, color) {
    const frame = this.stage.frameCounter;
    this._cachedNativeTextures.add(nativeTexture);
    const cache = this._getCache(nativeTexture);
    const item = cache.get(color);
    item.lf = frame;
    if (item.tx) {
      if (nativeTexture.update > item.u) {
        this._tintTexture(item.tx, nativeTexture, color);
      }
      return item.tx;
    } else {
      const before = cache.memoryUsage;
      let target = cache.reuseTexture(frame);
      if (target) {
        target.ctx.clearRect(0, 0, target.width, target.height);
      } else {
        target = document.createElement("canvas");
        target.width = nativeTexture.w;
        target.height = nativeTexture.h;
        target.ctx = target.getContext("2d");
      }
      this._tintTexture(target, nativeTexture, color);
      cache.set(color, target, frame);
      const after = cache.memoryUsage;
      if (after !== before) {
        this._addMemoryUsage(after - before);
      }
      return target;
    }
  }
  _tintTexture(target, source, color) {
    let col = color.toString(16);
    while (col.length < 6) {
      col = "0" + col;
    }
    target.ctx.fillStyle = "#" + col;
    target.ctx.globalCompositeOperation = "copy";
    target.ctx.fillRect(0, 0, source.w, source.h);
    target.ctx.globalCompositeOperation = "multiply";
    target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
    target.ctx.globalCompositeOperation = "destination-in";
    target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
  }
  _hasCache(nativeTexture) {
    return !!nativeTexture._tintCache;
  }
  _getCache(nativeTexture) {
    if (!nativeTexture._tintCache) {
      nativeTexture._tintCache = new C2dTintCache(nativeTexture);
    }
    return nativeTexture._tintCache;
  }
  gc(aggressive = false) {
    const frame = this.stage.frameCounter;
    let delta = 0;
    this._cachedNativeTextures.forEach((texture) => {
      const cache = this._getCache(texture);
      if (aggressive) {
        delta += cache.memoryUsage;
        cache.clear();
      } else {
        const before = cache.memoryUsage;
        cache.cleanup(frame);
        cache.releaseBlancoTextures();
        delta += cache.memoryUsage - before;
      }
    });
    if (aggressive) {
      this._cachedNativeTextures.clear();
    }
    if (delta) {
      this._addMemoryUsage(delta);
    }
  }
}
class C2dTintCache {
  constructor(nativeTexture) {
    this._tx = nativeTexture;
    this._colors = /* @__PURE__ */ new Map();
    this._blancoTextures = null;
    this._lastCleanupFrame = 0;
    this._memTextures = 0;
  }
  get memoryUsage() {
    return this._memTextures * this._tx.w * this._tx.h;
  }
  releaseBlancoTextures() {
    this._memTextures -= this._blancoTextures.length;
    this._blancoTextures = [];
  }
  clear() {
    this._blancoTextures = null;
    this._colors.clear();
    this._memTextures = 0;
  }
  get(color) {
    let item = this._colors.get(color);
    if (!item) {
      item = { lf: -1, tx: void 0, u: -1 };
      this._colors.set(color, item);
    }
    return item;
  }
  set(color, texture, frame) {
    const item = this.get(color);
    item.lf = frame;
    item.tx = texture;
    item.u = frame;
    this._memTextures++;
  }
  cleanup(frame) {
    if (this._lastCleanupFrame !== frame) {
      this._blancoTextures = [];
      this._colors.forEach((item, color) => {
        if (item.lf < frame - 1) {
          if (item.tx) {
            this._blancoTextures.push(item.tx);
          }
          this._colors.delete(color);
        }
      });
      this._lastCleanupFrame = frame;
    }
  }
  reuseTexture(frame) {
    this.cleanup(frame);
    if (this._blancoTextures && this._blancoTextures.length) {
      this._memTextures--;
      return this._blancoTextures.pop();
    }
  }
}
class C2dRenderer extends Renderer {
  constructor(stage2) {
    super(stage2);
    this.tintManager = new C2dTextureTintManager(stage2);
    this.setupC2d(this.stage.c2d.canvas);
  }
  destroy() {
    this.tintManager.destroy();
  }
  _createDefaultShader(ctx) {
    return new DefaultShader2(ctx);
  }
  _getShaderBaseType() {
    return C2dShader;
  }
  _getShaderAlternative(shaderType) {
    return shaderType.getC2d && shaderType.getC2d();
  }
  createCoreQuadList(ctx) {
    return new C2dCoreQuadList(ctx);
  }
  createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
    return new C2dCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
  }
  createCoreRenderExecutor(ctx) {
    return new C2dCoreRenderExecutor(ctx);
  }
  createCoreRenderState(ctx) {
    return new CoreRenderState(ctx);
  }
  createRenderTexture(w, h, pw, ph) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = pw;
    canvas2.height = ph;
    this.setupC2d(canvas2);
    return canvas2;
  }
  freeRenderTexture(nativeTexture) {
    this.tintManager.delete(nativeTexture);
  }
  gc(aggressive) {
    this.tintManager.gc(aggressive);
  }
  uploadTextureSource(textureSource, options) {
    if (options.source.buffer) {
      const canvas2 = document.createElement("canvas");
      canvas2.width = options.w;
      canvas2.height = options.h;
      const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
      canvas2.getContext("2d").putImageData(imageData, 0, 0);
      return canvas2;
    }
    return options.source;
  }
  freeTextureSource(textureSource) {
    this.tintManager.delete(textureSource.nativeTexture);
  }
  addQuad(renderState, quads, index) {
    const elementCore = quads.quadElements[index];
    quads.setRenderContext(index, elementCore._renderContext);
    quads.setWhite(index, elementCore.isWhite());
    quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
  }
  isRenderTextureReusable(renderState, renderTextureInfo) {
    return false;
  }
  finishRenderState(renderState) {
  }
  setupC2d(canvas2) {
    const ctx = canvas2.getContext("2d");
    canvas2.ctx = ctx;
    ctx._scissor = null;
    canvas2.ctx.save();
  }
}
class SparkShader extends WebGLShader {
  enableAttribs() {
    let gl = this.gl;
    gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
    gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
    if (this._attrib("aTextureCoord") !== -1) {
      gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
      gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
    }
    if (this._attrib("aColor") !== -1) {
      gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
      gl.enableVertexAttribArray(this._attrib("aColor"));
    }
  }
  disableAttribs() {
    let gl = this.gl;
    gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
    if (this._attrib("aTextureCoord") !== -1) {
      gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
    }
    if (this._attrib("aColor") !== -1) {
      gl.disableVertexAttribArray(this._attrib("aColor"));
    }
  }
  setupUniforms(operation) {
    this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
  }
  draw(operation) {
    let gl = this.gl;
    let length = operation.length;
    if (length) {
      let glTexture = operation.getTexture(0);
      let pos = 0;
      for (let i = 0; i < length; i++) {
        let tx = operation.getTexture(i);
        if (glTexture !== tx) {
          if (glTexture.options && glTexture.options.imageRef) {
            let elementPostion = i > 0 ? i - 1 : i;
            const precision2 = this.ctx.stage.getOption("precision");
            let vc = operation.getElementCore(elementPostion);
            this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px * precision2, vc._worldContext.py * precision2, vc._colorUl, vc);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
          }
          glTexture = tx;
          pos = i;
        }
      }
      if (pos < length) {
        if (glTexture.options && glTexture.options.imageRef) {
          const precision2 = this.ctx.stage.getOption("precision");
          let vc = operation.getElementCore(pos);
          this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px * precision2, vc._worldContext.py * precision2, vc._colorUl, vc);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, glTexture);
          gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
        }
      }
    }
  }
}
SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;
class SparkRenderer extends WebGLRenderer {
  constructor(stage2) {
    super(stage2);
  }
  _createDefaultShader(ctx) {
    return new SparkShader(ctx);
  }
  createCoreRenderExecutor(ctx) {
    global.beginDrawing();
    let ret = super.createCoreRenderExecutor(ctx);
    global.endDrawing();
    return ret;
  }
}
class ImageWorker {
  constructor(options = {}) {
    this._items = /* @__PURE__ */ new Map();
    this._id = 0;
    this._initWorker();
  }
  destroy() {
    if (this._worker) {
      this._worker.terminate();
    }
  }
  _initWorker() {
    const code = `(${createWorker.toString()})()`;
    const blob = new Blob([code.replace('"use strict";', "")]);
    const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
      type: "application/javascript; charset=utf-8"
    });
    this._worker = new Worker(blobURL);
    this._worker.postMessage({ type: "config", config: { path: window.location.href, protocol: window.location.protocol } });
    this._worker.onmessage = (e) => {
      if (e.data && e.data.id) {
        const id = e.data.id;
        const item = this._items.get(id);
        if (item) {
          if (e.data.type == "data") {
            this.finish(item, e.data.info);
          } else {
            this.error(item, e.data.info);
          }
        }
      }
    };
  }
  create(src) {
    const id = ++this._id;
    const item = new ImageWorkerImage(this, id, src);
    this._items.set(id, item);
    this._worker.postMessage({ type: "add", id, src });
    return item;
  }
  cancel(image) {
    this._worker.postMessage({ type: "cancel", id: image.id });
    this._items.delete(image.id);
  }
  error(image, info) {
    image.error(info);
    this._items.delete(image.id);
  }
  finish(image, info) {
    image.load(info);
    this._items.delete(image.id);
  }
}
class ImageWorkerImage {
  constructor(manager, id, src) {
    this._manager = manager;
    this._id = id;
    this._src = src;
    this._onError = null;
    this._onLoad = null;
  }
  get id() {
    return this._id;
  }
  get src() {
    return this._src;
  }
  set onError(f) {
    this._onError = f;
  }
  set onLoad(f) {
    this._onLoad = f;
  }
  cancel() {
    this._manager.cancel(this);
  }
  load(info) {
    if (this._onLoad) {
      this._onLoad(info);
    }
  }
  error(info) {
    if (this._onError) {
      this._onError(info);
    }
  }
}
const createWorker = function() {
  function ImageWorkerServer() {
    this.items = /* @__PURE__ */ new Map();
    var t = this;
    onmessage = function(e) {
      t._receiveMessage(e);
    };
  }
  ImageWorkerServer.isPathAbsolute = function(path) {
    return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == "data:";
  };
  ImageWorkerServer.prototype._receiveMessage = function(e) {
    if (e.data.type === "config") {
      this.config = e.data.config;
      var base = this.config.path;
      var hasHashPath = /#.*?\//;
      if (hasHashPath.test(base)) {
        base = base.replace(/#.*$/, "");
      }
      var parts = base.split("/");
      parts.pop();
      this._relativeBase = parts.join("/") + "/";
    } else if (e.data.type === "add") {
      this.add(e.data.id, e.data.src);
    } else if (e.data.type === "cancel") {
      this.cancel(e.data.id);
    }
  };
  ImageWorkerServer.prototype.add = function(id, src) {
    if (!ImageWorkerServer.isPathAbsolute(src)) {
      src = this._relativeBase + src;
    }
    if (src.substr(0, 2) === "//") {
      src = this.config.protocol + src;
    }
    var item = new ImageWorkerServerItem(id, src);
    var t = this;
    item.onFinish = function(result) {
      t.finish(item, result);
    };
    item.onError = function(info) {
      t.error(item, info);
    };
    this.items.set(id, item);
    item.start();
  };
  ImageWorkerServer.prototype.cancel = function(id) {
    var item = this.items.get(id);
    if (item) {
      item.cancel();
      this.items.delete(id);
    }
  };
  ImageWorkerServer.prototype.finish = function(item, { imageBitmap, hasAlphaChannel }) {
    postMessage({
      type: "data",
      id: item.id,
      info: {
        imageBitmap,
        hasAlphaChannel
      }
    }, [imageBitmap]);
    this.items.delete(item.id);
  };
  ImageWorkerServer.prototype.error = function(item, { type, message }) {
    postMessage({
      type: "error",
      id: item.id,
      info: {
        type,
        message
      }
    });
    this.items.delete(item.id);
  };
  ImageWorkerServer.isWPEBrowser = function() {
    return navigator.userAgent.indexOf("WPE") !== -1;
  };
  function ImageWorkerServerItem(id, src) {
    this._onError = void 0;
    this._onFinish = void 0;
    this._id = id;
    this._src = src;
    this._xhr = void 0;
    this._mimeType = void 0;
    this._canceled = false;
  }
  Object.defineProperty(ImageWorkerServerItem.prototype, "id", {
    get: function() {
      return this._id;
    }
  });
  Object.defineProperty(ImageWorkerServerItem.prototype, "onFinish", {
    get: function() {
      return this._onFinish;
    },
    set: function(f) {
      this._onFinish = f;
    }
  });
  Object.defineProperty(ImageWorkerServerItem.prototype, "onError", {
    get: function() {
      return this._onError;
    },
    set: function(f) {
      this._onError = f;
    }
  });
  ImageWorkerServerItem.prototype.start = function() {
    this._xhr = new XMLHttpRequest();
    this._xhr.open("GET", this._src, true);
    this._xhr.responseType = "blob";
    var t = this;
    this._xhr.onerror = function(oEvent) {
      t.error({ type: "connection", message: "Connection error" });
    };
    this._xhr.onload = function(oEvent) {
      var blob = t._xhr.response;
      t._mimeType = blob.type;
      t._createImageBitmap(blob);
    };
    this._xhr.send();
  };
  ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
    var t = this;
    createImageBitmap(blob, { premultiplyAlpha: "premultiply", colorSpaceConversion: "none", imageOrientation: "none" }).then(function(imageBitmap) {
      t.finish({
        imageBitmap,
        hasAlphaChannel: t._hasAlphaChannel()
      });
    }).catch(function(e) {
      t.error({ type: "parse", message: "Error parsing image data" });
    });
  };
  ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
    if (ImageWorkerServer.isWPEBrowser()) {
      return true;
    } else {
      return this._mimeType.indexOf("image/png") !== -1;
    }
  };
  ImageWorkerServerItem.prototype.cancel = function() {
    if (this._canceled)
      return;
    if (this._xhr) {
      this._xhr.abort();
    }
    this._canceled = true;
  };
  ImageWorkerServerItem.prototype.error = function(type, message) {
    if (!this._canceled && this._onError) {
      this._onError({ type, message });
    }
  };
  ImageWorkerServerItem.prototype.finish = function(info) {
    if (!this._canceled && this._onFinish) {
      this._onFinish(info);
    }
  };
  new ImageWorkerServer();
};
class WebPlatform {
  init(stage2) {
    this.stage = stage2;
    this._looping = false;
    this._awaitingLoop = false;
    this._loopHandler = null;
    this._idleLoopCounter = 0;
    this._idleLoopDelay = 60;
    if (this.stage.getOption("useImageWorker")) {
      if (!window.createImageBitmap || !window.Worker) {
        console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
      } else {
        this._imageWorker = new ImageWorker();
      }
    }
    this._registerVisibilityChangeHandler();
  }
  destroy() {
    if (this._imageWorker) {
      this._imageWorker.destroy();
    }
    this._removeKeyHandler();
    this._removeClickHandler();
    this._removeHoverHandler();
    this._removeScrollWheelHandler();
    this._removeVisibilityChangeHandler();
  }
  startLoop() {
    this._looping = true;
    if (!this._awaitingLoop) {
      this.loop();
    }
  }
  stopLoop() {
    this._looping = false;
  }
  switchLoop() {
    if (this._idleLoopCounter < this._idleLoopDelay) {
      this._idleLoopCounter++;
      return;
    }
    if (!this.stage.ctx.hasRenderUpdates()) {
      this.stopLoop();
      this._loopHandler = setInterval(() => {
        this.stage.updateFrame();
        this.stage.idleFrame();
        if (this.stage.ctx.hasRenderUpdates()) {
          clearInterval(this._loopHandler);
          this.startLoop();
        }
      }, 1e3 / 60);
    } else {
      this._idleLoopCounter = 0;
    }
  }
  loop() {
    let self2 = this;
    let lp = function() {
      self2._awaitingLoop = false;
      if (self2._looping) {
        self2.stage.updateFrame();
        if (self2.stage.getOption("pauseRafLoopOnIdle")) {
          self2.switchLoop();
        }
        self2.stage.renderFrame();
        requestAnimationFrame(lp);
        self2._awaitingLoop = true;
      }
    };
    requestAnimationFrame(lp);
  }
  uploadCompressedGlTexture(gl, textureSource, source, options) {
    const view = !source.pvr ? new DataView(source.mipmaps[0]) : source.mipmaps[0];
    gl.compressedTexImage2D(
      gl.TEXTURE_2D,
      0,
      source.glInternalFormat,
      source.pixelWidth,
      source.pixelHeight,
      0,
      view
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  }
  uploadGlTexture(gl, textureSource, source, options) {
    if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || window.ImageBitmap && source instanceof ImageBitmap) {
      gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
    } else if (source instanceof HTMLCanvasElement) {
      if (Utils$2.isZiggo || this.stage.getOption("forceTxCanvasSource")) {
        gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
      } else if (source.width > 0 && source.height > 0) {
        const ctx = source.getContext("2d");
        gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
      }
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
    }
  }
  /**
   * KTX File format specification
   * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
   **/
  handleKtxLoad(cb, src) {
    var self2 = this;
    return function() {
      var arraybuffer = this.response;
      var view = new DataView(arraybuffer);
      var targetIdentifier = 3632701469;
      if (targetIdentifier !== view.getUint32(0) + view.getUint32(4) + view.getUint32(8)) {
        cb("Parsing failed: identifier ktx mismatch:", src);
      }
      var littleEndian = view.getUint32(12) === 16909060 ? true : false;
      var data = {
        glType: view.getUint32(16, littleEndian),
        glTypeSize: view.getUint32(20, littleEndian),
        glFormat: view.getUint32(24, littleEndian),
        glInternalFormat: view.getUint32(28, littleEndian),
        glBaseInternalFormat: view.getUint32(32, littleEndian),
        pixelWidth: view.getUint32(36, littleEndian),
        pixelHeight: view.getUint32(40, littleEndian),
        pixelDepth: view.getUint32(44, littleEndian),
        numberOfArrayElements: view.getUint32(48, littleEndian),
        numberOfFaces: view.getUint32(52, littleEndian),
        numberOfMipmapLevels: view.getUint32(56, littleEndian),
        bytesOfKeyValueData: view.getUint32(60, littleEndian),
        kvps: [],
        mipmaps: [],
        get width() {
          return this.pixelWidth;
        },
        get height() {
          return this.pixelHeight;
        }
      };
      const props = (obj) => {
        const p = [];
        for (let v in obj) {
          p.push(obj[v]);
        }
        return p;
      };
      const formats = Object.values(self2.stage.renderer.getCompressedTextureExtensions()).filter((obj) => obj != null).map((obj) => props(obj)).reduce((prev, current) => prev.concat(current));
      if (!formats.includes(data.glInternalFormat)) {
        console.warn("[Lightning] Unrecognized texture extension format:", src, data.glInternalFormat, self2.stage.renderer.getCompressedTextureExtensions());
      }
      var offset = 64;
      offset += data.bytesOfKeyValueData;
      for (var i = 0; i < data.numberOfMipmapLevels; i++) {
        var imageSize = view.getUint32(offset);
        offset += 4;
        data.mipmaps.push(view.buffer.slice(offset, imageSize));
        offset += imageSize;
      }
      cb(null, {
        source: data,
        renderInfo: { src, compressed: true }
      });
    };
  }
  handlePvrLoad(cb, src) {
    return function() {
      const pvrHeaderLength = 13;
      const pvrFormatEtc1 = 36196;
      const pvrWidth = 7;
      const pvrHeight = 6;
      const pvrMipmapCount = 11;
      const pvrMetadata = 12;
      const arrayBuffer = this.response;
      const header = new Int32Array(arrayBuffer, 0, pvrHeaderLength);
      const dataOffset = header[pvrMetadata] + 52;
      const pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
      var data = {
        glInternalFormat: pvrFormatEtc1,
        pixelWidth: header[pvrWidth],
        pixelHeight: header[pvrHeight],
        numberOfMipmapLevels: header[pvrMipmapCount],
        mipmaps: [],
        pvr: true,
        get width() {
          return this.pixelWidth;
        },
        get height() {
          return this.pixelHeight;
        }
      };
      let offset = 0;
      let width = data.pixelWidth;
      let height = data.pixelHeight;
      for (var i = 0; i < data.numberOfMipmapLevels; i++) {
        const level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
        const view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
        data.mipmaps.push(view);
        offset += level;
        width = width >> 1;
        height = height >> 1;
      }
      cb(null, {
        source: data,
        renderInfo: { src, compressed: true }
      });
    };
  }
  loadSrcTexture({ src, hasAlpha }, cb) {
    let cancelCb = void 0;
    let isPng = src.indexOf(".png") >= 0 || src.substr(0, 21) == "data:image/png;base64";
    let isKtx = src.indexOf(".ktx") >= 0;
    let isPvr = src.indexOf(".pvr") >= 0;
    if (isKtx || isPvr) {
      let request = new XMLHttpRequest();
      request.addEventListener(
        "load",
        isKtx ? this.handleKtxLoad(cb, src) : this.handlePvrLoad(cb, src)
      );
      request.open("GET", src);
      request.responseType = "arraybuffer";
      request.send();
      cancelCb = function() {
        request.abort();
      };
    } else if (this._imageWorker) {
      const image = this._imageWorker.create(src);
      image.onError = function(err) {
        return cb("Image load error");
      };
      image.onLoad = function({ imageBitmap, hasAlphaChannel }) {
        cb(null, {
          source: imageBitmap,
          renderInfo: { src, compressed: false },
          hasAlpha: hasAlphaChannel,
          premultiplyAlpha: true
        });
      };
      cancelCb = function() {
        image.cancel();
      };
    } else {
      let image = new Image();
      if (!(src.substr(0, 5) == "data:") && !Utils$2.isPS4) {
        image.crossOrigin = "Anonymous";
      }
      image.onerror = function(err) {
        if (image.src) {
          return cb("Image load error");
        }
      };
      image.onload = function() {
        cb(null, {
          source: image,
          renderInfo: { src, compressed: false },
          hasAlpha: isPng || hasAlpha
        });
      };
      image.src = src;
      cancelCb = function() {
        image.onerror = null;
        image.onload = null;
        image.removeAttribute("src");
      };
    }
    return cancelCb;
  }
  createWebGLContext(w, h) {
    let canvas2 = this.stage.getOption("canvas") || document.createElement("canvas");
    if (w && h) {
      canvas2.width = w;
      canvas2.height = h;
    }
    let opts = {
      alpha: true,
      antialias: false,
      premultipliedAlpha: true,
      stencil: true,
      preserveDrawingBuffer: false
    };
    let gl = canvas2.getContext("webgl", opts) || canvas2.getContext("experimental-webgl", opts);
    if (!gl) {
      throw new Error("This browser does not support webGL.");
    }
    return gl;
  }
  createCanvasContext(w, h) {
    let canvas2 = this.stage.getOption("canvas") || document.createElement("canvas");
    if (w && h) {
      canvas2.width = w;
      canvas2.height = h;
    }
    let c2d = canvas2.getContext("2d");
    if (!c2d) {
      throw new Error("This browser does not support 2d canvas.");
    }
    return c2d;
  }
  getHrTime() {
    return window.performance ? window.performance.now() : (/* @__PURE__ */ new Date()).getTime();
  }
  getDrawingCanvas() {
    return document.createElement("canvas");
  }
  getTextureOptionsForDrawingCanvas(canvas2) {
    let options = {};
    options.source = canvas2;
    return options;
  }
  nextFrame(changes) {
  }
  registerKeydownHandler(keyhandler) {
    this._keydownListener = (e) => {
      keyhandler(e);
    };
    window.addEventListener("keydown", this._keydownListener);
  }
  registerKeyupHandler(keyhandler) {
    this._keyupListener = (e) => {
      keyhandler(e);
    };
    window.addEventListener("keyup", this._keyupListener);
  }
  _removeKeyHandler() {
    if (this._keydownListener) {
      window.removeEventListener("keydown", this._keydownListener);
    }
    if (this._keyupListener) {
      window.removeEventListener("keyup", this._keyupListener);
    }
  }
  registerClickHandler(clickHandler) {
    this._clickListener = (e) => {
      clickHandler(e);
    };
    window.addEventListener("mousedown", this._clickListener);
  }
  _removeClickHandler() {
    if (this._clickListener) {
      window.removeEventListener("mousedown", this._clickListener);
    }
  }
  registerHoverHandler(hoverHandler) {
    this._hoverListener = (e) => {
      hoverHandler(e);
    };
    window.addEventListener("mousemove", this._hoverListener);
  }
  _removeHoverHandler() {
    if (this._hoverListener) {
      window.removeEventListener("mousemove", this._hoverListener);
    }
  }
  registerScrollWheelHandler(registerScrollWheelHandler) {
    this._scrollWheelListener = (e) => {
      registerScrollWheelHandler(e);
    };
    window.addEventListener("wheel", this._scrollWheelListener);
  }
  _removeScrollWheelHandler() {
    if (this._scrollWheelListener) {
      window.removeEventListener("wheel", this._scrollWheelListener);
    }
  }
  /**
   * Fix for issue reported at: https://github.com/WebPlatformForEmbedded/WPEWebKit/issues/882
   */
  _registerVisibilityChangeHandler() {
    this._visibilityChangeHandler = () => {
      if (document.visibilityState === "visible") {
        this.stage.root.core.setHasRenderUpdates(2);
        this.stage.renderFrame();
      }
    };
    document.addEventListener("visibilitychange", this._visibilityChangeHandler);
  }
  _removeVisibilityChangeHandler() {
    if (this._visibilityChangeHandler) {
      document.removeEventListener("visibilitychange", this._visibilityChangeHandler);
    }
  }
}
class PlatformLoader {
  static load(options) {
    if (options.platform) {
      return options.platform;
    } else {
      return WebPlatform;
    }
  }
}
let Utils$1 = class Utils2 {
  static isFunction(value) {
    return typeof value === "function";
  }
  static isNumber(value) {
    return typeof value === "number";
  }
  static isInteger(value) {
    return typeof value === "number" && value % 1 === 0;
  }
  static isBoolean(value) {
    return value === true || value === false;
  }
  static isString(value) {
    return typeof value == "string";
  }
  static isObject(value) {
    let type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  static isPlainObject(value) {
    let type = typeof value;
    return !!value && type == "object";
  }
  static isObjectLiteral(value) {
    return typeof value === "object" && value && value.constructor === Object;
  }
  static getArrayIndex(index, arr) {
    return Utils2.getModuloIndex(index, arr.length);
  }
  static equalValues(v1, v2) {
    if (typeof v1 !== typeof v2)
      return false;
    if (Utils2.isObjectLiteral(v1)) {
      return Utils2.isObjectLiteral(v2) && Utils2.equalObjectLiterals(v1, v2);
    } else if (Array.isArray(v1)) {
      return Array.isArray(v2) && Utils2.equalArrays(v1, v2);
    } else {
      return v1 === v2;
    }
  }
  static equalObjectLiterals(obj1, obj2) {
    let keys1 = Object.keys(obj1);
    let keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (let i = 0, n = keys1.length; i < n; i++) {
      const k1 = keys1[i];
      const k2 = keys2[i];
      if (k1 !== k2) {
        return false;
      }
      const v1 = obj1[k1];
      const v2 = obj2[k2];
      if (!Utils2.equalValues(v1, v2)) {
        return false;
      }
    }
    return true;
  }
  static equalArrays(v1, v2) {
    if (v1.length !== v2.length) {
      return false;
    }
    for (let i = 0, n = v1.length; i < n; i++) {
      if (!this.equalValues(v1[i], v2[i])) {
        return false;
      }
    }
    return true;
  }
};
class WebGLState {
  constructor(id, gl) {
    this._id = id;
    this._gl = gl;
    this._program = void 0;
    this._buffers = /* @__PURE__ */ new Map();
    this._framebuffers = /* @__PURE__ */ new Map();
    this._renderbuffers = /* @__PURE__ */ new Map();
    this._vertexAttribs = new Array(16);
    this._nonDefaultFlags = /* @__PURE__ */ new Set();
    this._settings = /* @__PURE__ */ new Map();
    this._textures = new Array(8);
    this._maxTexture = 0;
    this._activeTexture = gl.TEXTURE0;
    this._pixelStorei = new Array(5);
  }
  _getDefaultFlag(cap) {
    return cap === this._gl.DITHER;
  }
  setFlag(cap, v) {
    const def = this._getDefaultFlag(cap);
    if (v === def) {
      return this._nonDefaultFlags.delete(cap);
    } else {
      if (!this._nonDefaultFlags.has(cap)) {
        this._nonDefaultFlags.add(cap);
        return true;
      } else {
        return false;
      }
    }
  }
  setBuffer(target, buffer) {
    const change = this._buffers.get(target) !== buffer;
    this._buffers.set(target, buffer);
    if (change && target === this._gl.ARRAY_BUFFER) {
      this._vertexAttribs = [];
    }
    return change;
  }
  setFramebuffer(target, buffer) {
    const change = this._framebuffers.get(target) !== buffer;
    this._framebuffers.set(target, buffer);
    return change;
  }
  setRenderbuffer(target, buffer) {
    const change = this._renderbuffers.get(target) !== buffer;
    this._renderbuffers.set(target, buffer);
    return change;
  }
  setProgram(program) {
    const change = this._program !== program;
    this._program = program;
    return change;
  }
  setSetting(func, v) {
    const s = this._settings.get(func);
    const change = !s || !Utils$1.equalValues(s, v);
    this._settings.set(func, v);
    return change;
  }
  disableVertexAttribArray(index) {
    const va = this._vertexAttribs[index];
    if (va && va[5]) {
      va[5] = false;
      return true;
    }
    return false;
  }
  enableVertexAttribArray(index) {
    const va = this._vertexAttribs[index];
    if (va) {
      if (!va[0]) {
        va[0] = true;
        return true;
      }
    } else {
      this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
      return true;
    }
    return false;
  }
  vertexAttribPointer(index, props) {
    let va = this._vertexAttribs[index];
    let equal = false;
    if (va) {
      equal = va[0] === props[0] && va[1] === props[1] && va[2] === props[2] && va[3] === props[3] && va[4] === props[4];
    }
    if (equal) {
      return false;
    } else {
      props[5] = va ? va[5] : false;
      return true;
    }
  }
  setActiveTexture(texture) {
    const changed = this._activeTexture !== texture;
    this._activeTexture = texture;
    return changed;
  }
  bindTexture(target, texture) {
    const activeIndex = WebGLState._getTextureIndex(this._activeTexture);
    this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
    const current = this._textures[activeIndex];
    const targetIndex = WebGLState._getTextureTargetIndex(target);
    if (current) {
      if (current[targetIndex] === texture) {
        return false;
      }
      current[targetIndex] = texture;
      return true;
    } else {
      if (texture) {
        this._textures[activeIndex] = [];
        this._textures[activeIndex][targetIndex] = texture;
        return true;
      } else {
        return false;
      }
    }
  }
  setPixelStorei(pname, param) {
    const i = WebGLState._getPixelStoreiIndex(pname);
    const change = !Utils$1.equalValues(this._pixelStorei[i], param);
    this._pixelStorei[i] = param;
    return change;
  }
  migrate(s) {
    const t = this;
    this._migrateFlags(t, s);
    if (s._program !== t._program) {
      this._gl._useProgram(s._program);
    }
    this._migrateFramebuffers(t, s);
    this._migrateRenderbuffers(t, s);
    const buffersChanged = this._migrateBuffers(t, s);
    this._migrateAttributes(t, s, buffersChanged);
    this._migrateFlags(t, s);
    this._migrateSettings(t, s);
    this._migratePixelStorei(t, s);
    this._migrateTextures(t, s);
  }
  _migratePixelStorei(t, s) {
    for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
      if (t._pixelStorei[i] !== s._pixelStorei[i]) {
        const value = s._pixelStorei[i] !== void 0 ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
        this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
      }
    }
  }
  _migrateTextures(t, s) {
    const max = Math.max(t._maxTexture, s._maxTexture);
    let activeTexture = t._activeTexture;
    for (let i = 0; i < max; i++) {
      const sTargets = s._textures[i];
      const tTargets = t._textures[i];
      const textureNumb = WebGLState._getTextureByIndex(i);
      const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
      for (let j = 0, n = targetMax; j < n; j++) {
        const target = WebGLState._getTextureTargetByIndex(j);
        if (activeTexture !== textureNumb) {
          this._gl._activeTexture(textureNumb);
          activeTexture = textureNumb;
        }
        const texture = sTargets && sTargets[j] || null;
        this._gl._bindTexture(target, texture);
      }
    }
    if (s._activeTexture !== activeTexture) {
      this._gl._activeTexture(s._activeTexture);
    }
  }
  _migrateBuffers(t, s) {
    s._buffers.forEach((framebuffer, target) => {
      if (t._buffers.get(target) !== framebuffer) {
        this._gl._bindBuffer(target, framebuffer);
      }
    });
    t._buffers.forEach((buffer, target) => {
      const b = s._buffers.get(target);
      if (b === void 0) {
        this._gl._bindBuffer(target, null);
      }
    });
    return s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER);
  }
  _migrateFramebuffers(t, s) {
    s._framebuffers.forEach((framebuffer, target) => {
      if (t._framebuffers.get(target) !== framebuffer) {
        this._gl._bindFramebuffer(target, framebuffer);
      }
    });
    t._framebuffers.forEach((framebuffer, target) => {
      const fb = s._framebuffers.get(target);
      if (fb === void 0) {
        this._gl._bindFramebuffer(target, null);
      }
    });
  }
  _migrateRenderbuffers(t, s) {
    s._renderbuffers.forEach((renderbuffer, target) => {
      if (t._renderbuffers.get(target) !== renderbuffer) {
        this._gl._bindRenderbuffer(target, renderbuffer);
      }
    });
    t._renderbuffers.forEach((renderbuffer, target) => {
      const fb = s._renderbuffers.get(target);
      if (fb === void 0) {
        this._gl._bindRenderbuffer(target, null);
      }
    });
  }
  _migrateAttributes(t, s, buffersChanged) {
    if (!buffersChanged) {
      t._vertexAttribs.forEach((attrib, index) => {
        if (!s._vertexAttribs[index]) {
          this._gl._disableVertexAttribArray(index);
        }
      });
      s._vertexAttribs.forEach((attrib, index) => {
        this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
        if (attrib[5]) {
          this._gl._enableVertexAttribArray(index);
        } else {
          this._gl._disableVertexAttribArray(index);
        }
      });
    } else {
      s._vertexAttribs.forEach((attrib, index) => {
        if (attrib[0]) {
          this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
        }
        if (attrib[5]) {
          this._gl._enableVertexAttribArray(index);
        }
      });
    }
  }
  _migrateSettings(t, s) {
    const defaults2 = this.constructor.getDefaultSettings();
    t._settings.forEach((value, func) => {
      const name2 = func.name || func.xname;
      if (!s._settings.has(func)) {
        let args = defaults2.get(name2);
        if (Utils$1.isFunction(args)) {
          args = args(this._gl);
        }
        s._settings.set(func, args);
        func.apply(this._gl, args);
      }
    });
    s._settings.forEach((value, func) => {
      const tValue = t._settings.get(func);
      if (!tValue || !Utils$1.equalValues(tValue, value)) {
        func.apply(this._gl, value);
      }
    });
  }
  _migrateFlags(t, s) {
    t._nonDefaultFlags.forEach((setting) => {
      if (!s._nonDefaultFlags.has(setting)) {
        if (this._getDefaultFlag(setting)) {
          this._gl._enable(setting);
        } else {
          this._gl._disable(setting);
        }
      }
    });
    s._nonDefaultFlags.forEach((setting) => {
      if (!t._nonDefaultFlags.has(setting)) {
        if (this._getDefaultFlag(setting)) {
          this._gl._disable(setting);
        } else {
          this._gl._enable(setting);
        }
      }
    });
  }
  static getDefaultSettings() {
    if (!this._defaultSettings) {
      this._defaultSettings = /* @__PURE__ */ new Map();
      const d = this._defaultSettings;
      const g = WebGLRenderingContext.prototype;
      d.set("viewport", function(gl) {
        return [0, 0, gl.canvas.width, gl.canvas.height];
      });
      d.set("scissor", function(gl) {
        return [0, 0, gl.canvas.width, gl.canvas.height];
      });
      d.set("blendColor", [0, 0, 0, 0]);
      d.set("blendEquation", [g.FUNC_ADD]);
      d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
      d.set("blendFunc", [g.ONE, g.ZERO]);
      d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
      d.set("clearColor", [0, 0, 0, 0]);
      d.set("clearDepth", [1]);
      d.set("clearStencil", [0]);
      d.set("colorMask", [true, true, true, true]);
      d.set("cullFace", [g.BACK]);
      d.set("depthFunc", [g.LESS]);
      d.set("depthMask", [true]);
      d.set("depthRange", [0, 1]);
      d.set("frontFace", [g.CCW]);
      d.set("lineWidth", [1]);
      d.set("polygonOffset", [0, 0]);
      d.set("sampleCoverage", [1, false]);
      d.set("stencilFunc", [g.ALWAYS, 0, 1]);
      d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
      d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
      d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
      d.set("stencilMask", [1]);
      d.set("_stencilMaskSeparateFront", [1]);
      d.set("_stencilMaskSeparateBack", [1]);
      d.set("_stencilMaskSeparateFrontAndBack", [1]);
      d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
      d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
      d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
      d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
      d.set("vertexAttrib1f", []);
      d.set("vertexAttrib1fv", []);
      d.set("vertexAttrib2f", []);
      d.set("vertexAttrib2fv", []);
      d.set("vertexAttrib3f", []);
      d.set("vertexAttrib3fv", []);
      d.set("vertexAttrib4f", []);
      d.set("vertexAttrib4fv", []);
    }
    return this._defaultSettings;
  }
  static _getTextureTargetIndex(target) {
    switch (target) {
      case 3553:
        return 0;
      case 34067:
        return 1;
      default:
        throw new Error("Unknown texture target: " + target);
    }
  }
  static _getTextureTargetByIndex(index) {
    if (!this._textureTargetIndices) {
      this._textureTargetIndices = [3553, 34067];
    }
    return this._textureTargetIndices[index];
  }
  static _getTextureIndex(index) {
    return index - 33984;
  }
  static _getTextureByIndex(index) {
    return index + 33984;
  }
  static _getPixelStoreiIndex(pname) {
    switch (pname) {
      case 3333:
        return 0;
      case 3317:
        return 1;
      case 37440:
        return 2;
      case 37441:
        return 3;
      case 37443:
        return 4;
      case 37445:
        return 5;
      default:
        throw new Error("Unknown pixelstorei: " + pname);
    }
  }
  static _getPixelStoreiByIndex(index) {
    if (!this._pixelStoreiIndices) {
      this._pixelStoreiIndices = [3333, 3317, 37440, 37441, 37443];
    }
    return this._pixelStoreiIndices[index];
  }
  static _getDefaultPixelStoreiByIndex(index) {
    if (!this._pixelStoreiDefaults) {
      this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
    }
    return this._pixelStoreiDefaults[index];
  }
}
class WebGLStateManager {
  _initStateManager(id = "default") {
    this._states = {};
    this._state = this._getState(id);
  }
  _getState(id) {
    if (!this._states[id]) {
      this._states[id] = new WebGLState(id, this);
    }
    return this._states[id];
  }
  switchState(id = "default") {
    if (this._state._id !== id) {
      const newState = this._getState(id);
      this._state.migrate(newState);
      this._state = newState;
    }
  }
  $useProgram(program) {
    if (this._state.setProgram(program))
      this._useProgram(program);
  }
  $bindBuffer(target, fb) {
    if (this._state.setBuffer(target, fb))
      this._bindBuffer(target, fb);
  }
  $bindFramebuffer(target, fb) {
    if (this._state.setFramebuffer(target, fb))
      this._bindFramebuffer(target, fb);
  }
  $bindRenderbuffer(target, fb) {
    if (this._state.setRenderbuffer(target, fb))
      this._bindRenderbuffer(target, fb);
  }
  $enable(cap) {
    if (this._state.setFlag(cap, true))
      this._enable(cap);
  }
  $disable(cap) {
    if (this._state.setFlag(cap, false))
      this._disable(cap);
  }
  $viewport(x, y, w, h) {
    if (this._state.setSetting(this._viewport, [x, y, w, h]))
      this._viewport(x, y, w, h);
  }
  $scissor(x, y, w, h) {
    if (this._state.setSetting(this._scissor, [x, y, w, h]))
      this._scissor(x, y, w, h);
  }
  $disableVertexAttribArray(index) {
    if (this._state.disableVertexAttribArray(index))
      this._disableVertexAttribArray(index);
  }
  $enableVertexAttribArray(index) {
    if (this._state.enableVertexAttribArray(index))
      this._enableVertexAttribArray(index);
  }
  $vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
      this._vertexAttribPointer(index, size, type, normalized, stride, offset);
  }
  $activeTexture(texture) {
    if (this._state.setActiveTexture(texture))
      this._activeTexture(texture);
  }
  $bindTexture(target, texture) {
    if (this._state.bindTexture(target, texture))
      this._bindTexture(target, texture);
  }
  $pixelStorei(pname, param) {
    if (this._state.setPixelStorei(pname, param)) {
      this._pixelStorei(pname, param);
    }
  }
  $stencilFuncSeparate(face, func, ref, mask) {
    let f;
    switch (face) {
      case this.FRONT:
        f = this._stencilFuncSeparateFront;
        break;
      case this.BACK:
        f = this._stencilFuncSeparateBack;
        break;
      case this.FRONT_AND_BACK:
        f = this._stencilFuncSeparateFrontAndBack;
        break;
    }
    if (this._state.setSetting(f, [func, ref, mask]))
      f.apply(this, [func, ref, mask]);
  }
  _stencilFuncSeparateFront(func, ref, mask) {
    this._stencilFuncSeparate(this.FRONT, func, ref, mask);
  }
  _stencilFuncSeparateBack(func, ref, mask) {
    this._stencilFuncSeparate(this.BACK, func, ref, mask);
  }
  _stencilFuncSeparateFrontAndBack(func, ref, mask) {
    this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
  }
  $stencilMaskSeparate(face, mask) {
    let f;
    switch (face) {
      case this.FRONT:
        f = this._stencilMaskSeparateFront;
        break;
      case this.BACK:
        f = this._stencilMaskSeparateBack;
        break;
      case this.FRONT_AND_BACK:
        f = this._stencilMaskSeparateFrontAndBack;
        break;
    }
    if (this._state.setSetting(f, [mask]))
      f.apply(this, [mask]);
  }
  _stencilMaskSeparateFront(mask) {
    this._stencilMaskSeparate(this.FRONT, mask);
  }
  _stencilMaskSeparateBack(mask) {
    this._stencilMaskSeparate(this.BACK, mask);
  }
  _stencilMaskSeparateFrontAndBack(mask) {
    this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
  }
  $stencilOpSeparate(face, fail, zfail, zpass) {
    let f;
    switch (face) {
      case this.FRONT:
        f = this._stencilOpSeparateFront;
        break;
      case this.BACK:
        f = this._stencilOpSeparateBack;
        break;
      case this.FRONT_AND_BACK:
        f = this._stencilOpSeparateFrontAndBack;
        break;
    }
    if (this._state.setSetting(f, [fail, zfail, zpass]))
      f.apply(this, [fail, zfail, zpass]);
  }
  _stencilOpSeparateFront(fail, zfail, zpass) {
    this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
  }
  _stencilOpSeparateBack(fail, zfail, zpass) {
    this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
  }
  _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
    this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
  }
  $blendColor(red, green, blue, alpha) {
    if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
      this._blendColor(red, green, blue, alpha);
  }
  $blendEquation(mode) {
    if (this._state.setSetting(this._blendEquation, [mode]))
      this._blendEquation(mode);
  }
  $blendEquationSeparate(modeRGB, modeAlpha) {
    if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
      this._blendEquationSeparate(modeRGB, modeAlpha);
  }
  $blendFunc(sfactor, dfactor) {
    if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
      this._blendFunc(sfactor, dfactor);
  }
  $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
    if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
      this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  $clearColor(red, green, blue, alpha) {
    if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
      this._clearColor(red, green, blue, alpha);
  }
  $clearDepth(depth) {
    if (this._state.setSetting(this._clearDepth, [depth]))
      this._clearDepth(depth);
  }
  $clearStencil(s) {
    if (this._state.setSetting(this._clearStencil, [s]))
      this._clearStencil(s);
  }
  $colorMask(red, green, blue, alpha) {
    if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
      this._colorMask(red, green, blue, alpha);
  }
  $cullFace(mode) {
    if (this._state.setSetting(this._cullFace, [mode]))
      this._cullFace(mode);
  }
  $depthFunc(func) {
    if (this._state.setSetting(this._depthFunc, [func]))
      this._depthFunc(func);
  }
  $depthMask(flag) {
    if (this._state.setSetting(this._depthMask, [flag]))
      this._depthMask(flag);
  }
  $depthRange(zNear, zFar) {
    if (this._state.setSetting(this._depthRange, [zNear, zFar]))
      this._depthRange(zNear, zFar);
  }
  $frontFace(mode) {
    if (this._state.setSetting(this._frontFace, [mode]))
      this._frontFace(mode);
  }
  $lineWidth(width) {
    if (this._state.setSetting(this._lineWidth, [width]))
      this._lineWidth(width);
  }
  $polygonOffset(factor, units) {
    if (this._state.setSetting(this._polygonOffset, [factor, units]))
      this._polygonOffset(factor, units);
  }
  $sampleCoverage(value, invert) {
    if (this._state.setSetting(this._sampleCoverage, [value, invert]))
      this._sampleCoverage(value, invert);
  }
  $stencilFunc(func, ref, mask) {
    if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
      this._stencilFunc(func, ref, mask);
  }
  $stencilMask(mask) {
    if (this._state.setSetting(this._stencilMask, [mask]))
      this._stencilMask(mask);
  }
  $stencilOp(fail, zfail, zpass) {
    if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
      this._stencilOp(fail, zfail, zpass);
  }
  $vertexAttrib1f(indx, x) {
    if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
      this._vertexAttrib1f(indx, x);
  }
  $vertexAttrib1fv(indx, values) {
    if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
      this._vertexAttrib1fv(indx, values);
  }
  $vertexAttrib2f(indx, x, y) {
    if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
      this._vertexAttrib2f(indx, x, y);
  }
  $vertexAttrib2fv(indx, values) {
    if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
      this._vertexAttrib2fv(indx, values);
  }
  $vertexAttrib3f(indx, x, y, z) {
    if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
      this._vertexAttrib3f(indx, x, y, z);
  }
  $vertexAttrib3fv(indx, values) {
    if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
      this._vertexAttrib3fv(indx, values);
  }
  $vertexAttrib4f(indx, x, y, z, w) {
    if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
      this._vertexAttrib4f(indx, x, y, z, w);
  }
  $vertexAttrib4fv(indx, values) {
    if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
      this._vertexAttrib4fv(indx, values);
  }
  /**
   * Sets up the rendering context for context sharing.
   * @param {WebGLRenderingContext} gl
   * @param {string} id
   */
  static enable(gl, id = "default") {
    const names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
    gl.__proto__;
    names.forEach((name2) => {
      if (name2 !== "constructor") {
        const method = WebGLStateManager.prototype[name2];
        if (name2.charAt(0) === "$") {
          name2 = name2.substr(1);
        }
        if (gl[name2] !== method) {
          if (gl[name2]) {
            if (!gl[name2].name) {
              gl[name2].xname = name2;
            }
            gl["_" + name2] = gl[name2];
          }
          gl[name2] = method;
        }
      }
    });
    WebGLStateManager.prototype._initStateManager.call(gl, id);
    return gl;
  }
}
class TextureManager {
  constructor(stage2) {
    this.stage = stage2;
    this._usedMemory = 0;
    this._uploadedTextureSources = [];
    this.textureSourceHashmap = /* @__PURE__ */ new Map();
  }
  get usedMemory() {
    return this._usedMemory;
  }
  destroy() {
    for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
      this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
    }
    this.textureSourceHashmap.clear();
    this._usedMemory = 0;
  }
  getReusableTextureSource(id) {
    return this.textureSourceHashmap.get(id);
  }
  getTextureSource(func, id) {
    let textureSource = id ? this.textureSourceHashmap.get(id) : null;
    if (!textureSource) {
      textureSource = new TextureSource(this, func);
      if (id) {
        textureSource.lookupId = id;
        this.textureSourceHashmap.set(id, textureSource);
      }
    }
    return textureSource;
  }
  uploadTextureSource(textureSource, options) {
    if (textureSource.isLoaded())
      return;
    this._addMemoryUsage(textureSource.w * textureSource.h);
    const nativeTexture = this._nativeUploadTextureSource(textureSource, options);
    textureSource._nativeTexture = nativeTexture;
    nativeTexture.w = textureSource.w;
    nativeTexture.h = textureSource.h;
    nativeTexture.update = this.stage.frameCounter;
    this._uploadedTextureSources.push(textureSource);
    this.addToLookupMap(textureSource);
    this._updateVramUsage(textureSource, 1);
  }
  _addMemoryUsage(delta) {
    this._usedMemory += delta;
    this.stage.addMemoryUsage(delta);
  }
  _updateVramUsage(textureSource, sign) {
    const nativeTexture = textureSource.nativeTexture;
    var usage;
    if (!Stage.isWebglSupported())
      return;
    if (!textureSource.isLoaded())
      return;
    if (!nativeTexture.hasOwnProperty("bytesPerPixel") || isNaN(nativeTexture.bytesPerPixel))
      return;
    usage = sign * (textureSource.w * textureSource.h * nativeTexture.bytesPerPixel);
    this.stage.addVramUsage(usage, textureSource.hasAlpha);
  }
  addToLookupMap(textureSource) {
    const lookupId = textureSource.lookupId;
    if (lookupId) {
      if (!this.textureSourceHashmap.has(lookupId)) {
        this.textureSourceHashmap.set(lookupId, textureSource);
      }
    }
  }
  gc() {
    this.freeUnusedTextureSources();
    this._cleanupLookupMap();
  }
  freeUnusedTextureSources() {
    let remainingTextureSources = [];
    for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
      let ts = this._uploadedTextureSources[i];
      if (ts.allowCleanup()) {
        this._freeManagedTextureSource(ts);
      } else {
        remainingTextureSources.push(ts);
      }
    }
    this._uploadedTextureSources = remainingTextureSources;
    this._cleanupLookupMap();
  }
  _freeManagedTextureSource(textureSource) {
    if (textureSource.isLoaded()) {
      this._nativeFreeTextureSource(textureSource);
      this._addMemoryUsage(-textureSource.w * textureSource.h);
      this._updateVramUsage(textureSource, -1);
    }
    textureSource.loadingSince = null;
  }
  _cleanupLookupMap() {
    this.textureSourceHashmap.forEach((textureSource, lookupId) => {
      if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
        this.textureSourceHashmap.delete(lookupId);
      }
    });
  }
  /**
   * Externally free texture source.
   * @param textureSource
   */
  freeTextureSource(textureSource) {
    const index = this._uploadedTextureSources.indexOf(textureSource);
    const managed = index !== -1;
    if (textureSource.isLoaded()) {
      if (managed) {
        this._addMemoryUsage(-textureSource.w * textureSource.h);
        this._uploadedTextureSources.splice(index, 1);
      }
      this._nativeFreeTextureSource(textureSource);
    }
    textureSource.loadingSince = null;
  }
  _nativeUploadTextureSource(textureSource, options) {
    return this.stage.renderer.uploadTextureSource(textureSource, options);
  }
  _nativeFreeTextureSource(textureSource) {
    this.stage.renderer.freeTextureSource(textureSource);
    textureSource.clearNativeTexture();
  }
}
class TextureThrottler {
  constructor(stage2) {
    this.stage = stage2;
    this.genericCancelCb = (textureSource) => {
      this._remove(textureSource);
    };
    this._sources = [];
    this._data = [];
  }
  destroy() {
    this._sources = [];
    this._data = [];
  }
  processSome() {
    if (this._sources.length) {
      const start2 = Date.now();
      do {
        this._processItem();
      } while (this._sources.length && Date.now() - start2 < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME);
    }
  }
  _processItem() {
    const source = this._sources.pop();
    const data = this._data.pop();
    if (source.isLoading()) {
      source.processLoadedSource(data);
    }
  }
  add(textureSource, data) {
    this._sources.push(textureSource);
    this._data.push(data);
  }
  _remove(textureSource) {
    const index = this._sources.indexOf(textureSource);
    if (index >= 0) {
      this._sources.splice(index, 1);
      this._data.splice(index, 1);
    }
  }
}
TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;
class CoreContext {
  constructor(stage2) {
    this.stage = stage2;
    this.root = null;
    this.updateTreeOrder = 0;
    this.renderState = this.stage.renderer.createCoreRenderState(this);
    this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
    this.renderExec.init();
    this._usedMemory = 0;
    this._renderTexturePool = [];
    this._renderTextureId = 1;
    this._zSorts = [];
    this.renderToTextureCount = 0;
  }
  get usedMemory() {
    return this._usedMemory;
  }
  destroy() {
    this._renderTexturePool.forEach((texture) => this._freeRenderTexture(texture));
    this._usedMemory = 0;
  }
  hasRenderUpdates() {
    return !!this.root._parent._hasRenderUpdates;
  }
  render() {
    this.root._parent._hasRenderUpdates = 0;
    this._render();
  }
  update() {
    this._update();
    if (this.root._hasUpdates) {
      this._update();
    }
    this._performForcedZSorts();
  }
  /**
   * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
   */
  _performForcedZSorts() {
    const n = this._zSorts.length;
    if (n) {
      for (let i = 0, n2 = this._zSorts.length; i < n2; i++) {
        if (this._zSorts[i].zSort) {
          this._zSorts[i].sortZIndexedChildren();
        }
      }
      this._zSorts = [];
    }
  }
  _update() {
    this.updateTreeOrder = 0;
    this.root.update();
  }
  _render() {
    const debugFrame = this.stage.getOption("debugFrame");
    this._fillRenderState();
    if (this.stage.getOption("readPixelsBeforeDraw")) {
      this._readPixels();
    }
    this._performRender();
    if (debugFrame) {
      console.log(`[Lightning] RTT Renders in frame: ${this.renderToTextureCount}`);
    }
    if (this.stage.getOption("readPixelsAfterDraw") && this.renderToTextureCount >= this.stage.getOption("readPixelsAfterDrawThreshold")) {
      if (debugFrame) {
        console.log(`[Lightning] readPixelsAfterDraw behavior triggered`);
      }
      this._readPixels();
    }
    this.renderToTextureCount = 0;
  }
  _readPixels() {
    const pixels = new Uint8Array(4);
    const gl = this.stage.gl;
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
  _fillRenderState() {
    this.renderState.reset();
    this.root.render();
    this.renderState.finish();
  }
  _performRender() {
    this.renderExec.execute();
  }
  _addMemoryUsage(delta) {
    this._usedMemory += delta;
    this.stage.addMemoryUsage(delta);
  }
  allocateRenderTexture(w, h) {
    let prec = this.stage.getRenderPrecision();
    let pw = Math.max(1, Math.round(w * prec));
    let ph = Math.max(1, Math.round(h * prec));
    const n = this._renderTexturePool.length;
    for (let i = n - 1; i >= 0; i--) {
      const texture2 = this._renderTexturePool[i];
      if (texture2.w === pw && texture2.h === ph && texture2.update !== this.stage.frameCounter) {
        texture2.f = this.stage.frameCounter;
        this._renderTexturePool.splice(i, 1);
        return texture2;
      }
    }
    const texture = this._createRenderTexture(w, h, pw, ph);
    texture.precision = prec;
    return texture;
  }
  releaseRenderTexture(texture) {
    this._renderTexturePool.push(texture);
  }
  freeUnusedRenderTextures(maxAge = 60) {
    let limit = this.stage.frameCounter - maxAge;
    this._renderTexturePool = this._renderTexturePool.filter((texture) => {
      if (texture.f <= limit) {
        this._freeRenderTexture(texture);
        return false;
      }
      return true;
    });
  }
  _createRenderTexture(w, h, pw, ph) {
    this._addMemoryUsage(pw * ph);
    const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
    texture.id = this._renderTextureId++;
    texture.f = this.stage.frameCounter;
    texture.ow = w;
    texture.oh = h;
    texture.w = pw;
    texture.h = ph;
    return texture;
  }
  _freeRenderTexture(nativeTexture) {
    this.stage.renderer.freeRenderTexture(nativeTexture);
    this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
  }
  copyRenderTexture(renderTexture, nativeTexture, options) {
    this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
  }
  forceZSort(elementCore) {
    this._zSorts.push(elementCore);
  }
}
class TransitionSettings {
  constructor(stage2) {
    this.stage = stage2;
    this._timingFunction = "ease";
    this._timingFunctionImpl = StageUtils.getTimingFunction(this._timingFunction);
    this.delay = 0;
    this.duration = 0.2;
    this.merger = null;
  }
  get timingFunction() {
    return this._timingFunction;
  }
  set timingFunction(v) {
    this._timingFunction = v;
    this._timingFunctionImpl = StageUtils.getTimingFunction(v);
  }
  get timingFunctionImpl() {
    return this._timingFunctionImpl;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
}
TransitionSettings.prototype.isTransitionSettings = true;
class TransitionManager {
  constructor(stage2) {
    this.stage = stage2;
    this.stage.on("frameStart", () => this.progress());
    this.active = /* @__PURE__ */ new Set();
    this.defaultTransitionSettings = new TransitionSettings(this.stage);
  }
  progress() {
    if (this.active.size) {
      let dt = this.stage.dt;
      let filter2 = false;
      this.active.forEach(function(a) {
        a.progress(dt);
        if (!a.isRunning()) {
          filter2 = true;
        }
      });
      if (filter2) {
        this.active = new Set([...this.active].filter((t) => t.isRunning()));
      }
    }
  }
  createSettings(settings2) {
    const transitionSettings = new TransitionSettings();
    Base.patchObject(transitionSettings, settings2);
    return transitionSettings;
  }
  addActive(transition) {
    this.active.add(transition);
  }
  removeActive(transition) {
    this.active.delete(transition);
  }
}
class MultiSpline {
  constructor() {
    this._clear();
  }
  _clear() {
    this._p = [];
    this._pe = [];
    this._idp = [];
    this._f = [];
    this._v = [];
    this._lv = [];
    this._sm = [];
    this._s = [];
    this._ve = [];
    this._sme = [];
    this._se = [];
    this._length = 0;
  }
  parse(rgba, def) {
    let i, n;
    if (!Utils$2.isObjectLiteral(def)) {
      def = { 0: def };
    }
    let defaultSmoothness = 0.5;
    let items = [];
    for (let key in def) {
      if (def.hasOwnProperty(key)) {
        let obj = def[key];
        if (!Utils$2.isObjectLiteral(obj)) {
          obj = { v: obj };
        }
        let p = parseFloat(key);
        if (key === "sm") {
          defaultSmoothness = obj.v;
        } else if (!isNaN(p) && p >= 0 && p <= 2) {
          obj.p = p;
          obj.f = Utils$2.isFunction(obj.v);
          obj.lv = obj.f ? obj.v(0, 0) : obj.v;
          items.push(obj);
        }
      }
    }
    items = items.sort(function(a, b) {
      return a.p - b.p;
    });
    n = items.length;
    for (i = 0; i < n; i++) {
      let last = i === n - 1;
      if (!items[i].hasOwnProperty("pe")) {
        items[i].pe = last ? items[i].p <= 1 ? 1 : 2 : items[i + 1].p;
      } else {
        const max = i < n - 1 ? items[i + 1].p : 1;
        if (items[i].pe > max) {
          items[i].pe = max;
        }
      }
      if (items[i].pe === items[i].p) {
        items[i].idp = 0;
      } else {
        items[i].idp = 1 / (items[i].pe - items[i].p);
      }
    }
    for (i = 0; i < n; i++) {
      if (!items[i].hasOwnProperty("sm")) {
        items[i].sm = defaultSmoothness;
      }
      if (!items[i].hasOwnProperty("s")) {
        if (i === 0 || i === n - 1 || items[i].p === 1) {
          items[i].s = rgba ? [0, 0, 0, 0] : 0;
        } else {
          const pi = items[i - 1];
          const ni = items[i + 1];
          if (pi.p === ni.p) {
            items[i].s = rgba ? [0, 0, 0, 0] : 0;
          } else {
            if (rgba) {
              const nc = MultiSpline.getRgbaComponents(ni.lv);
              const pc = MultiSpline.getRgbaComponents(pi.lv);
              const d = 1 / (ni.p - pi.p);
              items[i].s = [
                d * (nc[0] - pc[0]),
                d * (nc[1] - pc[1]),
                d * (nc[2] - pc[2]),
                d * (nc[3] - pc[3])
              ];
            } else {
              items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
            }
          }
        }
      }
    }
    for (i = 0; i < n - 1; i++) {
      if (!items[i].f) {
        let last = i === n - 1;
        if (!items[i].hasOwnProperty("ve")) {
          items[i].ve = last ? items[i].lv : items[i + 1].lv;
        }
        if (Utils$2.isNumber(items[i].v) && Utils$2.isNumber(items[i].lv)) {
          if (!items[i].hasOwnProperty("sme")) {
            items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
          }
          if (!items[i].hasOwnProperty("se")) {
            items[i].se = last ? rgba ? [0, 0, 0, 0] : 0 : items[i + 1].s;
          }
          if (rgba) {
            items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
          } else {
            items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
          }
          items[i].f = true;
        }
      }
    }
    if (this.length) {
      this._clear();
    }
    for (i = 0, n = items.length; i < n; i++) {
      this._add(items[i]);
    }
  }
  _add(item) {
    this._p.push(item.p || 0);
    this._pe.push(item.pe || 0);
    this._idp.push(item.idp || 0);
    this._f.push(item.f || false);
    this._v.push(
      item.hasOwnProperty("v") ? item.v : 0
      /* v might be false or null */
    );
    this._lv.push(item.lv || 0);
    this._sm.push(item.sm || 0);
    this._s.push(item.s || 0);
    this._ve.push(item.ve || 0);
    this._sme.push(item.sme || 0);
    this._se.push(item.se || 0);
    this._length++;
  }
  _getItem(p) {
    const n = this._length;
    if (!n) {
      return -1;
    }
    if (p < this._p[0]) {
      return 0;
    }
    for (let i = 0; i < n; i++) {
      if (this._p[i] <= p && p < this._pe[i]) {
        return i;
      }
    }
    return n - 1;
  }
  getValue(p) {
    const i = this._getItem(p);
    if (i === -1) {
      return void 0;
    } else {
      if (this._f[i]) {
        const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
        return this._v[i](o);
      } else {
        return this._v[i];
      }
    }
  }
  get length() {
    return this._length;
  }
  static getRgbaComponents(argb) {
    let r = (argb / 65536 | 0) % 256;
    let g = (argb / 256 | 0) % 256;
    let b = argb % 256;
    let a = argb / 16777216 | 0;
    return [r, g, b, a];
  }
  static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
    let dp = p2 - p1;
    s1 *= dp;
    s2 *= dp;
    let helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
    if (!helpers) {
      return function(p) {
        if (p === 0)
          return v1;
        if (p === 1)
          return v2;
        return v2 * p + v1 * (1 - p);
      };
    } else {
      return function(p) {
        if (p === 0)
          return v1;
        if (p === 1)
          return v2;
        return MultiSpline.calculateSpline(helpers, p);
      };
    }
  }
  static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
    let dp = p2 - p1;
    s1[0] *= dp;
    s1[1] *= dp;
    s1[2] *= dp;
    s1[3] *= dp;
    s2[0] *= dp;
    s2[1] *= dp;
    s2[2] *= dp;
    s2[3] *= dp;
    let cv1 = MultiSpline.getRgbaComponents(v1);
    let cv2 = MultiSpline.getRgbaComponents(v2);
    let helpers = [
      MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
      MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
      MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
      MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
    ];
    if (!helpers[0]) {
      return function(p) {
        if (p === 0)
          return v1;
        if (p === 1)
          return v2;
        return MultiSpline.mergeColors(v2, v1, p);
      };
    } else {
      return function(p) {
        if (p === 0)
          return v1;
        if (p === 1)
          return v2;
        return MultiSpline.getArgbNumber([
          Math.min(255, MultiSpline.calculateSpline(helpers[0], p)),
          Math.min(255, MultiSpline.calculateSpline(helpers[1], p)),
          Math.min(255, MultiSpline.calculateSpline(helpers[2], p)),
          Math.min(255, MultiSpline.calculateSpline(helpers[3], p))
        ]);
      };
    }
  }
  /**
   * Creates helpers to be used in the spline function.
   * @param {number} v1
   *   From value.
   * @param {number} v2
   *   To value.
   * @param {number} o1
   *   From smoothness (0 = linear, 1 = smooth).
   * @param {number} s1
   *   From slope (0 = horizontal, infinite = vertical).
   * @param {number} i2
   *   To smoothness.
   * @param {number} s2
   *   To slope.
   * @returns {Number[]}
   *   The helper values to be supplied to the spline function.
   *   If the configuration is actually linear, null is returned.
   */
  static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
    if (!o1 && !i2) {
      return null;
    }
    let csx = o1;
    let csy = v1 + s1 * o1;
    let cex = 1 - i2;
    let cey = v2 - s2 * i2;
    let xa = 3 * csx - 3 * cex + 1;
    let xb = -6 * csx + 3 * cex;
    let xc = 3 * csx;
    let ya = 3 * csy - 3 * cey + v2 - v1;
    let yb = 3 * (cey + v1) - 6 * csy;
    let yc = 3 * (csy - v1);
    let yd = v1;
    return [xa, xb, xc, ya, yb, yc, yd];
  }
  /**
   * Calculates the intermediate spline value based on the specified helpers.
   * @param {number[]} helpers
   *   Obtained from getSplineHelpers.
   * @param {number} p
   * @return {number}
   */
  static calculateSpline(helpers, p) {
    let xa = helpers[0];
    let xb = helpers[1];
    let xc = helpers[2];
    let ya = helpers[3];
    let yb = helpers[4];
    let yc = helpers[5];
    let yd = helpers[6];
    if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
      return p;
    }
    let t = 0.5, cbx, dx;
    for (let it = 0; it < 20; it++) {
      cbx = t * (t * (t * xa + xb) + xc);
      dx = p - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc) + yd;
      }
      let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
      if (cbxd > 1e-10 && cbxd < 1e-10) {
        break;
      }
      t += dx / cbxd;
    }
    let minT = 0;
    let maxT = 1;
    for (let it = 0; it < 20; it++) {
      t = 0.5 * (minT + maxT);
      cbx = t * (t * (t * xa + xb) + xc);
      dx = p - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc) + yd;
      }
      if (dx < 0) {
        maxT = t;
      } else {
        minT = t;
      }
    }
    return t;
  }
  static mergeColors(c1, c2, p) {
    let r1 = (c1 / 65536 | 0) % 256;
    let g1 = (c1 / 256 | 0) % 256;
    let b1 = c1 % 256;
    let a1 = c1 / 16777216 | 0;
    let r2 = (c2 / 65536 | 0) % 256;
    let g2 = (c2 / 256 | 0) % 256;
    let b2 = c2 % 256;
    let a2 = c2 / 16777216 | 0;
    let r = r1 * p + r2 * (1 - p);
    let g = g1 * p + g2 * (1 - p);
    let b = b1 * p + b2 * (1 - p);
    let a = a1 * p + a2 * (1 - p);
    return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
  }
  static getArgbNumber(rgba) {
    rgba[0] = Math.max(0, Math.min(255, rgba[0]));
    rgba[1] = Math.max(0, Math.min(255, rgba[1]));
    rgba[2] = Math.max(0, Math.min(255, rgba[2]));
    rgba[3] = Math.max(0, Math.min(255, rgba[3]));
    let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
    if (v < 0) {
      v = 4294967295 + v + 1;
    }
    return v;
  }
}
class AnimationActionSettings {
  constructor(animationSettings) {
    this.animationSettings = animationSettings;
    this._selector = "";
    this._items = new MultiSpline();
    this._props = [];
    this._propSetters = [];
    this._resetValue = void 0;
    this._hasResetValue = false;
    this._hasColorProperty = void 0;
  }
  getResetValue() {
    if (this._hasResetValue) {
      return this._resetValue;
    } else {
      return this._items.getValue(0);
    }
  }
  apply(element, p, factor) {
    const elements = this.getAnimatedElements(element);
    let v = this._items.getValue(p);
    if (v === void 0 || !elements.length) {
      return;
    }
    if (factor !== 1) {
      let sv = this.getResetValue();
      if (Utils$2.isNumber(v) && Utils$2.isNumber(sv)) {
        if (this.hasColorProperty()) {
          v = StageUtils.mergeColors(v, sv, factor);
        } else {
          v = StageUtils.mergeNumbers(v, sv, factor);
        }
      }
    }
    const n = this._propSetters.length;
    const m = elements.length;
    for (let j = 0; j < m; j++) {
      for (let i = 0; i < n; i++) {
        this._propSetters[i](elements[j], v);
      }
    }
  }
  getAnimatedElements(element) {
    return element.select(this._selector);
  }
  reset(element) {
    const elements = this.getAnimatedElements(element);
    let v = this.getResetValue();
    if (v === void 0 || !elements.length) {
      return;
    }
    const n = this._propSetters.length;
    const m = elements.length;
    for (let j = 0; j < m; j++) {
      for (let i = 0; i < n; i++) {
        this._propSetters[i](elements[j], v);
      }
    }
  }
  set selector(v) {
    this._selector = v;
  }
  set t(v) {
    this.selector = v;
  }
  get resetValue() {
    return this._resetValue;
  }
  set resetValue(v) {
    this._resetValue = v;
    this._hasResetValue = v !== void 0;
  }
  set rv(v) {
    this.resetValue = v;
  }
  set value(v) {
    this._items.parse(this.hasColorProperty(), v);
  }
  set v(v) {
    this.value = v;
  }
  set properties(v) {
    if (!Array.isArray(v)) {
      v = [v];
    }
    this._props = [];
    v.forEach((prop) => {
      this._props.push(prop);
      this._propSetters.push(Element$1.getSetter(prop));
    });
  }
  set property(v) {
    this._hasColorProperty = void 0;
    this.properties = v;
  }
  set p(v) {
    this.properties = v;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
  hasColorProperty() {
    if (this._hasColorProperty === void 0) {
      this._hasColorProperty = this._props.length ? Element$1.isColorProperty(this._props[0]) : false;
    }
    return this._hasColorProperty;
  }
}
AnimationActionSettings.prototype.isAnimationActionSettings = true;
class AnimationSettings {
  constructor() {
    this._actions = [];
    this.delay = 0;
    this.duration = 1;
    this.repeat = 0;
    this.repeatOffset = 0;
    this.repeatDelay = 0;
    this.autostop = false;
    this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
    this._stopTimingFunction = "ease";
    this._stopTimingFunctionImpl = StageUtils.getTimingFunction(this._stopTimingFunction);
    this.stopDuration = 0;
    this.stopDelay = 0;
  }
  get actions() {
    return this._actions;
  }
  set actions(v) {
    this._actions = [];
    for (let i = 0, n = v.length; i < n; i++) {
      const e = v[i];
      if (!e.isAnimationActionSettings) {
        const aas = new AnimationActionSettings(this);
        aas.patch(e);
        this._actions.push(aas);
      } else {
        this._actions.push(e);
      }
    }
  }
  /**
   * Applies the animation to the specified element, for the specified progress between 0 and 1.
   * @param {Element} element;
   * @param {number} p;
   * @param {number} factor;
   */
  apply(element, p, factor = 1) {
    this._actions.forEach(function(action) {
      action.apply(element, p, factor);
    });
  }
  /**
   * Resets the animation to the reset values.
   * @param {Element} element;
   */
  reset(element) {
    this._actions.forEach(function(action) {
      action.reset(element);
    });
  }
  get stopTimingFunction() {
    return this._stopTimingFunction;
  }
  set stopTimingFunction(v) {
    this._stopTimingFunction = v;
    this._stopTimingFunctionImpl = StageUtils.getTimingFunction(v);
  }
  get stopTimingFunctionImpl() {
    return this._stopTimingFunctionImpl;
  }
  patch(settings2) {
    Base.patchObject(this, settings2);
  }
}
AnimationSettings.STOP_METHODS = {
  FADE: "fade",
  REVERSE: "reverse",
  FORWARD: "forward",
  IMMEDIATE: "immediate",
  ONETOTWO: "onetotwo"
};
class Animation extends EventEmitter {
  constructor(manager, settings2, element) {
    super();
    this.manager = manager;
    this._settings = settings2;
    this._element = element;
    this._state = Animation.STATES.IDLE;
    this._p = 0;
    this._delayLeft = 0;
    this._repeatsLeft = 0;
    this._stopDelayLeft = 0;
    this._stopP = 0;
  }
  start() {
    if (this._element && this._element.attached) {
      this._p = 0;
      this._delayLeft = this.settings.delay;
      this._repeatsLeft = this.settings.repeat;
      this._state = Animation.STATES.PLAYING;
      this.emit("start");
      this.checkActive();
    } else {
      console.warn("[Lightning] Element must be attached before starting animation");
    }
  }
  play() {
    if (this._state === Animation.STATES.PAUSED) {
      this._state = Animation.STATES.PLAYING;
      this.checkActive();
      this.emit("resume");
    } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
      this._state = Animation.STATES.PLAYING;
      this.emit("stopContinue");
    } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
      this.start();
    }
  }
  pause() {
    if (this._state === Animation.STATES.PLAYING) {
      this._state = Animation.STATES.PAUSED;
      this.emit("pause");
    }
  }
  replay() {
    if (this._state == Animation.STATES.FINISHED) {
      this.start();
    } else {
      this.play();
    }
  }
  skipDelay() {
    this._delayLeft = 0;
    this._stopDelayLeft = 0;
  }
  finish() {
    if (this._state === Animation.STATES.PLAYING) {
      this._delayLeft = 0;
      this._p = 1;
    } else if (this._state === Animation.STATES.STOPPING) {
      this._stopDelayLeft = 0;
      this._p = 0;
    }
  }
  stop() {
    if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE)
      return;
    this._stopDelayLeft = this.settings.stopDelay || 0;
    if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.IMMEDIATE && !this._stopDelayLeft || this._delayLeft > 0) {
      this._state = Animation.STATES.STOPPING;
      this.emit("stop");
    } else {
      if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
        this._stopP = 0;
      }
      this._state = Animation.STATES.STOPPING;
      this.emit("stop");
    }
    this.checkActive();
  }
  stopNow() {
    if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
      this._state = Animation.STATES.STOPPING;
      this._p = 0;
      this.emit("stop");
      this.reset();
      this._state = Animation.STATES.STOPPED;
      this.emit("stopFinish");
    }
  }
  isPaused() {
    return this._state === Animation.STATES.PAUSED;
  }
  isPlaying() {
    return this._state === Animation.STATES.PLAYING;
  }
  isStopping() {
    return this._state === Animation.STATES.STOPPING;
  }
  isFinished() {
    return this._state === Animation.STATES.FINISHED;
  }
  checkActive() {
    if (this.isActive()) {
      this.manager.addActive(this);
    }
  }
  isActive() {
    return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
  }
  progress(dt) {
    if (!this._element)
      return;
    this._progress(dt);
    this.apply();
  }
  _progress(dt) {
    if (this._state == Animation.STATES.STOPPING) {
      this._stopProgress(dt);
      return;
    }
    if (this._state != Animation.STATES.PLAYING) {
      return;
    }
    if (this._delayLeft > 0) {
      this._delayLeft -= dt;
      if (this._delayLeft < 0) {
        dt = -this._delayLeft;
        this._delayLeft = 0;
        this.emit("delayEnd");
      } else {
        return;
      }
    }
    if (this.settings.duration === 0) {
      this._p = 1;
    } else if (this.settings.duration > 0) {
      this._p += dt / this.settings.duration;
    }
    if (this._p >= 1) {
      if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
        if (this._repeatsLeft > 0) {
          this._repeatsLeft--;
        }
        this._p = this.settings.repeatOffset;
        this.emit("progress", this._p);
        if (this.settings.repeatDelay) {
          this._delayLeft = this.settings.repeatDelay;
        }
        this.emit("repeat", this._repeatsLeft);
      } else {
        this._p = 1;
        this.emit("progress", this._p);
        this._state = Animation.STATES.FINISHED;
        this.emit("finish");
        if (this.settings.autostop) {
          this.stop();
        }
      }
    } else {
      this.emit("progress", this._p);
    }
  }
  _stopProgress(dt) {
    let duration = this._getStopDuration();
    if (this._stopDelayLeft > 0) {
      this._stopDelayLeft -= dt;
      if (this._stopDelayLeft < 0) {
        dt = -this._stopDelayLeft;
        this._stopDelayLeft = 0;
        this.emit("stopDelayEnd");
      } else {
        return;
      }
    }
    if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.IMMEDIATE) {
      this._state = Animation.STATES.STOPPED;
      this.emit("stopFinish");
    } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
      if (duration === 0) {
        this._p = 0;
      } else if (duration > 0) {
        this._p -= dt / duration;
      }
      if (this._p <= 0) {
        this._p = 0;
        this._state = Animation.STATES.STOPPED;
        this.emit("stopFinish");
      }
    } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FADE) {
      this._progressStopTransition(dt);
      if (this._stopP >= 1) {
        this._p = 0;
        this._state = Animation.STATES.STOPPED;
        this.emit("stopFinish");
      }
    } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.ONETOTWO) {
      if (this._p < 2) {
        if (duration === 0) {
          this._p = 2;
        } else if (duration > 0) {
          if (this._p < 1) {
            this._p += dt / this.settings.duration;
          } else {
            this._p += dt / duration;
          }
        }
        if (this._p >= 2) {
          this._p = 2;
          this._state = Animation.STATES.STOPPED;
          this.emit("stopFinish");
        } else {
          this.emit("progress", this._p);
        }
      }
    } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
      if (this._p < 1) {
        if (this.settings.duration == 0) {
          this._p = 1;
        } else {
          this._p += dt / this.settings.duration;
        }
        if (this._p >= 1) {
          if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
            this._p = 1;
            this._state = Animation.STATES.STOPPED;
            this.emit("stopFinish");
          } else {
            if (this._repeatsLeft > 0) {
              this._repeatsLeft--;
              this._p = 0;
              this.emit("repeat", this._repeatsLeft);
            } else {
              this._p = 1;
              this._state = Animation.STATES.STOPPED;
              this.emit("stopFinish");
            }
          }
        } else {
          this.emit("progress", this._p);
        }
      }
    }
  }
  _progressStopTransition(dt) {
    if (this._stopP < 1) {
      if (this._stopDelayLeft > 0) {
        this._stopDelayLeft -= dt;
        if (this._stopDelayLeft < 0) {
          dt = -this._stopDelayLeft;
          this._stopDelayLeft = 0;
          this.emit("delayEnd");
        } else {
          return;
        }
      }
      const duration = this._getStopDuration();
      if (duration == 0) {
        this._stopP = 1;
      } else {
        this._stopP += dt / duration;
      }
      if (this._stopP >= 1) {
        this._stopP = 1;
      }
    }
  }
  _getStopDuration() {
    return this.settings.stopDuration || this.settings.duration;
  }
  apply() {
    if (this._state === Animation.STATES.STOPPED) {
      this.reset();
    } else {
      let factor = 1;
      if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
        factor = 1 - this.settings.stopTimingFunctionImpl(this._stopP);
      }
      this._settings.apply(this._element, this._p, factor);
    }
  }
  reset() {
    this._settings.reset(this._element);
  }
  get state() {
    return this._state;
  }
  get p() {
    return this._p;
  }
  get delayLeft() {
    return this._delayLeft;
  }
  get element() {
    return this._element;
  }
  get frame() {
    return Math.round(this._p * this._settings.duration * 60);
  }
  get settings() {
    return this._settings;
  }
}
Animation.STATES = {
  IDLE: 0,
  PLAYING: 1,
  STOPPING: 2,
  STOPPED: 3,
  FINISHED: 4,
  PAUSED: 5
};
class AnimationManager {
  constructor(stage2) {
    this.stage = stage2;
    this.stage.on("frameStart", () => this.progress());
    this.active = /* @__PURE__ */ new Set();
  }
  progress() {
    if (this.active.size) {
      let dt = this.stage.dt;
      let filter2 = false;
      this.active.forEach(function(a) {
        if (a.isActive()) {
          a.progress(dt);
        } else {
          filter2 = true;
        }
      });
      if (filter2) {
        this.active = new Set([...this.active].filter((t) => t.isActive()));
      }
    }
  }
  createAnimation(element, settings2) {
    if (Utils$2.isObjectLiteral(settings2)) {
      settings2 = this.createSettings(settings2);
    }
    return new Animation(
      this,
      settings2,
      element
    );
  }
  createSettings(settings2) {
    const animationSettings = new AnimationSettings();
    Base.patchObject(animationSettings, settings2);
    return animationSettings;
  }
  addActive(transition) {
    this.active.add(transition);
  }
}
class RectangleTexture extends Texture {
  _getLookupId() {
    return "__whitepix";
  }
  _getSourceLoader() {
    return function(cb) {
      var whitePixel = new Uint8Array([255, 255, 255, 255]);
      cb(null, { source: whitePixel, w: 1, h: 1, permanent: true });
    };
  }
  isAutosizeTexture() {
    return false;
  }
}
class Stage extends EventEmitter {
  constructor(options = {}) {
    super();
    this._setOptions(options);
    this._usedMemory = 0;
    this._lastGcFrame = 0;
    this._usedVramAlpha = 0;
    this._usedVramNonAlpha = 0;
    const platformType = Stage.platform ? Stage.platform : PlatformLoader.load(options);
    this.platform = new platformType();
    if (this.platform.init) {
      this.platform.init(this);
    }
    this.gl = null;
    this.c2d = null;
    const context = this.getOption("context");
    if (context) {
      if (context.useProgram) {
        this.gl = context;
      } else {
        this.c2d = context;
      }
    } else {
      if (Utils$2.isWeb && (!Stage.isWebglSupported() || this.getOption("canvas2d"))) {
        this.c2d = this.platform.createCanvasContext(this.getOption("w"), this.getOption("h"));
      } else {
        this.gl = this.platform.createWebGLContext(this.getOption("w"), this.getOption("h"));
      }
    }
    if (this.gl) {
      WebGLStateManager.enable(this.gl, "lightning");
    }
    this._mode = this.gl ? 0 : 1;
    if (this.getCanvas()) {
      this._options.w = this.getCanvas().width;
      this._options.h = this.getCanvas().height;
    }
    if (this._mode === 0) {
      if (Utils$2.isSpark) {
        this._renderer = new SparkRenderer(this);
      } else {
        this._renderer = new WebGLRenderer(this);
      }
    } else {
      this._renderer = new C2dRenderer(this);
    }
    this.setClearColor(this.getOption("clearColor"));
    this.frameCounter = 0;
    this.transitions = new TransitionManager(this);
    this.animations = new AnimationManager(this);
    this.textureManager = new TextureManager(this);
    this.textureThrottler = new TextureThrottler(this);
    this.startTime = 0;
    this.currentTime = 0;
    this.dt = 0;
    this.rectangleTexture = new RectangleTexture(this);
    this.rectangleTexture.load();
    this.rectangleTexture.source.permanent = true;
    this.ctx = new CoreContext(this);
    this._updateSourceTextures = /* @__PURE__ */ new Set();
  }
  get renderer() {
    return this._renderer;
  }
  static isWebglSupported() {
    if (Utils$2.isNode) {
      return true;
    }
    try {
      return !!window.WebGLRenderingContext;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns the rendering mode.
   * @returns {number}
   *  0: WebGL
   *  1: Canvas2d
   */
  get mode() {
    return this._mode;
  }
  isWebgl() {
    return this.mode === 0;
  }
  isC2d() {
    return this.mode === 1;
  }
  getOption(name2) {
    return this._options[name2];
  }
  _setOptions(o) {
    this._options = {};
    let opt = (name2, def) => {
      let value = o[name2];
      if (value === void 0) {
        this._options[name2] = def;
      } else {
        this._options[name2] = value;
      }
    };
    opt("canvas", null);
    opt("context", null);
    opt("w", 1920);
    opt("h", 1080);
    opt("srcBasePath", null);
    opt("memoryPressure", 24e6);
    opt("bufferMemory", 2e6);
    opt("textRenderIssueMargin", 0);
    opt("fontSharp", { precision: 0.6666666667, fontSize: 24 });
    opt("clearColor", [0, 0, 0, 0]);
    opt("defaultFontFace", "sans-serif");
    opt("fixedDt", 0);
    opt("useImageWorker", true);
    opt("autostart", true);
    opt("precision", 1);
    opt("canvas2d", false);
    opt("platform", null);
    opt("readPixelsBeforeDraw", false);
    opt("readPixelsAfterDraw", false);
    opt("readPixelsAfterDrawThreshold", 0);
    opt("debugFrame", false);
    opt("forceTxCanvasSource", false);
    opt("pauseRafLoopOnIdle", false);
  }
  setApplication(app2) {
    this.application = app2;
  }
  init() {
    if (this.application.getOption("debug") && this.platform._imageWorker) {
      console.log("[Lightning] Using image worker!");
    }
    if (this.application.getOption("debug") && this.c2d) {
      console.log("[Lightning] Using canvas2d renderer");
    }
    this.application.setAsRoot();
    if (this.getOption("autostart")) {
      this.platform.startLoop();
    }
  }
  destroy() {
    this.platform.stopLoop();
    this.platform.destroy();
    this.ctx.destroy();
    this.textureManager.destroy();
    this._renderer.destroy();
  }
  stop() {
    this.platform.stopLoop();
  }
  resume() {
    this.platform.startLoop();
  }
  get root() {
    return this.application;
  }
  getCanvas() {
    return this._mode ? this.c2d.canvas : this.gl.canvas;
  }
  getRenderPrecision() {
    return this._options.precision;
  }
  /**
   * Marks a texture for updating it's source upon the next drawFrame.
   * @param texture
   */
  addUpdateSourceTexture(texture) {
    if (this._updatingFrame) {
      texture._performUpdateSource();
    } else {
      this._updateSourceTextures.add(texture);
    }
  }
  removeUpdateSourceTexture(texture) {
    if (this._updateSourceTextures) {
      this._updateSourceTextures.delete(texture);
    }
  }
  hasUpdateSourceTexture(texture) {
    return this._updateSourceTextures && this._updateSourceTextures.has(texture);
  }
  _performUpdateSource() {
    if (this._updateSourceTextures.size) {
      this._updateSourceTextures.forEach((texture) => {
        texture._performUpdateSource();
      });
      this._updateSourceTextures = /* @__PURE__ */ new Set();
    }
  }
  _calculateDt() {
    this.startTime = this.currentTime;
    this.currentTime = this.platform.getHrTime();
    if (this._options.fixedDt) {
      this.dt = this._options.fixedDt;
    } else {
      this.dt = !this.startTime ? 0.02 : 1e-3 * (this.currentTime - this.startTime);
    }
  }
  updateFrame() {
    this._calculateDt();
    this.emit("frameStart");
    this._performUpdateSource();
    this.emit("update");
  }
  idleFrame() {
    this.textureThrottler.processSome();
    this.emit("frameEnd");
    this.frameCounter++;
  }
  renderFrame() {
    const changes = this.ctx.hasRenderUpdates();
    this.textureThrottler.processSome();
    if (changes) {
      this._updatingFrame = true;
      this.ctx.update();
      this.ctx.render();
      this._updatingFrame = false;
    }
    this.platform.nextFrame(changes);
    this.emit("frameEnd");
    this.frameCounter++;
  }
  isUpdatingFrame() {
    return this._updatingFrame;
  }
  drawFrame() {
    this.updateFrame();
    this.renderFrame();
  }
  forceRenderUpdate() {
    if (this.root) {
      this.root.core._parent.setHasRenderUpdates(1);
    }
  }
  setClearColor(clearColor) {
    this.forceRenderUpdate();
    if (clearColor === null) {
      this._clearColor = null;
    } else if (Array.isArray(clearColor)) {
      this._clearColor = clearColor;
    } else {
      this._clearColor = StageUtils.getRgbaComponentsNormalized(clearColor);
    }
  }
  getClearColor() {
    return this._clearColor;
  }
  createElement(settings2) {
    if (settings2) {
      return this.element(settings2);
    } else {
      return new Element$1(this);
    }
  }
  createShader(settings2) {
    return Shader.create(this, settings2);
  }
  element(settings2) {
    if (settings2.isElement)
      return settings2;
    let element;
    if (settings2.type) {
      element = new settings2.type(this);
    } else {
      element = new Element$1(this);
    }
    element.patch(settings2);
    return element;
  }
  c(settings2) {
    return this.element(settings2);
  }
  get w() {
    return this._options.w;
  }
  get h() {
    return this._options.h;
  }
  get coordsWidth() {
    return this.w / this._options.precision;
  }
  get coordsHeight() {
    return this.h / this._options.precision;
  }
  addMemoryUsage(delta) {
    this._usedMemory += delta;
    if (this._lastGcFrame !== this.frameCounter) {
      if (this._usedMemory > this.getOption("memoryPressure")) {
        this.gc(false);
        if (this._usedMemory > this.getOption("memoryPressure") - 2e6) {
          this.gc(true);
        }
      }
    }
  }
  get usedMemory() {
    return this._usedMemory;
  }
  addVramUsage(delta, alpha) {
    if (alpha) {
      this._usedVramAlpha += delta;
    } else {
      this._usedVramNonAlpha += delta;
    }
  }
  get usedVramAlpha() {
    return this._usedVramAlpha;
  }
  get usedVramNonAlpha() {
    return this._usedVramNonAlpha;
  }
  get usedVram() {
    return this._usedVramAlpha + this._usedVramNonAlpha;
  }
  gc(aggressive) {
    if (this._lastGcFrame !== this.frameCounter) {
      this._lastGcFrame = this.frameCounter;
      const memoryUsageBefore = this._usedMemory;
      this.gcTextureMemory(aggressive);
      this.gcRenderTextureMemory(aggressive);
      this.renderer.gc(aggressive);
      if (this.application.getOption("debug")) {
        console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
        const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
        console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
      }
    }
  }
  gcTextureMemory(aggressive = false) {
    if (aggressive && this.ctx.root.visible) {
      this.ctx.root.visible = false;
      this.textureManager.gc();
      this.ctx.root.visible = true;
    } else {
      this.textureManager.gc();
    }
  }
  gcRenderTextureMemory(aggressive = false) {
    if (aggressive && this.root.visible) {
      this.root.visible = false;
      this.ctx.freeUnusedRenderTextures(0);
      this.root.visible = true;
    } else {
      this.ctx.freeUnusedRenderTextures(0);
    }
  }
  getDrawingCanvas() {
    return this.platform.getDrawingCanvas();
  }
  update() {
    this.ctx.update();
  }
  addServiceProvider(serviceprovider) {
    if (Utils$2.isSpark) {
      this.platform.addServiceProvider(serviceprovider);
    }
  }
  getChildrenByPosition(x, y) {
    const children = [];
    this.root.core.update();
    this.root.core.collectAtCoord(x, y, children);
    return children;
  }
}
let Application$1 = class Application extends Component {
  constructor(options = {}, properties) {
    Application._temp_options = options;
    Application.booting = true;
    const stage2 = new Stage(options.stage);
    super(stage2, properties);
    Application.booting = false;
    this.__updateFocusCounter = 0;
    this.__keypressTimers = /* @__PURE__ */ new Map();
    this.__hoveredChild = null;
    this.stage.init();
    this.updateFocusSettings();
    this.__keymap = this.getOption("keys");
    if (this.__keymap) {
      this.stage.platform.registerKeydownHandler((e) => {
        this._receiveKeydown(e);
      });
      this.stage.platform.registerKeyupHandler((e) => {
        this._receiveKeyup(e);
      });
    }
    if (this.getOption("enablePointer")) {
      this.stage.platform.registerClickHandler((e) => {
        this._receiveClick(e);
      });
      this.stage.platform.registerHoverHandler((e) => {
        this._receiveHover(e);
      });
      this.stage.platform.registerScrollWheelHandler((e) => {
        this._recieveScrollWheel(e);
      });
      this.cursor = "default";
    }
  }
  getOption(name2) {
    return this.__options[name2];
  }
  _setOptions(o) {
    this.__options = {};
    let opt = (name2, def) => {
      let value = o[name2];
      if (value === void 0) {
        this.__options[name2] = def;
      } else {
        this.__options[name2] = value;
      }
    };
    opt("debug", false);
    opt("keys", {
      38: "Up",
      40: "Down",
      37: "Left",
      39: "Right",
      13: "Enter",
      8: "Back",
      27: "Exit"
    });
    opt("enablePointer", false);
  }
  __construct() {
    this.stage.setApplication(this);
    this._setOptions(Application._temp_options);
    delete Application._temp_options;
    super.__construct();
  }
  __init() {
    super.__init();
    this.__updateFocus();
  }
  updateFocusPath() {
    this.__updateFocus();
  }
  __updateFocus() {
    const notOverridden = this.__updateFocusRec();
    if (!Application.booting && notOverridden) {
      this.updateFocusSettings();
    }
  }
  __updateFocusRec() {
    const updateFocusId = ++this.__updateFocusCounter;
    this.__updateFocusId = updateFocusId;
    const newFocusPath = this.__getFocusPath();
    const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
    const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : void 0;
    if (!prevFocusedComponent) {
      this._focusPath = [];
      for (let i = 0, n = newFocusPath.length; i < n; i++) {
        this._focusPath.push(newFocusPath[i]);
        this._focusPath[i]._focus(newFocusedComponent, void 0);
        const focusOverridden = this.__updateFocusId !== updateFocusId;
        if (focusOverridden) {
          return false;
        }
      }
      return true;
    } else {
      let m = Math.min(this._focusPath.length, newFocusPath.length);
      let index;
      for (index = 0; index < m; index++) {
        if (this._focusPath[index] !== newFocusPath[index]) {
          break;
        }
      }
      if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {
        if (this.getOption("debug")) {
          console.log("[Lightning] Focus changed: " + newFocusedComponent.getLocationString());
        }
        for (let i = this._focusPath.length - 1; i >= index; i--) {
          const unfocusedElement = this._focusPath.pop();
          unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
          const focusOverridden = this.__updateFocusId !== updateFocusId;
          if (focusOverridden) {
            return false;
          }
        }
        for (let i = index, n = newFocusPath.length; i < n; i++) {
          this._focusPath.push(newFocusPath[i]);
          this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
          const focusOverridden = this.__updateFocusId !== updateFocusId;
          if (focusOverridden) {
            return false;
          }
        }
        for (let i = 0; i < index; i++) {
          this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
        }
      }
    }
    return true;
  }
  updateFocusSettings() {
    const focusedComponent = this._focusPath[this._focusPath.length - 1];
    const focusSettings = {};
    const defaultSetFocusSettings = Component.prototype._setFocusSettings;
    for (let i = 0, n = this._focusPath.length; i < n; i++) {
      if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
        this._focusPath[i]._setFocusSettings(focusSettings);
      }
    }
    const defaultHandleFocusSettings = Component.prototype._handleFocusSettings;
    for (let i = 0, n = this._focusPath.length; i < n; i++) {
      if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
        this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
      }
    }
    this.__prevFocusSettings = focusSettings;
  }
  _handleFocusSettings(settings2, prevSettings, focused, prevFocused) {
  }
  __getFocusPath() {
    const path = [this];
    let current = this;
    do {
      const nextFocus = current._getFocused();
      if (!nextFocus || nextFocus === current) {
        break;
      }
      let ptr = nextFocus.cparent;
      if (ptr === current) {
        path.push(nextFocus);
      } else {
        const newParts = [nextFocus];
        do {
          if (!ptr) {
            current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
          }
          newParts.push(ptr);
          ptr = ptr.cparent;
        } while (ptr !== current);
        for (let i = 0, n = newParts.length; i < n; i++) {
          path.push(newParts[n - i - 1]);
        }
      }
      current = nextFocus;
    } while (true);
    return path;
  }
  get focusPath() {
    return this._focusPath;
  }
  /**
   * Injects an event in the state machines, top-down from application to focused component.
   */
  focusTopDownEvent(events2, ...args) {
    const path = this.focusPath;
    const n = path.length;
    for (let i = 0; i < n; i++) {
      const event = path[i]._getMostSpecificHandledMember(events2);
      if (event !== void 0) {
        const returnValue = path[i][event](...args);
        if (returnValue !== false) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Injects an event in the state machines, bottom-up from focused component to application.
   */
  focusBottomUpEvent(events2, ...args) {
    const path = this.focusPath;
    const n = path.length;
    for (let i = n - 1; i >= 0; i--) {
      const event = path[i]._getMostSpecificHandledMember(events2);
      if (event !== void 0) {
        const returnValue = path[i][event](...args);
        if (returnValue !== false) {
          return true;
        }
      }
    }
    return false;
  }
  _receiveKeydown(e) {
    const obj = e;
    const key = this.__keymap[e.keyCode];
    const path = this.focusPath;
    let keys;
    if (key) {
      keys = Array.isArray(key) ? key : [key];
    }
    if (keys) {
      for (let i = 0, n = keys.length; i < n; i++) {
        const hasTimer = this.__keypressTimers.has(keys[i]);
        if (path[path.length - 1].longpress && hasTimer) {
          return;
        }
        if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
          this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
        }
      }
    } else {
      if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
        this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
      }
    }
    this.updateFocusPath();
    const consumer2 = path[path.length - 1];
    if (keys && consumer2.longpress) {
      for (let i = 0, n = keys.length; i < n; i++) {
        this._startLongpressTimer(keys[i], consumer2);
      }
    }
  }
  /**
   * Keyup listener
   * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
   *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
   *
   * @param e
   * @private
   */
  _receiveKeyup(e) {
    const obj = e;
    const key = this.__keymap[e.keyCode];
    let keys;
    if (key) {
      keys = Array.isArray(key) ? key : [key];
    }
    if (keys) {
      for (let i = 0, n = keys.length; i < n; i++) {
        if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
          this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
        }
      }
    } else {
      if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
        this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
      }
    }
    this.updateFocusPath();
    if (keys) {
      for (let i = 0, n = keys.length; i < n; i++) {
        if (this.__keypressTimers.has(keys[i])) {
          clearTimeout(this.__keypressTimers.get(keys[i]));
          this.__keypressTimers.delete(keys[i]);
        }
      }
    }
  }
  /**
   * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
   * before the timer goes off.
   *
   * If key is not release (keyup) the longpress handler will be fired.
   * Configuration can be via the Components template:
   *
   * static _template() {
   *     return {
   *         w:100, h:100,
   *         longpress:{up:700, down:500}
   *     }
   * }     *
   * // this will get called when up has been pressed for 700ms
   * _handleUpLong() {
   *
   * }
   *
   * @param key
   * @param element
   * @private
   */
  _startLongpressTimer(key, element) {
    const config = element.longpress;
    const lookup = key.toLowerCase();
    if (config[lookup]) {
      const timeout2 = config[lookup];
      if (!Utils$2.isNumber(timeout2)) {
        element._throwError("config value for longpress must be a number");
      } else {
        this.__keypressTimers.set(key, setTimeout(
          () => {
            if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
              this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
            }
            this.__keypressTimers.delete(key);
          },
          timeout2 || 500
          /* prevent 0ms */
        ));
      }
    }
    return;
  }
  _recieveScrollWheel(e) {
    const obj = e;
    const { clientX, clientY } = obj;
    if (clientX <= this.stage.w && clientY <= this.stage.h) {
      if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
        this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
      }
    }
  }
  fireTopDownScrollWheelHandler(event, obj) {
    let children = this.stage.application.children;
    let affected = this._findChildren([], children).reverse();
    let n = affected.length;
    while (n--) {
      const child = affected[n];
      if (child && child[event]) {
        child._captureScroll(obj);
        return true;
      }
    }
    return false;
  }
  fireBottomUpScrollWheelHandler(event, obj) {
    const { clientX, clientY } = obj;
    const target = this._getTargetChild(clientX, clientY);
    let child = target;
    while (child !== null) {
      if (child && child[event]) {
        child._handleScroll(obj);
        return true;
      }
      child = child.parent;
    }
    return false;
  }
  _receiveClick(e) {
    const obj = e;
    const { clientX, clientY } = obj;
    if (clientX <= this.stage.w && clientY <= this.stage.h) {
      this.stage.application.fireBottomUpClickHandler(obj);
    }
  }
  fireBottomUpClickHandler(obj) {
    const { clientX, clientY } = obj;
    const target = this._getTargetChild(clientX, clientY);
    let child = target;
    while (child !== null) {
      if (child && child["_handleClick"]) {
        child._handleClick(target);
        break;
      }
      child = child.parent;
    }
  }
  _receiveHover(e) {
    const obj = e;
    const { clientX, clientY } = obj;
    if (clientX <= this.stage.w && clientY <= this.stage.h) {
      this.stage.application.fireBottomUpHoverHandler(obj);
    }
  }
  fireBottomUpHoverHandler(obj) {
    const { clientX, clientY } = obj;
    const target = this._getTargetChild(clientX, clientY);
    if (target !== this.__hoveredChild) {
      let hoveredBranch = /* @__PURE__ */ new Set();
      let newHoveredBranch = /* @__PURE__ */ new Set();
      if (target) {
        newHoveredBranch = new Set(target.getAncestors());
      }
      if (this.__hoveredChild) {
        hoveredBranch = new Set(this.__hoveredChild.getAncestors());
        for (const elem of [...hoveredBranch].filter((e) => !newHoveredBranch.has(e))) {
          const c = Component.getComponent(elem);
          if (c["_handleUnhover"]) {
            c._handleUnhover(elem);
          }
          if (elem.parent && elem.parent.cursor) {
            this.stage.getCanvas().style.cursor = elem.parent.cursor;
          }
        }
      }
      this.__hoveredChild = target;
      const diffBranch = [...newHoveredBranch].filter((e) => !hoveredBranch.has(e));
      for (const elem of diffBranch) {
        const c = Component.getComponent(elem);
        if (c["_handleHover"]) {
          c._handleHover(elem);
        }
      }
      const lastElement = diffBranch[0];
      if (lastElement && lastElement.cursor) {
        this.stage.getCanvas().style.cursor = lastElement.cursor;
      }
      if (diffBranch.length === 0 && target) {
        const c = Component.getComponent(target);
        if (c["_handleHover"]) {
          c._handleHover(target);
        }
      }
    }
  }
  _getTargetChild(clientX, clientY) {
    let children = this.stage.application.children;
    let affected = this._findChildren([], children);
    let hoverableChildren = this._withinClickableRange(affected, clientX, clientY);
    hoverableChildren.sort((a, b) => {
      if (a.zIndex > b.zIndex) {
        return 1;
      } else if (a.zIndex < b.zIndex) {
        return -1;
      } else {
        return a.id > b.id ? 1 : -1;
      }
    });
    if (hoverableChildren.length) {
      return hoverableChildren.slice(-1)[0];
    } else {
      return null;
    }
  }
  _findChildren(bucket, children) {
    let n = children.length;
    while (n--) {
      const child = children[n];
      if (child.__active && child.collision) {
        if (child.collision === true) {
          bucket.push(child);
        }
        if (child.hasChildren()) {
          this._findChildren(bucket, child.children);
        }
      }
    }
    return bucket;
  }
  _withinClickableRange(affectedChildren, cursorX, cursorY) {
    let n = affectedChildren.length;
    const candidates = [];
    while (n--) {
      const child = affectedChildren[n];
      const precision2 = this.stage.getRenderPrecision();
      const ctx = child.core._worldContext;
      const cx = ctx.px * precision2;
      const cy = ctx.py * precision2;
      const cw = child.finalW * ctx.ta * precision2;
      const ch = child.finalH * ctx.td * precision2;
      if (cx > this.stage.w || cy > this.stage.h) {
        continue;
      }
      if (child.parent.core._scissor) {
        const scissor = child.parent.core._scissor.map((v) => v * precision2);
        if (!this._testCollision(cursorX, cursorY, ...scissor))
          continue;
      }
      if (this._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
        candidates.push(child);
      }
    }
    return candidates;
  }
  _testCollision(px, py, cx, cy, cw, ch) {
    if (px >= cx && px <= cx + cw && py >= cy && py <= cy + ch) {
      return true;
    }
    return false;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroy();
      this.stage.destroy();
      this._destroyed = true;
    }
  }
  _destroy() {
    this.stage.setApplication(void 0);
    this._updateAttachedFlag();
    this._updateEnabledFlag();
    if (this.__keypressTimers.size) {
      for (const timer of this.__keypressTimers.values()) {
        clearTimeout(timer);
      }
      this.__keypressTimers.clear();
    }
  }
  getCanvas() {
    return this.stage.getCanvas();
  }
};
class StaticCanvasTexture extends Texture {
  constructor(stage2) {
    super(stage2);
    this._factory = void 0;
    this._lookupId = void 0;
  }
  set content({ factory, lookupId = void 0 }) {
    this._factory = factory;
    this._lookupId = lookupId;
    this._changed();
  }
  _getIsValid() {
    return !!this._factory;
  }
  _getLookupId() {
    return this._lookupId;
  }
  _getSourceLoader() {
    const f = this._factory;
    return (cb) => {
      return f((err, canvas2) => {
        if (err) {
          return cb(err);
        }
        cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas2));
      }, this.stage);
    };
  }
}
class Tools {
  static getCanvasTexture(canvasFactory, lookupId) {
    return { type: StaticCanvasTexture, content: { factory: canvasFactory, lookupId } };
  }
  static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
    if (!Array.isArray(radius)) {
      radius = [radius, radius, radius, radius];
    }
    let factory = (cb, stage2) => {
      if (Utils$2.isSpark) {
        stage2.platform.createRoundRect(cb, stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
      } else {
        cb(null, this.createRoundRect(stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
      }
    };
    let id = "rect" + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
    return Tools.getCanvasTexture(factory, id);
  }
  static createRoundRect(stage2, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
    if (fill === void 0)
      fill = true;
    if (strokeWidth === void 0)
      strokeWidth = 0;
    let canvas2 = stage2.platform.getDrawingCanvas();
    let ctx = canvas2.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    canvas2.width = w + strokeWidth + 2;
    canvas2.height = h + strokeWidth + 2;
    ctx.beginPath();
    let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;
    ctx.moveTo(x + radius[0], y);
    ctx.lineTo(x + w - radius[1], y);
    ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
    ctx.lineTo(x + w, y + h - radius[2]);
    ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
    ctx.lineTo(x + radius[3], y + h);
    ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
    ctx.lineTo(x, y + radius[0]);
    ctx.arcTo(x, y, x + radius[0], y, radius[0]);
    ctx.closePath();
    if (fill) {
      if (Utils$2.isNumber(fillColor)) {
        ctx.fillStyle = StageUtils.getRgbaString(fillColor);
      } else {
        ctx.fillStyle = "white";
      }
      ctx.fill();
    }
    if (strokeWidth) {
      if (Utils$2.isNumber(strokeColor)) {
        ctx.strokeStyle = StageUtils.getRgbaString(strokeColor);
      } else {
        ctx.strokeStyle = "white";
      }
      ctx.lineWidth = strokeWidth;
      ctx.stroke();
    }
    return canvas2;
  }
  static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
    if (!Array.isArray(radius)) {
      radius = [radius, radius, radius, radius];
    }
    let factory = (cb, stage2) => {
      if (Utils$2.isSpark) {
        stage2.platform.createShadowRect(cb, stage2, w, h, radius, blur, margin);
      } else {
        cb(null, this.createShadowRect(stage2, w, h, radius, blur, margin));
      }
    };
    let id = "shadow" + [w, h, blur, margin].concat(radius).join(",");
    return Tools.getCanvasTexture(factory, id);
  }
  static createShadowRect(stage2, w, h, radius, blur, margin) {
    let canvas2 = stage2.platform.getDrawingCanvas();
    let ctx = canvas2.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    canvas2.width = w + margin * 2;
    canvas2.height = h + margin * 2;
    ctx.globalAlpha = 0.01;
    ctx.fillRect(0, 0, 0.01, 0.01);
    ctx.globalAlpha = 1;
    ctx.shadowColor = StageUtils.getRgbaString(4294967295);
    ctx.fillStyle = StageUtils.getRgbaString(4294967295);
    ctx.shadowBlur = blur;
    ctx.shadowOffsetX = w + 10 + margin;
    ctx.shadowOffsetY = margin;
    ctx.beginPath();
    const x = -(w + 10);
    const y = 0;
    ctx.moveTo(x + radius[0], y);
    ctx.lineTo(x + w - radius[1], y);
    ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
    ctx.lineTo(x + w, y + h - radius[2]);
    ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
    ctx.lineTo(x + radius[3], y + h);
    ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
    ctx.lineTo(x, y + radius[0]);
    ctx.arcTo(x, y, x + radius[0], y, radius[0]);
    ctx.closePath();
    ctx.fill();
    return canvas2;
  }
  static getSvgTexture(url, w, h) {
    let factory = (cb, stage2) => {
      if (Utils$2.isSpark) {
        stage2.platform.createSvg(cb, stage2, url, w, h);
      } else {
        this.createSvg(cb, stage2, url, w, h);
      }
    };
    let id = "svg" + [w, h, url].join(",");
    return Tools.getCanvasTexture(factory, id);
  }
  static createSvg(cb, stage2, url, w, h) {
    let canvas2 = stage2.platform.getDrawingCanvas();
    let ctx = canvas2.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    let img = new Image();
    img.onload = () => {
      canvas2.width = w;
      canvas2.height = h;
      ctx.drawImage(img, 0, 0, canvas2.width, canvas2.height);
      cb(null, canvas2);
    };
    img.onError = (err) => {
      cb(err);
    };
    if (!Utils$2.isPS4) {
      img.crossOrigin = "Anonymous";
    }
    img.src = url;
  }
}
class ObjMerger {
  static isMf(f) {
    return Utils$2.isFunction(f) && f.__mf;
  }
  static mf(f) {
    f.__mf = true;
    return f;
  }
  static merge(a, b) {
    const aks = Object.keys(a);
    const bks = Object.keys(b);
    if (!bks.length) {
      return a;
    }
    const ai = {};
    const bi = {};
    for (let i = 0, n = bks.length; i < n; i++) {
      const key = bks[i];
      ai[key] = -1;
      bi[key] = i;
    }
    for (let i = 0, n = aks.length; i < n; i++) {
      const key = aks[i];
      ai[key] = i;
      if (bi[key] === void 0) {
        bi[key] = -1;
      }
    }
    const aksl = aks.length;
    const result = {};
    for (let i = 0, n = bks.length; i < n; i++) {
      const key = bks[i];
      const aIndex = ai[key];
      let curIndex2 = aIndex;
      while (--curIndex2 >= 0) {
        const akey = aks[curIndex2];
        if (bi[akey] !== -1) {
          break;
        }
      }
      while (++curIndex2 < aIndex) {
        const akey = aks[curIndex2];
        result[akey] = a[akey];
      }
      const bv = b[key];
      const av = a[key];
      let r;
      if (this.isMf(bv)) {
        r = bv(av);
      } else {
        if (!Utils$2.isObjectLiteral(av) || !Utils$2.isObjectLiteral(bv)) {
          r = bv;
        } else {
          r = ObjMerger.merge(av, bv);
        }
      }
      if (r !== void 0) {
        result[key] = r;
      }
    }
    let curIndex = aksl;
    while (--curIndex >= 0) {
      const akey = aks[curIndex];
      if (bi[akey] !== -1) {
        break;
      }
    }
    while (++curIndex < aksl) {
      const akey = aks[curIndex];
      result[akey] = a[akey];
    }
    return result;
  }
}
class ObjectListProxy extends ObjectList {
  constructor(target) {
    super();
    this._target = target;
  }
  onAdd(item, index) {
    this._target.addAt(item, index);
  }
  onRemove(item, index) {
    this._target.removeAt(index);
  }
  onSync(removed, added, order) {
    this._target._setByArray(order);
  }
  onSet(item, index) {
    this._target.setAt(item, index);
  }
  onMove(item, fromIndex, toIndex) {
    this._target.setAt(item, toIndex);
  }
  createItem(object) {
    return this._target.createItem(object);
  }
  isItem(object) {
    return this._target.isItem(object);
  }
}
class ObjectListWrapper extends ObjectListProxy {
  constructor(target, wrap) {
    super(target);
    this._wrap = wrap;
  }
  wrap(item) {
    let wrapper = this._wrap(item);
    item._wrapper = wrapper;
    return wrapper;
  }
  onAdd(item, index) {
    item = this.wrap(item);
    super.onAdd(item, index);
  }
  onRemove(item, index) {
    super.onRemove(item, index);
  }
  onSync(removed, added, order) {
    added.forEach((a) => this.wrap(a));
    order = order.map((a) => a._wrapper);
    super.onSync(removed, added, order);
  }
  onSet(item, index) {
    item = this.wrap(item);
    super.onSet(item, index);
  }
  onMove(item, fromIndex, toIndex) {
    super.onMove(item, fromIndex, toIndex);
  }
}
class NoiseTexture extends Texture {
  _getLookupId() {
    return "__noise";
  }
  _getSourceLoader() {
    const gl = this.stage.gl;
    return function(cb) {
      const noise = new Uint8Array(128 * 128 * 4);
      for (let i = 0; i < 128 * 128 * 4; i += 4) {
        const v = Math.floor(Math.random() * 256);
        noise[i] = v;
        noise[i + 1] = v;
        noise[i + 2] = v;
        noise[i + 3] = 255;
      }
      const texParams = {};
      if (gl) {
        texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
        texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
        texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
        texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
      }
      cb(null, { source: noise, w: 128, h: 128, texParams });
    };
  }
}
class HtmlTexture extends Texture {
  constructor(stage2) {
    super(stage2);
    this._htmlElement = void 0;
    this._scale = 1;
  }
  set htmlElement(v) {
    this._htmlElement = v;
    this._changed();
  }
  get htmlElement() {
    return this._htmlElement;
  }
  set scale(v) {
    this._scale = v;
    this._changed();
  }
  get scale() {
    return this._scale;
  }
  set html(v) {
    if (!v) {
      this.htmlElement = void 0;
    } else {
      const d = document.createElement("div");
      d.innerHTML = "<div>" + v + "</div>";
      this.htmlElement = d.firstElementChild;
    }
  }
  get html() {
    return this._htmlElement.innerHTML;
  }
  _getIsValid() {
    return this.htmlElement;
  }
  _getLookupId() {
    return this._scale + ":" + this._htmlElement.innerHTML;
  }
  _getSourceLoader() {
    const htmlElement = this._htmlElement;
    const scale = this._scale;
    return function(cb) {
      if (!window.html2canvas) {
        return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
      }
      const area = HtmlTexture.getPreloadArea();
      area.appendChild(htmlElement);
      html2canvas(htmlElement, { backgroundColor: null, scale }).then(function(canvas2) {
        area.removeChild(htmlElement);
        if (canvas2.height === 0) {
          return cb(new Error("Canvas height is 0"));
        }
        cb(null, { source: canvas2, width: canvas2.width, height: canvas2.height });
      }).catch((e) => {
        console.error("[Lightning]", e);
      });
    };
  }
  static getPreloadArea() {
    if (!this._preloadArea) {
      this._preloadArea = document.createElement("div");
      if (this._preloadArea.attachShadow) {
        this._preloadArea.attachShadow({ mode: "closed" });
      }
      this._preloadArea.style.opacity = 0;
      this._preloadArea.style.pointerEvents = "none";
      this._preloadArea.style.position = "fixed";
      this._preloadArea.style.display = "block";
      this._preloadArea.style.top = "100vh";
      this._preloadArea.style.overflow = "hidden";
      document.body.appendChild(this._preloadArea);
    }
    return this._preloadArea;
  }
}
class StaticTexture extends Texture {
  constructor(stage2, options) {
    super(stage2);
    this._options = options;
  }
  set options(v) {
    if (this._options !== v) {
      this._options = v;
      this._changed();
    }
  }
  get options() {
    return this._options;
  }
  _getIsValid() {
    return !!this._options;
  }
  _getSourceLoader() {
    return (cb) => {
      cb(null, this._options);
    };
  }
}
class ListComponent extends Component {
  constructor(stage2) {
    super(stage2);
    this._wrapper = super._children.a({});
    this._reloadVisibleElements = false;
    this._visibleItems = /* @__PURE__ */ new Set();
    this._index = 0;
    this._started = false;
    this._scrollTransitionSettings = this.stage.transitions.createSettings({});
    this._itemSize = 100;
    this._viewportScrollOffset = 0;
    this._itemScrollOffset = 0;
    this._roll = false;
    this._rollMin = 0;
    this._rollMax = 0;
    this._progressAnimation = null;
    this._invertDirection = false;
    this._horizontal = true;
    this.itemList = new ListItems(this);
  }
  _allowChildrenAccess() {
    return false;
  }
  get items() {
    return this.itemList.get();
  }
  set items(children) {
    this.itemList.patch(children);
  }
  start() {
    this._wrapper.transition(this.property, this._scrollTransitionSettings);
    this._scrollTransition = this._wrapper.transition(this.property);
    this._scrollTransition.on("progress", (p) => this.update());
    this.setIndex(0, true, true);
    this._started = true;
    this.update();
  }
  setIndex(index, immediate = false, closest = false) {
    let nElements = this.length;
    if (!nElements)
      return;
    this.emit("unfocus", this.getElement(this.realIndex), this._index, this.realIndex);
    if (closest) {
      let offset = Utils$2.getModuloIndex(index, nElements);
      let o = Utils$2.getModuloIndex(this.index, nElements);
      let diff = offset - o;
      if (diff > 0.5 * nElements) {
        diff -= nElements;
      } else if (diff < -0.5 * nElements) {
        diff += nElements;
      }
      this._index += diff;
    } else {
      this._index = index;
    }
    if (this._roll || this.viewportSize > this._itemSize * nElements) {
      this._index = Utils$2.getModuloIndex(this._index, nElements);
    }
    let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
    let value = direction * this._index * this._itemSize;
    if (this._roll) {
      let min, max, scrollDelta;
      if (direction == 1) {
        max = (nElements - 1) * this._itemSize;
        scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
        max -= scrollDelta;
        min = this.viewportSize - (this._itemSize + scrollDelta);
        if (this._rollMin)
          min -= this._rollMin;
        if (this._rollMax)
          max += this._rollMax;
        value = Math.max(Math.min(value, max), min);
      } else {
        max = nElements * this._itemSize - this.viewportSize;
        scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
        max += scrollDelta;
        let min2 = scrollDelta;
        if (this._rollMin)
          min2 -= this._rollMin;
        if (this._rollMax)
          max += this._rollMax;
        value = Math.min(Math.max(-max, value), -min2);
      }
    }
    this._scrollTransition.start(value);
    if (immediate) {
      this._scrollTransition.finish();
    }
    this.emit("focus", this.getElement(this.realIndex), this._index, this.realIndex);
  }
  getAxisPosition() {
    let target = -this._scrollTransition._targetValue;
    let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
    let value = -direction * this._index * this._itemSize;
    return this._viewportScrollOffset * this.viewportSize + (value - target);
  }
  update() {
    if (!this._started)
      return;
    let nElements = this.length;
    if (!nElements)
      return;
    let direction = this._horizontal ^ this._invertDirection ? -1 : 1;
    let v = this._horizontal ? this._wrapper.x : this._wrapper.y;
    let viewportSize = this.viewportSize;
    let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
    v += scrollDelta;
    let s, e, ps, pe;
    if (direction == -1) {
      s = Math.floor(-v / this._itemSize);
      ps = 1 - (-v / this._itemSize - s);
      e = Math.floor((viewportSize - v) / this._itemSize);
      pe = (viewportSize - v) / this._itemSize - e;
    } else {
      s = Math.ceil(v / this._itemSize);
      ps = 1 + v / this._itemSize - s;
      e = Math.ceil((v - viewportSize) / this._itemSize);
      pe = e - (v - viewportSize) / this._itemSize;
    }
    if (this._roll || viewportSize > this._itemSize * nElements) {
      if (e >= nElements) {
        e = nElements - 1;
        pe = 1;
      }
      if (s >= nElements) {
        s = nElements - 1;
        ps = 1;
      }
      if (e <= -1) {
        e = 0;
        pe = 1;
      }
      if (s <= -1) {
        s = 0;
        ps = 1;
      }
    }
    let offset = -direction * s * this._itemSize;
    let item;
    for (let index = s; direction == -1 ? index <= e : index >= e; direction == -1 ? index++ : index--) {
      let realIndex = Utils$2.getModuloIndex(index, nElements);
      let element = this.getElement(realIndex);
      item = element.parent;
      this._visibleItems.delete(item);
      if (this._horizontal) {
        item.x = offset + scrollDelta;
      } else {
        item.y = offset + scrollDelta;
      }
      let wasVisible = item.visible;
      item.visible = true;
      if (!wasVisible || this._reloadVisibleElements) {
        this.emit("visible", index, realIndex);
      }
      if (this._progressAnimation) {
        let p = 1;
        if (index == s) {
          p = ps;
        } else if (index == e) {
          p = pe;
        }
        this._progressAnimation.apply(element, p);
      }
      offset += this._itemSize;
    }
    let self2 = this;
    this._visibleItems.forEach(function(invisibleItem) {
      invisibleItem.visible = false;
      self2._visibleItems.delete(invisibleItem);
    });
    for (let index = s; direction == -1 ? index <= e : index >= e; direction == -1 ? index++ : index--) {
      let realIndex = Utils$2.getModuloIndex(index, nElements);
      this._visibleItems.add(this.getWrapper(realIndex));
    }
    this._reloadVisibleElements = false;
  }
  setPrevious() {
    this.setIndex(this._index - 1);
  }
  setNext() {
    this.setIndex(this._index + 1);
  }
  getWrapper(index) {
    return this._wrapper.children[index];
  }
  getElement(index) {
    let e = this._wrapper.children[index];
    return e ? e.children[0] : null;
  }
  reload() {
    this._reloadVisibleElements = true;
    this.update();
  }
  get element() {
    let e = this._wrapper.children[this.realIndex];
    return e ? e.children[0] : null;
  }
  get length() {
    return this._wrapper.children.length;
  }
  get property() {
    return this._horizontal ? "x" : "y";
  }
  get viewportSize() {
    return this._horizontal ? this.w : this.h;
  }
  get index() {
    return this._index;
  }
  get realIndex() {
    return Utils$2.getModuloIndex(this._index, this.length);
  }
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(v) {
    this._itemSize = v;
    this.update();
  }
  get viewportScrollOffset() {
    return this._viewportScrollOffset;
  }
  set viewportScrollOffset(v) {
    this._viewportScrollOffset = v;
    this.update();
  }
  get itemScrollOffset() {
    return this._itemScrollOffset;
  }
  set itemScrollOffset(v) {
    this._itemScrollOffset = v;
    this.update();
  }
  get scrollTransitionSettings() {
    return this._scrollTransitionSettings;
  }
  set scrollTransitionSettings(v) {
    this._scrollTransitionSettings.patch(v);
  }
  set scrollTransition(v) {
    this._scrollTransitionSettings.patch(v);
  }
  get scrollTransition() {
    return this._scrollTransition;
  }
  get progressAnimation() {
    return this._progressAnimation;
  }
  set progressAnimation(v) {
    if (Utils$2.isObjectLiteral(v)) {
      this._progressAnimation = this.stage.animations.createSettings(v);
    } else {
      this._progressAnimation = v;
    }
    this.update();
  }
  get roll() {
    return this._roll;
  }
  set roll(v) {
    this._roll = v;
    this.update();
  }
  get rollMin() {
    return this._rollMin;
  }
  set rollMin(v) {
    this._rollMin = v;
    this.update();
  }
  get rollMax() {
    return this._rollMax;
  }
  set rollMax(v) {
    this._rollMax = v;
    this.update();
  }
  get invertDirection() {
    return this._invertDirection;
  }
  set invertDirection(v) {
    if (!this._started) {
      this._invertDirection = v;
    }
  }
  get horizontal() {
    return this._horizontal;
  }
  set horizontal(v) {
    if (v !== this._horizontal) {
      if (!this._started) {
        this._horizontal = v;
      }
    }
  }
}
class ListItems extends ObjectListWrapper {
  constructor(list) {
    let wrap = (item) => {
      let parent = item.stage.createElement();
      parent.add(item);
      parent.visible = false;
      return parent;
    };
    super(list._wrapper._children, wrap);
    this.list = list;
  }
  onAdd(item, index) {
    super.onAdd(item, index);
    this.checkStarted(index);
  }
  checkStarted(index) {
    this.list._reloadVisibleElements = true;
    if (!this.list._started) {
      this.list.start();
    } else {
      if (this.list.length === 1) {
        this.list.setIndex(0, true, true);
      } else {
        if (this.list._index >= this.list.length) {
          this.list.setIndex(0);
        }
      }
      this.list.update();
    }
  }
  onRemove(item, index) {
    super.onRemove(item, index);
    let ri = this.list.realIndex;
    if (ri === index) {
      if (ri === this.list.length) {
        ri--;
      }
      if (ri >= 0) {
        this.list.setIndex(ri);
      }
    } else if (ri > index) {
      this.list.setIndex(ri - 1);
    }
    this.list._reloadVisibleElements = true;
  }
  onSet(item, index) {
    super.onSet(item, index);
    this.checkStarted(index);
  }
  onSync(removed, added, order) {
    super.onSync(removed, added, order);
    this.checkStarted(0);
  }
  get _signalProxy() {
    return true;
  }
}
class LinearBlurShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._direction = new Float32Array([1, 0]);
    this._kernelRadius = 1;
  }
  get x() {
    return this._direction[0];
  }
  set x(v) {
    this._direction[0] = v;
    this.redraw();
  }
  get y() {
    return this._direction[1];
  }
  set y(v) {
    this._direction[1] = v;
    this.redraw();
  }
  get kernelRadius() {
    return this._kernelRadius;
  }
  set kernelRadius(v) {
    this._kernelRadius = v;
    this.redraw();
  }
  useDefault() {
    return this._kernelRadius === 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("direction", this._direction, this.gl.uniform2fv);
    this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);
    const w = operation.getRenderWidth();
    const h = operation.getRenderHeight();
    this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
  }
}
LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;
class BoxBlurShader extends DefaultShader$1 {
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const dx = 1 / operation.getTextureWidth(0);
    const dy = 1 / operation.getTextureHeight(0);
    this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
  }
}
BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;
class BlurShader extends DefaultShader2 {
  constructor(context) {
    super(context);
    this._kernelRadius = 1;
  }
  get kernelRadius() {
    return this._kernelRadius;
  }
  set kernelRadius(v) {
    this._kernelRadius = v;
    this.redraw();
  }
  useDefault() {
    return this._amount === 0;
  }
  _beforeDrawEl({ target }) {
    target.ctx.filter = "blur(" + this._kernelRadius + "px)";
  }
  _afterDrawEl({ target }) {
    target.ctx.filter = "none";
  }
}
class FastBlurComponent extends Component {
  static _template() {
    return {};
  }
  get wrap() {
    return this.tag("Wrap");
  }
  set content(v) {
    return this.wrap.content = v;
  }
  get content() {
    return this.wrap.content;
  }
  set padding(v) {
    this.wrap._paddingX = v;
    this.wrap._paddingY = v;
    this.wrap._updateBlurSize();
  }
  set paddingX(v) {
    this.wrap._paddingX = v;
    this.wrap._updateBlurSize();
  }
  set paddingY(v) {
    this.wrap._paddingY = v;
    this.wrap._updateBlurSize();
  }
  set amount(v) {
    return this.wrap.amount = v;
  }
  get amount() {
    return this.wrap.amount;
  }
  _onResize() {
    this.wrap.w = this.renderWidth;
    this.wrap.h = this.renderHeight;
  }
  get _signalProxy() {
    return true;
  }
  _build() {
    this.patch({
      Wrap: { type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent }
    });
  }
}
class C2dFastBlurComponent extends Component {
  static _template() {
    return {
      forceZIndexContext: true,
      rtt: true,
      Textwrap: { shader: { type: BlurShader }, Content: {} }
    };
  }
  constructor(stage2) {
    super(stage2);
    this._textwrap = this.sel("Textwrap");
    this._wrapper = this.sel("Textwrap>Content");
    this._amount = 0;
    this._paddingX = 0;
    this._paddingY = 0;
  }
  static getSpline() {
    if (!this._multiSpline) {
      this._multiSpline = new MultiSpline();
      this._multiSpline.parse(false, { 0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39 });
    }
    return this._multiSpline;
  }
  get content() {
    return this.sel("Textwrap>Content");
  }
  set content(v) {
    this.sel("Textwrap>Content").patch(v, true);
  }
  set padding(v) {
    this._paddingX = v;
    this._paddingY = v;
    this._updateBlurSize();
  }
  set paddingX(v) {
    this._paddingX = v;
    this._updateBlurSize();
  }
  set paddingY(v) {
    this._paddingY = v;
    this._updateBlurSize();
  }
  _updateBlurSize() {
    let w = this.renderWidth;
    let h = this.renderHeight;
    let paddingX = this._paddingX;
    let paddingY = this._paddingY;
    this._wrapper.x = paddingX;
    this._textwrap.x = -paddingX;
    this._wrapper.y = paddingY;
    this._textwrap.y = -paddingY;
    this._textwrap.w = w + paddingX * 2;
    this._textwrap.h = h + paddingY * 2;
  }
  get amount() {
    return this._amount;
  }
  /**
   * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
   * Best results for non-fractional values.
   * @param v;
   */
  set amount(v) {
    this._amount = v;
    this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
  }
  static _amountToKernelRadius(v) {
    return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
  }
  get _signalProxy() {
    return true;
  }
}
class WebGLFastBlurComponent extends Component {
  static _template() {
    const onUpdate = function(element, elementCore) {
      if (elementCore._recalc & 2 + 128) {
        const w = elementCore.w;
        const h = elementCore.h;
        let cur = elementCore;
        do {
          cur = cur._children[0];
          cur._element.w = w;
          cur._element.h = h;
        } while (cur._children);
      }
    };
    return {
      Textwrap: { rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {} },
      Layers: {
        L0: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L1: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L2: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L3: { rtt: true, onUpdate, renderOffscreen: true, visible: false, Content: { shader: { type: BoxBlurShader } } }
      },
      Result: { shader: { type: FastBlurOutputShader }, visible: false }
    };
  }
  get _signalProxy() {
    return true;
  }
  constructor(stage2) {
    super(stage2);
    this._textwrap = this.sel("Textwrap");
    this._wrapper = this.sel("Textwrap>Content");
    this._layers = this.sel("Layers");
    this._output = this.sel("Result");
    this._amount = 0;
    this._paddingX = 0;
    this._paddingY = 0;
  }
  _buildLayers() {
    const filterShaderSettings = [{ x: 1, y: 0, kernelRadius: 1 }, { x: 0, y: 1, kernelRadius: 1 }, { x: 1.5, y: 0, kernelRadius: 1 }, { x: 0, y: 1.5, kernelRadius: 1 }];
    const filterShaders = filterShaderSettings.map((s) => {
      const shader = Shader.create(this.stage, Object.assign({ type: LinearBlurShader }, s));
      return shader;
    });
    this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
    this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
    this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
  }
  _setLayerTexture(element, texture, steps) {
    if (!steps.length) {
      element.texture = texture;
    } else {
      const step2 = steps.pop();
      const child = element.stage.c({ rtt: true, shader: step2 });
      this._setLayerTexture(child, texture, steps);
      element.childList.add(child);
    }
    return element;
  }
  get content() {
    return this.sel("Textwrap>Content");
  }
  set content(v) {
    this.sel("Textwrap>Content").patch(v, true);
  }
  set padding(v) {
    this._paddingX = v;
    this._paddingY = v;
    this._updateBlurSize();
  }
  set paddingX(v) {
    this._paddingX = v;
    this._updateBlurSize();
  }
  set paddingY(v) {
    this._paddingY = v;
    this._updateBlurSize();
  }
  getLayer(i) {
    return this._layers.sel("L" + i);
  }
  getLayerContents(i) {
    return this.getLayer(i).sel("Content");
  }
  _onResize() {
    this._updateBlurSize();
  }
  _updateBlurSize() {
    let w = this.renderWidth;
    let h = this.renderHeight;
    let paddingX = this._paddingX;
    let paddingY = this._paddingY;
    let fw = w + paddingX * 2;
    let fh = h + paddingY * 2;
    this._textwrap.w = fw;
    this._wrapper.x = paddingX;
    this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
    this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
    this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
    this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
    this._output.x = -paddingX;
    this._textwrap.x = -paddingX;
    this._output.w = fw;
    this._textwrap.h = fh;
    this._wrapper.y = paddingY;
    this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
    this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
    this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
    this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
    this._output.y = -paddingY;
    this._textwrap.y = -paddingY;
    this._output.h = fh;
    this.w = w;
    this.h = h;
  }
  /**
   * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
   * Best results for non-fractional values.
   * @param v;
   */
  set amount(v) {
    this._amount = v;
    this._update();
  }
  get amount() {
    return this._amount;
  }
  _update() {
    let v = Math.min(4, Math.max(0, this._amount));
    if (v === 0) {
      this._textwrap.renderToTexture = false;
      this._output.shader.otherTextureSource = null;
      this._output.visible = false;
    } else {
      this._textwrap.renderToTexture = true;
      this._output.visible = true;
      this.getLayer(0).visible = v > 0;
      this.getLayer(1).visible = v > 1;
      this.getLayer(2).visible = v > 2;
      this.getLayer(3).visible = v > 3;
      if (v <= 1) {
        this._output.texture = this._textwrap.getTexture();
        this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
        this._output.shader.a = v;
      } else if (v <= 2) {
        this._output.texture = this.getLayer(0).getTexture();
        this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
        this._output.shader.a = v - 1;
      } else if (v <= 3) {
        this._output.texture = this.getLayer(1).getTexture();
        this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
        this._output.shader.a = v - 2;
      } else if (v <= 4) {
        this._output.texture = this.getLayer(2).getTexture();
        this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
        this._output.shader.a = v - 3;
      }
    }
  }
  set shader(s) {
    super.shader = s;
    if (!this.renderToTexture) {
      console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
    }
  }
  _firstActive() {
    this._buildLayers();
  }
}
class FastBlurOutputShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._a = 0;
    this._otherTextureSource = null;
  }
  get a() {
    return this._a;
  }
  set a(v) {
    this._a = v;
    this.redraw();
  }
  set otherTextureSource(v) {
    this._otherTextureSource = v;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("a", this._a, this.gl.uniform1f);
    this._setUniform("uSampler2", 1, this.gl.uniform1i);
  }
  beforeDraw(operation) {
    let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;
    let gl = this.gl;
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.activeTexture(gl.TEXTURE0);
  }
}
FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;
class BloomComponent extends Component {
  static _template() {
    const onUpdate = function(element, elementCore) {
      if (elementCore._recalc & 2 + 128) {
        const w = elementCore.w;
        const h = elementCore.h;
        let cur = elementCore;
        do {
          cur = cur._children[0];
          cur._element.w = w;
          cur._element.h = h;
        } while (cur._children);
      }
    };
    return {
      Textwrap: {
        rtt: true,
        forceZIndexContext: true,
        renderOffscreen: true,
        BloomBase: {
          shader: { type: BloomBaseShader },
          Content: {}
        }
      },
      Layers: {
        L0: { rtt: true, onUpdate, scale: 2, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L1: { rtt: true, onUpdate, scale: 4, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L2: { rtt: true, onUpdate, scale: 8, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } },
        L3: { rtt: true, onUpdate, scale: 16, pivot: 0, visible: false, Content: { shader: { type: BoxBlurShader } } }
      }
    };
  }
  get _signalProxy() {
    return true;
  }
  constructor(stage2) {
    super(stage2);
    this._textwrap = this.sel("Textwrap");
    this._wrapper = this.sel("Textwrap.Content");
    this._layers = this.sel("Layers");
    this._amount = 0;
    this._paddingX = 0;
    this._paddingY = 0;
  }
  _build() {
    const filterShaderSettings = [{ x: 1, y: 0, kernelRadius: 3 }, { x: 0, y: 1, kernelRadius: 3 }, { x: 1.5, y: 0, kernelRadius: 3 }, { x: 0, y: 1.5, kernelRadius: 3 }];
    const filterShaders = filterShaderSettings.map((s) => {
      const shader = this.stage.createShader(Object.assign({ type: LinearBlurShader }, s));
      return shader;
    });
    this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
    this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
    this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
  }
  _setLayerTexture(element, texture, steps) {
    if (!steps.length) {
      element.texture = texture;
    } else {
      const step2 = steps.pop();
      const child = element.stage.c({ rtt: true, shader: step2 });
      this._setLayerTexture(child, texture, steps);
      element.childList.add(child);
    }
    return element;
  }
  get content() {
    return this.sel("Textwrap.Content");
  }
  set content(v) {
    this.sel("Textwrap.Content").patch(v);
  }
  set padding(v) {
    this._paddingX = v;
    this._paddingY = v;
    this._updateBlurSize();
  }
  set paddingX(v) {
    this._paddingX = v;
    this._updateBlurSize();
  }
  set paddingY(v) {
    this._paddingY = v;
    this._updateBlurSize();
  }
  getLayer(i) {
    return this._layers.sel("L" + i);
  }
  getLayerContents(i) {
    return this.getLayer(i).sel("Content");
  }
  _onResize() {
    this._updateBlurSize();
  }
  _updateBlurSize() {
    let w = this.renderWidth;
    let h = this.renderHeight;
    let paddingX = this._paddingX;
    let paddingY = this._paddingY;
    let fw = w + paddingX * 2;
    let fh = h + paddingY * 2;
    this._textwrap.w = fw;
    this._wrapper.x = paddingX;
    this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
    this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
    this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
    this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
    this._textwrap.x = -paddingX;
    this._textwrap.h = fh;
    this._wrapper.y = paddingY;
    this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
    this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
    this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
    this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
    this._textwrap.y = -paddingY;
    this.w = w;
    this.h = h;
  }
  /**
   * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
   * Best results for non-fractional values.
   * @param v;
   */
  set amount(v) {
    this._amount = v;
    this._update();
  }
  get amount() {
    return this._amount;
  }
  _update() {
    let v = Math.min(4, Math.max(0, this._amount));
    if (v > 0) {
      this.getLayer(0).visible = v > 0;
      this.getLayer(1).visible = v > 1;
      this.getLayer(2).visible = v > 2;
      this.getLayer(3).visible = v > 3;
    }
  }
  set shader(s) {
    super.shader = s;
    if (!this.renderToTexture) {
      console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
    }
  }
  _firstActive() {
    this._build();
  }
}
class BloomBaseShader extends DefaultShader$1 {
}
BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;
class SmoothScaleComponent extends Component {
  static _template() {
    return {
      ContentWrap: {
        renderOffscreen: true,
        forceZIndexContext: true,
        onAfterUpdate: SmoothScaleComponent._updateDimensions,
        Content: {}
      },
      Scale: { visible: false }
    };
  }
  constructor(stage2) {
    super(stage2);
    this._smoothScale = 1;
    this._iterations = 0;
  }
  get content() {
    return this.tag("Content");
  }
  set content(v) {
    this.tag("Content").patch(v, true);
  }
  get smoothScale() {
    return this._smoothScale;
  }
  set smoothScale(v) {
    if (this._smoothScale !== v) {
      let its = 0;
      while (v < 0.5 && its < 12) {
        its++;
        v = v * 2;
      }
      this.scale = v;
      this._setIterations(its);
      this._smoothScale = v;
    }
  }
  _setIterations(its) {
    if (this._iterations !== its) {
      const scalers = this.sel("Scale").childList;
      const content = this.sel("ContentWrap");
      while (scalers.length < its) {
        const first = scalers.length === 0;
        const texture = first ? content.getTexture() : scalers.last.getTexture();
        scalers.a({ rtt: true, renderOffscreen: true, texture });
      }
      SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);
      const useScalers = its > 0;
      this.patch({
        ContentWrap: { renderToTexture: useScalers },
        Scale: { visible: useScalers }
      });
      for (let i = 0, n = scalers.length; i < n; i++) {
        scalers.getAt(i).patch({
          visible: i < its,
          renderOffscreen: i !== its - 1
        });
      }
      this._iterations = its;
    }
  }
  static _updateDimensions(contentWrap, force) {
    const content = contentWrap.children[0];
    let w = content.renderWidth;
    let h = content.renderHeight;
    if (w !== contentWrap.w || h !== contentWrap.h || force) {
      contentWrap.w = w;
      contentWrap.h = h;
      const scalers = contentWrap.parent.tag("Scale").children;
      for (let i = 0, n = scalers.length; i < n; i++) {
        w = w * 0.5;
        h = h * 0.5;
        scalers[i].w = w;
        scalers[i].h = h;
      }
    }
  }
  get _signalProxy() {
    return true;
  }
}
class BorderComponent extends Component {
  static _template() {
    return {
      Content: {},
      Borders: {
        Top: { rect: true, visible: false, mountY: 1 },
        Right: { rect: true, visible: false },
        Bottom: { rect: true, visible: false },
        Left: { rect: true, visible: false, mountX: 1 }
      }
    };
  }
  get _signalProxy() {
    return true;
  }
  constructor(stage2) {
    super(stage2);
    this._borderTop = this.tag("Top");
    this._borderRight = this.tag("Right");
    this._borderBottom = this.tag("Bottom");
    this._borderLeft = this.tag("Left");
    this.onAfterUpdate = function(element) {
      const content = element.childList.first;
      let w = element.core.w || content.renderWidth;
      let h = element.core.h || content.renderHeight;
      element._borderTop.w = w;
      element._borderBottom.y = h;
      element._borderBottom.w = w;
      element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
      element._borderLeft.y = -element._borderTop.h;
      element._borderRight.x = w;
      element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
      element._borderRight.y = -element._borderTop.h;
    };
    this.borderWidth = 1;
  }
  get content() {
    return this.sel("Content");
  }
  set content(v) {
    this.sel("Content").patch(v, true);
  }
  get borderWidth() {
    return this.borderWidthTop;
  }
  get borderWidthTop() {
    return this._borderTop.h;
  }
  get borderWidthRight() {
    return this._borderRight.w;
  }
  get borderWidthBottom() {
    return this._borderBottom.h;
  }
  get borderWidthLeft() {
    return this._borderLeft.w;
  }
  set borderWidth(v) {
    this.borderWidthTop = v;
    this.borderWidthRight = v;
    this.borderWidthBottom = v;
    this.borderWidthLeft = v;
  }
  set borderWidthTop(v) {
    this._borderTop.h = v;
    this._borderTop.visible = v > 0;
  }
  set borderWidthRight(v) {
    this._borderRight.w = v;
    this._borderRight.visible = v > 0;
  }
  set borderWidthBottom(v) {
    this._borderBottom.h = v;
    this._borderBottom.visible = v > 0;
  }
  set borderWidthLeft(v) {
    this._borderLeft.w = v;
    this._borderLeft.visible = v > 0;
  }
  get colorBorder() {
    return this.colorBorderTop;
  }
  get colorBorderTop() {
    return this._borderTop.color;
  }
  get colorBorderRight() {
    return this._borderRight.color;
  }
  get colorBorderBottom() {
    return this._borderBottom.color;
  }
  get colorBorderLeft() {
    return this._borderLeft.color;
  }
  set colorBorder(v) {
    this.colorBorderTop = v;
    this.colorBorderRight = v;
    this.colorBorderBottom = v;
    this.colorBorderLeft = v;
  }
  set colorBorderTop(v) {
    this._borderTop.color = v;
  }
  set colorBorderRight(v) {
    this._borderRight.color = v;
  }
  set colorBorderBottom(v) {
    this._borderBottom.color = v;
  }
  set colorBorderLeft(v) {
    this._borderLeft.color = v;
  }
  get borderTop() {
    return this._borderTop;
  }
  set borderTop(settings2) {
    this.borderTop.patch(settings2);
  }
  get borderRight() {
    return this._borderRight;
  }
  set borderRight(settings2) {
    this.borderRight.patch(settings2);
  }
  get borderBottom() {
    return this._borderBottom;
  }
  set borderBottom(settings2) {
    this.borderBottom.patch(settings2);
  }
  get borderLeft() {
    return this._borderLeft;
  }
  set borderLeft(settings2) {
    this.borderLeft.patch(settings2);
  }
  set borders(settings2) {
    this.borderTop = settings2;
    this.borderLeft = settings2;
    this.borderBottom = settings2;
    this.borderRight = settings2;
  }
}
class WebGLGrayscaleShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._amount = 1;
  }
  static getC2d() {
    return C2dGrayscaleShader;
  }
  set amount(v) {
    this._amount = v;
    this.redraw();
  }
  get amount() {
    return this._amount;
  }
  useDefault() {
    return this._amount === 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("amount", this._amount, this.gl.uniform1f);
  }
}
WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;
class C2dGrayscaleShader extends DefaultShader2 {
  constructor(context) {
    super(context);
    this._amount = 1;
  }
  static getWebGL() {
    return WebGLGrayscaleShader;
  }
  set amount(v) {
    this._amount = v;
    this.redraw();
  }
  get amount() {
    return this._amount;
  }
  useDefault() {
    return this._amount === 0;
  }
  _beforeDrawEl({ target }) {
    target.ctx.filter = "grayscale(" + this._amount + ")";
  }
  _afterDrawEl({ target }) {
    target.ctx.filter = "none";
  }
}
class DitheringShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._noiseTexture = new NoiseTexture(ctx.stage);
    this._graining = 1 / 256;
    this._random = false;
  }
  set graining(v) {
    this._graining = v;
    this.redraw();
  }
  set random(v) {
    this._random = v;
    this.redraw();
  }
  setExtraAttribsInBuffer(operation) {
    this._noiseTexture.load();
    let offset = operation.extraAttribsDataByteOffset / 4;
    let floats = operation.quads.floats;
    let length = operation.length;
    for (let i = 0; i < length; i++) {
      let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
      let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();
      let ulx = 0;
      let uly = 0;
      if (this._random) {
        ulx = Math.random();
        uly = Math.random();
        brx += ulx;
        bry += uly;
        if (Math.random() < 0.5) {
          const t = ulx;
          ulx = brx;
          brx = t;
        }
        if (Math.random() < 0.5) {
          const t = uly;
          uly = bry;
          bry = t;
        }
      }
      floats[offset] = ulx;
      floats[offset + 1] = uly;
      floats[offset + 2] = brx;
      floats[offset + 3] = uly;
      floats[offset + 4] = brx;
      floats[offset + 5] = bry;
      floats[offset + 6] = ulx;
      floats[offset + 7] = bry;
      offset += 8;
    }
  }
  beforeDraw(operation) {
    let gl = this.gl;
    gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    let glTexture = this._noiseTexture.source.nativeTexture;
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.activeTexture(gl.TEXTURE0);
  }
  getExtraAttribBytesPerVertex() {
    return 8;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
    this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
  }
  enableAttribs() {
    super.enableAttribs();
    let gl = this.gl;
    gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
  }
  disableAttribs() {
    super.disableAttribs();
    let gl = this.gl;
    gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
  }
  useDefault() {
    return this._graining === 0;
  }
  afterDraw(operation) {
    if (this._random) {
      this.redraw();
    }
  }
}
DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;
class CircularPushShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._inputValue = 0;
    this._maxDerivative = 0.01;
    this._normalizedValue = 0;
    this._offset = 0;
    this._amount = 0.1;
    this._aspectRatio = 1;
    this._offsetX = 0;
    this._offsetY = 0;
    this.buckets = 100;
  }
  get aspectRatio() {
    return this._aspectRatio;
  }
  set aspectRatio(v) {
    this._aspectRatio = v;
    this.redraw();
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(v) {
    this._offsetX = v;
    this.redraw();
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(v) {
    this._offsetY = v;
    this.redraw();
  }
  set amount(v) {
    this._amount = v;
    this.redraw();
  }
  get amount() {
    return this._amount;
  }
  set inputValue(v) {
    this._inputValue = v;
  }
  get inputValue() {
    return this._inputValue;
  }
  set maxDerivative(v) {
    this._maxDerivative = v;
  }
  get maxDerivative() {
    return this._maxDerivative;
  }
  set buckets(v) {
    if (v > 100) {
      console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
      v = 100;
    }
    this._buckets = v;
    this._values = new Uint8Array(this._getValues(v));
    this.redraw();
  }
  get buckets() {
    return this._buckets;
  }
  _getValues(n) {
    const v = [];
    for (let i = 0; i < n; i++) {
      v.push(this._inputValue);
    }
    return v;
  }
  /**
   * Progresses the shader with the specified (fractional) number of buckets.
   * @param {number} o;
   *   A number from 0 to 1 (1 = all buckets).
   */
  progress(o) {
    this._offset += o * this._buckets;
    const full = Math.floor(this._offset);
    this._offset -= full;
    this._shiftBuckets(full);
    this.redraw();
  }
  _shiftBuckets(n) {
    for (let i = this._buckets - 1; i >= 0; i--) {
      const targetIndex = i - n;
      if (targetIndex < 0) {
        this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
        this._values[i] = 255 * this._normalizedValue;
      } else {
        this._values[i] = this._values[targetIndex];
      }
    }
  }
  set offset(v) {
    this._offset = v;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
    this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
    this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
    this._setUniform("amount", this._amount, this.gl.uniform1f);
    this._setUniform("offset", this._offset, this.gl.uniform1f);
    this._setUniform("buckets", this._buckets, this.gl.uniform1f);
    this._setUniform("uValueSampler", 1, this.gl.uniform1i);
  }
  useDefault() {
    return this._amount === 0;
  }
  beforeDraw(operation) {
    const gl = this.gl;
    gl.activeTexture(gl.TEXTURE1);
    if (!this._valuesTexture) {
      this._valuesTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (Utils$2.isNode) {
        gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
      }
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    } else {
      gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
    }
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
    gl.activeTexture(gl.TEXTURE0);
  }
  cleanup() {
    if (this._valuesTexture) {
      this.gl.deleteTexture(this._valuesTexture);
    }
  }
}
CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;
class InversionShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._amount = 1;
  }
  set amount(v) {
    this._amount = v;
    this.redraw();
  }
  get amount() {
    return this._amount;
  }
  useDefault() {
    return this._amount === 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("amount", this._amount, this.gl.uniform1f);
  }
}
InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;
class OutlineShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._width = 5;
    this._col = 4294967295;
    this._color = [1, 1, 1, 1];
  }
  set width(v) {
    this._width = v;
    this.redraw();
  }
  get color() {
    return this._col;
  }
  set color(v) {
    if (this._col !== v) {
      const col = StageUtils.getRgbaComponentsNormalized(v);
      col[0] = col[0] * col[3];
      col[1] = col[1] * col[3];
      col[2] = col[2] * col[3];
      this._color = col;
      this.redraw();
      this._col = v;
    }
  }
  useDefault() {
    return this._width === 0 || this._col[3] === 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    let gl = this.gl;
    this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
  }
  enableAttribs() {
    super.enableAttribs();
    this.gl.enableVertexAttribArray(this._attrib("aCorner"));
  }
  disableAttribs() {
    super.disableAttribs();
    this.gl.disableVertexAttribArray(this._attrib("aCorner"));
  }
  setExtraAttribsInBuffer(operation) {
    let offset = operation.extraAttribsDataByteOffset / 4;
    let floats = operation.quads.floats;
    let length = operation.length;
    for (let i = 0; i < length; i++) {
      const elementCore = operation.getElementCore(i);
      const ddw = this._width / elementCore.w;
      const dw = ddw / (1 - 2 * ddw);
      const ddh = this._width / elementCore.h;
      const dh = ddh / (1 - 2 * ddh);
      floats[offset] = -dw;
      floats[offset + 1] = -dh;
      floats[offset + 2] = 1 + dw;
      floats[offset + 3] = -dh;
      floats[offset + 4] = 1 + dw;
      floats[offset + 5] = 1 + dh;
      floats[offset + 6] = -dw;
      floats[offset + 7] = 1 + dh;
      offset += 8;
    }
  }
  beforeDraw(operation) {
    let gl = this.gl;
    gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
  }
  getExtraAttribBytesPerVertex() {
    return 8;
  }
}
OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;
class PixelateShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._size = new Float32Array([4, 4]);
  }
  get x() {
    return this._size[0];
  }
  set x(v) {
    this._size[0] = v;
    this.redraw();
  }
  get y() {
    return this._size[1];
  }
  set y(v) {
    this._size[1] = v;
    this.redraw();
  }
  get size() {
    return this._size[0];
  }
  set size(v) {
    this._size[0] = v;
    this._size[1] = v;
    this.redraw();
  }
  useDefault() {
    return this._size[0] === 0 && this._size[1] === 0;
  }
  static getWebGLImpl() {
    return WebGLPixelateShaderImpl;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    let gl = this.gl;
    this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
  }
  getExtraAttribBytesPerVertex() {
    return 8;
  }
  enableAttribs() {
    super.enableAttribs();
    this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
  }
  disableAttribs() {
    super.disableAttribs();
    this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
  }
  setExtraAttribsInBuffer(operation) {
    let offset = operation.extraAttribsDataByteOffset / 4;
    let floats = operation.quads.floats;
    let length = operation.length;
    for (let i = 0; i < length; i++) {
      let w = operation.quads.getTextureWidth(operation.index + i);
      let h = operation.quads.getTextureHeight(operation.index + i);
      floats[offset] = w;
      floats[offset + 1] = h;
      floats[offset + 2] = w;
      floats[offset + 3] = h;
      floats[offset + 4] = w;
      floats[offset + 5] = h;
      floats[offset + 6] = w;
      floats[offset + 7] = h;
      offset += 8;
    }
  }
  beforeDraw(operation) {
    let gl = this.gl;
    gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
  }
}
PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;
class RadialFilterShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._radius = 0;
    this._cutoff = 1;
  }
  set radius(v) {
    this._radius = v;
    this.redraw();
  }
  get radius() {
    return this._radius;
  }
  set cutoff(v) {
    this._cutoff = v;
    this.redraw();
  }
  get cutoff() {
    return this._cutoff;
  }
  useDefault() {
    return this._radius === 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
    this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
  }
}
RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;
RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;
class RoundedRectangleShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._blend = 0;
    this._radius = [1, 1, 1, 1];
    this._stroke = 0;
    this._fc = 16777215;
    this._fillColor = this._getNormalizedColor(4294967295);
    this._strokeColor = this._getNormalizedColor(16777215);
  }
  set blend(p) {
    this._blend = Math.min(Math.max(p, 0), 1);
  }
  set radius(v) {
    if (Array.isArray(v)) {
      if (v.length === 2) {
        this._radius = [v[0], v[1], v[0], v[1]];
      } else if (v.length === 3) {
        this._radius = [v[0], v[1], v[2], this._radius[3]];
      } else if (v.length === 4) {
        this._radius = v;
      } else {
        this._radius = [v[0], v[0], v[0], v[0]];
      }
    } else {
      this._radius = [v, v, v, v];
    }
    this.redraw();
  }
  get radius() {
    return this._radius;
  }
  set topLeft(num) {
    this._radius[0] = num;
    this.redraw();
  }
  get topLeft() {
    return this._radius[0];
  }
  set topRight(num) {
    this._radius[1] = num;
    this.redraw();
  }
  get topRight() {
    return this._radius[1];
  }
  set bottomRight(num) {
    this._radius[2] = num;
    this.redraw();
  }
  get bottomRight() {
    return this._radius[2];
  }
  set bottomLeft(num) {
    this._radius[3] = num;
    this.redraw();
  }
  get bottomLeft() {
    return this._radius[4];
  }
  set strokeColor(argb) {
    this._sc = argb;
    this._strokeColor = this._getNormalizedColor(argb);
    this.redraw();
  }
  get strokeColor() {
    return this._sc;
  }
  set fillColor(argb) {
    this._fc = argb;
    this._fillColor = this._getNormalizedColor(argb);
    this.redraw();
  }
  get fillColor() {
    return this._fc;
  }
  set stroke(num) {
    this._stroke = num;
    this.redraw();
  }
  get stroke() {
    return this._stroke;
  }
  _getNormalizedColor(color) {
    const col = StageUtils.getRgbaComponentsNormalized(color);
    col[0] *= col[3];
    col[1] *= col[3];
    col[2] *= col[3];
    return new Float32Array(col);
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    const renderPrecision = this.ctx.stage.getRenderPrecision();
    const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision);
    this._setUniform("radius", new Float32Array(_radius), this.gl.uniform4fv);
    this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
    this._setUniform("blend", this._blend, this.gl.uniform1f);
    this._setUniform("strokeColor", this._strokeColor, this.gl.uniform4fv);
    this._setUniform("fillColor", this._fillColor, this.gl.uniform4fv);
    this._setUniform("stroke", this._stroke * renderPrecision, this.gl.uniform1f);
    this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
  }
}
RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;
class FadeOutShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._fade = [0, 0, 0, 0];
  }
  set top(num) {
    this._fade[0] = num;
    this.redraw();
  }
  get top() {
    return this._fade[0];
  }
  set right(num) {
    this._fade[1] = num;
    this.redraw();
  }
  get right() {
    return this._fade[1];
  }
  set bottom(num) {
    this._fade[2] = num;
    this.redraw();
  }
  get bottom() {
    return this._fade[2];
  }
  set left(num) {
    this._fade[3] = num;
    this.redraw();
  }
  get left() {
    return this._fade[3];
  }
  set fade(v) {
    if (Array.isArray(v)) {
      if (v.length === 2) {
        this._fade = [v[0], v[1], v[0], v[1]];
      } else if (v.length === 3) {
        this._fade = [v[0], v[1], v[2], this._fade[3]];
      } else if (v.length === 4) {
        this._fade = v;
      } else {
        this._fade = [v[0], v[0], v[0], v[0]];
      }
    } else {
      this._fade = [v, v, v, v];
    }
    this.redraw();
  }
  get fade() {
    return this._fade;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    const renderPrecision = this.ctx.stage.getRenderPrecision();
    const fade2 = this._fade.map((f) => f * renderPrecision);
    this._setUniform("fade", new Float32Array(fade2), this.gl.uniform4fv);
    this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
  }
}
FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;
class VignetteShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._magnitude = 1.3;
    this._intensity = 0.7;
    this._pivot = [0.5, 0.5];
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    this._setUniform("magnitude", this._magnitude, this.gl.uniform1f);
    this._setUniform("intensity", this._intensity, this.gl.uniform1f);
    this._setUniform("pivot", new Float32Array(this._pivot), this.gl.uniform2fv);
    this.redraw();
  }
  set pivot(v) {
    if (Array.isArray(v)) {
      this._pivot = v;
    } else {
      this._pivot = [v, v];
    }
    this.redraw();
  }
  get pivotX() {
    return this._pivot[0];
  }
  set pivotX(v) {
    this._pivot[0] = v;
    this.redraw();
  }
  get pivotY() {
    return this._pivot[1];
  }
  set pivotY(v) {
    this._pivot[1] = v;
    this.redraw();
  }
  get intensity() {
    return this._intensity;
  }
  set intensity(v) {
    this._intensity = v;
    this.redraw();
  }
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(v) {
    this._magnitude = v;
    this.redraw();
  }
}
VignetteShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`;
class SpinnerShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._radius = 100;
    this._width = 50;
    this._period = 1;
    this._angle = 0.5;
    this._smooth = 5e-3;
    this._color = 4294967295;
    this._backgroundColor = 4278190080;
    this._time = Date.now();
  }
  set radius(v) {
    this._radius = v;
    this.redraw();
  }
  set width(v) {
    this._width = v;
    this.redraw();
  }
  set period(v) {
    this._period = v;
    this.redraw();
  }
  set angle(v) {
    this._angle = v;
    this.redraw();
  }
  set smooth(v) {
    this._smooth = v;
    this.redraw();
  }
  set color(v) {
    this._color = v;
    this.redraw();
  }
  set backgroundColor(v) {
    this._backgroundColor = v;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);
    const renderPrecision = this.ctx.stage.getRenderPrecision();
    this._setUniform("radius", this._radius * renderPrecision, this.gl.uniform1f);
    this._setUniform("width", this._width * renderPrecision, this.gl.uniform1f);
    this._setUniform("period", this._period, this.gl.uniform1f);
    this._setUniform("angle", this._angle, this.gl.uniform1f);
    this._setUniform("smooth", this._smooth, this.gl.uniform1f);
    this._setUniform("color", new Float32Array(StageUtils.getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
    this._setUniform("backgroundColor", new Float32Array(StageUtils.getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
    this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    this.redraw();
  }
}
SpinnerShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;
class HoleShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._x = 0;
    this._y = 0;
    this._w = 0;
    this._h = 0;
    this._radius = 0;
  }
  get x() {
    return this._x;
  }
  set x(v) {
    this._x = v;
    this.redraw();
  }
  get y() {
    return this._y;
  }
  set y(v) {
    this._y = v;
    this.redraw();
  }
  get w() {
    return this._w;
  }
  set w(v) {
    this._w = v;
    this.redraw();
  }
  get h() {
    return this._h;
  }
  set h(v) {
    this._h = v;
    this.redraw();
  }
  get radius() {
    return this._radius;
  }
  set radius(v) {
    this._radius = v;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    const renderPrecision = this.ctx.stage.getRenderPrecision();
    this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
    this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
    this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
    this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
    this._setUniform("radius", (this._radius + 0.5) * renderPrecision, this.gl.uniform1f);
    this._setUniform("resolution", new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
  }
  useDefault() {
    return this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0;
  }
}
HoleShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;
class RadialGradientShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._pivot = [0, 0];
    this._ic = 4294967295;
    this._normalizedIC = this._getNormalizedColor(this._ic);
    this._oc = 16777215;
    this._normalizedOC = this._getNormalizedColor(this._oc);
    this._radius = 0;
  }
  set radiusX(v) {
    this.radius = v;
  }
  get radiusX() {
    return this._radius;
  }
  set radiusY(v) {
    this._radiusY = v;
    this.redraw();
  }
  get radiusY() {
    return this._radiusY;
  }
  set radius(v) {
    this._radius = v;
    this.redraw();
  }
  set innerColor(argb) {
    this._ic = argb;
    this._normalizedIC = this._getNormalizedColor(argb);
    this.redraw();
  }
  get innerColor() {
    return this._ic;
  }
  set outerColor(argb) {
    this._oc = argb;
    this._normalizedOC = this._getNormalizedColor(argb);
    this.redraw();
  }
  set color(argb) {
    this.innerColor = argb;
  }
  get color() {
    return this.innerColor;
  }
  get outerColor() {
    return this._ic;
  }
  set x(f) {
    this._x = f;
    this.redraw();
  }
  set y(f) {
    this._y = f;
    this.redraw();
  }
  set pivot(v) {
    if (Array.isArray(v) && v.length === 2) {
      this._pivot = v;
    } else if (Array.isArray(v)) {
      this._pivot = [v[0], v[1] || v[0]];
    } else {
      this._pivot = [v, v];
    }
    this.redraw();
  }
  get pivot() {
    return this._pivot[0];
  }
  set pivotY(f) {
    this._pivot[1] = f;
    this.redraw();
  }
  get pivotY() {
    return this._pivot[1];
  }
  set pivotX(f) {
    this._pivot[0] = f;
    this.redraw();
  }
  get pivotX() {
    return this._pivot[0];
  }
  _getNormalizedColor(color) {
    const col = StageUtils.getRgbaComponentsNormalized(color);
    col[0] *= col[3];
    col[1] *= col[3];
    col[2] *= col[3];
    return new Float32Array(col);
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    if (this._x) {
      this._pivot[0] = this._x / owner.w;
    }
    if (this._y) {
      this._pivot[1] = this._y / owner.h;
    }
    if (this._radius === 0) {
      this._radius = owner.w * 0.5;
    }
    this._setUniform("innerColor", this._normalizedIC, this.gl.uniform4fv);
    this._setUniform("fill", StageUtils.getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
    this._setUniform("outerColor", this._normalizedOC, this.gl.uniform4fv);
    this._setUniform("pivot", new Float32Array(this._pivot), this.gl.uniform2fv);
    this._setUniform("resolution", new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
    this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
    this._setUniform("radius", this._radius, this.gl.uniform1f);
    this._setUniform("radiusY", this._radiusY || this._radius, this.gl.uniform1f);
  }
}
RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;
class Light3dShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._strength = 0.5;
    this._ambient = 0.5;
    this._fudge = 0.4;
    this._rx = 0;
    this._ry = 0;
    this._z = 0;
    this._pivotX = NaN;
    this._pivotY = NaN;
    this._pivotZ = 0;
    this._lightY = 0;
    this._lightZ = 0;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    let vr = operation.shaderOwner;
    let element = vr.element;
    let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
    let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
    let coords = vr.getRenderTextureCoords(pivotX, pivotY);
    let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
    let gl = this.gl;
    this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
    this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
    this._setUniform("z", this._z, gl.uniform1f);
    this._setUniform("lightY", this.lightY, gl.uniform1f);
    this._setUniform("lightZ", this.lightZ, gl.uniform1f);
    this._setUniform("strength", this._strength, gl.uniform1f);
    this._setUniform("ambient", this._ambient, gl.uniform1f);
    this._setUniform("fudge", this._fudge, gl.uniform1f);
  }
  set strength(v) {
    this._strength = v;
    this.redraw();
  }
  get strength() {
    return this._strength;
  }
  set ambient(v) {
    this._ambient = v;
    this.redraw();
  }
  get ambient() {
    return this._ambient;
  }
  set fudge(v) {
    this._fudge = v;
    this.redraw();
  }
  get fudge() {
    return this._fudge;
  }
  get rx() {
    return this._rx;
  }
  set rx(v) {
    this._rx = v;
    this.redraw();
  }
  get ry() {
    return this._ry;
  }
  set ry(v) {
    this._ry = v;
    this.redraw();
  }
  get z() {
    return this._z;
  }
  set z(v) {
    this._z = v;
    this.redraw();
  }
  get pivotX() {
    return this._pivotX;
  }
  set pivotX(v) {
    this._pivotX = v + 1;
    this.redraw();
  }
  get pivotY() {
    return this._pivotY;
  }
  set pivotY(v) {
    this._pivotY = v + 1;
    this.redraw();
  }
  get lightY() {
    return this._lightY;
  }
  set lightY(v) {
    this._lightY = v;
    this.redraw();
  }
  get pivotZ() {
    return this._pivotZ;
  }
  set pivotZ(v) {
    this._pivotZ = v;
    this.redraw();
  }
  get lightZ() {
    return this._lightZ;
  }
  set lightZ(v) {
    this._lightZ = v;
    this.redraw();
  }
  useDefault() {
    return this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1;
  }
}
Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;
class PerspectiveShader extends DefaultShader$1 {
  constructor(ctx) {
    super(ctx);
    this._fudge = 0.2;
    this._rx = 0;
    this._ry = 0;
    this._z = 1;
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const vr = operation.shaderOwner;
    const element = vr.element;
    const pivotX = element.pivotX * vr.w;
    const pivotY = element.pivotY * vr.h;
    const coords = vr.getRenderTextureCoords(pivotX, pivotY);
    const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
    const gl = this.gl;
    this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
    this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
    this._setUniform("z", this._z, gl.uniform1f);
    this._setUniform("fudge", this._fudge, gl.uniform1f);
  }
  set fudge(v) {
    this._fudge = v;
    this.redraw();
  }
  get fudge() {
    return this._fudge;
  }
  get rx() {
    return this._rx;
  }
  set rx(v) {
    this._rx = v;
    this.redraw();
  }
  get ry() {
    return this._ry;
  }
  set ry(v) {
    this._ry = v;
    this.redraw();
  }
  get z() {
    return this._z;
  }
  set z(v) {
    this._z = v;
    this.redraw();
  }
  useDefault() {
    return this._rx === 0 && this._ry === 0 && this._z === 0;
  }
}
PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;
class MagnifierShader extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._x = 0;
    this._y = 0;
    this._w = 0;
    this._h = 0;
    this._radius = 0;
    this._magnification = 0.6;
  }
  get x() {
    return this._x;
  }
  set x(v) {
    this._x = v;
    this.redraw();
  }
  get y() {
    return this._y;
  }
  set y(v) {
    this._y = v;
    this.redraw();
  }
  get w() {
    return this._w;
  }
  set w(v) {
    this._w = v;
    this.redraw();
  }
  get h() {
    return this._h;
  }
  set h(v) {
    this._h = v;
    this.redraw();
  }
  get magnification() {
    return this._magnification;
  }
  set magnification(v) {
    this._magnification = v;
    this.redraw();
  }
  get radius() {
    return this._radius;
  }
  set radius(v) {
    this._radius = v;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    const renderPrecision = this.ctx.stage.getRenderPrecision();
    this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
    this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
    this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
    this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
    this._setUniform("magnification", this._magnification, this.gl.uniform1f);
    this._setUniform(
      "radius",
      (this._radius + 0.5) * renderPrecision,
      this.gl.uniform1f
    );
    this._setUniform(
      "resolution",
      new Float32Array([
        owner._w * renderPrecision,
        owner._h * renderPrecision
      ]),
      this.gl.uniform2fv
    );
  }
  useDefault() {
    return this._w === 0 && this._h === 0;
  }
}
MagnifierShader.vertexShaderSource = DefaultShader$1.vertexShaderSource;
MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;
class SpinnerShader2 extends DefaultShader$1 {
  constructor(context) {
    super(context);
    this._period = 1;
    this._stroke = 0;
    this._showDot = true;
    this._clockwise = true;
    this._bc = 4278190080;
    this._normalizedBC = this._getNormalizedColor(this._bc);
    this._c = 4294967295;
    this._normalizedC = this._getNormalizedColor(this._c);
  }
  set radius(v) {
    if (v === 0) {
      v = 1;
    }
    this._radius = v;
  }
  set stroke(value) {
    this._stroke = Math.abs(value);
  }
  get stroke() {
    return this._stroke;
  }
  set color(argb) {
    this._c = argb;
    this._normalizedC = this._getNormalizedColor(argb);
  }
  get color() {
    return this._c;
  }
  set backgroundColor(argb) {
    this._bc = argb;
    this._normalizedBC = this._getNormalizedColor(argb);
  }
  get backgroundColor() {
    return this._sc;
  }
  set showDot(bool) {
    this._showDot = bool;
  }
  get showDot() {
    return this._showDot;
  }
  set clockwise(bool) {
    this._clockwise = bool;
  }
  get clockwise() {
    return this._clockwise;
  }
  set period(v) {
    this._period = v;
  }
  get period() {
    return this._period;
  }
  _getNormalizedColor(color) {
    const col = StageUtils.getRgbaComponentsNormalized(color);
    col[0] *= col[3];
    col[1] *= col[3];
    col[2] *= col[3];
    return new Float32Array(col);
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const owner = operation.shaderOwner;
    const radius = this._radius || owner._w / 2;
    if (this._stroke === 0) {
      this._stroke = radius * 0.33;
    }
    this._setUniform("resolution", new Float32Array([owner._w, owner._h]), this.gl.uniform2fv);
    this._setUniform("color", this._normalizedC, this.gl.uniform4fv);
    this._setUniform("backgroundColor", this._normalizedBC, this.gl.uniform4fv);
    this._setUniform("stroke", this._stroke, this.gl.uniform1f);
    this._setUniform("radius", radius, this.gl.uniform1f);
    this._setUniform("direction", this._clockwise ? -1 : 1, this.gl.uniform1f);
    this._setUniform("showDot", !!this._showDot, this.gl.uniform1f);
    this._setUniform("time", Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
    this._setUniform("period", this._period, this.gl.uniform1f);
    this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
    if (this._sc !== this._bc || this._stroke !== radius * 0.5) {
      this.redraw();
    }
  }
}
SpinnerShader2.spinSync = Date.now();
SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;
const lightning = {
  Application: Application$1,
  Component,
  Base,
  Utils: Utils$2,
  StageUtils,
  Element: Element$1,
  Tools,
  Stage,
  ElementCore,
  ElementTexturizer,
  Texture,
  EventEmitter,
  shaders: {
    Grayscale: WebGLGrayscaleShader,
    BoxBlur: BoxBlurShader,
    Dithering: DitheringShader,
    CircularPush: CircularPushShader,
    Inversion: InversionShader,
    LinearBlur: LinearBlurShader,
    Outline: OutlineShader,
    Pixelate: PixelateShader,
    RadialFilter: RadialFilterShader,
    RoundedRectangle: RoundedRectangleShader,
    Spinner2: SpinnerShader2,
    FadeOut: FadeOutShader,
    Hole: HoleShader,
    Vignette: VignetteShader,
    Spinner: SpinnerShader,
    RadialGradient: RadialGradientShader,
    Light3d: Light3dShader,
    Perspective: PerspectiveShader,
    Magnifier: MagnifierShader,
    WebGLShader,
    WebGLDefaultShader: DefaultShader$1,
    C2dShader,
    C2dDefaultShader: DefaultShader2,
    c2d: {
      Grayscale: C2dGrayscaleShader,
      Blur: BlurShader
    }
  },
  textures: {
    RectangleTexture,
    NoiseTexture,
    TextTexture,
    ImageTexture,
    HtmlTexture,
    StaticTexture,
    StaticCanvasTexture,
    SourceTexture
  },
  components: {
    FastBlurComponent,
    BloomComponent,
    SmoothScaleComponent,
    BorderComponent,
    ListComponent
  },
  tools: {
    ObjMerger,
    ObjectListProxy,
    ObjectListWrapper
  }
};
if (Utils$2.isWeb) {
  window.lng = lightning;
}
let ColorShift$1 = class ColorShift extends lightning.shaders.WebGLDefaultShader {
  set brightness(v) {
    this._brightness = (v - 50) / 100;
    this.redraw();
  }
  set contrast(v) {
    this._contrast = (v + 50) / 100;
    this.redraw();
  }
  set gamma(v) {
    this._gamma = (v + 50) / 100;
    this.redraw();
  }
  setupUniforms(operation) {
    super.setupUniforms(operation);
    const gl = this.gl;
    this._setUniform(
      "colorAdjust",
      [this._brightness || 0, this._contrast || 1, this._gamma || 1],
      gl.uniform3fv
    );
  }
};
ColorShift$1.before = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
        
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec3 colorAdjust;
    
    const mat3 RGBtoOpponentMat = mat3(0.2814, -0.0971, -0.0930, 0.6938, 0.1458,-0.2529, 0.0638, -0.0250, 0.4665);
    const mat3 OpponentToRGBMat = mat3(1.1677, 0.9014, 0.7214, -6.4315, 2.5970, 0.1257, -0.5044, 0.0159, 2.0517);    
`;
ColorShift$1.after = `    
    vec3 brightnessContrast(vec3 value, float brightness, float contrast)
    {
        return (value - 0.5) * contrast + 0.5 + brightness;
    }   
    
    vec3 updateGamma(vec3 value, float param)
    {
        return vec3(pow(abs(value.r), param),pow(abs(value.g), param),pow(abs(value.b), param));
    } 
       
    void main(void){
        vec4 fragColor = texture2D(uSampler, vTextureCoord);        
        vec4 color = filter(fragColor) * vColor;       
        
        vec3 bc = brightnessContrast(color.rgb,colorAdjust[0],colorAdjust[1]);        
        vec3 ga = updateGamma(bc.rgb, colorAdjust[2]);  
              
        gl_FragColor = vec4(ga.rgb, color.a);          
    }    
`;
class ProtanopiaShader extends ColorShift$1 {
}
ProtanopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.20,  0.99, -0.19, 0.0);
        vec4 g = vec4( 0.16,  0.79,  0.04, 0.0);
        vec4 b = vec4( 0.01, -0.01,  1.00, 0.0);
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));      
    }    
    ${ColorShift$1.after} 
`;
class DeuteranopiaShader extends ColorShift$1 {
}
DeuteranopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.43,  0.72, -0.15, 0.0 );
        vec4 g = vec4( 0.34,  0.57,  0.09, 0.0 );
        vec4 b = vec4(-0.02,  0.03,  1.00, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }
       
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= opponentColor.y * 1.5; 
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));    
    }
    ${ColorShift$1.after}    
`;
class TritanopiaShader extends ColorShift$1 {
}
TritanopiaShader.fragmentShaderSource = `
    ${ColorShift$1.before}    
    vec4 vision(vec4 color)
    {
        vec4 r = vec4( 0.97,  0.11, -0.08, 0.0 );
        vec4 g = vec4( 0.02,  0.82,  0.16, 0.0 );
        vec4 b = vec4(-0.06,  0.88,  0.18, 0.0 );
       
        return vec4(dot(color, r), dot(color, g), dot(color, b), color.a);	
    }   
    
    vec4 filter( vec4 color )
    {   
        vec3 opponentColor = RGBtoOpponentMat * vec3(color.r, color.g, color.b);
        opponentColor.x -= ((3.0 * opponentColor.z) - opponentColor.y) * 0.25;
        vec3 rgbColor = OpponentToRGBMat * opponentColor;
        return vision(vec4(rgbColor.r, rgbColor.g, rgbColor.b, color.a));
    }   
    ${ColorShift$1.after} 
`;
class NeutralShader extends ColorShift$1 {
}
NeutralShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 filter( vec4 color )
    {
        return color;
    }
    ${ColorShift$1.after}
`;
class MonochromacyShader extends ColorShift$1 {
}
MonochromacyShader.fragmentShaderSource = `
    ${ColorShift$1.before}
    vec4 filter( vec4 color )
    {   
        float grey = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        return vec4(vec3(grey, grey, grey), 1.0 ); 
    }
    ${ColorShift$1.after}
`;
const colorshiftShader = (type) => {
  const shadersMap = {
    normal: NeutralShader,
    monochromacy: MonochromacyShader,
    deuteranopia: DeuteranopiaShader,
    tritanopia: TritanopiaShader,
    protanopia: ProtanopiaShader
  };
  type = typeof type === "string" && type.toLowerCase() || null;
  return Object.keys(shadersMap).indexOf(type) > -1 ? shadersMap[type] : false;
};
const Accessibility = {
  colorshift(component, type = false, config = { brightness: 50, contrast: 50, gamma: 50 }) {
    config = { ...{ brightness: 50, contrast: 50, gamma: 50 }, ...config };
    const shader = type && colorshiftShader(type);
    if (shader) {
      Log$1.info("Accessibility Colorshift", type, config);
      component.rtt = true;
      component.shader = {
        type: shader,
        ...config
      };
    } else {
      Log$1.info("Accessibility Colorshift", "Disabled");
      component.rtt = false;
      component.shader = null;
    }
  }
};
let Log;
let Settings;
let ApplicationInstance$1;
let Ads$1;
let Lightning;
const initLightningSdkPlugin = {
  set log(v) {
    Log = v;
  },
  set settings(v) {
    Settings = v;
  },
  set ads(v) {
    Ads$1 = v;
  },
  set lightning(v) {
    Lightning = v;
  },
  set appInstance(v) {
    ApplicationInstance$1 = v;
  }
};
const initMetrics = (config) => {
  sendMetric = config.sendMetric;
};
let sendMetric = (type, event, params) => {
  Log.info("Sending metric", type, event, params);
};
const metrics$1 = {
  app: ["launch", "loaded", "ready", "close"],
  page: ["view", "leave"],
  user: ["click", "input"],
  media: [
    "abort",
    "canplay",
    "ended",
    "pause",
    "play",
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    "volumechange",
    "waiting",
    "seeking",
    "seeked"
  ]
};
const errorMetric = (type, message, code, visible, params = {}) => {
  params = { params, ...{ message, code, visible } };
  sendMetric(type, "error", params);
};
const Metric = (type, events2, options = {}) => {
  return events2.reduce(
    (obj, event) => {
      obj[event] = (name2, params = {}) => {
        params = { ...options, ...name2 ? { name: name2 } : {}, ...params };
        sendMetric(type, event, params);
      };
      return obj;
    },
    {
      error(message, code, params) {
        errorMetric(type, message, code, params);
      },
      event(name2, params) {
        sendMetric(type, name2, params);
      }
    }
  );
};
const Metrics = (types2) => {
  return Object.keys(types2).reduce(
    (obj, type) => {
      type === "media" ? obj[type] = (url) => Metric(type, types2[type], { url }) : obj[type] = Metric(type, types2[type]);
      return obj;
    },
    { error: errorMetric, event: sendMetric }
  );
};
const Metrics$1 = Metrics(metrics$1);
const formatLocale = (locale) => {
  if (locale && locale.length === 2) {
    return `${locale.toLowerCase()}-${locale.toUpperCase()}`;
  } else {
    return locale;
  }
};
const getLocale = (defaultValue) => {
  if ("language" in navigator) {
    const locale = formatLocale(navigator.language);
    return Promise.resolve(locale);
  } else {
    return Promise.resolve(defaultValue);
  }
};
const getLanguage = (defaultValue) => {
  if ("language" in navigator) {
    const language2 = formatLocale(navigator.language).slice(0, 2);
    return Promise.resolve(language2);
  } else {
    return Promise.resolve(defaultValue);
  }
};
const getCountryCode = (defaultValue) => {
  if ("language" in navigator) {
    const countryCode = formatLocale(navigator.language).slice(3, 5);
    return Promise.resolve(countryCode);
  } else {
    return Promise.resolve(defaultValue);
  }
};
const hasOrAskForGeoLocationPermission = () => {
  return new Promise((resolve) => {
    if (Settings.get("platform", "forceBrowserGeolocation") === true)
      resolve(true);
    if ("permissions" in navigator && typeof navigator.permissions.query === "function") {
      navigator.permissions.query({ name: "geolocation" }).then((status) => {
        resolve(status.state === "granted" || status.status === "granted");
      });
    } else {
      resolve(false);
    }
  });
};
const getLatLon = (defaultValue) => {
  return new Promise((resolve) => {
    hasOrAskForGeoLocationPermission().then((granted) => {
      if (granted === true) {
        if ("geolocation" in navigator) {
          navigator.geolocation.getCurrentPosition(
            // success
            (result) => result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
            // error
            () => resolve(defaultValue),
            // options
            {
              enableHighAccuracy: true,
              timeout: 5e3,
              maximumAge: 0
            }
          );
        } else {
          return queryForLatLon().then((result) => resolve(result || defaultValue));
        }
      } else {
        return queryForLatLon().then((result) => resolve(result || defaultValue));
      }
    });
  });
};
const queryForLatLon = () => {
  return new Promise((resolve) => {
    fetch("https://geolocation-db.com/json/").then((response) => response.json()).then(
      ({ latitude, longitude }) => latitude && longitude ? resolve([latitude, longitude]) : resolve(false)
    ).catch(() => resolve(false));
  });
};
const defaultProfile = {
  ageRating: "adult",
  city: "New York",
  zipCode: "27505",
  countryCode: () => getCountryCode("US"),
  ip: "127.0.0.1",
  household: "b2244e9d4c04826ccd5a7b2c2a50e7d4",
  language: () => getLanguage("en"),
  latlon: () => getLatLon([40.7128, 74.006]),
  locale: () => getLocale("en-US"),
  mac: "00:00:00:00:00:00",
  operator: "metrological",
  platform: "metrological",
  packages: [],
  uid: "ee6723b8-7ab3-462c-8d93-dbf61227998e",
  stbType: "metrological"
};
let getInfo = (key) => {
  const profile = { ...defaultProfile, ...Settings.get("platform", "profile") };
  return Promise.resolve(typeof profile[key] === "function" ? profile[key]() : profile[key]);
};
let setInfo = (key, params) => {
  if (key in defaultProfile)
    return defaultProfile[key] = params;
};
const initProfile = (config) => {
  getInfo = config.getInfo ? config.getInfo : getInfo;
  setInfo = config.setInfo ? config.setInfo : setInfo;
};
const initPurchase = (config) => {
  if (config.billingUrl)
    config.billingUrl;
};
const defaultChannels = [
  {
    number: 1,
    name: "Metro News 1",
    description: "New York Cable News Channel",
    entitled: true,
    program: {
      title: "The Morning Show",
      description: "New York's best morning show",
      startTime: new Date(/* @__PURE__ */ new Date() - 60 * 5 * 1e3).toUTCString(),
      // started 5 minutes ago
      duration: 60 * 30,
      // 30 minutes
      ageRating: 0
    }
  },
  {
    number: 2,
    name: "MTV",
    description: "Music Television",
    entitled: true,
    program: {
      title: "Beavis and Butthead",
      description: "American adult animated sitcom created by Mike Judge",
      startTime: new Date(/* @__PURE__ */ new Date() - 60 * 20 * 1e3).toUTCString(),
      // started 20 minutes ago
      duration: 60 * 45,
      // 45 minutes
      ageRating: 18
    }
  },
  {
    number: 3,
    name: "NBC",
    description: "NBC TV Network",
    entitled: false,
    program: {
      title: "The Tonight Show Starring Jimmy Fallon",
      description: "Late-night talk show hosted by Jimmy Fallon on NBC",
      startTime: new Date(/* @__PURE__ */ new Date() - 60 * 10 * 1e3).toUTCString(),
      // started 10 minutes ago
      duration: 60 * 60,
      // 1 hour
      ageRating: 10
    }
  }
];
const channels = () => Settings.get("platform", "tv", defaultChannels);
const randomChannel = () => channels()[~~(channels.length * Math.random())];
let currentChannel;
const callbacks = {};
const emit$1 = (event, ...args) => {
  callbacks[event] && callbacks[event].forEach((cb) => {
    cb.apply(null, args);
  });
};
let methods = {
  getChannel() {
    if (!currentChannel)
      currentChannel = randomChannel();
    return new Promise((resolve, reject) => {
      if (currentChannel) {
        const channel = { ...currentChannel };
        delete channel.program;
        resolve(channel);
      } else {
        reject("No channel found");
      }
    });
  },
  getProgram() {
    if (!currentChannel)
      currentChannel = randomChannel();
    return new Promise((resolve, reject) => {
      currentChannel.program ? resolve(currentChannel.program) : reject("No program found");
    });
  },
  setChannel(number) {
    return new Promise((resolve, reject) => {
      if (number) {
        const newChannel = channels().find((c) => c.number === number);
        if (newChannel) {
          currentChannel = newChannel;
          const channel = { ...currentChannel };
          delete channel.program;
          emit$1("channelChange", channel);
          resolve(channel);
        } else {
          reject("Channel not found");
        }
      } else {
        reject("No channel number supplied");
      }
    });
  }
};
const initTV = (config) => {
  methods = {};
  if (config.getChannel && typeof config.getChannel === "function") {
    methods.getChannel = config.getChannel;
  }
  if (config.getProgram && typeof config.getProgram === "function") {
    methods.getProgram = config.getProgram;
  }
  if (config.setChannel && typeof config.setChannel === "function") {
    methods.setChannel = config.setChannel;
  }
  if (config.emit && typeof config.emit === "function") {
    config.emit(emit$1);
  }
};
const initPin = (config) => {
  if (config.submit && typeof config.submit === "function") {
    config.submit;
  }
  if (config.check && typeof config.check === "function") {
    config.check;
  }
};
const executeAsPromise = (method, args = null, context = null) => {
  let result;
  if (method && typeof method === "function") {
    try {
      result = method.apply(context, args);
    } catch (e) {
      result = e;
    }
  } else {
    result = method;
  }
  if (result !== null && typeof result === "object" && result.then && typeof result.then === "function") {
    return result;
  } else {
    return new Promise((resolve, reject) => {
      if (result instanceof Error) {
        reject(result);
      } else {
        resolve(result);
      }
    });
  }
};
const events$1 = {
  abort: "Abort",
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  durationchange: "DurationChange",
  emptied: "Emptied",
  encrypted: "Encrypted",
  ended: "Ended",
  error: "Error",
  interruptbegin: "InterruptBegin",
  interruptend: "InterruptEnd",
  loadeddata: "LoadedData",
  loadedmetadata: "LoadedMetadata",
  loadstart: "LoadStart",
  pause: "Pause",
  play: "Play",
  playing: "Playing",
  progress: "Progress",
  ratechange: "Ratechange",
  seeked: "Seeked",
  seeking: "Seeking",
  stalled: "Stalled",
  // suspend: 'Suspend', // this one is called a looooot for some videos
  timeupdate: "TimeUpdate",
  volumechange: "VolumeChange",
  waiting: "Waiting"
};
const autoSetupMixin = (sourceObject, setup2 = () => {
}) => {
  let ready = false;
  const doSetup = () => {
    if (ready === false) {
      setup2();
      ready = true;
    }
  };
  return Object.keys(sourceObject).reduce((obj, key) => {
    if (typeof sourceObject[key] === "function") {
      obj[key] = function() {
        doSetup();
        return sourceObject[key].apply(sourceObject, arguments);
      };
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === "function") {
      obj.__defineGetter__(key, function() {
        doSetup();
        return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
      });
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === "function") {
      obj.__defineSetter__(key, function() {
        doSetup();
        return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
          sourceObject,
          arguments
        );
      });
    } else {
      obj[key] = sourceObject[key];
    }
    return obj;
  }, {});
};
let timeout = null;
const easeExecution = (cb, delay) => {
  clearTimeout(timeout);
  timeout = setTimeout(() => {
    cb();
  }, delay);
};
const VideoTexture = () => {
  return class VideoTexture extends Lightning.Component {
    static _template() {
      return {
        Video: {
          alpha: 1,
          visible: false,
          pivot: 0.5,
          texture: { type: Lightning.textures.StaticTexture, options: {} }
        }
      };
    }
    set videoEl(v) {
      this._videoEl = v;
    }
    get videoEl() {
      return this._videoEl;
    }
    get videoView() {
      return this.tag("Video");
    }
    get videoTexture() {
      return this.videoView.texture;
    }
    get isVisible() {
      return this.videoView.alpha === 1 && this.videoView.visible === true;
    }
    _init() {
      this._createVideoTexture();
    }
    _createVideoTexture() {
      const stage2 = this.stage;
      const gl = stage2.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height };
      this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
      this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
    }
    start() {
      const stage2 = this.stage;
      this._lastTime = 0;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage2.gl;
            const currentTime = (/* @__PURE__ */ new Date()).getTime();
            const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();
            const frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
            const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoView.visible = true;
                this.videoTexture.options.w = this.videoEl.width;
                this.videoTexture.options.h = this.videoEl.height;
                const expectedAspectRatio = this.videoView.w / this.videoView.h;
                const realAspectRatio = this.videoEl.width / this.videoEl.height;
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoView.scaleY = 1;
                } else {
                  this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoView.scaleX = 1;
                }
              } catch (e) {
                Log.error("texImage2d video", e);
                this.stop();
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage2.on("frameStart", this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }
    stop() {
      const stage2 = this.stage;
      stage2.removeListener("frameStart", this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoView.visible = false;
      if (this.videoTexture.options.source) {
        const gl = stage2.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
    position(top, left2) {
      this.videoView.patch({
        smooth: {
          x: left2,
          y: top
        }
      });
    }
    size(width, height) {
      this.videoView.patch({
        smooth: {
          w: width,
          h: height
        }
      });
    }
    show() {
      this.videoView.setSmooth("alpha", 1);
    }
    hide() {
      this.videoView.setSmooth("alpha", 0);
    }
  };
};
let mediaUrl$1 = (url) => url;
let videoEl;
let videoTexture;
let metrics;
let consumer$1;
let precision = 1;
let textureMode = false;
const initVideoPlayer = (config) => {
  if (config.mediaUrl) {
    mediaUrl$1 = config.mediaUrl;
  }
};
let eventHandlers = {};
const state$1 = {
  adsEnabled: false,
  playing: false,
  _playingAds: false,
  get playingAds() {
    return this._playingAds;
  },
  set playingAds(val) {
    if (this._playingAds !== val) {
      this._playingAds = val;
      fireOnConsumer$1(val === true ? "AdStart" : "AdEnd");
    }
  },
  skipTime: false,
  playAfterSeek: null
};
const hooks = {
  play() {
    state$1.playing = true;
  },
  pause() {
    state$1.playing = false;
  },
  seeked() {
    state$1.playAfterSeek === true && videoPlayerPlugin.play();
    state$1.playAfterSeek = null;
  },
  abort() {
    deregisterEventListeners();
  }
};
const withPrecision = (val) => Math.round(precision * val) + "px";
const fireOnConsumer$1 = (event, args) => {
  if (consumer$1) {
    consumer$1.fire("$videoPlayer" + event, args, videoEl.currentTime);
    consumer$1.fire("$videoPlayerEvent", event, args, videoEl.currentTime);
  }
};
const fireHook = (event, args) => {
  hooks[event] && typeof hooks[event] === "function" && hooks[event].call(null, event, args);
};
let customLoader = null;
let customUnloader = null;
const loader$1 = (url, videoEl2, config) => {
  return customLoader && typeof customLoader === "function" ? customLoader(url, videoEl2, config) : new Promise((resolve) => {
    url = mediaUrl$1(url);
    videoEl2.setAttribute("src", url);
    videoEl2.load();
    resolve();
  });
};
const unloader = (videoEl2) => {
  return customUnloader && typeof customUnloader === "function" ? customUnloader(videoEl2) : new Promise((resolve) => {
    videoEl2.removeAttribute("src");
    videoEl2.load();
    resolve();
  });
};
const setupVideoTag = () => {
  const videoEls = document.getElementsByTagName("video");
  if (videoEls && videoEls.length) {
    return videoEls[0];
  } else {
    const videoEl2 = document.createElement("video");
    const platformSettingsWidth = Settings.get("platform", "width") ? Settings.get("platform", "width") : 1920;
    const platformSettingsHeight = Settings.get("platform", "height") ? Settings.get("platform", "height") : 1080;
    videoEl2.setAttribute("id", "video-player");
    videoEl2.setAttribute("width", withPrecision(platformSettingsWidth));
    videoEl2.setAttribute("height", withPrecision(platformSettingsHeight));
    videoEl2.style.position = "absolute";
    videoEl2.style.zIndex = "1";
    videoEl2.style.display = "none";
    videoEl2.style.visibility = "hidden";
    videoEl2.style.top = withPrecision(0);
    videoEl2.style.left = withPrecision(0);
    videoEl2.style.width = withPrecision(platformSettingsWidth);
    videoEl2.style.height = withPrecision(platformSettingsHeight);
    document.body.appendChild(videoEl2);
    return videoEl2;
  }
};
const setUpVideoTexture = () => {
  if (!ApplicationInstance$1.tag("VideoTexture")) {
    const el = ApplicationInstance$1.stage.c({
      type: VideoTexture(),
      ref: "VideoTexture",
      zIndex: 0,
      videoEl
    });
    ApplicationInstance$1.childList.addAt(el, 0);
  }
  return ApplicationInstance$1.tag("VideoTexture");
};
const registerEventListeners = () => {
  Log.info("VideoPlayer", "Registering event listeners");
  Object.keys(events$1).forEach((event) => {
    const handler = (e) => {
      if (metrics && metrics[event] && typeof metrics[event] === "function") {
        metrics[event]({ currentTime: videoEl.currentTime });
      }
      fireHook(event, { videoElement: videoEl, event: e });
      fireOnConsumer$1(events$1[event], { videoElement: videoEl, event: e });
    };
    eventHandlers[event] = handler;
    videoEl.addEventListener(event, handler);
  });
};
const deregisterEventListeners = () => {
  Log.info("VideoPlayer", "Deregistering event listeners");
  Object.keys(eventHandlers).forEach((event) => {
    videoEl.removeEventListener(event, eventHandlers[event]);
  });
  eventHandlers = {};
};
const videoPlayerPlugin = {
  consumer(component) {
    consumer$1 = component;
  },
  loader(loaderFn) {
    customLoader = loaderFn;
  },
  unloader(unloaderFn) {
    customUnloader = unloaderFn;
  },
  position(top = 0, left2 = 0) {
    videoEl.style.left = withPrecision(left2);
    videoEl.style.top = withPrecision(top);
    if (textureMode === true) {
      videoTexture.position(top, left2);
    }
  },
  size(width = 1920, height = 1080) {
    videoEl.style.width = withPrecision(width);
    videoEl.style.height = withPrecision(height);
    videoEl.width = parseFloat(videoEl.style.width);
    videoEl.height = parseFloat(videoEl.style.height);
    if (textureMode === true) {
      videoTexture.size(width, height);
    }
  },
  area(top = 0, right2 = 1920, bottom = 1080, left2 = 0) {
    this.position(top, left2);
    this.size(right2 - left2, bottom - top);
  },
  open(url, config = {}) {
    if (!this.canInteract)
      return;
    metrics = Metrics$1.media(url);
    this.hide();
    deregisterEventListeners();
    if (this.src == url) {
      this.clear().then(this.open(url, config));
    } else {
      const adConfig = { enabled: state$1.adsEnabled, duration: 300 };
      if (config.videoId) {
        adConfig.caid = config.videoId;
      }
      Ads$1.get(adConfig, consumer$1).then((ads) => {
        state$1.playingAds = true;
        ads.prerolls().then(() => {
          state$1.playingAds = false;
          loader$1(url, videoEl, config).then(() => {
            registerEventListeners();
            this.show();
            this.play();
          }).catch((e) => {
            fireOnConsumer$1("error", { videoElement: videoEl, event: e });
          });
        });
      });
    }
  },
  reload() {
    if (!this.canInteract)
      return;
    const url = videoEl.getAttribute("src");
    this.close();
    this.open(url);
  },
  close() {
    Ads$1.cancel();
    if (state$1.playingAds) {
      state$1.playingAds = false;
      Ads$1.stop();
      setTimeout(() => {
        this.close();
      });
    }
    if (!this.canInteract)
      return;
    this.clear();
    this.hide();
    deregisterEventListeners();
  },
  clear() {
    if (!this.canInteract)
      return;
    this.pause();
    if (textureMode === true)
      videoTexture.stop();
    return unloader(videoEl).then(() => {
      fireOnConsumer$1("Clear", { videoElement: videoEl });
    });
  },
  play() {
    if (!this.canInteract)
      return;
    if (textureMode === true)
      videoTexture.start();
    executeAsPromise(videoEl.play, null, videoEl).catch((e) => {
      fireOnConsumer$1("error", { videoElement: videoEl, event: e });
    });
  },
  pause() {
    if (!this.canInteract)
      return;
    videoEl.pause();
  },
  playPause() {
    if (!this.canInteract)
      return;
    this.playing === true ? this.pause() : this.play();
  },
  mute(muted = true) {
    if (!this.canInteract)
      return;
    videoEl.muted = muted;
  },
  loop(looped = true) {
    videoEl.loop = looped;
  },
  seek(time) {
    if (!this.canInteract)
      return;
    if (!this.src)
      return;
    if (state$1.playAfterSeek === null) {
      state$1.playAfterSeek = !!state$1.playing;
    }
    this.pause();
    videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
  },
  skip(seconds) {
    if (!this.canInteract)
      return;
    if (!this.src)
      return;
    state$1.skipTime = (state$1.skipTime || videoEl.currentTime) + seconds;
    easeExecution(() => {
      this.seek(state$1.skipTime);
      state$1.skipTime = false;
    }, 300);
  },
  show() {
    if (!this.canInteract)
      return;
    if (textureMode === true) {
      videoTexture.show();
    } else {
      videoEl.style.display = "block";
      videoEl.style.visibility = "visible";
    }
  },
  hide() {
    if (!this.canInteract)
      return;
    if (textureMode === true) {
      videoTexture.hide();
    } else {
      videoEl.style.display = "none";
      videoEl.style.visibility = "hidden";
    }
  },
  enableAds(enabled = true) {
    state$1.adsEnabled = enabled;
  },
  /* Public getters */
  get duration() {
    return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
  },
  get currentTime() {
    return videoEl && videoEl.currentTime;
  },
  get muted() {
    return videoEl && videoEl.muted;
  },
  get looped() {
    return videoEl && videoEl.loop;
  },
  get src() {
    return videoEl && videoEl.getAttribute("src");
  },
  get playing() {
    return state$1.playing;
  },
  get playingAds() {
    return state$1.playingAds;
  },
  get canInteract() {
    return state$1.playingAds === false;
  },
  get top() {
    return videoEl && parseFloat(videoEl.style.top);
  },
  get left() {
    return videoEl && parseFloat(videoEl.style.left);
  },
  get bottom() {
    return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
  },
  get right() {
    return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
  },
  get width() {
    return videoEl && parseFloat(videoEl.style.width);
  },
  get height() {
    return videoEl && parseFloat(videoEl.style.height);
  },
  get visible() {
    if (textureMode === true) {
      return videoTexture.isVisible;
    } else {
      return videoEl && videoEl.style.display === "block";
    }
  },
  get adsEnabled() {
    return state$1.adsEnabled;
  },
  // prefixed with underscore to indicate 'semi-private'
  // because it's not recommended to interact directly with the video element
  get _videoEl() {
    return videoEl;
  },
  get _consumer() {
    return consumer$1;
  }
};
const VideoPlayer = autoSetupMixin(videoPlayerPlugin, () => {
  precision = ApplicationInstance$1 && ApplicationInstance$1.stage && ApplicationInstance$1.stage.getRenderPrecision() || precision;
  videoEl = setupVideoTag();
  textureMode = Settings.get("platform", "textureMode", false);
  if (textureMode === true) {
    videoEl.setAttribute("crossorigin", "anonymous");
    videoTexture = setUpVideoTexture();
  }
});
let consumer;
let getAds = () => {
  return Promise.resolve({
    prerolls: [],
    midrolls: [],
    postrolls: []
  });
};
const initAds = (config) => {
  if (config.getAds) {
    getAds = config.getAds;
  }
};
const state = {
  active: false
};
const playSlot = (slot = []) => {
  return slot.reduce((promise, ad) => {
    return promise.then(() => {
      return playAd(ad);
    });
  }, Promise.resolve(null));
};
const playAd = (ad) => {
  return new Promise((resolve) => {
    if (state.active === false) {
      Log$1.info("Ad", "Skipping add due to inactive state");
      return resolve();
    }
    const videoEl2 = document.getElementsByTagName("video")[0];
    videoEl2.style.display = "block";
    videoEl2.style.visibility = "visible";
    videoEl2.src = mediaUrl$1(ad.url);
    videoEl2.load();
    let timeEvents = null;
    let timeout2;
    const cleanup = () => {
      Object.keys(handlers).forEach(
        (handler) => videoEl2.removeEventListener(handler, handlers[handler])
      );
      resolve();
    };
    const handlers = {
      play() {
        Log$1.info("Ad", "Play ad", ad.url);
        fireOnConsumer("Play", ad);
        sendBeacon(ad.callbacks, "defaultImpression");
      },
      ended() {
        fireOnConsumer("Ended", ad);
        sendBeacon(ad.callbacks, "complete");
        cleanup();
      },
      timeupdate() {
        if (!timeEvents && videoEl2.duration) {
          timeEvents = {
            firstQuartile: videoEl2.duration / 4,
            midPoint: videoEl2.duration / 2,
            thirdQuartile: videoEl2.duration / 4 * 3
          };
          Log$1.info("Ad", "Calculated quartiles times", { timeEvents });
        }
        if (timeEvents && timeEvents.firstQuartile && videoEl2.currentTime >= timeEvents.firstQuartile) {
          fireOnConsumer("FirstQuartile", ad);
          delete timeEvents.firstQuartile;
          sendBeacon(ad.callbacks, "firstQuartile");
        }
        if (timeEvents && timeEvents.midPoint && videoEl2.currentTime >= timeEvents.midPoint) {
          fireOnConsumer("MidPoint", ad);
          delete timeEvents.midPoint;
          sendBeacon(ad.callbacks, "midPoint");
        }
        if (timeEvents && timeEvents.thirdQuartile && videoEl2.currentTime >= timeEvents.thirdQuartile) {
          fireOnConsumer("ThirdQuartile", ad);
          delete timeEvents.thirdQuartile;
          sendBeacon(ad.callbacks, "thirdQuartile");
        }
      },
      stalled() {
        fireOnConsumer("Stalled", ad);
        timeout2 = setTimeout(() => {
          cleanup();
        }, 5e3);
      },
      canplay() {
        timeout2 && clearTimeout(timeout2);
      },
      error() {
        fireOnConsumer("Error", ad);
        cleanup();
      },
      // this doesn't work reliably on sky box, moved logic to timeUpdate event
      // loadedmetadata() {
      //   // calculate when to fire the time based events (now that duration is known)
      //   timeEvents = {
      //     firstQuartile: videoEl.duration / 4,
      //     midPoint: videoEl.duration / 2,
      //     thirdQuartile: (videoEl.duration / 4) * 3,
      //   }
      // },
      abort() {
        cleanup();
      }
      // todo: pause, resume, mute, unmute beacons
    };
    Object.keys(handlers).forEach((handler) => videoEl2.addEventListener(handler, handlers[handler]));
    videoEl2.play();
  });
};
const sendBeacon = (callbacks2, event) => {
  if (callbacks2 && callbacks2[event]) {
    Log$1.info("Ad", "Sending beacon", event, callbacks2[event]);
    return callbacks2[event].reduce((promise, url) => {
      return promise.then(
        () => fetch(url).then((response) => {
          if (response.status === 200) {
            fireOnConsumer("Beacon" + event + "Sent");
          } else {
            fireOnConsumer("Beacon" + event + "Failed" + response.status);
          }
          Promise.resolve(null);
        }).catch(() => {
          Promise.resolve(null);
        })
      );
    }, Promise.resolve(null));
  } else {
    Log$1.info("Ad", "No callback found for " + event);
  }
};
const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire("$ad" + event, args);
    consumer.fire("$adEvent", event, args);
  }
};
const Ads = {
  get(config, videoPlayerConsumer) {
    if (config.enabled === false) {
      return Promise.resolve({
        prerolls() {
          return Promise.resolve();
        }
      });
    }
    consumer = videoPlayerConsumer;
    return new Promise((resolve) => {
      Log$1.info("Ad", "Starting session");
      getAds(config).then((ads) => {
        Log$1.info("Ad", "API result", ads);
        resolve({
          prerolls() {
            if (ads.preroll) {
              state.active = true;
              fireOnConsumer("PrerollSlotImpression", ads);
              sendBeacon(ads.preroll.callbacks, "slotImpression");
              return playSlot(ads.preroll.ads).then(() => {
                fireOnConsumer("PrerollSlotEnd", ads);
                sendBeacon(ads.preroll.callbacks, "slotEnd");
                state.active = false;
              });
            }
            return Promise.resolve();
          },
          midrolls() {
            return Promise.resolve();
          },
          postrolls() {
            return Promise.resolve();
          }
        });
      });
    });
  },
  cancel() {
    Log$1.info("Ad", "Cancel Ad");
    state.active = false;
  },
  stop() {
    Log$1.info("Ad", "Stop Ad");
    state.active = false;
    const videoEl2 = document.getElementsByTagName("video")[0];
    videoEl2.pause();
    videoEl2.removeAttribute("src");
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target, symbol);
  }) : [];
}
function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;
const Deepmerge = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
let warned = false;
const deprecated = (force = false) => {
  if (force === true || warned === false) {
    console.warn(
      [
        "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'Language'-plugin instead.",
        "https://rdkcentral.github.io/Lightning-SDK/#/plugins/language"
      ].join("\n\n")
    );
  }
  warned = true;
};
class Locale {
  constructor() {
    this.__enabled = false;
  }
  /**
   * Loads translation object from external json file.
   *
   * @param {String} path Path to resource.
   * @return {Promise}
   */
  async load(path) {
    if (!this.__enabled) {
      return;
    }
    await fetch(path).then((resp) => resp.json()).then((resp) => {
      this.loadFromObject(resp);
    });
  }
  /**
   * Sets language used by module.
   *
   * @param {String} lang
   */
  setLanguage(lang) {
    deprecated();
    this.__enabled = true;
    this.language = lang;
  }
  /**
   * Returns reference to translation object for current language.
   *
   * @return {Object}
   */
  get tr() {
    deprecated(true);
    return this.__trObj[this.language];
  }
  /**
   * Loads translation object from existing object (binds existing object).
   *
   * @param {Object} trObj
   */
  loadFromObject(trObj) {
    deprecated();
    const fallbackLanguage = "en";
    if (Object.keys(trObj).indexOf(this.language) === -1) {
      Log$1.warn("No translations found for: " + this.language);
      if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
        Log$1.warn("Using fallback language: " + fallbackLanguage);
        this.language = fallbackLanguage;
      } else {
        const error = "No translations found for fallback language: " + fallbackLanguage;
        Log$1.error(error);
        throw Error(error);
      }
    }
    this.__trObj = trObj;
    for (const lang of Object.values(this.__trObj)) {
      for (const str of Object.keys(lang)) {
        lang[str] = new LocalizedString(lang[str]);
      }
    }
  }
}
class LocalizedString extends String {
  /**
   * Returns formatted LocalizedString.
   * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
   *
   * E.g.:
   * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
   * A and B and A
   *
   * @param  {...any} args List of arguments for placeholders.
   */
  format(...args) {
    const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this);
    return new LocalizedString(sub);
  }
}
const Locale$1 = new Locale();
class VersionLabel extends lightning.Component {
  static _template() {
    return {
      rect: true,
      color: 3137370284,
      h: 40,
      w: 100,
      x: (w) => w - 50,
      y: (h) => h - 50,
      mount: 1,
      Text: {
        w: (w) => w,
        h: (h) => h,
        y: 5,
        x: 20,
        text: {
          fontSize: 22,
          lineHeight: 26
        }
      }
    };
  }
  _firstActive() {
    this.tag("Text").text = `APP - v${this.version}
SDK - v${this.sdkVersion}`;
    this.tag("Text").loadTexture();
    this.w = this.tag("Text").renderWidth + 40;
    this.h = this.tag("Text").renderHeight + 5;
  }
}
class FpsIndicator extends lightning.Component {
  static _template() {
    return {
      rect: true,
      color: 4294967295,
      texture: lightning.Tools.getRoundRect(80, 80, 40),
      h: 80,
      w: 80,
      x: 100,
      y: 100,
      mount: 1,
      Background: {
        x: 3,
        y: 3,
        texture: lightning.Tools.getRoundRect(72, 72, 36),
        color: 4278222848
      },
      Counter: {
        w: (w) => w,
        h: (h) => h,
        y: 10,
        text: {
          fontSize: 32,
          textAlign: "center"
        }
      },
      Text: {
        w: (w) => w,
        h: (h) => h,
        y: 48,
        text: {
          fontSize: 15,
          textAlign: "center",
          text: "FPS"
        }
      }
    };
  }
  _setup() {
    this.config = {
      ...{
        log: false,
        interval: 500,
        threshold: 1
      },
      ...Settings$1.get("platform", "showFps")
    };
    this.fps = 0;
    this.lastFps = this.fps - this.config.threshold;
    const fpsCalculator = () => {
      this.fps = ~~(1 / this.stage.dt);
    };
    this.stage.on("frameStart", fpsCalculator);
    this.stage.off("framestart", fpsCalculator);
    this.interval = setInterval(this.showFps.bind(this), this.config.interval);
  }
  _firstActive() {
    this.showFps();
  }
  _detach() {
    clearInterval(this.interval);
  }
  showFps() {
    if (Math.abs(this.lastFps - this.fps) <= this.config.threshold)
      return;
    this.lastFps = this.fps;
    let bgColor = 4278222848;
    if (this.fps <= 40 && this.fps > 20)
      bgColor = 4294944e3;
    else if (this.fps <= 20)
      bgColor = 4294901760;
    this.tag("Background").setSmooth("color", bgColor);
    this.tag("Counter").text = `${this.fps}`;
    this.config.log && Log$1.info("FPS", this.fps);
  }
}
const fetchJson = (file) => {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState == XMLHttpRequest.DONE) {
        if (xhr.status === 0 || xhr.status === 200)
          resolve(JSON.parse(xhr.responseText));
        else
          reject(xhr.statusText);
      }
    };
    xhr.open("GET", file);
    xhr.send(null);
  });
};
let basePath;
let proxyUrl;
const initUtils = (config) => {
  basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || "/"));
  if (config.proxyUrl) {
    proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
  }
};
const Utils3 = {
  asset(relPath) {
    return basePath + relPath;
  },
  proxyUrl(url, options = {}) {
    return proxyUrl ? proxyUrl + "?" + makeQueryString(url, options) : url;
  },
  makeQueryString() {
    return makeQueryString(...arguments);
  },
  // since imageworkers don't work without protocol
  ensureUrlWithProtocol() {
    return ensureUrlWithProtocol(...arguments);
  }
};
const ensureUrlWithProtocol = (url) => {
  if (/^\/[^/]/i.test(url) && /^(?:file:)/i.test(window.location.protocol)) {
    return window.location.protocol + "//" + url;
  }
  if (/^\/\//.test(url)) {
    return window.location.protocol + url;
  }
  if (!/^(?:https?:)/i.test(url)) {
    return window.location.origin + url;
  }
  return url;
};
const makeFullStaticPath = (pathname = "/", path) => {
  path = path.charAt(path.length - 1) !== "/" ? path + "/" : path;
  if (/^(?:https?:)?(?:\/\/)/.test(path)) {
    return path;
  }
  if (path.charAt(0) === "/") {
    return path;
  } else {
    pathname = cleanUpPathName(pathname);
    path = path.charAt(0) === "." ? path.substr(1) : path;
    path = path.charAt(0) !== "/" ? "/" + path : path;
    return pathname + path;
  }
};
const cleanUpPathName = (pathname) => {
  if (pathname.slice(-1) === "/")
    return pathname.slice(0, -1);
  const parts = pathname.split("/");
  if (parts[parts.length - 1].indexOf(".") > -1)
    parts.pop();
  return parts.join("/");
};
const makeQueryString = (url, options = {}, type = "url") => {
  options.operator = "metrological";
  options[type] = url;
  return Object.keys(options).map((key) => {
    return encodeURIComponent(key) + "=" + encodeURIComponent("" + options[key]);
  }).join("&");
};
let meta = {};
let translations = {};
let language = null;
const initLanguage = (file, language2 = null) => {
  return new Promise((resolve, reject) => {
    fetchJson(file).then((json) => {
      setTranslations(json);
      typeof language2 === "object" && "then" in language2 && typeof language2.then === "function" ? language2.then(
        (lang) => setLanguage(lang).then(resolve).catch(reject)
      ).catch((e) => {
        Log$1.error(e);
        reject(e);
      }) : setLanguage(language2).then(resolve).catch(reject);
    }).catch(() => {
      const error = "Language file " + file + " not found";
      Log$1.error(error);
      reject(error);
    });
  });
};
const setTranslations = (obj) => {
  if ("meta" in obj) {
    meta = { ...obj.meta };
    delete obj.meta;
  }
  translations = obj;
};
const setLanguage = (lng) => {
  language = null;
  return new Promise((resolve, reject) => {
    if (lng in translations) {
      language = lng;
    } else {
      if ("map" in meta && lng in meta.map && meta.map[lng] in translations) {
        language = meta.map[lng];
      } else if ("default" in meta && meta.default in translations) {
        const error = "Translations for Language " + language + " not found. Using default language " + meta.default;
        Log$1.warn(error);
        language = meta.default;
      } else {
        const error = "Translations for Language " + language + " not found.";
        Log$1.error(error);
        reject(error);
      }
    }
    if (language) {
      Log$1.info("Setting language to", language);
      const translationsObj = translations[language];
      if (typeof translationsObj === "object") {
        resolve();
      } else if (typeof translationsObj === "string") {
        const url = Utils3.asset(translationsObj);
        fetchJson(url).then((json) => {
          translations[language] = json;
          resolve();
        }).catch((e) => {
          const error = "Error while fetching " + url;
          Log$1.error(error, e);
          reject(error);
        });
      }
    }
  });
};
const registry = {
  eventListeners: [],
  timeouts: [],
  intervals: [],
  targets: []
};
const Registry = {
  // Timeouts
  setTimeout(cb, timeout2, ...params) {
    const timeoutId = setTimeout(
      () => {
        registry.timeouts = registry.timeouts.filter((id) => id !== timeoutId);
        cb.apply(null, params);
      },
      timeout2,
      params
    );
    Log$1.info("Set Timeout", "ID: " + timeoutId);
    registry.timeouts.push(timeoutId);
    return timeoutId;
  },
  clearTimeout(timeoutId) {
    if (registry.timeouts.indexOf(timeoutId) > -1) {
      registry.timeouts = registry.timeouts.filter((id) => id !== timeoutId);
      Log$1.info("Clear Timeout", "ID: " + timeoutId);
      clearTimeout(timeoutId);
    } else {
      Log$1.error("Clear Timeout", "ID " + timeoutId + " not found");
    }
  },
  clearTimeouts() {
    registry.timeouts.forEach((timeoutId) => {
      this.clearTimeout(timeoutId);
    });
  },
  // Intervals
  setInterval(cb, interval, ...params) {
    const intervalId = setInterval(
      () => {
        registry.intervals.filter((id) => id !== intervalId);
        cb.apply(null, params);
      },
      interval,
      params
    );
    Log$1.info("Set Interval", "ID: " + intervalId);
    registry.intervals.push(intervalId);
    return intervalId;
  },
  clearInterval(intervalId) {
    if (registry.intervals.indexOf(intervalId) > -1) {
      registry.intervals = registry.intervals.filter((id) => id !== intervalId);
      Log$1.info("Clear Interval", "ID: " + intervalId);
      clearInterval(intervalId);
    } else {
      Log$1.error("Clear Interval", "ID " + intervalId + " not found");
    }
  },
  clearIntervals() {
    registry.intervals.forEach((intervalId) => {
      this.clearInterval(intervalId);
    });
  },
  // Event listeners
  addEventListener(target, event, handler) {
    target.addEventListener(event, handler);
    const targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
    registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
    registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
    registry.eventListeners[targetIndex][event].push(handler);
    Log$1.info(
      "Add eventListener",
      "Target:",
      target,
      "Event: " + event,
      "Handler:",
      handler.toString()
    );
  },
  removeEventListener(target, event, handler) {
    const targetIndex = registry.targets.indexOf(target);
    if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter((fn) => fn !== handler);
      Log$1.info(
        "Remove eventListener",
        "Target:",
        target,
        "Event: " + event,
        "Handler:",
        handler.toString()
      );
      target.removeEventListener(event, handler);
    } else {
      Log$1.error(
        "Remove eventListener",
        "Not found",
        "Target",
        target,
        "Event: " + event,
        "Handler",
        handler.toString()
      );
    }
  },
  // if `event` is omitted, removes all registered event listeners for target
  // if `target` is also omitted, removes all registered event listeners
  removeEventListeners(target, event) {
    if (target && event) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1) {
        registry.eventListeners[targetIndex][event].forEach((handler) => {
          this.removeEventListener(target, event, handler);
        });
      }
    } else if (target) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1) {
        Object.keys(registry.eventListeners[targetIndex]).forEach((_event) => {
          this.removeEventListeners(target, _event);
        });
      }
    } else {
      Object.keys(registry.eventListeners).forEach((targetIndex) => {
        this.removeEventListeners(registry.targets[targetIndex]);
      });
    }
  },
  // Clear everything (to be called upon app close for proper cleanup)
  clear() {
    this.clearTimeouts();
    this.clearIntervals();
    this.removeEventListeners();
    registry.eventListeners = [];
    registry.timeouts = [];
    registry.intervals = [];
    registry.targets = [];
  }
};
const isObject$2 = (v) => {
  return typeof v === "object" && v !== null;
};
const isString$2 = (v) => {
  return typeof v === "string";
};
const getRgbaComponents = (argb) => {
  return {
    r: (argb / 65536 | 0) % 256,
    g: (argb / 256 | 0) % 256,
    b: argb * 1 % 256,
    a: argb / 16777216 | 0
  };
};
const mergeColors = (c1, c2, p) => {
  let r1 = (c1 / 65536 | 0) % 256;
  let g1 = (c1 / 256 | 0) % 256;
  let b1 = c1 % 256;
  let a1 = c1 / 16777216 | 0;
  let r2 = (c2 / 65536 | 0) % 256;
  let g2 = (c2 / 256 | 0) % 256;
  let b2 = c2 % 256;
  let a2 = c2 / 16777216 | 0;
  let r = r1 * p + r2 * (1 - p);
  let g = g1 * p + g2 * (1 - p);
  let b = b1 * p + b2 * (1 - p);
  let a = a1 * p + a2 * (1 - p);
  return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
};
const calculateAlpha = (argb, p) => {
  if (p > 1) {
    p /= 100;
  } else if (p < 0) {
    p = 0;
  }
  let r = (argb / 65536 | 0) % 256;
  let g = (argb / 256 | 0) % 256;
  let b = argb % 256;
  return (r << 16) + (g << 8) + b + (Math.round(p * 255) | 0) * 16777216;
};
const getArgbNumber = (rgba) => {
  rgba[0] = Math.max(0, Math.min(255, rgba[0]));
  rgba[1] = Math.max(0, Math.min(255, rgba[1]));
  rgba[2] = Math.max(0, Math.min(255, rgba[2]));
  rgba[3] = Math.max(0, Math.min(255, rgba[3]));
  let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
  if (v < 0) {
    v = 4294967295 + v + 1;
  }
  return v;
};
const argbToHSLA = (argb) => {
  const col = getRgbaComponents(argb);
  const r = col.r / 255;
  const g = col.g / 255;
  const b = col.b / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (min + max) * 0.5;
  if (l > 0) {
    const maxMin = max - min;
    if (maxMin > 0) {
      const r2 = (max - r) / maxMin;
      const g2 = (max - g) / maxMin;
      const b2 = (max - b) / maxMin;
      if (l < 0.5) {
        s = max + min;
      } else {
        s = 2 - max - min;
      }
      if (r === max && g === min) {
        h = 5 + b2;
      } else if (r === max) {
        h = 1 - g2;
      } else if (g === max && b === min) {
        h = 1 + r2;
      } else if (g === max) {
        h = 3 - b2;
      } else if (b === max) {
        h = 3 + g2;
      } else {
        h = 5 - r2;
      }
      h = h / 6;
    }
  }
  return { h: h % 1, s, l, a: col.a };
};
const hslaToARGB = (hsla) => {
  let r = 1;
  let g = 1;
  let b = 1;
  let h = hsla.h;
  let s = hsla.s;
  let l = hsla.l;
  if (h < 0) {
    h += 1;
  }
  let max = 0;
  if (l <= 0.5) {
    max = l * (1 + s);
  } else {
    max = l + s - l * s;
  }
  if (max > 0) {
    h *= 6;
    const min = l + l - max;
    const minMax = (max - min) / max;
    const sextant = Math.floor(h);
    const fract = h - sextant;
    const minMaxFract = max * minMax * fract;
    const mid1 = min + minMaxFract;
    const mid2 = max - minMaxFract;
    if (sextant === 0) {
      r = max;
      g = mid1;
      b = min;
    }
    if (sextant === 1) {
      r = mid2;
      g = max;
      b = min;
    }
    if (sextant === 2) {
      r = min;
      g = max;
      b = mid1;
    }
    if (sextant === 3) {
      r = min;
      g = mid2;
      b = max;
    }
    if (sextant === 4) {
      r = mid1;
      g = min;
      b = max;
    }
    if (sextant === 5) {
      r = max;
      g = min;
      b = mid2;
    }
  }
  return getArgbNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), hsla.a]);
};
let colors = {
  white: "#ffffff",
  black: "#000000",
  red: "#ff0000",
  green: "#00ff00",
  blue: "#0000ff",
  yellow: "#feff00",
  cyan: "#00feff",
  magenta: "#ff00ff"
};
const normalizedColors = {
  //store for normalized colors
};
const addColors = (colorsToAdd, value) => {
  if (isObject$2(colorsToAdd)) {
    Object.keys(colorsToAdd).forEach((color) => cleanUpNormalizedColors(color));
    colors = Object.assign({}, colors, colorsToAdd);
  } else if (isString$2(colorsToAdd) && value) {
    cleanUpNormalizedColors(colorsToAdd);
    colors[colorsToAdd] = value;
  }
};
const cleanUpNormalizedColors = (color) => {
  for (let c in normalizedColors) {
    if (c.indexOf(color) > -1) {
      delete normalizedColors[c];
    }
  }
};
const initColors = (file) => {
  return new Promise((resolve, reject) => {
    if (typeof file === "object") {
      addColors(file);
      return resolve();
    }
    fetchJson(file).then((json) => {
      addColors(json);
      return resolve();
    }).catch(() => {
      const error = "Colors file " + file + " not found";
      Log$1.error(error);
      return reject(error);
    });
  });
};
const normalizeColorToARGB = (color) => {
  let targetColor = normalizedColors[color] || colors[color] || color;
  if (!targetColor) {
    targetColor = color;
  }
  const check = /^#([0-9A-F]{3}|[0-9A-F]{6})$/i;
  if (isString$2(targetColor) && check.test(targetColor)) {
    let hex = check.exec(targetColor)[1];
    if (hex.length === 3) {
      hex = hex.split("").map((value) => {
        return value + value;
      }).join("");
    }
    targetColor = `0xff${hex}` * 1;
  }
  if (!normalizedColors[color]) {
    normalizedColors[color] = targetColor;
  }
  return targetColor || 4294967295;
};
const Colors = (color) => {
  return Color.generate(color);
};
const Color = {
  color: null,
  generate: function(value = this.color) {
    if (normalizedColors[value]) {
      this.color = normalizedColors[value];
    } else {
      this.color = normalizeColorToARGB(value);
    }
    return this;
  },
  get() {
    return this.color;
  },
  alpha: function(percentage) {
    this.color = calculateAlpha(this.color, Math.abs(percentage));
    return this;
  },
  darker(percentage) {
    const hsl = argbToHSLA(this.color);
    hsl.l = hsl.l * (1 - percentage);
    this.color = hslaToARGB(hsl);
    return this;
  },
  lighter(percentage) {
    const hsl = argbToHSLA(this.color);
    hsl.l = hsl.l + (1 - hsl.l) * percentage;
    this.color = hslaToARGB(hsl);
    return this;
  },
  saturation(percentage) {
    const hsl = argbToHSLA(this.color);
    hsl.s = percentage;
    this.color = hslaToARGB(hsl);
    return this;
  },
  lightness(percentage) {
    const hsl = argbToHSLA(this.color);
    hsl.l = percentage;
    this.color = hslaToARGB(hsl);
    return this;
  },
  hue(degrees) {
    const hsl = argbToHSLA(this.color);
    hsl.h = degrees;
    this.color = hslaToARGB(hsl);
    return this;
  },
  mix(argb, p) {
    this.color = mergeColors(this.color, argb, p);
    return this;
  }
};
const name = "@lightningjs/sdk";
const version = "5.3.1";
const license = "Apache-2.0";
const types = "index.d.ts";
const scripts = {
  postinstall: "node ./scripts/postinstall.js",
  lint: "eslint '**/*.js'",
  release: "npm publish --access public",
  typedoc: "typedoc --tsconfig tsconfig.typedoc.json",
  tsd: "tsd"
};
const husky = {
  hooks: {
    "pre-commit": "lint-staged"
  }
};
const dependencies = {
  "@babel/polyfill": "^7.11.5",
  "@lightningjs/core": "^2.7.0",
  "@metrological/sdk": "^1.0.0",
  "@michieljs/execute-as-promise": "^1.0.0",
  deepmerge: "^4.2.2",
  localcookies: "^2.0.0",
  shelljs: "^0.8.5",
  "url-polyfill": "^1.1.10",
  "whatwg-fetch": "^3.0.0"
};
const devDependencies = {
  "@babel/core": "^7.11.6",
  "@babel/plugin-transform-parameters": "^7.10.5 ",
  "@babel/plugin-transform-spread": "^7.11.0",
  "@babel/preset-env": "^7.11.5",
  "babel-eslint": "^10.1.0",
  eslint: "^7.10.0",
  "eslint-config-prettier": "^6.12.0",
  "eslint-plugin-prettier": "^3.1.4",
  husky: "^4.3.0",
  "lint-staged": "^10.4.0",
  prettier: "^1.19.1",
  rollup: "^1.32.1",
  "rollup-plugin-babel": "^4.4.0",
  tsd: "^0.22.0",
  typedoc: "^0.23.9"
};
const repository = {
  type: "git",
  url: "git@github.com:rdkcentral/Lightning-SDK.git"
};
const bugs = {
  url: "https://github.com/rdkcentral/Lightning-SDK/issues"
};
const packageInfo = {
  name,
  version,
  license,
  types,
  scripts,
  "lint-staged": {
    "*.js": [
      "eslint --fix"
    ],
    "src/startApp.js": [
      "rollup -c ./rollup.config.js"
    ]
  },
  husky,
  dependencies,
  devDependencies,
  repository,
  bugs
};
let AppInstance;
const defaultOptions = {
  stage: { w: 1920, h: 1080, precision: 1, clearColor: 0, canvas2d: false },
  debug: false,
  defaultFontFace: "RobotoRegular",
  keys: {
    8: "Back",
    13: "Enter",
    27: "Menu",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    174: "ChannelDown",
    175: "ChannelUp",
    178: "Stop",
    250: "PlayPause",
    191: "Search",
    // Use "/" for keyboard
    409: "Search"
  }
};
const customFontFaces = [];
const fontLoader = (fonts, store) => new Promise((resolve, reject) => {
  fonts.map(({ family, url, urls, descriptors: descriptors2 }) => () => {
    const src = urls ? urls.map((url2) => {
      return "url(" + url2 + ")";
    }) : "url(" + url + ")";
    const fontFace = new FontFace(family, src, descriptors2 || {});
    store.push(fontFace);
    Log$1.info("Loading font", family);
    document.fonts.add(fontFace);
    return fontFace.load();
  }).reduce((promise, method) => {
    return promise.then(() => method());
  }, Promise.resolve(null)).then(resolve).catch(reject);
});
function Application2(App2, appData, platformSettings) {
  const { width, height } = platformSettings;
  if (width && height) {
    defaultOptions.stage["w"] = width;
    defaultOptions.stage["h"] = height;
    defaultOptions.stage["precision"] = width / 1920;
  }
  if (!width && !height && window.innerHeight === 720) {
    defaultOptions.stage["w"] = 1280;
    defaultOptions.stage["h"] = 720;
    defaultOptions.stage["precision"] = 1280 / 1920;
  }
  return class Application extends lightning.Application {
    constructor(options) {
      const config = Deepmerge(defaultOptions, options);
      if (options.stage.canvas) {
        config.stage.canvas = options.stage.canvas;
      }
      super(config);
      this.config = config;
    }
    static _template() {
      return {
        w: 1920,
        h: 1080
      };
    }
    colorshift(type = false, config = {}) {
      Accessibility.colorshift(this, type, config);
    }
    get keymapping() {
      return this.stage.application.config.keys;
    }
    /**
     * This function overrides the default keymap with the latest keymap.
     * @param customKeyMap
     * @param keepDuplicates
     */
    overrideKeyMap(customKeyMap, keepDuplicates = false) {
      const baseKeyMap = this.stage.application.config.keys;
      Object.keys(customKeyMap).reduce((keymapping, key) => {
        if (!keepDuplicates) {
          Object.keys(baseKeyMap).forEach((baseKey) => {
            if (baseKey != key && baseKeyMap[baseKey] == customKeyMap[key]) {
              delete keymapping[baseKey];
            }
          });
        }
        keymapping[key] = customKeyMap[key];
        return keymapping;
      }, baseKeyMap);
      return baseKeyMap;
    }
    _setup() {
      Promise.all([
        this.loadFonts(App2.config && App2.config.fonts || App2.getFonts && App2.getFonts() || []),
        // to be deprecated
        Locale$1.load(App2.config && App2.config.locale || App2.getLocale && App2.getLocale()),
        App2.language && this.loadLanguage(App2.language()),
        App2.colors && this.loadColors(App2.colors())
      ]).then(() => {
        Metrics$1.app.loaded();
        this.w = this.config.stage.w / this.config.stage.precision;
        this.h = this.config.stage.h / this.config.stage.precision;
        AppInstance = this.stage.c({
          ref: "App",
          type: App2,
          zIndex: 1,
          forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
        });
        this.childList.a(AppInstance);
        this._refocus();
        Log$1.info("App version", this.config.version);
        Log$1.info("SDK version", packageInfo.version);
        if (platformSettings.showVersion) {
          this.childList.a({
            ref: "VersionLabel",
            type: VersionLabel,
            version: this.config.version,
            sdkVersion: packageInfo.version,
            zIndex: 1
          });
        }
        if (platformSettings.showFps) {
          this.childList.a({
            ref: "FpsCounter",
            type: FpsIndicator,
            zIndex: 1
          });
        }
        super._setup();
      }).catch(console.error);
    }
    _handleBack() {
      this.closeApp();
    }
    _handleExit() {
      this.closeApp();
    }
    closeApp() {
      Log$1.info("Signaling App Close");
      if (platformSettings.onClose && typeof platformSettings.onClose === "function") {
        platformSettings.onClose(...arguments);
      } else {
        this.close();
      }
    }
    close() {
      Log$1.info("Closing App");
      Settings$1.clearSubscribers();
      Registry.clear();
      this.childList.remove(this.tag("App"));
      this.cleanupFonts();
      this.stage.gc();
      this.destroy();
    }
    loadFonts(fonts) {
      return platformSettings.fontLoader && typeof platformSettings.fontLoader === "function" ? platformSettings.fontLoader(fonts, customFontFaces) : fontLoader(fonts, customFontFaces);
    }
    cleanupFonts() {
      if ("delete" in document.fonts) {
        customFontFaces.forEach((fontFace) => {
          Log$1.info("Removing font", fontFace.family);
          document.fonts.delete(fontFace);
        });
      } else {
        Log$1.info("No support for removing manually-added fonts");
      }
    }
    loadLanguage(config) {
      let file = Utils3.asset("translations.json");
      let language2 = config;
      if (typeof language2 === "object") {
        language2 = config.language || null;
        file = config.file || file;
      }
      return initLanguage(file, language2);
    }
    loadColors(config) {
      let file = Utils3.asset("colors.json");
      if (config && (typeof config === "string" || typeof config === "object")) {
        file = config;
      }
      return initColors(file);
    }
    set focus(v) {
      this._focussed = v;
      this._refocus();
    }
    _getFocused() {
      return this._focussed || this.tag("App");
    }
  };
}
class ScaledImageTexture extends lightning.textures.ImageTexture {
  constructor(stage2) {
    super(stage2);
    this._scalingOptions = void 0;
  }
  set options(options) {
    this.resizeMode = this._scalingOptions = options;
  }
  _getLookupId() {
    return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`;
  }
  getNonDefaults() {
    const obj = super.getNonDefaults();
    if (this._src) {
      obj.src = this._src;
    }
    return obj;
  }
}
const events = [
  "timeupdate",
  "error",
  "ended",
  "loadeddata",
  "canplay",
  "play",
  "playing",
  "pause",
  "loadstart",
  "seeking",
  "seeked",
  "encrypted"
];
let mediaUrl = (url) => url;
const initMediaPlayer = (config) => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl;
  }
};
class Mediaplayer extends lightning.Component {
  _construct() {
    this._skipRenderToTexture = false;
    this._metrics = null;
    this._textureMode = Settings$1.get("platform", "textureMode") || false;
    Log$1.info("Texture mode: " + this._textureMode);
    console.warn(
      [
        "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'VideoPlayer'-plugin instead.",
        "https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer"
      ].join("\n\n")
    );
  }
  static _template() {
    return {
      Video: {
        VideoWrap: {
          VideoTexture: {
            visible: false,
            pivot: 0.5,
            texture: { type: lightning.textures.StaticTexture, options: {} }
          }
        }
      }
    };
  }
  set skipRenderToTexture(v) {
    this._skipRenderToTexture = v;
  }
  get textureMode() {
    return this._textureMode;
  }
  get videoView() {
    return this.tag("Video");
  }
  _init() {
    const videoEls = document.getElementsByTagName("video");
    if (videoEls && videoEls.length > 0)
      this.videoEl = videoEls[0];
    else {
      this.videoEl = document.createElement("video");
      this.videoEl.setAttribute("id", "video-player");
      this.videoEl.style.position = "absolute";
      this.videoEl.style.zIndex = "1";
      this.videoEl.style.display = "none";
      this.videoEl.setAttribute("width", "100%");
      this.videoEl.setAttribute("height", "100%");
      this.videoEl.style.visibility = this.textureMode ? "hidden" : "visible";
      document.body.appendChild(this.videoEl);
    }
    if (this.textureMode && !this._skipRenderToTexture) {
      this._createVideoTexture();
    }
    this.eventHandlers = [];
  }
  _registerListeners() {
    events.forEach((event) => {
      const handler = (e) => {
        if (this._metrics && this._metrics[event] && typeof this._metrics[event] === "function") {
          this._metrics[event]({ currentTime: this.videoEl.currentTime });
        }
        this.fire(event, { videoElement: this.videoEl, event: e });
      };
      this.eventHandlers.push(handler);
      this.videoEl.addEventListener(event, handler);
    });
  }
  _deregisterListeners() {
    Log$1.info("Deregistering event listeners MediaPlayer");
    events.forEach((event, index) => {
      this.videoEl.removeEventListener(event, this.eventHandlers[index]);
    });
    this.eventHandlers = [];
  }
  _attach() {
    this._registerListeners();
  }
  _detach() {
    this._deregisterListeners();
    this.close();
  }
  _createVideoTexture() {
    const stage2 = this.stage;
    const gl = stage2.gl;
    const glTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height };
  }
  _startUpdatingVideoTexture() {
    if (this.textureMode && !this._skipRenderToTexture) {
      const stage2 = this.stage;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage2.gl;
            const currentTime = (/* @__PURE__ */ new Date()).getTime();
            const frameCount = this.videoEl.webkitDecodedFrameCount;
            const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoTextureView.visible = true;
                this.videoTexture.options.w = this.videoEl.videoWidth;
                this.videoTexture.options.h = this.videoEl.videoHeight;
                const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoTextureView.scaleY = 1;
                } else {
                  this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoTextureView.scaleX = 1;
                }
              } catch (e) {
                Log$1.error("texImage2d video", e);
                this._stopUpdatingVideoTexture();
                this.videoTextureView.visible = false;
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage2.on("frameStart", this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }
  }
  _stopUpdatingVideoTexture() {
    if (this.textureMode) {
      const stage2 = this.stage;
      stage2.removeListener("frameStart", this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoTextureView.visible = false;
      if (this.videoTexture.options.source) {
        const gl = stage2.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
  }
  updateSettings(settings2 = {}) {
    this._consumer = settings2.consumer;
    if (this._consumer && this._consumer.getMediaplayerSettings) {
      settings2 = Object.assign(settings2, this._consumer.getMediaplayerSettings());
    }
    if (!lightning.Utils.equalValues(this._stream, settings2.stream)) {
      if (settings2.stream && settings2.stream.keySystem) {
        navigator.requestMediaKeySystemAccess(
          settings2.stream.keySystem.id,
          settings2.stream.keySystem.config
        ).then((keySystemAccess) => {
          return keySystemAccess.createMediaKeys();
        }).then((createdMediaKeys) => {
          return this.videoEl.setMediaKeys(createdMediaKeys);
        }).then(() => {
          if (settings2.stream && settings2.stream.src)
            this.open(settings2.stream.src);
        }).catch(() => {
          console.error("Failed to set up MediaKeys");
        });
      } else if (settings2.stream && settings2.stream.src) {
        if (Settings$1.get("app", "hls")) {
          if (!window.Hls) {
            window.Hls = class Hls {
              static isSupported() {
                console.warn("hls-light not included");
                return false;
              }
            };
          }
          if (window.Hls.isSupported()) {
            if (!this._hls)
              this._hls = new window.Hls({ liveDurationInfinity: true });
            this._hls.loadSource(settings2.stream.src);
            this._hls.attachMedia(this.videoEl);
            this.videoEl.style.display = "block";
          }
        } else {
          this.open(settings2.stream.src);
        }
      } else {
        this.close();
      }
      this._stream = settings2.stream;
    }
    this._setHide(settings2.hide);
    this._setVideoArea(settings2.videoPos);
  }
  _setHide(hide) {
    if (this.textureMode) {
      this.tag("Video").setSmooth("alpha", hide ? 0 : 1);
    } else {
      this.videoEl.style.visibility = hide ? "hidden" : "visible";
    }
  }
  open(url, settings2 = { hide: false, videoPosition: null }) {
    url = mediaUrl(url);
    this._metrics = Metrics$1.media(url);
    Log$1.info("Playing stream", url);
    if (this.application.noVideo) {
      Log$1.info("noVideo option set, so ignoring: " + url);
      return;
    }
    if (this.videoEl.getAttribute("src") === url) {
      this.close();
    }
    this.videoEl.setAttribute("src", url);
    this.videoEl.style.visibility = "hidden";
    this.videoEl.style.display = "none";
    setTimeout(() => {
      this.videoEl.style.display = "block";
      this.videoEl.style.visibility = "visible";
    });
    this._setHide(settings2.hide);
    this._setVideoArea(settings2.videoPosition || [0, 0, 1920, 1080]);
  }
  close() {
    this.videoEl.pause();
    this.videoEl.removeAttribute("src");
    this.videoEl.load();
    this._clearSrc();
    this.videoEl.style.display = "none";
  }
  playPause() {
    if (this.isPlaying()) {
      this.doPause();
    } else {
      this.doPlay();
    }
  }
  get muted() {
    return this.videoEl.muted;
  }
  set muted(v) {
    this.videoEl.muted = v;
  }
  get loop() {
    return this.videoEl.loop;
  }
  set loop(v) {
    this.videoEl.loop = v;
  }
  isPlaying() {
    return this._getState() === "Playing";
  }
  doPlay() {
    this.videoEl.play();
  }
  doPause() {
    this.videoEl.pause();
  }
  reload() {
    var url = this.videoEl.getAttribute("src");
    this.close();
    this.videoEl.src = url;
  }
  getPosition() {
    return Promise.resolve(this.videoEl.currentTime);
  }
  setPosition(pos) {
    this.videoEl.currentTime = pos;
  }
  getDuration() {
    return Promise.resolve(this.videoEl.duration);
  }
  seek(time, absolute = false) {
    if (absolute) {
      this.videoEl.currentTime = time;
    } else {
      this.videoEl.currentTime += time;
    }
  }
  get videoTextureView() {
    return this.tag("Video").tag("VideoTexture");
  }
  get videoTexture() {
    return this.videoTextureView.texture;
  }
  _setVideoArea(videoPos) {
    if (lightning.Utils.equalValues(this._videoPos, videoPos)) {
      return;
    }
    this._videoPos = videoPos;
    if (this.textureMode) {
      this.videoTextureView.patch({
        smooth: {
          x: videoPos[0],
          y: videoPos[1],
          w: videoPos[2] - videoPos[0],
          h: videoPos[3] - videoPos[1]
        }
      });
    } else {
      const precision2 = this.stage.getRenderPrecision();
      this.videoEl.style.left = Math.round(videoPos[0] * precision2) + "px";
      this.videoEl.style.top = Math.round(videoPos[1] * precision2) + "px";
      this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision2) + "px";
      this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision2) + "px";
    }
  }
  _fireConsumer(event, args) {
    if (this._consumer) {
      this._consumer.fire(event, args);
    }
  }
  _equalInitData(buf1, buf2) {
    if (!buf1 || !buf2)
      return false;
    if (buf1.byteLength != buf2.byteLength)
      return false;
    const dv1 = new Int8Array(buf1);
    const dv2 = new Int8Array(buf2);
    for (let i = 0; i != buf1.byteLength; i++)
      if (dv1[i] != dv2[i])
        return false;
    return true;
  }
  error(args) {
    this._fireConsumer("$mediaplayerError", args);
    this._setState("");
    return "";
  }
  loadeddata(args) {
    this._fireConsumer("$mediaplayerLoadedData", args);
  }
  play(args) {
    this._fireConsumer("$mediaplayerPlay", args);
  }
  playing(args) {
    this._fireConsumer("$mediaplayerPlaying", args);
    this._setState("Playing");
  }
  canplay(args) {
    this.videoEl.play();
    this._fireConsumer("$mediaplayerStart", args);
  }
  loadstart(args) {
    this._fireConsumer("$mediaplayerLoad", args);
  }
  seeked() {
    this._fireConsumer("$mediaplayerSeeked", {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1
    });
  }
  seeking() {
    this._fireConsumer("$mediaplayerSeeking", {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1
    });
  }
  durationchange(args) {
    this._fireConsumer("$mediaplayerDurationChange", args);
  }
  encrypted(args) {
    const video = args.videoElement;
    const event = args.event;
    if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
      this._previousInitData = event.initData;
      this._fireConsumer("$mediaplayerEncrypted", args);
    }
  }
  static _states() {
    return [
      class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture();
        }
        $exit() {
          this._stopUpdatingVideoTexture();
        }
        timeupdate() {
          this._fireConsumer("$mediaplayerProgress", {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1
          });
        }
        ended(args) {
          this._fireConsumer("$mediaplayerEnded", args);
          this._setState("");
        }
        pause(args) {
          this._fireConsumer("$mediaplayerPause", args);
          this._setState("Playing.Paused");
        }
        _clearSrc() {
          this._fireConsumer("$mediaplayerStop", {});
          this._setState("");
        }
        static _states() {
          return [class Paused extends this {
          }];
        }
      }
    ];
  }
}
class localCookie {
  constructor(e) {
    return e = e || {}, this.forceCookies = e.forceCookies || false, true === this._checkIfLocalStorageWorks() && true !== e.forceCookies ? { getItem: this._getItemLocalStorage, setItem: this._setItemLocalStorage, removeItem: this._removeItemLocalStorage, clear: this._clearLocalStorage, keys: this._getLocalStorageKeys } : { getItem: this._getItemCookie, setItem: this._setItemCookie, removeItem: this._removeItemCookie, clear: this._clearCookies, keys: this._getCookieKeys };
  }
  _checkIfLocalStorageWorks() {
    if ("undefined" == typeof localStorage)
      return false;
    try {
      return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), true);
    } catch (e) {
      return false;
    }
  }
  _getItemLocalStorage(e) {
    return window.localStorage.getItem(e);
  }
  _setItemLocalStorage(e, t) {
    return window.localStorage.setItem(e, t);
  }
  _removeItemLocalStorage(e) {
    return window.localStorage.removeItem(e);
  }
  _clearLocalStorage() {
    return window.localStorage.clear();
  }
  _getLocalStorageKeys() {
    return Object.keys(window.localStorage);
  }
  _getItemCookie(e) {
    var t = document.cookie.match(RegExp("(?:^|;\\s*)" + function(e2) {
      return e2.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
    }(e) + "=([^;]*)"));
    return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
  }
  _setItemCookie(e, t) {
    var o = /* @__PURE__ */ new Date(), r = new Date(o.getTime() + 15768e7);
    document.cookie = `${e}=${t}; expires=${r.toUTCString()};`;
  }
  _removeItemCookie(e) {
    document.cookie = `${e}=;Max-Age=-99999999;`;
  }
  _clearCookies() {
    document.cookie.split(";").forEach((e) => {
      document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
    });
  }
  _getCookieKeys() {
    return document.cookie.split(";").map((e) => e.split("=")[0]);
  }
}
let namespace;
let lc;
const initStorage = () => {
  namespace = Settings$1.get("platform", "id");
  lc = new localCookie();
};
const namespacedKey = (key) => namespace ? [namespace, key].join(".") : key;
const Storage = {
  get(key) {
    try {
      return JSON.parse(lc.getItem(namespacedKey(key)));
    } catch (e) {
      return null;
    }
  },
  set(key, value) {
    try {
      lc.setItem(namespacedKey(key), JSON.stringify(value));
      return true;
    } catch (e) {
      return false;
    }
  },
  remove(key) {
    lc.removeItem(namespacedKey(key));
  },
  clear() {
    if (namespace) {
      lc.keys().forEach((key) => {
        key.indexOf(namespace + ".") === 0 ? lc.removeItem(key) : null;
      });
    } else {
      lc.clear();
    }
  }
};
const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
const isWildcard = /^[!*$]$/;
const hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
const isNamedGroup = /^\/:/;
const stripRegex = (route, char = "R") => {
  if (hasRegex.test(route)) {
    route = route.replace(hasRegex, char);
  }
  return route;
};
const createRegister = (flags) => {
  const reg = /* @__PURE__ */ new Map();
  [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach((key) => {
    reg.set(key, flags[key]);
  });
  return reg;
};
class Request {
  constructor(hash = "", navArgs, storeCaller) {
    this._hash = hash;
    this._storeCaller = storeCaller;
    this._register = /* @__PURE__ */ new Map();
    this._isCreated = false;
    this._isSharedInstance = false;
    this._cancelled = false;
    this._copiedHistoryState = null;
    if (isObject$1(navArgs)) {
      this._register = createRegister(navArgs);
    } else if (isBoolean$1(navArgs)) {
      this._storeCaller = navArgs;
    }
    this._register.set(symbols.store, this._storeCaller);
  }
  cancel() {
    Log$1.debug("[router]:", `cancelled ${this._hash}`);
    this._cancelled = true;
  }
  get url() {
    return this._hash;
  }
  get register() {
    return this._register;
  }
  get hash() {
    return this._hash;
  }
  set hash(args) {
    this._hash = args;
  }
  get route() {
    return this._route;
  }
  set route(args) {
    this._route = args;
  }
  get provider() {
    return this._provider;
  }
  set provider(args) {
    this._provider = args;
  }
  get providerType() {
    return this._providerType;
  }
  set providerType(args) {
    this._providerType = args;
  }
  set page(args) {
    this._page = args;
  }
  get page() {
    return this._page;
  }
  set isCreated(args) {
    this._isCreated = args;
  }
  get isCreated() {
    return this._isCreated;
  }
  get isSharedInstance() {
    return this._isSharedInstance;
  }
  set isSharedInstance(args) {
    this._isSharedInstance = args;
  }
  get isCancelled() {
    return this._cancelled;
  }
  set copiedHistoryState(v) {
    this._copiedHistoryState = v;
  }
  get copiedHistoryState() {
    return this._copiedHistoryState;
  }
}
class Route {
  constructor(config = {}) {
    let type = ["on", "before", "after"].reduce((acc, type2) => {
      return isFunction$1(config[type2]) ? type2 : acc;
    }, void 0);
    this._cfg = config;
    if (type) {
      this._provider = {
        type,
        request: config[type]
      };
    }
  }
  get path() {
    return this._cfg.path;
  }
  get name() {
    return this._cfg.name;
  }
  get component() {
    return this._cfg.component;
  }
  get options() {
    return this._cfg.options;
  }
  get widgets() {
    return this._cfg.widgets;
  }
  get cache() {
    return this._cfg.cache;
  }
  get hook() {
    return this._cfg.hook;
  }
  get beforeNavigate() {
    return this._cfg.beforeNavigate;
  }
  get provider() {
    return this._provider;
  }
}
const getFloor = (route) => {
  return stripRegex(route).split("/").length;
};
const getRoutesByFloor = (floor) => {
  const matches = [];
  for (let [route] of routes$1.entries()) {
    if (getFloor(route) === floor) {
      matches.push(route);
    }
  }
  return matches;
};
const getRouteByHash = (hash) => {
  hash = hash.replace(/^#/, "");
  const getUrlParts = /(\/?:?[^/]+)/g;
  const candidates = getRoutesByFloor(getFloor(hash));
  const hashParts = hash.match(getUrlParts) || [];
  let regexStore = [];
  let matches = candidates.filter((route) => {
    let isMatching = true;
    if (hasRegex.test(route)) {
      const regMatches = route.match(hasRegex);
      if (regMatches && regMatches.length) {
        route = regMatches.reduce((fullRoute, regex) => {
          const lookupId = regexStore.length;
          fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`);
          regexStore.push(regex.substring(1, regex.length - 1));
          return fullRoute;
        }, route);
      }
    }
    const routeParts = route.match(getUrlParts) || [];
    for (let i = 0, j = routeParts.length; i < j; i++) {
      const routePart = routeParts[i];
      const hashPart = hashParts[i];
      if (hasLookupId.test(routePart)) {
        const routeMatches = hasLookupId.exec(routePart);
        const storeId = routeMatches[1];
        const routeRegex = regexStore[storeId];
        const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
        if (regMatches && regMatches.length) {
          const expression = regMatches[1];
          const modifiers = regMatches[2];
          const regex = new RegExp(`^/${expression}$`, modifiers);
          if (!regex.test(hashPart)) {
            isMatching = false;
          }
        }
      } else if (isNamedGroup.test(routePart)) {
        continue;
      } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
        isMatching = false;
      }
    }
    return isMatching;
  });
  if (matches.length) {
    if (matches.indexOf(hash) !== -1) {
      const match = matches[matches.indexOf(hash)];
      return routes$1.get(match);
    } else {
      matches = matches.sort((a) => {
        return isNamedGroup.test(a) ? -1 : 1;
      });
      if (routeExists(matches[0])) {
        return routes$1.get(matches[0]);
      }
    }
  }
  return false;
};
const getValuesFromHash = (hash = "", path) => {
  path = stripRegex(path, "");
  const getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
  const hashParts = hash.match(getUrlParts) || [];
  const routeParts = path.match(getUrlParts) || [];
  const getNamedGroup = /^\/:([\w-]+)\/?/;
  return routeParts.reduce((storage, value, index) => {
    const match = getNamedGroup.exec(value);
    if (match && match.length) {
      storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, "")));
    }
    return storage;
  }, /* @__PURE__ */ new Map());
};
const getOption = (stack, prop) => {
  if (stack && stack.hasOwnProperty(prop)) {
    return stack[prop];
  }
};
const createRoute = (config) => {
  if (config.path === "$") {
    let options = {
      preventStorage: true
    };
    if (isObject$1(config.options)) {
      options = {
        ...config.options,
        ...options
      };
    }
    config.options = options;
    if (bootRequest) {
      config.after = bootRequest;
    }
  }
  return new Route(config);
};
const createRequest = (url, args, store) => {
  return new Request(url, args, store);
};
const getHashByName = (obj) => {
  if (!obj.to && !obj.name) {
    return false;
  }
  const route = getRouteByName(obj.to || obj.name);
  const hasDynamicGroup = /\/:([\w-]+)\/?/;
  let hash = route;
  if (hasDynamicGroup.test(route)) {
    if (obj.params) {
      const keys = Object.keys(obj.params);
      hash = keys.reduce((acc, key) => {
        return acc.replace(`:${key}`, obj.params[key]);
      }, route);
    }
    if (obj.query) {
      return `${hash}${objectToQueryString(obj.query)}`;
    }
  }
  return hash;
};
const getRouteByName = (name2) => {
  for (let [path, route] of routes$1.entries()) {
    if (route.name === name2) {
      return path;
    }
  }
  return false;
};
const keepActivePageAlive = (route, request) => {
  if (isString$1(route)) {
    const routes2 = getRoutes();
    if (routes2.has(route)) {
      route = routes2.get(route);
    } else {
      return false;
    }
  }
  const register = request.register;
  const routeOptions = route.options;
  if (register.has("keepAlive")) {
    return register.get("keepAlive");
  } else if (routeOptions && routeOptions.keepAlive) {
    return routeOptions.keepAlive;
  }
  return false;
};
const emit = (page, events2 = [], params = {}) => {
  if (!isArray$1(events2)) {
    events2 = [events2];
  }
  events2.forEach((e) => {
    const event = `_on${ucfirst(e)}`;
    if (isFunction$1(page[event])) {
      page[event](params);
    }
  });
};
let activeWidget = null;
const getReferences = () => {
  if (!widgetsHost) {
    return;
  }
  return widgetsHost.get().reduce((storage, widget) => {
    const key = widget.ref.toLowerCase();
    storage[key] = widget;
    return storage;
  }, {});
};
const updateWidgets = (widgets, page) => {
  const configured = (widgets || []).map((ref) => ref.toLowerCase());
  widgetsHost.forEach((widget) => {
    widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
    if (widget.visible) {
      emit(widget, ["activated"], page);
    }
  });
  if (app$1.state === "Widgets" && activeWidget && !activeWidget.visible) {
    app$1._setState("");
  }
};
const getWidgetByName = (name2) => {
  name2 = ucfirst(name2);
  return widgetsHost.getByRef(name2) || false;
};
const focusWidget = (name2) => {
  const widget = getWidgetByName(name2);
  if (widget) {
    setActiveWidget(widget);
    if (app$1.state === "Widgets") {
      app$1.reload(activeWidget);
    } else {
      app$1._setState("Widgets", [activeWidget]);
    }
  }
};
const restoreFocus = () => {
  activeWidget = null;
  app$1._setState("");
};
const getActiveWidget = () => {
  return activeWidget;
};
const setActiveWidget = (instance) => {
  activeWidget = instance;
};
const createComponent = (stage2, type) => {
  return stage2.c({
    type,
    visible: false,
    widgets: getReferences()
  });
};
let history = [];
const updateHistory = (request) => {
  const hash = getActiveHash();
  if (!hash) {
    return;
  }
  const register = request.register;
  const forceNavigateStore = register.get(symbols.store);
  const activeRoute2 = getRouteByHash(hash);
  const preventStorage = getOption(activeRoute2.options, "preventStorage");
  let store = isBoolean$1(forceNavigateStore) ? forceNavigateStore : !preventStorage;
  if (store) {
    const toStore = hash.replace(/^\//, "");
    const location2 = locationInHistory(toStore);
    const stateObject = getStateObject(getActivePage(), request);
    const routerConfig2 = getRouterConfig();
    if (location2 === -1 || routerConfig2.get("storeSameHash")) {
      history.push({ hash: toStore, state: stateObject });
    } else {
      const prev = history.splice(location2, 1)[0];
      history.push({ hash: prev.hash, state: stateObject });
    }
  }
};
const locationInHistory = (hash) => {
  for (let i = 0; i < history.length; i++) {
    if (history[i].hash === hash) {
      return i;
    }
  }
  return -1;
};
const getHistoryState = (hash) => {
  let state2 = null;
  if (history.length) {
    if (!hash) {
      const record = history[history.length - 1];
      state2 = record.state;
    } else {
      if (locationInHistory(hash) !== -1) {
        const record = history[locationInHistory(hash)];
        state2 = record.state;
      }
    }
  }
  return state2;
};
const replaceHistoryState = (state2 = null, hash) => {
  if (!history.length) {
    return;
  }
  const location2 = hash ? locationInHistory(hash) : history.length - 1;
  if (location2 !== -1 && isObject$1(state2)) {
    history[location2].state = state2;
  }
};
const getStateObject = (page, request) => {
  if (request.isSharedInstance) {
    if (request.copiedHistoryState) {
      return request.copiedHistoryState;
    }
  } else if (page && isFunction$1(page.historyState)) {
    return page.historyState();
  }
  return null;
};
const getHistory = () => {
  return history.slice(0);
};
const setHistory = (arr = []) => {
  if (isArray$1(arr)) {
    history = arr;
  }
};
let application;
let app$1;
let pagesHost;
let stage;
let routerConfig;
let widgetsHost;
let rootHash;
let bootRequest;
let updateHash = true;
let beforeEachRoute = async (from, to) => {
  return true;
};
let afterEachRoute = () => {
};
let routes$1 = /* @__PURE__ */ new Map();
let components = /* @__PURE__ */ new Map();
let initialised = false;
let activePage = null;
let activeHash;
let activeRoute;
let lastAcceptedHash;
let previousState;
const mixin = (app2) => {
  if (app2.pages) {
    pagesHost = app2.pages.childList;
  }
  if (app2.widgets && app2.widgets.children) {
    widgetsHost = app2.widgets.childList;
    widgetsHost.forEach((w) => w.visible = false);
  }
  app2._handleBack = (e) => {
    step(-1);
    e.preventDefault();
  };
};
const bootRouter = (config, instance) => {
  let { appInstance, routes: routes2 } = config;
  if (instance && isPage(instance)) {
    app$1 = instance;
  }
  if (!app$1) {
    app$1 = appInstance || AppInstance;
  }
  application = app$1.application;
  pagesHost = application.childList;
  stage = app$1.stage;
  routerConfig = getConfigMap();
  mixin(app$1);
  if (isArray$1(routes2)) {
    setup(config);
  } else if (isFunction$1(routes2)) {
    console.warn("[Router]: Calling Router.route() directly is deprecated.");
    console.warn(
      "Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration"
    );
  }
};
const setup = (config) => {
  if (!initialised) {
    init(config);
  }
  config.routes.forEach((r) => {
    const path = cleanHash(r.path);
    if (!routeExists(path)) {
      const route = createRoute(r);
      routes$1.set(path, route);
      if (route.component) {
        let type = route.component;
        if (isComponentConstructor(type)) {
          if (!routerConfig.get("lazyCreate")) {
            type = createComponent(stage, type);
            pagesHost.a(type);
          }
        }
        components.set(path, type);
      }
    } else {
      console.error(`${path} already exists in routes configuration`);
    }
  });
};
const init = (config) => {
  rootHash = config.root;
  if (isFunction$1(config.boot)) {
    bootRequest = config.boot;
  }
  if (isBoolean$1(config.updateHash)) {
    updateHash = config.updateHash;
  }
  if (isFunction$1(config.beforeEachRoute)) {
    beforeEachRoute = config.beforeEachRoute;
  }
  if (isFunction$1(config.afterEachRoute)) {
    afterEachRoute = config.afterEachRoute;
  }
  if (config.bootComponent) {
    console.warn(
      "[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes"
    );
    console.warn(
      "[Router]: setting { bootComponent } property will be deprecated in a future release"
    );
    if (isPage(config.bootComponent)) {
      config.routes.push({
        path: "$",
        component: config.bootComponent,
        // we try to assign the bootRequest as after data-provider
        // so it will behave as any other component
        after: bootRequest || null,
        options: {
          preventStorage: true
        }
      });
    } else {
      console.error(`[Router]: ${config.bootComponent} is not a valid boot component`);
    }
  }
  config.routes.forEach((item) => {
    const strippedPath = stripRegex(item.path);
    const pattern = /.*\/:.*?\?$/u;
    if (pattern.test(strippedPath)) {
      const optionalPath = item.path.substring(0, item.path.lastIndexOf("/"));
      const originalPath = item.path.substring(0, item.path.lastIndexOf("?"));
      item.path = originalPath;
      let optionalItem = { ...item };
      optionalItem.path = optionalPath;
      config.routes.push(optionalItem);
    }
  });
  initialised = true;
};
const storeComponent = (route, type) => {
  if (components.has(route)) {
    components.set(route, type);
  }
};
const getComponent = (route) => {
  if (components.has(route)) {
    return components.get(route);
  }
  return null;
};
const mustUpdateLocationHash = () => {
  if (!routerConfig || !routerConfig.size) {
    return false;
  }
  const updateConfig = routerConfig.get("updateHash");
  return !(isBoolean$1(updateConfig) && !updateConfig || isBoolean$1(updateHash) && !updateHash);
};
const onRequestResolved = (request) => {
  const hash = request.hash;
  const route = request.route;
  const register = request.register;
  const page = request.page;
  if (getOption(route.options, "clearHistory")) {
    setHistory([]);
  } else if (hash && !isWildcard.test(route.path)) {
    updateHistory(request);
  }
  storeComponent(route.path, page);
  if (request.isSharedInstance || !request.isCreated) {
    emit(page, "changed");
  } else if (request.isCreated) {
    emit(page, "mounted");
  }
  if (widgetsHost) {
    updateWidgets(route.widgets, page);
  }
  if (getActivePage() && !request.isSharedInstance) {
    cleanUp(activePage, request);
  }
  if (register.get(symbols.historyState) && isFunction$1(page.historyState)) {
    page.historyState(register.get(symbols.historyState));
  }
  setActivePage(page);
  activeHash = request.hash;
  activeRoute = route.path;
  for (let request2 of navigateQueue.values()) {
    if (request2.isCancelled && request2.hash) {
      navigateQueue.delete(request2.hash);
    }
  }
  afterEachRoute(request);
  Log$1.info("[route]:", route.path);
  Log$1.info("[hash]:", hash);
};
const cleanUp = (page, request) => {
  const route = activeRoute;
  const register = request.register;
  const lazyDestroy = routerConfig.get("lazyDestroy");
  const destroyOnBack = routerConfig.get("destroyOnHistoryBack");
  const keepAlive = register.get("keepAlive");
  const isFromHistory = register.get(symbols.backtrack);
  let doCleanup = false;
  if (isFromHistory && (destroyOnBack || lazyDestroy)) {
    doCleanup = true;
  }
  if (lazyDestroy && !keepAlive) {
    doCleanup = true;
  }
  if (activeRoute === request.route.path) {
    doCleanup = true;
  }
  if (doCleanup) {
    storeComponent(route, page._routedType || page.constructor);
    pagesHost.remove(page);
    if (routerConfig.get("gcOnUnload")) {
      stage.gc();
    }
  } else {
    page.patch({
      x: 0,
      y: 0,
      scale: 1,
      alpha: 1,
      visible: false
    });
  }
};
const getActiveHash = () => {
  return activeHash;
};
const setActivePage = (page) => {
  activePage = page;
};
const getActivePage = () => {
  return activePage;
};
const getActiveRoute = () => {
  return activeRoute;
};
const getLastHash = () => {
  return lastAcceptedHash;
};
const setLastHash = (hash) => {
  lastAcceptedHash = hash;
};
const setPreviousState = (state2) => {
  previousState = state2;
};
const getPreviousState = () => {
  return previousState;
};
const routeExists = (key) => {
  return routes$1.has(key);
};
const getRootHash = () => {
  return rootHash;
};
const getBootRequest = () => {
  return bootRequest;
};
const getRouterConfig = () => {
  return routerConfig;
};
const getRoutes = () => {
  return routes$1;
};
const isFunction$1 = (v) => {
  return typeof v === "function";
};
const isObject$1 = (v) => {
  return typeof v === "object" && v !== null;
};
const isBoolean$1 = (v) => {
  return typeof v === "boolean";
};
const isPage = (v) => {
  if (v instanceof lightning.Element || isComponentConstructor(v)) {
    return true;
  }
  return false;
};
const isComponentConstructor = (type) => {
  return type.prototype && "isComponent" in type.prototype;
};
const isArray$1 = (v) => {
  return Array.isArray(v);
};
const ucfirst = (v) => {
  return `${v.charAt(0).toUpperCase()}${v.slice(1)}`;
};
const isString$1 = (v) => {
  return typeof v === "string";
};
const isPromise = (method) => {
  let result;
  if (isFunction$1(method)) {
    try {
      result = method.apply(null);
    } catch (e) {
      result = e;
    }
  } else {
    result = method;
  }
  return isObject$1(result) && isFunction$1(result.then);
};
const cleanHash = (hash = "") => {
  return hash.replace(/^#/, "").replace(/\/+$/, "");
};
const getConfigMap = () => {
  const routerSettings = Settings$1.get("platform", "router");
  const isObj = isObject$1(routerSettings);
  return [
    "backtrack",
    "gcOnUnload",
    "destroyOnHistoryBack",
    "lazyCreate",
    "lazyDestroy",
    "reuseInstance",
    "autoRestoreRemote",
    "numberNavigation",
    "updateHash",
    "storeSameHash"
  ].reduce((config, key) => {
    config.set(key, isObj ? routerSettings[key] : Settings$1.get("platform", key));
    return config;
  }, /* @__PURE__ */ new Map());
};
const getQueryStringParams = (hash = getActiveHash()) => {
  const resumeHash2 = getResumeHash();
  if ((hash === "$" || !hash) && resumeHash2) {
    if (isString$1(resumeHash2)) {
      hash = resumeHash2;
    }
  }
  let parse = "";
  const getQuery = /([?&].*)/;
  const matches = getQuery.exec(hash);
  const params = {};
  if (document.location && document.location.search) {
    parse = document.location.search;
  }
  if (matches && matches.length) {
    let hashParams = matches[1];
    if (parse) {
      hashParams = hashParams.replace(/^\?/, "");
      parse = `${parse}&${hashParams}`;
    } else {
      parse = hashParams;
    }
  }
  if (parse) {
    const urlParams = new URLSearchParams(parse);
    for (const [key, value] of urlParams.entries()) {
      params[key] = value;
    }
    return params;
  } else {
    return false;
  }
};
const objectToQueryString = (obj) => {
  if (!isObject$1(obj)) {
    return "";
  }
  return "?" + Object.keys(obj).map((key) => {
    return `${key}=${obj[key]}`;
  }).join("&");
};
const symbols = {
  route: Symbol("route"),
  hash: Symbol("hash"),
  store: Symbol("store"),
  fromHistory: Symbol("fromHistory"),
  expires: Symbol("expires"),
  resume: Symbol("resume"),
  backtrack: Symbol("backtrack"),
  historyState: Symbol("historyState"),
  queryParams: Symbol("queryParams")
};
const dataHooks = {
  on: (request) => {
    setPreviousState(app$1.state || "");
    app$1._setState("Loading");
    return execProvider(request);
  },
  before: (request) => {
    return execProvider(request);
  },
  after: (request) => {
    try {
      execProvider(request, true);
    } catch (e) {
    }
    return Promise.resolve();
  }
};
const execProvider = (request, emitProvided) => {
  const route = request.route;
  const provider = route.provider;
  const expires = route.cache ? route.cache * 1e3 : 0;
  const params = addPersistData(request);
  return provider.request(request.page, { ...params }).then(() => {
    request.page[symbols.expires] = Date.now() + expires;
    if (emitProvided) {
      emit(request.page, "dataProvided");
    }
  }).catch((e) => {
    request.page[symbols.expires] = Date.now();
    throw e;
  });
};
const addPersistData = ({ page, route, hash, register = /* @__PURE__ */ new Map() }) => {
  const urlValues = getValuesFromHash(hash, route.path);
  const queryParams = getQueryStringParams(hash);
  const pageData = new Map([...urlValues, ...register]);
  const params = {};
  for (let [name2, value] of pageData) {
    params[name2] = value;
  }
  if (queryParams) {
    params[symbols.queryParams] = queryParams;
  }
  if (register.size) {
    const obj = {};
    for (let [k, v] of register) {
      obj[k] = v;
    }
    page.persist = obj;
  }
  page.params = params;
  emit(page, ["urlParams"], params);
  return params;
};
const isPageExpired = (page) => {
  if (!page[symbols.expires]) {
    return false;
  }
  const expires = page[symbols.expires];
  const now = Date.now();
  return now >= expires;
};
const hasProvider = (path) => {
  if (routeExists(path)) {
    const record = routes$1.get(path);
    return !!record.provider;
  }
  return false;
};
const getProvider = (route) => {
  if (routeExists(route.path)) {
    const { provider } = routes$1.get(route.path);
    return {
      type: provider.type,
      provider: provider.request
    };
  }
};
const fade = (i, o) => {
  return new Promise((resolve) => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }]
      }
    });
    i.transition("alpha").on("finish", () => {
      if (o) {
        o.visible = false;
      }
      resolve();
    });
  });
};
const crossFade = (i, o) => {
  return new Promise((resolve) => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }]
      }
    });
    if (o) {
      o.patch({
        smooth: {
          alpha: [0, { duration: 0.5, delay: 0.3 }]
        }
      });
    }
    i.transition("alpha").on("finish", () => {
      resolve();
    });
  });
};
const moveOnAxes = (axis, direction, i, o) => {
  const bounds = axis === "x" ? 1920 : 1080;
  return new Promise((resolve) => {
    i.patch({
      [`${axis}`]: direction ? bounds * -1 : bounds,
      visible: true,
      smooth: {
        [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }]
      }
    });
    if (o) {
      o.patch({
        [`${axis}`]: 0,
        smooth: {
          [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }]
        }
      });
    }
    i.transition(axis).on("finish", () => {
      resolve();
    });
  });
};
const up = (i, o) => {
  return moveOnAxes("y", 0, i, o);
};
const down = (i, o) => {
  return moveOnAxes("y", 1, i, o);
};
const left = (i, o) => {
  return moveOnAxes("x", 0, i, o);
};
const right = (i, o) => {
  return moveOnAxes("x", 1, i, o);
};
const Transitions = {
  fade,
  crossFade,
  up,
  down,
  left,
  right
};
const executeTransition = (pageIn, pageOut = null) => {
  const transition = pageIn.pageTransition || pageIn.easing;
  const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
  const transitionsDisabled = getRouterConfig().get("disableTransitions");
  if (pageIn.easing) {
    console.warn("easing() method is deprecated and will be removed. Use pageTransition()");
  }
  if (!hasCustomTransitions || transitionsDisabled) {
    pageIn.visible = true;
    if (pageOut) {
      pageOut.visible = false;
    }
    return Promise.resolve();
  }
  if (transition) {
    let type;
    try {
      type = transition.call(pageIn, pageIn, pageOut);
    } catch (e) {
      type = "crossFade";
    }
    if (isPromise(type)) {
      return type;
    }
    if (isString$1(type)) {
      const fn = Transitions[type];
      if (fn) {
        return fn(pageIn, pageOut);
      }
    }
    if (pageIn.smoothIn) {
      const smooth = (p, v, args = {}) => {
        return new Promise((resolve) => {
          pageIn.visible = true;
          pageIn.setSmooth(p, v, args);
          pageIn.transition(p).on("finish", () => {
            resolve();
          });
        });
      };
      return pageIn.smoothIn({ pageIn, smooth });
    }
  }
  return Transitions.crossFade(pageIn, pageOut);
};
const load = async (request) => {
  let expired = false;
  try {
    request = await loader(request);
    if (request && !request.isCancelled) {
      if (app$1.state === "Loading") {
        if (getPreviousState() === "Widgets") {
          app$1._setState("Widgets", [getActiveWidget()]);
        } else {
          app$1._setState("");
        }
      }
      if (!request.isSharedInstance && !request.isCancelled) {
        await executeTransition(request.page, getActivePage());
      }
    } else {
      expired = true;
    }
    if (expired || request.isCancelled) {
      Log$1.debug("[router]:", `Rejected ${request.hash} because route to ${getLastHash()} started`);
      if (request.isCreated && !request.isSharedInstance) {
        pagesHost.remove(request.page);
      }
    } else {
      onRequestResolved(request);
      return request.page;
    }
  } catch (request2) {
    if (!request2.route) {
      console.error(request2);
    } else if (!expired) {
      const { route } = request2;
      if (getOption(route.options, "clearHistory")) {
        setHistory([]);
      } else if (!isWildcard.test(route.path)) {
        updateHistory(request2);
      }
      if (request2.isCreated && !request2.isSharedInstance) {
        pagesHost.remove(request2.page);
      }
      handleError(request2);
    }
  }
};
const loader = async (request) => {
  const route = request.route;
  const hash = request.hash;
  const register = request.register;
  let type = getComponent(route.path);
  let isConstruct = isComponentConstructor(type);
  let provide = false;
  if (!isConstruct && !register.get(symbols.backtrack)) {
    if (!mustReuse(route)) {
      type = type.constructor;
      isConstruct = true;
    }
  }
  if (!isConstruct) {
    request.page = type;
    if (hasProvider(route.path)) {
      if (isPageExpired(type) || type[symbols.hash] !== hash) {
        provide = true;
      }
    }
    let currentRoute = getActivePage() && getActivePage()[symbols.route];
    if (route.path === currentRoute) {
      request.isSharedInstance = true;
      if (isFunction$1(request.page.historyState)) {
        request.copiedHistoryState = request.page.historyState();
      }
    }
  } else {
    request.page = createComponent(stage, type);
    pagesHost.a(request.page);
    if (hasProvider(route.path)) {
      provide = true;
    }
    request.isCreated = true;
  }
  request.page[symbols.hash] = hash;
  request.page[symbols.route] = route.path;
  try {
    if (provide) {
      const { type: loadType, provider } = getProvider(route);
      request.provider = provider;
      request.providerType = loadType;
      await dataHooks[loadType](request);
      if (hash !== getLastHash()) {
        return false;
      } else {
        if (request.providerType !== "after") {
          emit(request.page, "dataProvided");
        }
        return request;
      }
    } else {
      addPersistData(request);
      return request;
    }
  } catch (e) {
    request.error = e;
    return Promise.reject(request);
  }
};
const handleError = (request) => {
  if (request && request.error) {
    console.error(request.error);
  } else if (request) {
    Log$1.error(request);
  }
  if (request.page && routeExists("!")) {
    navigate("!", { request }, false);
  }
};
const mustReuse = (route) => {
  const opt = getOption(route.options, "reuseInstance");
  const config = routerConfig.get("reuseInstance");
  if (isBoolean$1(opt)) {
    return opt;
  }
  return !(isBoolean$1(config) && config === false);
};
class RoutedApp extends lightning.Component {
  static _template() {
    return {
      Pages: {
        forceZIndexContext: true
      },
      /**
       * This is a default Loading page that will be made visible
       * during data-provider on() you CAN override in child-class
       */
      Loading: {
        rect: true,
        w: 1920,
        h: 1080,
        color: 4278190080,
        visible: false,
        zIndex: 99,
        Label: {
          mount: 0.5,
          x: 960,
          y: 540,
          text: {
            text: "Loading.."
          }
        }
      }
    };
  }
  static _states() {
    return [
      class Loading extends this {
        $enter() {
          this.tag("Loading").visible = true;
        }
        $exit() {
          this.tag("Loading").visible = false;
        }
      },
      class Widgets extends this {
        $enter(args, widget) {
          this._widget = widget;
          this._refocus();
        }
        _getFocused() {
          return this._widget;
        }
        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget;
          this._refocus();
        }
        _handleKey() {
          const restoreFocus2 = routerConfig.get("autoRestoreRemote");
          if (!isBoolean$1(restoreFocus2) || restoreFocus2 === true) {
            Router.focusPage();
          }
        }
      }
    ];
  }
  /**
   * Return location where pages need to be stored
   */
  get pages() {
    return this.tag("Pages");
  }
  /**
   * Tell router where widgets are stored
   */
  get widgets() {
    return this.tag("Widgets");
  }
  /**
   * we MUST register _handleBack method so the Router
   * can override it
   * @private
   */
  _handleBack() {
  }
  /**
   * We MUST return Router.activePage() so the new Page
   * can listen to the remote-control.
   */
  _getFocused() {
    return Router.getActivePage();
  }
}
let navigateQueue = /* @__PURE__ */ new Map();
let forcedHash = "";
let resumeHash = "";
const startRouter = (config, instance) => {
  bootRouter(config, instance);
  registerListener();
  start();
};
const start = () => {
  let hash = (getHash() || "").replace(/^#/, "");
  const bootKey = "$";
  const params = getQueryStringParams(hash);
  const bootRequest2 = getBootRequest();
  const rootHash2 = getRootHash();
  const isDirectLoad = hash.indexOf(bootKey) !== -1;
  if (isWildcard.test(hash) && hash !== bootKey) {
    hash = "";
  }
  resumeHash = isDirectLoad ? rootHash2 : hash || rootHash2;
  const ready = () => {
    if (!hash && rootHash2) {
      if (isString$1(rootHash2)) {
        navigate(rootHash2);
      } else if (isFunction$1(rootHash2)) {
        rootHash2().then((res) => {
          if (isObject$1(res)) {
            navigate(res.path, res.params);
          } else {
            navigate(res);
          }
        });
      }
    } else {
      queue(hash);
      handleHashChange().then(() => {
        app$1._refocus();
      }).catch((e) => {
        console.error(e);
      });
    }
  };
  if (routeExists(bootKey)) {
    if (hash && !isDirectLoad) {
      if (!getRouteByHash(hash)) {
        navigate("*", { failedHash: hash });
        return;
      }
    }
    navigate(
      bootKey,
      {
        resume: resumeHash,
        reload: bootKey === hash
      },
      false
    );
  } else if (isFunction$1(bootRequest2)) {
    bootRequest2(params).then(() => {
      ready();
    }).catch((e) => {
      handleBootError(e);
    });
  } else {
    ready();
  }
};
const handleBootError = (e) => {
  if (routeExists("!")) {
    navigate("!", { request: { error: e } });
  } else {
    console.error(e);
  }
};
const navigate = (url, args = {}, store) => {
  if (isObject$1(url)) {
    url = getHashByName(url);
    if (!url) {
      return;
    }
  }
  let hash = getHash();
  if (!mustUpdateLocationHash() && forcedHash) {
    hash = forcedHash;
  }
  if (hash.replace(/^#/, "") !== url) {
    queue(url, args, store);
    if (mustUpdateLocationHash()) {
      setHash(url);
    } else {
      forcedHash = url;
      handleHashChange(url).then(() => {
        app$1._refocus();
      }).catch((e) => {
        console.error(e);
      });
    }
  } else if (args.reload) {
    queue(url, args, store);
    handleHashChange(url).then(() => {
      app$1._refocus();
    }).catch((e) => {
      console.error(e);
    });
  }
};
const queue = (hash, args = {}, store) => {
  hash = cleanHash(hash);
  if (!navigateQueue.has(hash)) {
    for (let request2 of navigateQueue.values()) {
      request2.cancel();
    }
    const request = createRequest(hash, args, store);
    navigateQueue.set(decodeURIComponent(hash), request);
    return request;
  }
  return false;
};
const handleHashChange = async (override) => {
  const hash = cleanHash(override || getHash());
  const queueId = decodeURIComponent(hash);
  let request = navigateQueue.get(queueId);
  if (!request && !navigateQueue.size) {
    request = queue(hash);
  }
  const route = getRouteByHash(hash);
  if (!route) {
    if (routeExists("*")) {
      navigate("*", { failedHash: hash });
    } else {
      console.error(`Unable to navigate to: ${hash}`);
    }
    return;
  }
  request.hash = hash;
  request.route = route;
  let result = await beforeEachRoute(getActiveHash(), request);
  if (result && route.beforeNavigate) {
    result = await route.beforeNavigate(getActiveHash(), request);
  }
  if (isBoolean$1(result)) {
    if (result) {
      return resolveHashChange(request);
    }
  } else {
    request.cancel();
    navigateQueue.delete(queueId);
    if (isString$1(result)) {
      navigate(result);
    } else if (isObject$1(result)) {
      let store = true;
      if (isBoolean$1(result.store)) {
        store = result.store;
      }
      navigate(result.path, result.params, store);
    }
  }
};
const resolveHashChange = (request) => {
  const hash = request.hash;
  const route = request.route;
  const queueId = decodeURIComponent(hash);
  setLastHash(hash);
  if (route.path) {
    const component = getComponent(route.path);
    if (isFunction$1(route.hook)) {
      const urlParams = getValuesFromHash(hash, route.path);
      const params = {};
      for (const key of urlParams.keys()) {
        params[key] = urlParams.get(key);
      }
      route.hook(app$1, { ...params });
    }
    if (component) {
      const activePage2 = getActivePage();
      if (activePage2) {
        const keepAlive = keepActivePageAlive(getActiveRoute(), request);
        if (activePage2 && route.path === getActiveRoute() && !keepAlive) {
          activePage2._setState("");
        }
      }
      if (isPage(component)) {
        load(request).then(() => {
          app$1._refocus();
          navigateQueue.delete(queueId);
        });
      } else {
        component().then((contents) => {
          return contents.default;
        }).then((module) => {
          storeComponent(route.path, module);
          return load(request);
        }).then(() => {
          app$1._refocus();
          navigateQueue.delete(queueId);
        });
      }
    } else {
      navigateQueue.delete(queueId);
    }
  }
};
const step = (level = 0) => {
  if (!level || isNaN(level)) {
    return false;
  }
  const history2 = getHistory();
  level = Math.abs(level);
  if (level > history2.length) {
    if (isFunction$1(app$1._handleAppClose)) {
      return app$1._handleAppClose();
    }
    return app$1.application.closeApp();
  } else if (history2.length) {
    const route = history2.splice(history2.length - level, level)[0];
    setHistory(history2);
    return navigate(
      route.hash,
      {
        [symbols.backtrack]: true,
        [symbols.historyState]: route.state
      },
      false
    );
  } else if (routerConfig.get("backtrack")) {
    const hashLastPart = /(\/:?[\w%\s-]+)$/;
    let hash = stripRegex(getHash());
    let floor = getFloor(hash);
    if (floor > 1) {
      while (floor--) {
        hash = hash.replace(hashLastPart, "");
        if (getRouteByHash(hash)) {
          return navigate(hash, { [symbols.backtrack]: true }, false);
        }
      }
    }
  }
  return false;
};
const resume = () => {
  if (isString$1(resumeHash)) {
    navigate(resumeHash, false);
    resumeHash = "";
  } else if (isFunction$1(resumeHash)) {
    resumeHash().then((res) => {
      resumeHash = "";
      if (isObject$1(res)) {
        navigate(res.path, res.params);
      } else {
        navigate(res);
      }
    });
  } else {
    console.warn("[Router]: resume() called but no hash found");
  }
};
const reload = () => {
  if (!isNavigating()) {
    const hash = getActiveHash();
    navigate(hash, { reload: true }, false);
  }
};
const isNavigating = () => {
  if (navigateQueue.size) {
    let isProcessing = false;
    for (let request of navigateQueue.values()) {
      if (!request.isCancelled) {
        isProcessing = true;
      }
    }
    return isProcessing;
  }
  return false;
};
const getResumeHash = () => {
  return resumeHash;
};
let getHash = () => {
  return document.location.hash;
};
let setHash = (url) => {
  document.location.hash = url;
};
const initRouter = (config) => {
  if (config.getHash) {
    getHash = config.getHash;
  }
  if (config.setHash) {
    setHash = config.setHash;
  }
};
const registerListener = () => {
  Registry.addEventListener(window, "hashchange", async () => {
    if (mustUpdateLocationHash()) {
      try {
        await handleHashChange();
      } catch (e) {
        console.error(e);
      }
    }
  });
};
const root = () => {
  const rootHash2 = getRootHash();
  if (isString$1(rootHash2)) {
    navigate(rootHash2);
  } else if (isFunction$1(rootHash2)) {
    rootHash2().then((res) => {
      if (isObject$1(res)) {
        navigate(res.path, res.params);
      } else {
        navigate(res);
      }
    });
  }
};
const Router = {
  startRouter,
  navigate,
  resume,
  step,
  go: step,
  back: step.bind(null, -1),
  activePage: getActivePage,
  getActivePage() {
    return getActivePage();
  },
  getActiveRoute,
  getActiveHash,
  focusWidget,
  getActiveWidget,
  restoreFocus,
  isNavigating,
  getHistory,
  setHistory,
  getHistoryState,
  replaceHistoryState,
  getQueryStringParams,
  reload,
  symbols,
  App: RoutedApp,
  // keep backwards compatible
  focusPage: restoreFocus,
  root,
  /**
   * Deprecated api methods
   */
  setupRoutes() {
    console.warn("Router: setupRoutes is deprecated, consolidate your configuration");
    console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
  },
  on() {
    console.warn("Router.on() is deprecated, consolidate your configuration");
    console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
  },
  before() {
    console.warn("Router.before() is deprecated, consolidate your configuration");
    console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
  },
  after() {
    console.warn("Router.after() is deprecated, consolidate your configuration");
    console.warn("https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration");
  }
};
let ApplicationInstance;
const Launch = (App2, appSettings, platformSettings, appData) => {
  initSettings(appSettings, platformSettings);
  initUtils(platformSettings);
  initStorage();
  if (platformSettings.plugins) {
    platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
    platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
    platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
    platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
    platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
    platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
    platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
    platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
    platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
  }
  const app2 = Application2(App2, appData, platformSettings);
  initLightningSdkPlugin.log = Log$1;
  initLightningSdkPlugin.settings = Settings$1;
  initLightningSdkPlugin.ads = Ads;
  initLightningSdkPlugin.lightning = lightning;
  ApplicationInstance = new app2(appSettings);
  initLightningSdkPlugin.appInstance = ApplicationInstance;
  return ApplicationInstance;
};
class SubtitleComponent extends lightning.Component {
  static _template() {
    return {
      visible: false,
      rect: true,
      color: 2415919104,
      shader: { type: lightning.shaders.RoundedRectangle, radius: 5 },
      Text: {
        y: 5,
        x: 20,
        text: {
          textColor: 4294967295,
          fontSize: 38,
          lineHeight: 38 * 1.4,
          textAlign: "center",
          wordWrap: true,
          maxLines: 3,
          shadow: true,
          shadowColor: 4281545523
        }
      }
    };
  }
  _init() {
    this._textTextureDefaults = new lightning.textures.TextTexture(this.stage).cloneArgs();
    this.tag("Text").on("txLoaded", ({ _source }) => {
      this.w = _source.w + this.tag("Text").x * 2;
      this.h = _source.h;
      this.position();
    });
  }
  get textFormat() {
    const textTag = this.tag("Text").text;
    return {
      fontFace: textTag.fontFace || "sans-serif",
      fontSize: textTag.fontSize,
      lineHeight: textTag.lineHeight,
      textAlign: textTag.textAlign,
      wordWrap: true,
      maxLines: textTag.maxLines
    };
  }
  show() {
    this.visible = true;
  }
  hide() {
    this.visible = false;
  }
  position() {
    this.x = this._calculateX(this.xPos);
    this.y = this._calculateY(this.yPos);
  }
  set viewportW(v) {
    this._viewportW = v;
    this.x = this._calculateX(this.xPos);
  }
  get viewportW() {
    return this._viewportW || this.application.finalW;
  }
  set viewportH(v) {
    this._viewportH = v;
    this.y = this._calculateY(this.yPos);
  }
  get viewportH() {
    return this._viewportH || this.application.finalH;
  }
  _calculateX(x) {
    if (x === "center") {
      x = (this.viewportW - this.finalW) / 2;
    } else if (x === "left") {
      x = 60;
    } else if (x === "right") {
      x = this.viewportW - this.finalW - 60;
    }
    return x;
  }
  set xPos(v) {
    this._x = v;
    this.x = this._calculateX(v);
  }
  get xPos() {
    return this._x || "center";
  }
  _calculateY(y) {
    if (y === "center") {
      return (this.viewportH - this.finalH) / 2;
    } else if (y === "top") {
      return 60;
    } else if (y === "bottom") {
      return this.viewportH - this.finalH - 60;
    }
    return y;
  }
  set yPos(v) {
    this._y = v;
    this.y = this._calculateY(v);
  }
  get yPos() {
    return this._y || "bottom";
  }
  set fontFamily(v) {
    this.tag("Text").text.fontFace = v;
  }
  set fontSize(v) {
    this.tag("Text").text.fontSize = v;
    this.tag("Text").text.lineHeight = v * 1.3;
  }
  set fontColor(v) {
    this.tag("Text").color = v;
  }
  set backgroundColor(v) {
    this.color = v;
  }
  _defineBreakpoint(text, breakpoint) {
    if (breakpoint >= this.maxWidth)
      return this.maxWidth;
    const info = lightning.textures.TextTexture.renderer(
      this.stage,
      this.stage.platform.getDrawingCanvas(),
      {
        ...this._textTextureDefaults,
        ...this.textFormat,
        ...{ wordWrapWidth: breakpoint },
        text
      }
    )._calculateRenderInfo();
    if (info.width <= breakpoint && info.lines.length <= 2) {
      return breakpoint;
    } else {
      return this._defineBreakpoint(text, breakpoint * 1.25);
    }
  }
  set text(v) {
    this.alpha = 0;
    if (v && v.length) {
      const breakpoint = this._defineBreakpoint(v, 640);
      this.tag("Text").text.wordWrapWidth = breakpoint;
      this.tag("Text").text = v;
      this.alpha = 1;
    }
  }
  set textAlign(v) {
    this._textAlign = v;
    this.tag("Text").text.textAlign = v;
  }
  set maxWidth(v) {
    this._maxWidth = v;
  }
  get maxWidth() {
    return (this._maxWidth || 1200) - this.tag("Text").x * 2;
  }
  set maxLines(v) {
    this.tag("Text").text.maxLines = v;
  }
}
const theme = {
  colors: {
    background: 4279639853,
    primary: 4279509822,
    primaryLight: 4280169822,
    secondary: 4283596540,
    tertiary: 4284586236,
    accent: 4291485694,
    error: 4281685370,
    warning: 4281685370,
    info: 4281685370,
    white: 4294046193,
    yellow: 4294105945,
    accentGrey: {
      light: 4288784562,
      dark: 4282732896
    },
    dark: 4278584867,
    black: 4278190080
  }
};
const endp = [
  "/filters/dgnlsl30-movies-action?page=1&language=en&size=50",
  "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50",
  "/filters/marvel-movies?page=1&language=en&size=50",
  "/filters/gNAaDQJl13GS?page=1&language=en&size=100",
  "/filters/dgnlsl30-movies-action?page=1&language=en&size=50",
  "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50",
  "/filters/marvel-movies?page=1&language=en&size=50",
  "/filters/gNAaDQJl13GS?page=1&language=en&size=100",
  "/filters/dgnlsl30-movies-action?page=1&language=en&size=50",
  "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50",
  "/filters/marvel-movies?page=1&language=en&size=50",
  "/filters/gNAaDQJl13GS?page=1&language=en&size=100",
  "/filters/dgnlsl30-movies-action?page=1&language=en&size=50",
  "/filters/dgnlsl30-movies-comedy?page=1&language=en&size=50",
  "/filters/marvel-movies?page=1&language=en&size=50",
  "/filters/gNAaDQJl13GS?page=1&language=en&size=100"
];
const railName = [
  "Action Movies",
  "Only on Enlight",
  "Marvel Movies",
  "Drama Movies",
  "Romantic Comdey Movies",
  "Trending Now",
  "Comdey Movies",
  "Thriller Movies",
  "Action Movies",
  "Only on Enlight",
  "Marvel Movies",
  "Drama Movies",
  "Romantic Comdey Movies",
  "Trending Now",
  "Comdey Movies",
  "Thriller Movies",
  "Long Rail"
];
class CollectionWrapper extends lightning.Component {
  static _template() {
    return {
      Wrapper: {}
    };
  }
  _construct() {
    this._direction = CollectionWrapper.DIRECTION.row;
    this._scrollTransitionSettings = this.stage.transitions.createSettings({});
    this._spacing = 0;
    this._autoResize = false;
    this._requestingItems = false;
    this._requestThreshold = 1;
    this._requestsEnabled = false;
    this._gcThreshold = 5;
    this._gcIncrement = 0;
    this._forceLoad = false;
    this.clear();
  }
  _setup() {
    this._updateScrollTransition();
  }
  _updateScrollTransition() {
    const axis = this._direction === 1 ? "y" : "x";
    this.wrapper.transition(axis, this._scrollTransitionSettings);
    this._scrollTransition = this.wrapper.transition(axis);
  }
  _indexChanged(obj) {
    let { previousIndex: previous, index: target, dataLength: max, mainIndex, previousMainIndex, lines } = obj;
    if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
      previous = previousMainIndex;
      target = mainIndex;
      max = lines;
    }
    if (this._requestsEnabled && !this._requestingItems) {
      if (target + this._requestThreshold >= max) {
        this.requestItems(false, obj);
      }
    }
    this._refocus();
    this.scrollCollectionWrapper(obj);
    if (obj.previousIndex !== obj.index) {
      this.signal("onIndexChanged", obj);
    }
  }
  requestItems(reload2 = false, obj = void 0) {
    if (obj === void 0) {
      obj = {
        previous: 0,
        index: 0,
        max: 0
      };
    }
    this._requestingItems = true;
    this.signal("onRequestItems", obj).then((response) => {
      if (response === false) {
        this.enableRequests = false;
      }
      this._requestingItems = false;
      if (reload2) {
        this.clear();
      }
      const type = typeof response;
      if (Array.isArray(response) || type === "object" || type === "string" || type === "number") {
        this.add(response);
      }
    });
  }
  setIndex(index) {
    const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
    const previousIndex = this._index;
    this._index = targetIndex;
    this._indexChanged({ previousIndex, index: targetIndex, dataLength: this._items.length });
    return previousIndex !== targetIndex;
  }
  clear() {
    this._uids = [];
    this._items = [];
    this._index = 0;
    if (this._scrollTransition) {
      this._scrollTransition.reset(0, 1);
    }
    if (this.wrapper) {
      const hadChildren = this.wrapper.children > 0;
      this.wrapper.patch({
        x: 0,
        y: 0,
        children: []
      });
      if (hadChildren) {
        this._collectGarbage(true);
      }
    }
  }
  add(item) {
    this.addAt(item);
  }
  addAt(item, index = this._items.length) {
    if (index >= 0 && index <= this._items.length) {
      if (!Array.isArray(item)) {
        item = [item];
      }
      const items = this._normalizeDataItems(item);
      this._items.splice(index, 0, ...items);
      this.plotItems();
      this.setIndex(this._index);
    } else {
      throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
    }
  }
  remove(target) {
    if (this.hasItems && target.assignedID) {
      const itemWrappers = this.itemWrappers;
      for (let i = 0; i < this._items.length; i++) {
        let item = this._items[i];
        if (itemWrappers[i] && itemWrappers[i].component.isAlive) {
          item = itemWrappers[i].component;
        }
        if (target.assignedID === item.assignedID) {
          return this.removeAt(i);
        }
      }
    } else {
      throw new Error("remove: item not found");
    }
  }
  removeAt(index, amount = 1) {
    if (index < 0 && index >= this._items.length) {
      throw new Error("removeAt: The index " + index + " is out of bounds " + this._items.length);
    }
    const item = this._items[index];
    this._items.splice(index, amount);
    this.plotItems();
    return item;
  }
  reload(item) {
    this.clear();
    this.add(item);
  }
  plotItems(items, options) {
  }
  reposition(time = 70) {
    if (this._repositionDebounce) {
      clearTimeout(this._repositionDebounce);
    }
    this._repositionDebounce = setTimeout(() => {
      this.repositionItems();
    }, time);
  }
  repositionItems() {
    this.signal("onItemsRepositioned");
  }
  up() {
    return this._attemptNavigation(-1, 1);
  }
  down() {
    return this._attemptNavigation(1, 1);
  }
  left() {
    return this._attemptNavigation(-1, 0);
  }
  right() {
    return this._attemptNavigation(1, 0);
  }
  first() {
    return this.setIndex(0);
  }
  last() {
    return this.setIndex(this._items.length - 1);
  }
  next() {
    return this.setIndex(this._index + 1);
  }
  previous() {
    return this.setIndex(this._index - 1);
  }
  _attemptNavigation(shift, direction) {
    if (this.hasItems) {
      return this.navigate(shift, direction);
    }
    return false;
  }
  navigate(shift, direction = this._direction) {
    if (direction !== this._direction) {
      return false;
    }
    return this.setIndex(this._index + shift);
  }
  scrollCollectionWrapper(obj) {
    let { previousIndex: previous, index: target, dataLength: max, mainIndex, previousMainIndex, lines } = obj;
    if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
      previous = previousMainIndex;
      target = mainIndex;
      max = lines;
    }
    const { directionIsRow, main, mainDim, mainMarginFrom, mainMarginTo } = this._getPlotProperties(this._direction);
    const cw = this.currentItemWrapper;
    let bound = this[mainDim];
    if (bound === 0) {
      bound = directionIsRow ? 1920 : 1080;
    }
    const offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
    const sizes = this._getItemSizes(cw);
    const marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
    const marginTo = sizes[mainMarginTo] || sizes.margin || 0;
    let scroll = this._scroll;
    if (!isNaN(scroll)) {
      if (scroll >= 0 && scroll <= 1) {
        scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
      } else {
        scroll = scroll - cw[main];
      }
    } else if (typeof scroll === "function") {
      scroll = scroll.apply(this, [cw, obj]);
    } else if (typeof scroll === "object") {
      const { jump = false, after = false, backward = 0, forward = 1 } = scroll;
      if (jump) {
        let mod = target % jump;
        if (mod === 0) {
          scroll = marginFrom - cw[main];
        }
        if (mod === jump - 1) {
          const actualSize = marginFrom + cw[mainDim] + marginTo;
          scroll = mod * actualSize + marginFrom - cw[main];
        }
      } else if (after) {
        scroll = 0;
        if (target >= after - 1) {
          const actualSize = marginFrom + cw[mainDim] + marginTo;
          scroll = (after - 1) * actualSize + marginFrom - cw[main];
        }
      } else {
        const backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
        const forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
        if (target < max - 1 && (previous < target && offset + cw[main] + cw[mainDim] > forwardBound)) {
          scroll = forwardBound - (cw[main] + cw[mainDim]);
        } else if (target > 0 && (target < previous && offset + cw[main] < backwardBound)) {
          scroll = backwardBound - cw[main];
        } else if (target === max - 1) {
          scroll = bound - (cw[main] + cw[mainDim]);
        } else if (target === 0) {
          scroll = marginFrom - cw[main];
        }
      }
    } else if (isNaN(scroll)) {
      if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
        scroll = bound - (cw[main] + cw[mainDim]);
      } else if (target < previous && offset + cw[main] < 0) {
        scroll = marginFrom - cw[main];
      }
    }
    if (this.active && !isNaN(scroll) && this._scrollTransition) {
      if (this._scrollTransition.isRunning()) {
        this._scrollTransition.reset(scroll, 0.05);
      } else {
        this._scrollTransition.start(scroll);
      }
    } else if (!isNaN(scroll)) {
      this.wrapper[main] = scroll;
    }
  }
  $childInactive({ child }) {
    if (typeof child === "object") {
      const index = child.componentIndex;
      for (let key in this._items[index]) {
        if (child.component[key] !== void 0) {
          this._items[index][key] = child.component[key];
        }
      }
    }
    this._collectGarbage();
  }
  $getChildComponent({ index }) {
    return this._items[index];
  }
  _resizeWrapper(crossSize) {
    let obj = crossSize;
    if (!isNaN(crossSize)) {
      const { main, mainDim, crossDim } = this._getPlotProperties(this._direction);
      const lastItem = this.wrapper.childList.last;
      obj = {
        [mainDim]: lastItem[main] + lastItem[mainDim],
        [crossDim]: crossSize
      };
    }
    this.wrapper.patch(obj);
    if (this._autoResize) {
      this.patch(obj);
    }
  }
  _generateUniqueID() {
    let id = "";
    while (this._uids[id] || id === "") {
      id = Math.random().toString(36).substr(2, 9);
    }
    this._uids[id] = true;
    return id;
  }
  _getPlotProperties(direction) {
    const directionIsRow = direction === 0;
    return {
      directionIsRow: directionIsRow ? true : false,
      mainDirection: directionIsRow ? "rows" : "columns",
      main: directionIsRow ? "x" : "y",
      mainDim: directionIsRow ? "w" : "h",
      mainMarginTo: directionIsRow ? "marginRight" : "marginBottom",
      mainMarginFrom: directionIsRow ? "marginLeft" : "marginTop",
      crossDirection: !directionIsRow ? "columns" : "rows",
      cross: directionIsRow ? "y" : "x",
      crossDim: directionIsRow ? "h" : "w",
      crossMarginTo: directionIsRow ? "marginBottom" : "marginRight",
      crossMarginFrom: directionIsRow ? "marginTop" : "marginLeft"
    };
  }
  _getItemSizes(item) {
    const itemType = item.type;
    if (item.component && item.component.__attached) {
      item = item.component;
    }
    return {
      w: item.w || itemType && itemType["width"],
      h: item.h || itemType && itemType["height"],
      margin: item.margin || itemType && itemType["margin"] || 0,
      marginLeft: item.marginLeft || itemType && itemType["marginLeft"],
      marginRight: item.marginRight || itemType && itemType["marginRight"],
      marginTop: item.marginTop || itemType && itemType["marginTop"],
      marginBottom: item.marginBottom || itemType && itemType["marginBottom"]
    };
  }
  _collectGarbage(immediate) {
    this._gcIncrement++;
    if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
      this._gcIncrement = 0;
      this.stage.gc();
    }
  }
  _normalizeDataItems(array) {
    return array.map((item, index) => {
      return this._normalizeDataItem(item) || index;
    }).filter((item) => {
      if (!isNaN(item)) {
        console.warn(`Item at index: ${item}, is not a valid item. Removing it from dataset`);
        return false;
      }
      return true;
    });
  }
  _normalizeDataItem(item, index) {
    if (typeof item === "string" || typeof item === "number") {
      item = { label: item.toString() };
    }
    if (typeof item === "object") {
      let id = this._generateUniqueID();
      return { assignedID: id, type: this.itemType, collectionWrapper: this, isAlive: false, ...item };
    }
    return index;
  }
  _normalizePixelToPercentage(value, max) {
    if (value && value > 1) {
      return value / max;
    }
    return value || 0;
  }
  _getFocused() {
    if (this.hasItems) {
      return this.currentItemWrapper;
    }
    return this;
  }
  _handleRight() {
    return this.right();
  }
  _handleLeft() {
    return this.left();
  }
  _handleUp() {
    return this.up();
  }
  _handleDown() {
    return this.down();
  }
  _inactive() {
    if (this._repositionDebounce) {
      clearTimeout(this._repositionDebounce);
    }
    this._collectGarbage(true);
  }
  static get itemType() {
    return void 0;
  }
  set forceLoad(bool) {
    this._forceLoad = bool;
  }
  get forceLoad() {
    return this._forceLoad;
  }
  get requestingItems() {
    return this._requestingItems;
  }
  set requestThreshold(num) {
    this._requestThreshold = num;
  }
  get requestThreshold() {
    return this._requestThreshold;
  }
  set enableRequests(bool) {
    this._requestsEnabled = bool;
  }
  get enableRequests() {
    return this._requestsEnabled;
  }
  set gcThreshold(num) {
    this._gcThreshold = num;
  }
  get gcThreshold() {
    return this._gcThreshold;
  }
  get wrapper() {
    return this.tag("Wrapper");
  }
  get hasItems() {
    return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
  }
  get currentItemWrapper() {
    return this.wrapper.children[this._index];
  }
  get currentItem() {
    return this.currentItemWrapper && this.currentItemWrapper.component || void 0;
  }
  set direction(string) {
    this._direction = CollectionWrapper.DIRECTION[string] || CollectionWrapper.DIRECTION.row;
  }
  get direction() {
    return Object.keys(CollectionWrapper.DIRECTION)[this._direction];
  }
  set items(array) {
    this.clear();
    this.add(array);
  }
  get items() {
    const itemWrappers = this.itemWrappers;
    return this._items.map((item, index) => {
      if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
        return itemWrappers[index].component;
      }
      return item;
    });
  }
  get length() {
    return this._items.length;
  }
  set index(index) {
    this.setIndex(index);
  }
  get itemWrappers() {
    return this.wrapper.children;
  }
  get index() {
    return this._index;
  }
  set scrollTransition(obj) {
    this._scrollTransitionSettings.patch(obj);
    if (this.active) {
      this._updateScrollTransition();
    }
  }
  get scrollTransition() {
    return this._scrollTransition;
  }
  set scroll(value) {
    this._scroll = value;
  }
  get scroll() {
    return this._scroll;
  }
  set autoResize(bool) {
    this._autoResize = bool;
  }
  get autoResize() {
    return this._autoResize;
  }
  set spacing(num) {
    this._spacing = num;
  }
  get spacing() {
    return this._spacing;
  }
}
CollectionWrapper.DIRECTION = {
  row: 0,
  column: 1
};
class Cursor extends lightning.Component {
  static _template() {
    return {
      alpha: 0
    };
  }
  _construct() {
    this._blink = true;
  }
  _init() {
    this._blinkAnimation = this.animation({ duration: 1, repeat: -1, actions: [
      { p: "alpha", v: { 0: 0, 0.5: 1, 1: 0 } }
    ] });
  }
  show() {
    if (this._blink) {
      this._blinkAnimation.start();
    } else {
      this.alpha = 1;
    }
  }
  hide() {
    if (this._blink) {
      this._blinkAnimation.stop();
    } else {
      this.alpha = 0;
    }
  }
  set blink(bool) {
    this._blink = bool;
    if (this.active) {
      if (bool) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  get blink() {
    return this._blink;
  }
}
class ItemWrapper extends lightning.Component {
  static _template() {
    return {
      clipbox: true
    };
  }
  create() {
    if (this.children.length > 0) {
      return;
    }
    const component = this.fireAncestors("$getChildComponent", { index: this.componentIndex });
    component.isAlive = true;
    const { w, h, margin, marginTop, marginBottom, marginRight, marginLeft } = this;
    this.children = [{ ...component, w, h, margin, marginTop, marginRight, marginLeft, marginBottom }];
    if (this.hasFocus()) {
      this._refocus();
    }
  }
  get component() {
    return this.children[0] || this.fireAncestors("$getChildComponent", { index: this.componentIndex });
  }
  _setup() {
    if (this.forceLoad) {
      this.create();
    }
  }
  _active() {
    this.create();
  }
  _inactive() {
    if (!this.forceLoad) {
      this.children[0].isAlive = false;
      this.fireAncestors("$childInactive", { child: this });
      this.childList.clear();
    }
  }
  _getFocused() {
    return this.children && this.children[0] || this;
  }
}
class KeyWrapper extends lightning.Component {
  static _template() {
    return {
      clipbox: true
    };
  }
  _update() {
    let currentKey = this.children && this.children[0];
    if (currentKey && currentKey.action === this._key.data.action) {
      currentKey.patch({
        ...this._key
      });
    } else {
      this.children = [{ type: this._key.keyType, ...this._key }];
    }
    if (this.hasFocus()) {
      this._refocus();
    }
  }
  set key(obj) {
    this._key = obj;
    if (this.active) {
      this._update();
    }
  }
  get key() {
    return this._key;
  }
  _active() {
    this._update();
  }
  _inactive() {
    this.childList.clear();
  }
  _getFocused() {
    return this.children && this.children[0] || this;
  }
}
const limitWithinRange = (num, min, max) => {
  return Math.min(Math.max(num, min), max);
};
const defineProperties = (component, props) => {
  props.forEach((prop) => {
    Object.defineProperty(component, prop, {
      set: function(value) {
        component[`_${prop}`] = value;
      },
      get: function() {
        return component[`_${prop}`];
      }
    });
  });
};
const findIndexOfObject = (array, search, targetProp) => {
  for (let i = 0; i < array.length; i++) {
    if (array[i][targetProp] === search) {
      return i;
    }
  }
  return -1;
};
class Grid extends CollectionWrapper {
  _construct() {
    this._crossSpacing = 5;
    this._mainSpacing = 5;
    this._rows = 0;
    this._columns = 0;
    super._construct();
  }
  clear() {
    super.clear();
    this._mainIndex = 0;
    this._crossIndex = 0;
    this._previous = void 0;
  }
  setIndex(index) {
    const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
    const previousIndex = this._index;
    const { mainIndex: previousMainIndex, crossIndex: previousCrossIndex } = this._findLocationOfIndex(this._index);
    const { mainIndex, crossIndex } = this._findLocationOfIndex(targetIndex);
    this._mainIndex = mainIndex;
    this._crossIndex = crossIndex;
    this._previous = { mainIndex, crossIndex, realIndex: previousIndex };
    this._index = targetIndex;
    this._indexChanged({ previousIndex, index: targetIndex, mainIndex, previousMainIndex, crossIndex, previousCrossIndex, lines: this._lines.length, dataLength: this._items.length });
  }
  _findLocationOfIndex(index) {
    for (let i = 0; i < this._lines.length; i++) {
      if (this._lines[i].includes(index)) {
        return { mainIndex: i, crossIndex: this._lines[i].indexOf(index) };
      }
    }
    return { mainIndex: -1, crossIndex: -1 };
  }
  plotItems() {
    const items = this._items;
    const wrapper = this.wrapper;
    const { directionIsRow, mainDirection: mainDirection2, main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim, crossMarginTo, crossMarginFrom } = this._getPlotProperties(this._direction);
    const crossSize = this[crossDim];
    let mainPos = 0, crossPos = 0, lineIndex = 0;
    const animateItems = [];
    const viewboundMain = directionIsRow ? 1920 : 1080;
    const viewboundCross = directionIsRow ? 1080 : 1920;
    const renderContext = this.core.renderContext;
    this._lines = [[]];
    let cl = [];
    const newChildren = items.map((item, index) => {
      const sizes = this._getItemSizes(item);
      const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
      if (index === 0) {
        mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
      }
      if (cl.length > 0 && (this[mainDirection2] > 0 && this[mainDirection2] === cl.length || this[mainDirection2] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
        const bil = this._getBiggestInLine(cl);
        mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
        crossPos = targetCrossFromMargin;
        this._lines.push([]);
        cl = [];
        lineIndex++;
      } else {
        crossPos += targetCrossFromMargin;
      }
      const ref = `IW-${item.assignedID}`;
      let tmp = mainPos;
      let tcp = crossPos;
      const existingItemWrapper = wrapper.tag(ref);
      if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext[`p${main}`] + wrapper[main] + mainPos <= viewboundMain || renderContext[`p${cross}`] + wrapper[cross] + crossPos <= viewboundCross))) {
        tmp = existingItemWrapper[main];
        tcp = existingItemWrapper[cross];
        animateItems.push(index);
      }
      const newItem2 = {
        ref,
        type: ItemWrapper,
        componentIndex: index,
        forceLoad: this._forceLoad,
        ...sizes,
        [`assigned${main.toUpperCase()}`]: mainPos,
        [`assigned${cross.toUpperCase()}`]: crossPos,
        [main]: tmp,
        [cross]: tcp
      };
      crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
      this._lines[lineIndex].push(index);
      cl.push(newItem2);
      return newItem2;
    });
    wrapper.children = newChildren;
    animateItems.forEach((index) => {
      const item = wrapper.children[index];
      item.patch({
        smooth: { x: item.assignedX, y: item.assignedY }
      });
    });
    const biggestInLastLine = this._getBiggestInLine(cl);
    this._resizeWrapper({
      [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
      [crossDim]: crossSize
    });
  }
  repositionItems() {
    const wrapper = this.wrapper;
    if (!wrapper && wrapper.children.length) {
      return true;
    }
    const { main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim, crossMarginTo, crossMarginFrom } = this._getPlotProperties(this._direction);
    const crossSize = this[crossDim];
    let mainPos = 0, crossPos = 0, lineIndex = 0;
    let cl = [];
    this.lines = [[]];
    wrapper.children.forEach((item, index) => {
      const sizes = this._getItemSizes(item);
      const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
      if (index === 0) {
        mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
      }
      if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
        const bil = this._getBiggestInLine(cl);
        mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
        crossPos = targetCrossFromMargin;
        this._lines.push([]);
        cl = [];
        lineIndex++;
      } else {
        crossPos += targetCrossFromMargin;
      }
      item.patch({
        [`assigned${main.toUpperCase()}`]: mainPos,
        [`assigned${cross.toUpperCase()}`]: crossPos,
        [main]: mainPos,
        [cross]: crossPos
      });
      crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
      this._lines[lineIndex].push(index);
      cl.push(newItem);
    });
    const biggestInLastLine = this._getBiggestInLine(cl);
    this._resizeWrapper({
      [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
      [crossDim]: crossSize
    });
    super.repositionItems();
  }
  _getBiggestInLine(line) {
    const { mainDim } = this._getPlotProperties(this._direction);
    return line.reduce((biggestItem, newItem2) => {
      if (newItem2[mainDim] > biggestItem[mainDim]) {
        return newItem2;
      }
      return biggestItem;
    });
  }
  navigate(shift, direction) {
    const { directionIsRow, cross, crossDim } = this._getPlotProperties(this._direction);
    const overCross = directionIsRow && direction === CollectionWrapper.DIRECTION.column || !directionIsRow && direction === CollectionWrapper.DIRECTION.row;
    let targetMainIndex = this._mainIndex + !!!overCross * shift;
    let targetCrossIndex = this._crossIndex + !!overCross * shift;
    let targetIndex = this._index;
    if (overCross && targetCrossIndex > -1 && targetCrossIndex <= this._lines[targetMainIndex].length) {
      if (this._lines[targetMainIndex][targetCrossIndex] !== void 0) {
        targetIndex = this._lines[targetMainIndex][targetCrossIndex];
        this._previous = void 0;
      }
    } else if (!overCross && targetMainIndex < this._lines.length && targetMainIndex > -1) {
      const targetLine = this._lines[targetMainIndex];
      if (this._previous && this._previous.mainIndex === targetMainIndex) {
        targetIndex = this._previous.realIndex;
        targetCrossIndex = this._previous.crossIndex;
      } else if (targetLine) {
        const currentItem = this.currentItemWrapper;
        const m = targetLine.map((item) => {
          const targetItem = this.wrapper.children[item];
          if (targetItem[cross] <= currentItem[cross] && currentItem[cross] <= targetItem[cross] + targetItem[crossDim]) {
            return targetItem[cross] + targetItem[crossDim] - currentItem[cross];
          }
          if (targetItem[cross] >= currentItem[cross] && targetItem[cross] <= currentItem[cross] + currentItem[crossDim]) {
            return currentItem[cross] + currentItem[crossDim] - targetItem[cross];
          }
          return -1;
        });
        let acc = -1;
        let t = -1;
        for (let i = 0; i < m.length; i++) {
          if (m[i] === -1 && acc > -1) {
            break;
          }
          if (m[i] > acc) {
            acc = m[i];
            t = i;
          }
        }
        if (t > -1) {
          targetCrossIndex = t;
          targetIndex = targetLine[t];
        }
      }
      this._previous = { mainIndex: this._mainIndex, crossIndex: this._crossIndex, realIndex: this._index };
    }
    if (this._index !== targetIndex) {
      this.setIndex(targetIndex);
      return true;
    }
    return false;
  }
  set rows(num) {
    this._rows = num;
    this.direction = "row";
  }
  get rows() {
    return this._rows;
  }
  set columns(num) {
    this._columns = num;
    this.direction = "column";
  }
  get columns() {
    return this._columns;
  }
  set crossSpacing(num) {
    this._crossSpacing = num;
  }
  get crossSpacing() {
    return this._crossSpacing;
  }
  set mainSpacing(num) {
    this._mainSpacing = num;
  }
  get mainSpacing() {
    return this._mainSpacing;
  }
  set spacing(num) {
    this._spacing = num;
    this._mainSpacing = num;
    this._crossSpacing = num;
  }
}
class InputField extends lightning.Component {
  static _template() {
    return {
      PreLabel: { renderOffscreen: true },
      PostLabel: { renderOffscreen: true },
      Cursor: { type: Cursor, rect: true, w: 4, h: 54, x: 0, y: 0 }
    };
  }
  _construct() {
    this._input = "";
    this._previousInput = "";
    this._description = "";
    this._cursorX = 0;
    this._cursorIndex = 0;
    this._passwordMask = "*";
    this._passwordMode = false;
    this._autoHideCursor = true;
    this._labelPositionStatic = true;
    this._maxLabelWidth = 0;
  }
  _init() {
    this.tag("PreLabel").on("txLoaded", () => {
      this._labelTxLoaded();
    });
    this.tag("PostLabel").on("txLoaded", () => {
      this._labelTxLoaded;
    });
  }
  onInputChanged({ input = "" }) {
    let targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
    this._input = input;
    this._update(targetIndex);
  }
  toggleCursor(bool = !this._cursorVisible) {
    this._cursorVisible = bool;
    this.cursor[bool ? "show" : "hide"]();
  }
  _labelTxLoaded() {
    const preLabel = this.tag("PreLabel");
    const cursor = this.tag("Cursor");
    const postLabel = this.tag("PostLabel");
    this.h = preLabel.renderHeight || postLabel.renderHeight;
    cursor.x = preLabel.renderWidth + this._cursorX;
    postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
    this.setSmooth("x", this._labelOffset);
    if (!this.autoHideCursor) {
      this.toggleCursor(true);
    }
  }
  _update(index = 0) {
    const hasInput = this._input.length > 0;
    let pre = this._description + "";
    let post = "";
    if (hasInput) {
      pre = this._input.substring(0, index);
      post = this._input.substring(index, this._input.length);
      if (this._passwordMode) {
        pre = this._passwordMask.repeat(pre.length);
        post = this._passwordMask.repeat(post.length);
      }
      this.toggleCursor(true);
    } else if (this._autoHideCursor) {
      this.toggleCursor(false);
    }
    this.patch({
      PreLabel: { text: { text: pre } },
      PostLabel: { text: { text: post } }
    });
    if (this.h === 0) {
      this.tag("PreLabel").loadTexture();
      this.h = this.tag("PreLabel").renderHeight;
    }
    this._cursorIndex = index;
  }
  _handleRight() {
    this._update(Math.min(this._input.length, this._cursorIndex + 1));
  }
  _handleLeft() {
    this._update(Math.max(0, this._cursorIndex - 1));
  }
  _firstActive() {
    this._labelTxLoaded();
    this._update();
  }
  get input() {
    return this._input;
  }
  get hasInput() {
    return this._input.length > 0;
  }
  get cursorIndex() {
    return this._cursorIndex;
  }
  set inputText(obj) {
    this._inputText = obj;
    this.tag("PreLabel").patch({ text: obj });
    this.tag("PostLabel").patch({ text: obj });
  }
  get inputText() {
    return this._inputText;
  }
  set description(str) {
    this._description = str;
  }
  get description() {
    return this._description;
  }
  set cursor(obj) {
    if (obj.x) {
      this._cursorX = obj.x;
      delete obj.x;
    }
    this.tag("Cursor").patch(obj);
  }
  get cursor() {
    return this.tag("Cursor");
  }
  get cursorVisible() {
    return this._cursorVisible;
  }
  set autoHideCursor(bool) {
    this._autoHideCursor = bool;
  }
  get autoHideCursor() {
    return this._autoHideCursor;
  }
  set passwordMode(val) {
    this._passwordMode = val;
  }
  get passwordMode() {
    return this._passwordMode;
  }
  set passwordMask(str) {
    this._passwordMask = str;
  }
  get passwordmask() {
    return this._passwordMask;
  }
  // the width at which the text start scrolling
  set maxLabelWidth(val) {
    this._maxLabelWidth = val;
  }
  get maxLabelWidth() {
    return this._maxLabelWidth;
  }
  set labelPositionStatic(val) {
    this._labelPositionStatic = val;
  }
  get labelPositionStatic() {
    return this._labelPositionStatic;
  }
  get _labelOffset() {
    if (this._labelPositionStatic)
      return 0;
    let offset = this.maxLabelWidth - this.tag("Cursor").x;
    return offset < 0 ? offset : 0;
  }
}
let Key$1 = class Key extends lightning.Component {
  static _template() {
    return {
      Background: {
        w: (w) => w,
        h: (h) => h,
        rect: true
      },
      Label: {
        mount: 0.5,
        x: (w) => w / 2,
        y: (h) => h / 2
      }
    };
  }
  _construct() {
    this._backgroundColors = {};
    this._labelColors = {};
  }
  set data(obj) {
    this._data = obj;
    this._update();
  }
  get data() {
    return this._data;
  }
  set labelText(obj) {
    this._labelText = obj;
    this.tag("Label").patch({ text: obj });
  }
  get labelText() {
    return this._labelText;
  }
  set label(obj) {
    this.tag("Label").patch(obj);
  }
  get label() {
    return this.tag("Label");
  }
  set labelColors(obj) {
    this._labelColors = obj;
    this._update();
  }
  get labelColors() {
    return this._labelColors;
  }
  set backgroundColors(obj) {
    this._backgroundColors = obj;
    this._update();
  }
  get backgroundColors() {
    return this._backgroundColors;
  }
  set background(obj) {
    this.tag("Background").patch(obj);
  }
  get background() {
    return this.tag("Background");
  }
  _update() {
    if (!this.active) {
      return;
    }
    const { label = "" } = this._data;
    const hasFocus = this.hasFocus();
    let { focused, unfocused = 4278190080 } = this._backgroundColors;
    let { focused: labelFocused, unfocused: labelUnfocused = 4294967295 } = this._labelColors;
    this.patch({
      Background: { color: hasFocus && focused ? focused : unfocused },
      Label: { text: { text: label }, color: hasFocus && labelFocused ? labelFocused : labelUnfocused }
    });
  }
  _firstActive() {
    this._update();
  }
  _focus() {
    let { focused, unfocused = 4278190080 } = this._backgroundColors;
    let { focused: labelFocused, unfocused: labelUnfocused = 4294967295 } = this._labelColors;
    this.patch({
      Background: { smooth: { color: focused || unfocused } },
      Label: { smooth: { color: labelFocused || labelUnfocused } }
    });
  }
  _unfocus() {
    let { unfocused = 4278190080 } = this._backgroundColors;
    let { unfocused: labelUnfocused = 4294967295 } = this._labelColors;
    this.patch({
      Background: { smooth: { color: unfocused } },
      Label: { smooth: { color: labelUnfocused } }
    });
  }
  static get width() {
    return 80;
  }
  static get height() {
    return 80;
  }
};
class Keyboard extends lightning.Component {
  static _template() {
    return {
      Keys: { w: (w) => w }
    };
  }
  _construct() {
    this._input = "";
    this._inputField = void 0;
    this._maxCharacters = 56;
    this.navigationWrapAround = false;
    this.resetFocus();
  }
  resetFocus() {
    this._columnIndex = 0;
    this._rowIndex = 0;
    this._previousKey = null;
  }
  _setup() {
    this._keys = this.tag("Keys");
    this._update();
  }
  _update() {
    const { layouts, buttonTypes = {}, styling = {} } = this._config;
    if (!this._layout || this._layout && layouts[this._layout] === void 0) {
      console.error(`Configured layout "${this._layout}" does not exist. Picking first available: "${Object.keys(layouts)[0]}"`);
      this._layout = Object.keys(layouts)[0];
    }
    const { horizontalSpacing = 0, verticalSpacing = 0, align = "left" } = styling;
    let rowPosition = 0;
    const isEvent = /^[A-Z][A-Za-z0-9]{1}/;
    const hasLabel = /\:/;
    if (buttonTypes.default === void 0) {
      buttonTypes.default = Key$1;
    }
    this._keys.children = layouts[this._layout].map((row, rowIndex) => {
      const {
        x = 0,
        margin = 0,
        marginRight,
        marginLeft,
        marginTop,
        marginBottom,
        spacing: rowHorizontalSpacing = horizontalSpacing || 0,
        align: rowAlign = align
      } = styling[`Row${rowIndex + 1}`] || {};
      let keyPosition = 0;
      let rowHeight = 0;
      const rowKeys = row.map((key, keyIndex) => {
        const origin = key;
        let keyType = buttonTypes.default;
        let action = "Input";
        let label = key;
        if (isEvent.test(key)) {
          if (hasLabel.test(key)) {
            key = key.split(":");
            label = key[1].toString();
            key = key[0];
          }
          if (buttonTypes[key]) {
            keyType = buttonTypes[key];
            action = key.action || key;
          }
        }
        const keySpacing = keyType.margin || keyType.type.margin;
        const {
          w = keyType.type.width || 0,
          h = keyType.type.height || 0,
          marginLeft: marginLeft2 = keyType.type.marginLeft || keySpacing || 0,
          marginRight: marginRight2 = keyType.type.marginRight || keySpacing || rowHorizontalSpacing
        } = keyType;
        rowHeight = h > rowHeight ? h : rowHeight;
        const currentPosition2 = keyPosition + marginLeft2;
        keyPosition += marginLeft2 + w + marginRight2;
        return { ref: `Key-{${keyIndex + 1}}`, type: KeyWrapper, keyboard: this, x: currentPosition2, w, h, key: { data: { origin, key, label, action }, w, h, ...keyType } };
      });
      let rowOffset = x + (marginLeft || margin);
      let rowMount = 0;
      if (this.w && rowAlign === "center") {
        rowOffset = this.w / 2;
        rowMount = 0.5;
      }
      if (this.w && rowAlign === "right") {
        rowOffset = this.w - (marginRight || margin);
        rowMount = 1;
      }
      const currentPosition = rowPosition + (marginTop || margin);
      rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
      return {
        ref: `Row-${rowIndex + 1}`,
        x: rowOffset,
        mountX: rowMount,
        w: keyPosition,
        y: currentPosition,
        children: rowKeys
      };
    });
    this._refocus();
  }
  _getFocused() {
    return this.currentKeyWrapper || this;
  }
  _handleRight() {
    return this.navigate("row", 1);
  }
  _handleLeft() {
    return this.navigate("row", -1);
  }
  _handleUp() {
    return this.navigate("column", -1);
  }
  _handleDown() {
    return this.navigate("column", 1);
  }
  _handleKey({ key, code = "CustomKey" }) {
    if (code === "Backspace" && this._input.length === 0) {
      return false;
    }
    if (key === " ") {
      key = "Space";
    }
    const targetFound = this._findKey(key);
    if (targetFound) {
      this._handleEnter();
    }
    return targetFound;
  }
  _findKey(str) {
    const rows = this._config.layouts[this._layout];
    let i = 0, j = 0;
    for (; i < rows.length; i++) {
      for (j = 0; j < rows[i].length; j++) {
        let key = rows[i][j];
        if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
          this._rowIndex = i;
          this._columnIndex = j;
          return true;
        }
      }
    }
    return false;
  }
  _handleEnter() {
    const { origin, action } = this.currentKey.data;
    const event = {
      index: this._input.length,
      key: origin
    };
    if (this._inputField && this._inputField.cursorIndex) {
      event.index = this._inputField.cursorIndex;
    }
    if (action !== "Input") {
      const split = event.key.split(":");
      const call = `on${split[0]}`;
      const eventFunction = this[call];
      event.key = split[1];
      if (eventFunction && eventFunction.apply && eventFunction.call) {
        eventFunction.call(this, event);
      }
      this.signal(call, { input: this._input, keyboard: this, ...event });
    } else {
      this.addAt(event.key, event.index);
    }
  }
  _changeInput(input) {
    if (input.length > this._maxCharacters) {
      return;
    }
    const eventData = {
      previousInput: this._input,
      input: this._input = input
    };
    if (this._inputField && this._inputField.onInputChanged) {
      this._inputField.onInputChanged(eventData);
    }
    this.signal("onInputChanged", eventData);
  }
  focus(str) {
    this._findKey(str);
  }
  add(str) {
    this._changeInput(this._input + str);
  }
  addAt(str, index) {
    if (index > this._input.length - 1) {
      this.add(str);
    } else if (index > -1) {
      this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
    }
  }
  remove() {
    this._changeInput(this._input.substring(0, this._input.length - 1));
  }
  removeAt(index) {
    if (index > this._input.length - 1) {
      this.remove();
    } else if (index > -1) {
      this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
    }
  }
  clear() {
    this._changeInput("");
  }
  layout(key) {
    if (key === this._layout) {
      return;
    }
    this._layout = key;
    if (this.attached) {
      this.resetFocus();
      this._update();
    }
  }
  inputField(component) {
    if (component && component.isComponent) {
      this._rowIndex = 0;
      this._columnIndex = 0;
      this._input = component.input !== void 0 ? component.input : "";
      this._inputField = component;
    } else {
      this._rowIndex = 0;
      this._columnIndex = 0;
      this._input = "";
      this._inputField = void 0;
    }
  }
  navigate(direction, shift) {
    const targetIndex = (direction === "row" ? this._columnIndex : this._rowIndex) + shift;
    const currentRow = this.rows[this._rowIndex];
    if (direction === "row" && targetIndex > -1 && targetIndex < currentRow.children.length) {
      this._previous = null;
      return this._columnIndex = targetIndex;
    } else if (direction === "row" && this.navigationWrapAround) {
      this._previous = null;
      let rowLen = currentRow.children.length;
      return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
    }
    if (direction === "column" && targetIndex > -1 && targetIndex < this.rows.length) {
      const currentRowIndex = this._rowIndex;
      const currentColumnIndex = this._columnIndex;
      if (this._previous && this._previous.row === targetIndex) {
        const tmp = this._previous.column;
        this._previous.column = this._columnIndex;
        this._columnIndex = tmp;
        this._rowIndex = this._previous.row;
      } else {
        const targetRow = this.rows[targetIndex];
        const currentKey = this.currentKeyWrapper;
        const currentRow2 = this.rows[this._rowIndex];
        const currentX = currentRow2.x - currentRow2.w * currentRow2.mountX + currentKey.x;
        const m = targetRow.children.map((key) => {
          const keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
          if (keyX <= currentX && currentX < keyX + key.w) {
            return keyX + key.w - currentX;
          }
          if (keyX >= currentX && keyX <= currentX + currentKey.w) {
            return currentX + currentKey.w - keyX;
          }
          return -1;
        });
        let acc = -1;
        let t = -1;
        for (let i = 0; i < m.length; i++) {
          if (m[i] === -1 && acc > -1) {
            break;
          }
          if (m[i] > acc) {
            acc = m[i];
            t = i;
          }
        }
        if (t > -1) {
          this._rowIndex = targetIndex;
          this._columnIndex = t;
        } else if (this.navigationWrapAround) {
          this._columnIndex = Math.min(this.rows[0].children.length - 1, this._columnIndex);
          return this._rowIndex = 0;
        }
      }
      if (this._rowIndex !== currentRowIndex) {
        this._previous = { column: currentColumnIndex, row: currentRowIndex };
        return this._rowIndex = targetIndex;
      }
    } else if (direction === "column" && this.navigationWrapAround) {
      this._previous = { column: this._columnIndex, row: this._rowIndex };
      let nrRows = this.rows.length;
      this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
      this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
    }
    return false;
  }
  onSpace({ index }) {
    this.addAt(" ", index);
  }
  onBackspace({ index }) {
    this.removeAt(index);
  }
  onClear() {
    this.clear();
  }
  onLayout({ key }) {
    this.layout(key);
  }
  set config(obj) {
    this._config = obj;
    if (this.active) {
      this._update();
    }
  }
  get config() {
    return this._config;
  }
  set currentInputField(component) {
    this.inputField(component);
  }
  get currentInputField() {
    return this._inputField;
  }
  set currentLayout(str) {
    this.layout(str);
  }
  get currentLayout() {
    return this._layout;
  }
  set maxCharacters(num) {
    this._maxCharacters = num;
  }
  get maxCharacters() {
    return this._maxCharacters;
  }
  get rows() {
    return this._keys && this._keys.children;
  }
  get currentKeyWrapper() {
    return this.rows && this.rows[this._rowIndex].children[this._columnIndex];
  }
  get currentKey() {
    return this.currentKeyWrapper && this.currentKeyWrapper.key;
  }
}
class List extends CollectionWrapper {
  plotItems() {
    const items = this._items;
    const wrapper = this.wrapper;
    const { directionIsRow, main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim } = this._getPlotProperties(this._direction);
    let crossPos = 0, crossSize = 0, position = 0;
    const animateItems = [];
    const viewboundMain = directionIsRow ? 1920 : 1080;
    const viewboundCross = directionIsRow ? 1080 : 1920;
    const renderContext = this.core.renderContext;
    const newChildren = items.map((item, index) => {
      const sizes = this._getItemSizes(item);
      position += sizes[mainMarginFrom] || sizes.margin || 0;
      if (crossSize < sizes[crossDim]) {
        crossSize = sizes[crossDim];
      }
      const ref = `IW-${item.assignedID}`;
      let mainPos = position;
      crossPos = item[cross] || crossPos;
      let tmp = mainPos;
      let tcp = crossPos;
      const existingItemWrapper = wrapper.tag(ref);
      if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext[`p${main}`] + wrapper[main] + mainPos <= viewboundMain || renderContext[`p${cross}`] + wrapper[cross] + crossPos <= viewboundCross))) {
        tmp = existingItemWrapper[main];
        tcp = existingItemWrapper[cross];
        animateItems.push(index);
      }
      position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
      return {
        ref,
        type: ItemWrapper,
        componentIndex: index,
        forceLoad: this._forceLoad,
        ...sizes,
        [`assigned${main.toUpperCase()}`]: mainPos,
        [`assigned${cross.toUpperCase()}`]: crossPos,
        [main]: tmp,
        [cross]: tcp
      };
    });
    wrapper.children = newChildren;
    animateItems.forEach((index) => {
      const item = wrapper.children[index];
      item.patch({
        smooth: { x: item.assignedX, y: item.assignedY }
      });
    });
    this._resizeWrapper(crossSize);
  }
  repositionItems() {
    const wrapper = this.wrapper;
    if (!wrapper && wrapper.children.length) {
      return true;
    }
    const { main, mainDim, mainMarginTo, mainMarginFrom, cross, crossDim } = this._getPlotProperties(this._direction);
    let crossPos = 0, crossSize = 0, position = 0;
    wrapper.children.forEach((item) => {
      const sizes = this._getItemSizes(item);
      position += sizes[mainMarginFrom] || sizes.margin || 0;
      crossPos = item[cross] || crossPos;
      if (crossSize < sizes[crossDim]) {
        crossSize = sizes[crossDim];
      }
      const mainPos = position;
      position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
      item.patch({
        [`assigned${main.toUpperCase()}`]: mainPos,
        [`assigned${cross.toUpperCase()}`]: 0,
        [main]: mainPos,
        [cross]: crossPos,
        ...sizes
      });
    });
    this._resizeWrapper(crossSize);
    super.repositionItems();
  }
}
class ScrollingLabel extends lightning.Component {
  static _template() {
    return {
      LabelClipper: {
        w: (w) => w,
        rtt: true,
        shader: { type: lightning.shaders.FadeOut },
        LabelWrapper: {
          Label: { renderOffscreen: true },
          LabelCopy: { renderOffscreen: true }
        }
      }
    };
  }
  _construct() {
    this._autoStart = true;
    this._scrollAnimation = false;
    this._fade = 30;
    this._spacing = 30;
    this._label = {};
    this._align = "left";
    this._animationSettings = {
      delay: 0.7,
      repeat: -1,
      stopMethod: "immediate"
    };
  }
  _init() {
    const label = this.tag("Label");
    label.on("txLoaded", () => {
      this._update(label);
      this._updateAnimation(label);
      if (this._autoStart) {
        this.start();
      }
    });
  }
  _update(label = this.tag("Label")) {
    const renderWidth = label.renderWidth;
    const noScroll = renderWidth <= this.renderWidth;
    let labelPos = 0;
    if (noScroll && this._align !== "left") {
      labelPos = (this.renderWidth - renderWidth) * ScrollingLabel.ALIGN[this._align];
    }
    this.tag("LabelClipper").patch({
      h: label.renderHeight,
      shader: {
        right: noScroll ? 0 : this._fade
      },
      LabelWrapper: {
        x: 0,
        Label: {
          x: labelPos
        },
        LabelCopy: {
          x: renderWidth + this._spacing
        }
      }
    });
  }
  _updateAnimation(label = this.tag("Label")) {
    if (this._scrollAnimation) {
      this._scrollAnimation.stopNow();
    }
    if (label.renderWidth > this.renderWidth) {
      if (!this._animationSettings.duration) {
        this._animationSettings.duration = label.renderWidth / 50;
      }
      this._scrollAnimation = this.animation({
        ...this._animationSettings,
        actions: [
          { t: "LabelWrapper", p: "x", v: { sm: 0, 0: 0, 1: -(label.renderWidth + this._spacing) } },
          { t: "LabelClipper", p: "shader.left", v: { 0: 0, 0.2: this._fade, 0.8: this._fade, 1: 0 } }
        ]
      });
    }
  }
  start() {
    if (this._scrollAnimation) {
      this._scrollAnimation.stopNow();
      this.tag("LabelCopy").patch({
        text: this._label
      });
      this._scrollAnimation.start();
    }
  }
  stop() {
    if (this._scrollAnimation) {
      this._scrollAnimation.stopNow();
      this.tag("LabelCopy").text = "";
    }
  }
  set label(obj) {
    if (typeof obj === "string") {
      obj = { text: obj };
    }
    this._label = { ...this._label, ...obj };
    this.tag("Label").patch({
      text: obj
    });
  }
  get label() {
    return this.tag("Label");
  }
  set align(pos) {
    this._align = pos;
  }
  get align() {
    return this._align;
  }
  set autoStart(bool) {
    this._autoStart = bool;
  }
  get autoStart() {
    return this._autoStart;
  }
  set repeat(num) {
    this.animationSettings = { repeat: num };
  }
  get repeat() {
    return this._animationSettings.repeat;
  }
  set delay(num) {
    this.animationSettings = { delay: num };
  }
  get delay() {
    return this._animationSettings.delay;
  }
  set duration(num) {
    this.animationSettings = { duration: num };
  }
  get duration() {
    return this._animationSettings.duration;
  }
  set animationSettings(obj) {
    this._animationSettings = { ...this._animationSettings, ...obj };
    if (this._scrollAnimation) {
      this._updateAnimation();
    }
  }
  get animationSettings() {
    return this._animationSettings;
  }
}
ScrollingLabel.ALIGN = {
  left: 0,
  center: 0.5,
  right: 1
};
const calcCarouselNavigation = (dir, current, min, max) => {
  let target = current + dir;
  if (target < min) {
    target = max;
  }
  if (target > max) {
    target = min;
  }
  return target;
};
class Stepper extends lightning.Component {
  static _template() {
    return {
      h: 80,
      w: 574,
      Focus: { alpha: 0, w: (w) => w, h: (h) => h, rect: true },
      Label: { x: 30, y: (h) => h * 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } },
      ValueWrapper: {
        x: (w) => w - 30,
        w: 200,
        h: (h) => h,
        mountX: 1,
        Value: { x: (w) => w * 0.5, y: (h) => h * 0.5, mountX: 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } }
      }
    };
  }
  _construct() {
    this._focusColor = 4278227525;
    this._labelColor = 4288519581;
    this._labelColorFocused = 4294967295;
    this._padding = 30;
    this._max = 100;
    this._min = 0;
    this._value = 50;
    this._options = void 0;
    this._label = "label";
    this._focusAnimation = null;
    defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "padding", "max", "min", "focusAnimation"]);
  }
  _update() {
    this.patch({
      Focus: { color: this._focusColor },
      Label: { x: this._padding, color: this._labelColor, text: { text: this._label } },
      ValueWrapper: {
        x: (w) => w - this._padding,
        Value: { color: this._labelColor, text: { text: this.optionValue || this.value } }
      }
    });
    if (this.hasFocus()) {
      this._focus();
    }
  }
  _createFocusAnimation() {
    this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
      { t: "Focus", p: "alpha", v: { 0: 0, 1: 1 } },
      { t: "Label", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
      { t: "ValueWrapper.Value", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } }
    ] });
  }
  _firstActive() {
    if (!this._focusAnimation) {
      this._createFocusAnimation();
    }
    this._update();
  }
  _navigate(dir) {
    this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
    const event = {
      value: this._value
    };
    if (this._options) {
      event.options = this._options;
    }
    this.fireAncestors("$onValueChanged", event);
    this.signal("onValueChanged", event);
  }
  _handleLeft() {
    this._navigate(-1);
  }
  _handleRight() {
    this._navigate(1);
  }
  _focus() {
    if (this._focusAnimation) {
      this._focusAnimation.start();
    }
  }
  _unfocus() {
    if (this._focusAnimation) {
      this._focusAnimation.stop();
    }
  }
  set label(str) {
    this._label = str;
    if (this.active) {
      this.tag("Label").text.text = str;
    }
  }
  get label() {
    return this._label;
  }
  set value(str) {
    this._value = str;
    if (this.active) {
      this.tag("Value").text.text = this.optionValue || this._value;
    }
  }
  get value() {
    return this._value;
  }
  get optionValue() {
    return this._options && this._options[this._value] && this._options[this._value].label || void 0;
  }
  set options(arr) {
    const refactor = arr.map((option) => {
      if (typeof option === "string") {
        return { label: option };
      }
      return option;
    });
    this._value = 0;
    this._options = refactor;
    this._max = refactor.length - 1;
    this._update();
  }
  get options() {
    return this._options;
  }
}
class ArrowStepper extends Stepper {
  static _template() {
    return {
      ...super._template(),
      ValueWrapper: {
        x: (w) => w - 30,
        w: 200,
        h: (h) => h,
        mountX: 1,
        ArrowLeft: { y: (h) => h * 0.5, mountY: 0.5 },
        Value: { x: (w) => w * 0.5, y: (h) => h * 0.5, mountX: 0.5, mountY: 0.5, text: { text: "", fontSize: 22 } },
        ArrowRight: { y: (h) => h * 0.5, x: (w) => w, mountY: 0.5, mountX: 1 }
      }
    };
  }
  _update() {
    this.patch({
      Focus: { color: this._focusColor },
      Label: { x: this._padding, color: this._labelColor, text: { text: this._label } },
      ValueWrapper: {
        x: (w) => w - this._padding,
        ArrowLeft: { color: this._labelColor },
        Value: { color: this._labelColor, text: { text: this.optionValue || this.value } },
        ArrowRight: { color: this._labelColor }
      }
    });
    if (this.hasFocus()) {
      this._focus();
    }
  }
  _createFocusAnimation() {
    this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
      { t: "Focus", p: "alpha", v: { 0: 0, 1: 1 } },
      { t: "ValueWrapper.ArrowLeft", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
      { t: "ValueWrapper.Value", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } },
      { t: "ValueWrapper.ArrowRight", p: "color", v: { 0: this._labelColor, 1: this._labelColorFocused } }
    ] });
  }
  _firstActive() {
    if (!this._focusAnimation) {
      this._createFocusAnimation();
    }
    const arrowLeft = this.tag("ArrowLeft");
    const arrowRight = this.tag("ArrowRight");
    if (!(arrowLeft.src !== void 0 && arrowLeft.text !== null)) {
      arrowLeft.text = { text: "◀", fontSize: 18 };
    }
    if (!(arrowRight.src !== void 0 && arrowRight.text !== null)) {
      arrowRight.text = { text: "▶", fontSize: 18 };
    }
    this._update();
  }
}
class ColorShift2 extends lightning.Component {
  static _template() {
    return {
      w: 574,
      h: 240,
      List: { type: List, w: (w) => w, h: (h) => h, forceLoad: true, spacing: 0, direction: "column" }
    };
  }
  _construct() {
    this._autoColorShift = true;
    this._focusColor = 4278227525;
    this._labelColor = 4288519581;
    this._labelColorFocused = 4294967295;
    this._options = [
      {
        type: "neutral",
        label: "normal"
      },
      {
        type: "protanopia",
        label: "Protanopia"
      },
      {
        type: "deuteranopia",
        label: "Deuteranopia"
      },
      {
        type: "tritanopia",
        label: "Tritanopia"
      },
      {
        type: "monochromacy",
        label: "Achromatopsia"
      }
    ];
    defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "options", "autoColorShift"]);
  }
  _getFocused() {
    return this.tag("List");
  }
  _shiftColors() {
    if (this._autoColorShift && (this.application && this.application.colorshift)) {
      this.application.colorshift(this._settings.correction, this._settings);
    }
  }
  $onValueChanged() {
    const listItems = this.tag("List").items;
    const correction = listItems[0];
    this._settings = {
      correction: correction.options[correction.value].type,
      brightness: listItems[1].value,
      contrast: listItems[2].value,
      gamma: listItems[3].value
    };
    if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
      const steppers = listItems.slice(1);
      steppers.forEach((stepper) => {
        stepper.value = 50;
      });
    }
    this._currentCorrection = this._settings.correction;
    this._shiftColors();
    this.signal("onColorShift", this._settings);
  }
  _update() {
    const list = this.tag("List");
    const steppers = ["Brightness", "Contrast", "Gamma"];
    const options = this._options;
    const settings2 = this._settings;
    const colors2 = {
      focusColor: this._focusColor,
      labelColor: this._labelColor,
      labelColorFocused: this._labelColorFocused
    };
    this._shiftColors();
    const settingItems = steppers.map((stepper) => {
      const lowerC = stepper.toLocaleLowerCase();
      return { type: this[`${lowerC}Component`], label: stepper, value: settings2[lowerC], w: this.finalW, h: 80, ...colors2 };
    });
    settingItems.unshift({ type: this.correctionComponent, options, value: findIndexOfObject(options, settings2.correction, "type"), label: "Color adjustment", w: this.finalW, h: 80, ...colors2 });
    list.clear();
    list.add(settingItems);
  }
  _firstActive() {
    if (!this._settings) {
      this._settings = {
        correction: "neutral",
        brightness: 50,
        contrast: 50,
        gamma: 50
      };
    }
    this._update();
  }
  set settings(obj) {
    this._settings = obj;
    if (this.active) {
      const listItems = this.tag("List").items;
      listItems[0] = findIndexOfObject(this._options, obj.correction, "type");
      listItems[1] = obj.brightness || 50;
      listItems[2] = obj.contrast || 50;
      listItems[3] = obj.gamma || 50;
    }
  }
  get settings() {
    return this._settings;
  }
  get correctionTag() {
    return this.tag("List").items[0];
  }
  get brightnessTag() {
    return this.tag("List").items[1];
  }
  get contrastTag() {
    return this.tag("List").items[2];
  }
  get gammaTag() {
    return this.tag("List").items[3];
  }
  get adjustmentTags() {
    return this.tag("List").items;
  }
  set stepperComponent(component) {
    this._stepperComponent = component;
  }
  get stepperComponent() {
    return this._stepperComponent || ArrowStepper;
  }
  set correctionComponent(component) {
    this._correctionComponent = component;
  }
  get correctionComponent() {
    return this._correctionComponent || this.stepperComponent;
  }
  set brightnessComponent(component) {
    this._brightnessComponent = component;
  }
  get brightnessComponent() {
    return this._brightnessComponent || this.stepperComponent;
  }
  set contrastComponent(component) {
    this._contrastComponent = component;
  }
  get contrastComponent() {
    return this._contrastComponent || this.stepperComponent;
  }
  set gammaComponent(component) {
    this._gammaComponent = component;
  }
  get gammaComponent() {
    return this._gammaComponent || this.stepperComponent;
  }
}
class CarouselItem extends lightning.Component {
  static _template() {
    return {
      Focus: { alpha: 0, x: (w) => w * 0.5, y: (h) => h * 0.5, mount: 0.5, w: 120, h: 50, rect: true, shader: { type: lightning.shaders.RoundedRectangle, radius: 25 } },
      Label: { x: (w) => w * 0.5, y: (h) => h * 0.5, mount: 0.5, renderOffscreen: true, text: { text: "", fontSize: 22 } }
    };
  }
  _construct() {
    this._focusColor = 4278227525;
    this._labelColor = 4288519581;
    this._labelColorFocused = 4294967295;
    this._padding = 40;
    defineProperties(this, ["focusColor", "labelColor", "labelColorFocused", "padding"]);
  }
  set label(str) {
    this.tag("Label").text.text = str;
    this._label = str;
  }
  get label() {
    return this._label;
  }
  _init() {
    const label = this.tag("Label");
    label.on("txLoaded", () => {
      this.patch({
        w: label.renderWidth,
        Focus: { w: label.renderWidth + this._padding * 2 }
      });
      if (this.collectionWrapper) {
        this.collectionWrapper.reposition();
      }
    });
  }
  _focus() {
    this.patch({
      Focus: { smooth: { alpha: 1 } },
      Label: { smooth: { color: this._labelColorFocused } }
    });
  }
  _unfocus(target) {
    if (target.isCarouselItem === true) {
      this.patch({
        Focus: { smooth: { alpha: 0 } },
        Label: { smooth: { color: this._labelColor } }
      });
    }
  }
  _firstActive() {
    this.patch({
      Focus: { color: this._focusColor },
      Label: { color: this._labelColor }
    });
    if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
      this._focus();
    }
  }
  get isCarouselItem() {
    return true;
  }
  static get width() {
    return 120;
  }
  static get height() {
    return 50;
  }
}
class ProgressBar extends lightning.Component {
  static _template() {
    return {
      w: 300,
      h: 10,
      Background: {
        w: (w) => w,
        h: (h) => h,
        rect: true,
        rtt: true,
        shader: { type: lightning.shaders.RoundedRectangle, radius: 5 },
        Progress: { h: (h) => h, w: 10, rect: true, shader: { type: lightning.shaders.RoundedRectangle, radius: 0 } }
      }
    };
  }
  _construct() {
    this._progressColor = 4278227525;
    this._progressColorFocused = void 0;
    this._backgroundColor = 4288519581;
    this._backgroundColorFocused = void 0;
    this._backgroundRadius = 5;
    this._progressRadius = 0;
    this.value = 0.5;
    defineProperties(this, ["progressColor", "backgroundColor", "progressColorFocused", "backgroundColorFocused"]);
  }
  progress(p) {
    if (p > 1) {
      p = p / 100;
    }
    this._value = p;
    this.tag("Progress").w = this.w * p;
  }
  _createFocusAnimation() {
    this._focusAnimation = this.animation({ duration: 0.2, stopMethod: "reverse", actions: [
      { t: "Background", p: "color", v: { 0: this._backgroundColor, 1: this._backgroundColorFocused || this._backgroundColor } },
      { t: "Background.Progress", p: "color", v: { 0: this._progressColor, 1: this._progressColorFocused || this._progressColor } }
    ] });
  }
  _firstActive() {
    if (!this._focusAnimation) {
      this._createFocusAnimation();
    }
    this.patch({
      Background: {
        color: this._backgroundColor,
        shader: { radius: this._backgroundRadius },
        Progress: {
          color: this._progressColor,
          shader: { radius: this._progressRadius }
        }
      }
    });
    this.progress(this._value);
    if (this.hasFocus()) {
      this._focus();
    }
  }
  _focus() {
    if (this._focusAnimation) {
      this._focusAnimation.start();
    }
  }
  _unfocus() {
    if (this._focusAnimation) {
      this._focusAnimation.stop();
    }
  }
  set value(p) {
    this._value = p;
    if (this.active) {
      this.progress(p);
    }
  }
  get value() {
    return this._value;
  }
  set backgroundRadius(num) {
    this._backgroundRadius = num;
    if (this.active) {
      this.tag("Background").shader.radius = num;
    }
  }
  get progressRadius() {
    return this._progressRadius;
  }
  set progressRadius(num) {
    this._progressRadius = num;
    if (this.active) {
      this.tag("Progress").shader.radius = num;
    }
  }
  get progressRadius() {
    return this._progressRadius;
  }
  get backgroundTag() {
    return this.tag("Background");
  }
  get progressTag() {
    return this.tag("Progress");
  }
}
class VideoSpecItem extends lightning.Component {
  static _template() {
    return {
      VideoSpec: {
        w: 120,
        h: 80,
        shader: { type: lightning.shaders.RoundedRectangle, radius: 20, stroke: 8, strokeColor: theme.colors.accentGrey.light },
        color: theme.colors.accentGrey.light,
        Spec: {
          mount: 0.5,
          color: theme.colors.accentGrey.light,
          text: { fontSize: 22 }
        }
      }
    };
  }
  set specData(spec) {
    this.patch({
      VideoSpec: {
        Spec: {
          text: spec
        }
      }
    });
  }
  set customColor(color) {
    this.patch({
      VideoSpec: {
        shader: {
          strokeColor: color
        },
        Spec: {
          smooth: { color }
        }
      }
    });
  }
}
const cardSizes = {
  regular: {
    w: 216,
    h: 324,
    margin: 30,
    minimumCardsInViewport: 7
  },
  wide: {
    w: 324,
    h: 216,
    margin: 30,
    minimumCardsInViewport: 5
  }
};
class RailItem extends lightning.Component {
  constructor() {
    super(...arguments);
    this.data = {};
    this.index = 0;
    this.totalElements = 0;
    this.cardSize = cardSizes.regular;
  }
  /**
   * This function is responsible for the creation and return of the UI template. This
   * function takes  no parameters and returns the template of the Rail Item component.
   *
   * @returns Template for the Rail Item Component.
   *
   */
  static _template() {
    return {
      rect: true,
      color: theme.colors.accentGrey.dark,
      shader: { type: lightning.shaders.RoundedRectangle, radius: 20 },
      Image: {
        w: (w) => w,
        h: (h) => h,
        shader: { type: lightning.shaders.FadeOut, innerColor: theme.colors.black, bottom: 200 }
      },
      Label: {
        x: 10,
        y: 326.25,
        w: (w) => w,
        color: theme.colors.accentGrey.light,
        text: { fontSize: 22.5 }
      },
      ProgressBar: {
        h: 5,
        w: 200,
        x: 10,
        y: cardSizes.regular.h - 20,
        type: ProgressBar,
        progressColorFocused: theme.colors.yellow,
        progressColor: theme.colors.yellow
      },
      VideoSpec: {
        visible: true,
        VideoSpec1: {
          x: 55,
          y: 25,
          shader: null,
          type: VideoSpecItem,
          specData: "  16+  ",
          customColor: theme.colors.yellow
        },
        VideoSpec2: {
          x: 120,
          y: 25,
          shader: null,
          type: VideoSpecItem,
          specData: "  4k  ",
          customColor: theme.colors.yellow
        },
        VideoSpec3: {
          x: 175,
          y: 25,
          shader: null,
          type: VideoSpecItem,
          specData: "  cc  ",
          customColor: theme.colors.yellow
        }
      },
      PlayButton: {
        h: 100,
        visible: false,
        text: {
          fontSize: 35,
          textColor: theme.colors.white,
          textAlign: "left",
          textIndent: 20,
          textBaseline: "hanging",
          text: "Play Video",
          mountY: 0.5
        }
      }
    };
  }
  /**
   * Setter for setting the values for the item property.
   *
   * @Param The value that needs to be setted to the item property.
   *
   */
  set item(obj) {
    const { label, src, data, index, totalElements, cardSize } = obj;
    this.data = data;
    this.index = index;
    this.totalElements = totalElements;
    this.cardSize = cardSize;
    this.patch({
      Image: {
        src,
        shader: { type: lightning.shaders.RoundedRectangle, radius: 20 }
      },
      Label: { y: this.cardSize.h + 10, text: label == null ? void 0 : label.toString() },
      w: this.cardSize.w,
      h: this.cardSize.h,
      ProgressBar: {
        x: 10,
        y: this.cardSize.h - 20,
        w: this.cardSize.w - 20,
        value: Math.floor(Math.random() * 101)
      }
    });
  }
  /**
  * This function overrides the default behaviour of keypress 'Enter'.
  * This functions checks the index to see the focused element and decides
  * the route to navigate.
  */
  _handleEnter() {
    Router.navigate(`content/railItem/${this.data.uid}`, { from: "Home", data: this.data });
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      //     // smooth: { color: theme.colors.black, scale: 1.1 },
      Image: {
        shader: { type: lightning.shaders.FadeOut, innerColor: theme.colors.black, top: 200, bottom: 200 }
      },
      Label: {
        smooth: { color: theme.colors.white }
      },
      Rectangle: { color: theme.colors.yellow, x: 10, y: (y) => y + 54, w: (w) => w - 20, h: 5, rect: true },
      PlayButton: {
        visible: true,
        color: theme.colors.yellow,
        y: this.cardSize.h / 2
      }
    });
    const cardData = {
      cardWidth: this.w,
      cardHeight: this.h,
      cardIndex: this.index,
      railTotalElements: this.totalElements,
      cardSize: this.cardSize
    };
    this.fireAncestors("$changeItemOnFocus", this.data, cardData);
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      // smooth: { color: theme.colors.accentGrey.dark, scale: 1.0 },
      Label: {
        smooth: { color: theme.colors.accentGrey.light }
      },
      Rectangle: void 0,
      PlayButton: {
        visible: false
      }
    });
  }
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.3.4";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
class AxiosRequester {
  constructor() {
    this.AxiosAPI = axios$1.create({ baseURL: "https://api-entertainment.enlight.diagnal.com/v1b3/content" });
  }
  /**
   * Generic funciton used to handle the API request to the server.
   * This function takes one parameter as input and has two returns
   * 
   * @param uri, @type string,  @desc this is the uri from which the data has to be fetched.
   * 
   * @return response, @type AxiosResponse<any> | undefined, @desc This Axiosresponse object, this will return the data fetched if successful.
   * @return error,  @type  AxiosError<any> | undefined, @desc THis error object, this will return error on failure.
   * 
   */
  async fetch(uri) {
    try {
      const response = await this.AxiosAPI.get(uri);
      return [response, void 0];
    } catch (error) {
      return [void 0, error];
    }
  }
}
class Rail extends lightning.Component {
  constructor() {
    super(...arguments);
    this.index = -1;
    this.dataLength = 0;
    this.railIndex = 0;
    this.axiosRequester = new AxiosRequester();
    this.responseData = {};
    this.data = [];
  }
  /**
  * This function is responsible for the creation and return of the UI template. This
  * function takes  no parameters and returns the template of the Rail component.
  *
  * @returns Template for the Rail Component.
  *
  */
  static _template() {
    return {
      Header: {
        x: 50,
        y: 20,
        color: theme.colors.white,
        text: { text: "", fontSize: 35 }
      },
      Slider: {
        w: 800,
        h: 350,
        x: 480,
        y: 280,
        mount: 0.5,
        Wrapper: {}
      }
    };
  }
  /**
  * This function is responsible for setting up the initial states of the component when
  * attached for the first time. This function takes  no parameters and has no return.
  */
  _init() {
    const rail = [];
    if (this.railIndex < endp.length) {
      this.axiosRequester.fetch(endp[this.railIndex]).then((response) => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (response) {
          this.responseData = (_a = response[0]) == null ? void 0 : _a.data;
          this.dataLength = this.responseData.totalElements || 0;
          this.data = this.responseData.content || [];
          for (let i = 0; i < this.dataLength; i++) {
            let cardSize = cardSizes.regular;
            let img_src = (_c = (_b = this.data[i]) == null ? void 0 : _b.images.find((img) => img.width === 288)) == null ? void 0 : _c.url;
            if (this.dataLength === 10 || this.dataLength === 31) {
              cardSize = cardSizes.wide;
              img_src = (_e = (_d = this.data[i]) == null ? void 0 : _d.images.find((img) => img.width === 526)) == null ? void 0 : _e.url;
            }
            let label = (_f = this.data[i]) == null ? void 0 : _f.title;
            console.log((_g = this.data[i]) == null ? void 0 : _g.images);
            let cardWidthIncludingMargin = cardSize.w + cardSize.margin;
            rail.push({
              type: RailItem,
              x: i * cardWidthIncludingMargin,
              item: { label, src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg", data: this.data[i], index: i, totalElements: this.dataLength, cardSize }
            });
          }
        }
        this.patch({
          Header: { text: railName[this.railIndex] }
        });
        this.tag("Wrapper").children = rail;
        this.index = 0;
        this._setState("RowItem");
      });
    } else {
      this.setLongRail();
    }
  }
  async setLongRail() {
    var _a, _b, _c;
    console.log("je");
    this.data = await Storage.get("longData");
    this.dataLength = this.data.length;
    console.log(this.data.length);
    const rail = [];
    for (let i = 0; i < this.dataLength; i++) {
      let label = (_a = this.data[i]) == null ? void 0 : _a.title;
      let img_src = (_c = (_b = this.data[i]) == null ? void 0 : _b.images.find((img) => img.width === 288)) == null ? void 0 : _c.url;
      rail.push({
        type: RailItem,
        x: i * (216 + 30),
        item: { label, src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg", data: this.data[i] }
      });
    }
    this.patch({
      Header: { text: railName[this.railIndex] }
    });
    this.tag("Wrapper").children = rail;
    this.index = 0;
  }
  /**
   * To repostion the wrapper on the focused element. Function does not take any parameters
   * nor has any return.
   */
  repositionWrapper() {
    const wrapper = this.tag("Wrapper");
    const currentFocus = wrapper.children[this.index];
    const cardSize = currentFocus.cardSize;
    if (this.index < this.dataLength - (cardSize.minimumCardsInViewport - 1)) {
      wrapper.setSmooth("x", -(cardSize.w + cardSize.margin) * this.index, { duration: 0.3 });
    }
  }
  /**
   * This function overrides the default behaviour of keypress 'Left'.
   * This functions checks the index to see the focused element and decides
   * wheather if it should move to the left or not. And then it will reposition
   * the wrapper.
   */
  _handleLeft() {
    if (this.index > 0) {
      this.index -= 1;
      this.repositionWrapper();
    }
  }
  /**
   * This function overrides the default behaviour of keypress 'Right'.
   * This functions checks the index to see the focused element and decides
   * wheather if it should move to the right or not. And then it will reposition
   * the wrapper.
   */
  _handleRight() {
    if (this.index < this.dataLength - 1) {
      this.index += 1;
      this.repositionWrapper();
    }
  }
  /**
   * This function will override the default behavior of the getFocused() method
   *
   * @returns Return the child Component that this Component wishes to receive focus. Returning null
   * or undefined tells the focus engine to not set focus on this Component at all.By default,
   * this Component's own instance is returned.
   */
  // override _getFocused(): any {
  //     return this.tag('Slider.Wrapper' as any).children[this.index];
  // }
  _getFocused() {
    return this.tag("Slider.Wrapper").children[this.index];
  }
}
class NavTextItem extends lightning.Component {
  /**
   * This function is responsible for the creation and return of the UI template. This
   * function takes  no parameters and returns the template of the component.
   *
   * @returns Template for the Component.
   *
   */
  static _template() {
    return {
      NavText: {
        w: 120,
        color: theme.colors.accentGrey.light,
        text: { fontSize: 35 }
      }
    };
  }
  /**
   * Setter for setting the values for the item property.
   *
   * @Param The value that needs to be setted to the item property.
   *
   */
  set navtext(text) {
    this.patch({
      NavText: {
        text: text == null ? void 0 : text.toString()
      }
    });
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      smooth: { scale: 1.1 },
      NavText: {
        smooth: { color: theme.colors.white }
      },
      Rectangle: { color: theme.colors.yellow, x: 2, y: (y) => y + 50, w: 100, h: 5, rect: true }
    });
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      smooth: { color: theme.colors.primary, scale: 1 },
      NavText: {
        smooth: { color: theme.colors.accentGrey.light }
      },
      Rectangle: void 0
    });
  }
}
class NavProfileItem extends lightning.Component {
  /**
   * This function is responsible for the creation and return of the UI template. This
   * function takes  no parameters and returns the template of the component.
   *
   * @returns Template for the Component.
   *
   */
  static _template() {
    return {
      w: 50,
      h: 50,
      src: "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/808/289/5qtySjfuJfOLvVrVXuwNo2BIVPH.jpg",
      shader: { type: lightning.shaders.RoundedRectangle, radius: 10, stroke: 5, strokeColor: theme.colors.white }
    };
  }
  /**
   * Setter for setting the values for the item property.
   *
   * @Param The value that needs to be setted to the item property.
   *
   */
  set navtext(text) {
    this.patch({
      NavText: {
        text: text == null ? void 0 : text.toString()
      }
    });
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      smooth: { scale: 1.1 },
      shader: { strokeColor: theme.colors.yellow }
    });
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      smooth: { scale: 1 },
      shader: { strokeColor: theme.colors.white }
    });
  }
}
class TopNav extends lightning.Component {
  constructor() {
    super(...arguments);
    this.index = 0;
  }
  static _template() {
    return {
      Navbar: {
        w: 1920,
        h: 1080,
        rect: true,
        zIndex: 1,
        shader: { x: 100, y: -100, pivot: 0.5, type: lightning.shaders.RadialGradient, outerColor: theme.colors.primaryLight, innerColor: theme.colors.dark, radius: 800 },
        NavItems: {
          x: 10,
          y: 10,
          NavMenu: {
            shader: null
          }
        }
      }
    };
  }
  /**
  * This function is responsible for setting up the initial states of the component when
  * attached for the first time. This function takes  no parameters and has no return.
  */
  _init() {
    var _a;
    const menus = {
      Home: {
        type: NavTextItem,
        x: 20,
        y: 12,
        navtext: "Home"
      },
      Search: {
        type: NavTextItem,
        x: 140,
        y: 12,
        navtext: "Search"
      },
      Gridlayout: {
        type: NavTextItem,
        x: 280,
        y: 12,
        navtext: "Grids"
      },
      Profile: {
        x: 1840,
        y: 15,
        type: NavProfileItem
      }
      // Exit: {
      //     type: NavTextItem,
      //     x: (x: number) => x - 100, y: 20,
      //     navtext: "Exit"
      // }
    };
    this.tag("Navbar.NavItems.NavMenu").children = menus;
    (_a = this.tag("Navbar")) == null ? void 0 : _a.animation({
      duration: 8,
      repeat: -1,
      delay: 2,
      actions: [
        { p: "shader.radius", v: { 0: { v: 800 }, 0.5: { v: 400 }, 1: { v: 800 } } }
      ]
    }).start();
  }
  /**
   * This function overrides the default behaviour of keypress 'Left'.
   * This functions checks the index to see the focused element and decides
   * wheather if it should move to the left or not. 
   */
  _handleLeft() {
    if (this.index > 0) {
      this.index -= 1;
    }
  }
  /**
   * This function overrides the default behaviour of keypress 'Right'.
   * This functions checks the index to see the focused element and decides
   * wheather if it should move to the right or not.
   */
  _handleRight() {
    if (this.index < 3) {
      this.index += 1;
    }
  }
  /**
  * This function overrides the default behaviour of keypress 'Enter'.
  * This functions checks the index to see the focused element and decides
  * the route to navigate.
  */
  _handleEnter() {
    if (this.index === 0) {
      Router.navigate("home");
    } else if (this.index === 1) {
      Router.navigate("search");
    } else if (this.index === 2) {
      Router.navigate("grid");
    } else {
      Router.navigate("settings");
    }
  }
  _getFocused() {
    return this.tag("Navbar.NavItems.NavMenu").children[this.index];
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.index = 0;
  }
}
class BackButton extends lightning.Component {
  static _template() {
    return {
      Back: {
        w: 80,
        color: theme.colors.accentGrey.light,
        text: { text: "Back", fontSize: 35 }
      }
    };
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      smooth: { scale: 1.1 },
      Back: {
        smooth: { color: theme.colors.white }
      },
      Rectangle: { color: theme.colors.yellow, x: 2, y: (y) => y + 50, w: 80, h: 5, rect: true }
    });
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      smooth: { color: theme.colors.primary, scale: 1 },
      Back: {
        smooth: { color: theme.colors.accentGrey.light }
      },
      Rectangle: void 0
    });
  }
}
class PlayPauseButton extends lightning.Component {
  constructor() {
    super(...arguments);
    this._isPlaying = false;
  }
  static _template() {
    return {
      mount: 0.5,
      x: 1920 / 2,
      y: 1080 / 2,
      rect: true,
      w: 150,
      h: 150,
      color: 0,
      Background: {
        rect: true,
        w: 150,
        h: 150,
        color: 4289440683,
        shader: {
          type: lightning.shaders.RoundedRectangle,
          radius: 75
        }
      },
      Text: {
        mount: 0.5,
        x: 75,
        y: 75,
        text: {
          textColor: 4294967295,
          text: "Pause"
        }
      }
    };
  }
  _setup() {
    this._isPlaying = true;
  }
  set isPlaying(isPlaying) {
    this._isPlaying = isPlaying;
    this.tag("Text").patch({
      text: {
        text: isPlaying ? "Pause" : "Play"
      }
    });
  }
  get isPlaying() {
    return this._isPlaying;
  }
}
class Button extends lightning.Component {
  static _template() {
    return {
      Button: {
        w: 500,
        h: 100,
        color: 0,
        rect: true,
        shader: { type: lightning.shaders.RadialGradient, innerColor: theme.colors.accentGrey.dark },
        Label: {
          shader: null,
          h: (h) => h,
          text: {
            fontSize: 35,
            textColor: theme.colors.white,
            textAlign: "left",
            textIndent: 20,
            textBaseline: "hanging"
          }
        }
      }
    };
  }
  set label(text) {
    this.patch({
      Button: {
        Label: {
          text
        }
      }
    });
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      smooth: { scale: 1.1 },
      Button: {
        shader: { innerColor: 2868042585 },
        Label: {
          text: {
            textColor: theme.colors.white
          }
        }
      }
    });
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      smooth: { scale: 1 },
      Button: {
        shader: { innerColor: theme.colors.accentGrey.dark }
      }
    });
  }
}
class PreviewComponent extends lightning.Component {
  constructor() {
    super(...arguments);
    this.firstActive = true;
  }
  static _template() {
    return {
      ContentView: {
        Thumbnail: {
          x: 1e3,
          y: 110,
          scale: 1.5,
          shader: { type: lightning.shaders.FadeOut, innerColor: theme.colors.black, left: 200, bottom: 200 }
        },
        ContentDetails: {
          ContentData: {
            shader: null,
            zIndex: 2,
            Title: {
              x: 40,
              y: 165,
              shader: null,
              text: {
                fontSize: 80
              },
              color: theme.colors.white
            },
            Description: {
              x: 40,
              y: 270,
              w: 900,
              shader: null,
              text: {
                wordWrap: true,
                maxLines: 3,
                maxLinesSuffix: "...",
                fontSize: 30
              },
              color: theme.colors.accentGrey.light
            },
            Genre: {
              x: 40,
              y: 380,
              w: 900,
              shader: null,
              text: {
                fontSize: 24
              },
              color: theme.colors.accentGrey.light
            },
            Info: {
              visible: false,
              Director: {
                x: 40,
                y: 440,
                w: 100,
                shader: null,
                text: {
                  text: "Director : ",
                  fontSize: 24
                },
                color: theme.colors.accentGrey.light
              },
              Starring: {
                x: 40,
                y: 470,
                w: 100,
                shader: null,
                text: {
                  text: "Staring  : ",
                  fontSize: 24
                },
                color: theme.colors.accentGrey.light
              },
              DirectorList: {
                x: 150,
                y: 440,
                w: 800,
                shader: null,
                text: {
                  fontSize: 24
                },
                color: theme.colors.accentGrey.light
              },
              StarringList: {
                x: 150,
                y: 470,
                w: 800,
                shader: null,
                text: {
                  fontSize: 24,
                  wordWrap: true,
                  maxLines: 1,
                  maxLinesSuffix: "..."
                },
                color: theme.colors.accentGrey.light
              }
            },
            VideoSpec: {
              visible: false,
              VideoSpec1: {
                x: 70,
                y: 140,
                shader: null,
                type: VideoSpecItem,
                specData: "  16+  "
              },
              VideoSpec2: {
                x: 135,
                y: 140,
                shader: null,
                type: VideoSpecItem,
                specData: "  4k  "
              },
              VideoSpec3: {
                x: 193,
                y: 140,
                shader: null,
                type: VideoSpecItem,
                specData: "  cc  "
              }
            }
          }
        }
      }
    };
  }
  set data(eventDetails) {
    console.log(eventDetails);
    const { imgSrc, title, description, genre, directorsList, actorsList } = eventDetails;
    this.tag("ContentView.Thumbnail").patch({
      smooth: { src: imgSrc }
    });
    this.tag("ContentView.Thumbnail").transition("src").on("start", () => {
      this.tag("ContentView.Thumbnail").setSmooth("alpha", 0, { duration: 0.5 });
    });
    this.tag("ContentView.Thumbnail").transition("src").on("finish", () => {
      this.tag("ContentView.Thumbnail").setSmooth("alpha", 1, { duration: 0.5 });
    });
    const contentAnimation = this.tag("ContentView.ContentDetails").animation({
      duration: 1,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 1, 0.5: 0, 0.8: 0, 1: 1 } },
        { p: "x", v: { 0: 10, 0.6: -100, 0.65: 10 } },
        { p: "y", v: { 0: 0, 0.6: 0, 0.65: -30, 1: 0 } }
      ]
    });
    this.patch({
      ContentView: {
        shader: { type: lightning.shaders.RadialGradient, x: 300, y: 300, innerColor: 4278190080, radius: 1500 },
        ContentDetails: {
          x: 10,
          ContentData: {
            Title: {
              text: {
                text: title
              }
            },
            Description: {
              text: {
                text: description
              }
            },
            Genre: {
              text: {
                text: genre
              }
            },
            Info: {
              visible: true,
              DirectorList: {
                text: {
                  text: directorsList
                }
              },
              StarringList: {
                text: {
                  text: actorsList
                }
              }
            },
            VideoSpec: {
              visible: true
            }
          }
        }
      }
    });
    if (this.firstActive) {
      this.firstActive = false;
      this.tag("ContentView.ContentDetails").animation({
        duration: 1,
        delay: 0,
        repeat: 0,
        actions: [
          { p: "alpha", v: { 0: 0, 1: 1 } },
          { p: "y", v: { 0: -30, 1: 0 } }
        ]
      }).start();
      return;
    }
    contentAnimation.start();
  }
  // Animate on Navigation to details page (invoked from pageTransitionOut of home page )
  animate() {
    this.tag("ContentView.ContentDetails").animation({
      duration: 2,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 1, 0.5: 0 } },
        { p: "y", v: { 0: 0, 0.5: -30, 1: 0 } }
      ]
    }).start();
  }
  _init() {
    this.tag("ContentView.Thumbnail").on("txError", () => {
      console.error("texture failed to load: " + this.tag("ContentView.Thumbnail").src);
    });
  }
}
class FocusBox extends lightning.Component {
  static _template() {
    return {
      Box: {
        x: 80,
        y: 665,
        InnerBox: {
          zIndex: 3,
          w: 100,
          h: 100,
          rect: true,
          shader: { type: lightning.shaders.RoundedRectangle, radius: 20, stroke: 5, strokeColor: theme.colors.yellow },
          color: Colors("transparent")
        }
      }
    };
  }
}
class Home extends lightning.Component {
  constructor() {
    super(...arguments);
    this.index = 0;
    this.rowLength = endp.length;
    this.hideNav = false;
    this.eventData = {};
    this.Wrapper = this.getByRef("Background.Slider.Wrapper");
  }
  /**
   * This function is responsible for the creation and return of the UI template. This function
   * takes  no parameters and returns the template.
   *
   * @returns Template for the Application
   *
   */
  static _template() {
    return {
      // Navbar: { type: TopNav },
      Background: {
        w: 1920,
        h: 1080,
        color: theme.colors.black,
        rect: true,
        Box: {
          x: 80,
          y: 665,
          InnerBox: {
            zIndex: 3,
            w: 100,
            h: 100,
            rect: true,
            shader: { type: lightning.shaders.RoundedRectangle, radius: 20, stroke: 5, strokeColor: theme.colors.yellow },
            color: Colors("transparent")
          }
        },
        ContentDetails: {
          type: PreviewComponent
        },
        Slider: {
          zIndex: 2,
          clipping: true,
          w: 1920,
          h: (h) => h,
          x: 960,
          y: 1100,
          mount: 0.5,
          Wrapper: {}
        }
      }
    };
  }
  $changeItemOnFocus(data, cardData) {
    var _a, _b;
    let imgSrc = (_a = data.images.find((img) => img.width === 828)) == null ? void 0 : _a.url;
    let title = data.title;
    let description = data.description;
    let genre = data.genre.join(" . ");
    let directorsList = data.director.map((a) => a.personName).join(", ");
    let actorsList = data.actor.map((a) => a.personName).join(", ");
    const { railTotalElements, cardIndex, cardSize } = cardData;
    const { minimumCardsInViewport, w, h, margin } = cardSize;
    const previewItem = {
      type: PreviewComponent,
      data: { imgSrc, title, description, genre, directorsList, actorsList }
    };
    this.tag("Background.ContentDetails").patch(previewItem);
    (_b = this.tag("Box")) == null ? void 0 : _b.patch({
      InnerBox: {
        w,
        h
        // shader: { w: cardData.cardWidth, h: cardData.cardHeight }
      }
    });
    const focusBox = this.tag("Box");
    if (cardIndex >= railTotalElements - (minimumCardsInViewport - 1)) {
      focusBox.setSmooth("x", (w + margin) * (minimumCardsInViewport - (railTotalElements - cardIndex)) + 80, { duration: 0.3 });
    } else
      focusBox.setSmooth("x", 80, { duration: 0.3 });
  }
  // initializing the component
  _init() {
    this.backgroundFetchAndSave();
    const rails = [];
    for (let i = 0; i < this.rowLength; i++) {
      rails.push({ type: Rail, x: 0, y: i * (500 + 50), railIndex: i });
    }
    this.tag("Background.Slider.Wrapper").children = rails;
  }
  async backgroundFetchAndSave() {
    let axiosRequester = new AxiosRequester();
    let longData = [];
    for (let epoint of endp) {
      await axiosRequester.fetch(epoint).then((response) => {
        var _a;
        if (response) {
          let responseData = (_a = response[0]) == null ? void 0 : _a.data;
          let data = responseData.content || [];
          longData = [...longData, ...data];
        }
      });
    }
    await Storage.set("longData", longData);
  }
  // repositioning the wrapper
  repositionWrapper() {
    const wrapper = this.tag("Background.Slider.Wrapper");
    const sliderH = this.tag("Background.Slider").h;
    const currentWrapperY = wrapper.transition("y").targetvalue || wrapper.y;
    const currentFocus = wrapper.children[this.index];
    const currentFocusY = currentFocus.y + currentWrapperY;
    const currentFocusOuterHeight = currentFocus.y + currentFocus.h;
    if (currentFocusY < 0) {
      wrapper.setSmooth("y", -currentFocus.y);
    } else if (currentFocusOuterHeight > sliderH) {
      wrapper.setSmooth("y", sliderH - currentFocusOuterHeight);
    }
  }
  // adding animation on entering the page.
  _active() {
    const railInAnimation = this.tag("Background.Slider").animation({
      duration: 1,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 0, 1: 1 } },
        { p: "y", v: { 0: 1400, 1: 1100 } }
      ]
    });
    const focusBorderInAnimation = this.tag("Background.Box").animation({
      duration: 1,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 0, 1: 1 } },
        { p: "y", v: { 0: 965, 1: 665 } }
      ]
    });
    railInAnimation.start();
    focusBorderInAnimation.start();
  }
  // handling up button click
  _handleUp() {
    if (this.index > 0) {
      this.index -= 1;
      if (this.index >= 0) {
        this.repositionWrapper();
      }
    }
  }
  // handling down button click
  _handleDown() {
    if (this.index < this.rowLength - 1) {
      this.index += 1;
      this.repositionWrapper();
    }
  }
  /**
     * This function will override the default behavior of the getFocused() method
     *
     * @returns Return the child Component that this Component wishes to receive focus. Returning null
     * or undefined tells the focus engine to not set focus on this Component at all.By default,
     * this Component's own instance is returned.
     */
  _getFocused() {
    if (this.index <= 0) {
      this.patch({
        Navbar: {
          visible: true
        }
      });
    } else {
      this.patch({
        Navbar: {
          visible: false
        }
      });
    }
    if (this.index >= 0) {
      return this.tag("Background.Slider.Wrapper").children[this.index];
    } else {
      return this.tag("Navbar");
    }
  }
  // Animating the page transition
  pageTransitionOut(page) {
    return new Promise((resolve, reject) => {
      this.tag("Background.Slider").patch({
        smooth: { y: [1300, { duration: 1, delay: 0, timingFunction: "ease" }], alpha: 0 }
      });
      this.tag("Background.Box").patch({
        smooth: { y: [865, { duration: 1, delay: 0, timingFunction: "ease" }], alpha: 0 }
      });
      this.tag("Background.ContentDetails").animate();
      this.tag("Background.Slider").transition("y").on("finish", () => {
        resolve();
      });
    });
  }
}
class Search extends lightning.Component {
  constructor() {
    super(...arguments);
    this.index = 2;
    this.intervalSub = 0;
  }
  static _template() {
    return {
      w: 1920,
      h: 1080,
      color: theme.colors.primaryLight,
      rect: true,
      shader: { x: 100, y: -100, pivot: 0.5, type: lightning.shaders.RadialGradient, outerColor: theme.colors.primaryLight, innerColor: theme.colors.dark, radius: 800 },
      SearchComponent: {
        x: 40,
        y: 40,
        shader: null,
        SearchBox: {
          x: 0,
          y: 60,
          w: 950,
          h: 60,
          rect: true,
          color: theme.colors.accentGrey.light,
          shader: { type: lightning.shaders.RoundedRectangle, radius: 30 },
          InputWrapper: {
            x: 20,
            color: theme.colors.dark,
            InputField: {
              y: 20,
              type: InputField
            }
          }
        },
        BackButton: { type: BackButton },
        Keyboard: {
          x: 0,
          y: 140,
          type: Keyboard,
          config: keyboardConfig,
          currentLayout: "abc",
          maxCharacters: 24,
          signals: { onSearch: true }
        }
      }
    };
  }
  _setup() {
    const inputField = this.tag("SearchComponent.SearchBox.InputWrapper.InputField");
    this.tag("Keyboard").inputField(inputField);
  }
  onSearch(event) {
    console.log("search", event.input);
  }
  _active() {
    super._active();
    this.tag("SearchComponent.SearchBox.InputWrapper.InputField").color = theme.colors.accentGrey.dark;
    const LongRail = { type: Rail, x: -30, y: 380, railIndex: 16 };
    this.tag("SearchComponent").patch({ LongRail });
  }
  _getFocused() {
    return this.tag("Keyboard");
  }
  // overrides the default up button actions
  _handleUp() {
    if (this.index > 1) {
      this.index -= 1;
    }
  }
  // overrides the default down button actions
  _handleDown() {
    if (this.index < 3) {
      this.index += 1;
    }
  }
  // overrides the default behavior when enter button is clicked
  _handleEnter() {
    if (this.index === 1) {
      Router.navigate("home");
    }
  }
  // returns the focused components
  _getFocused() {
    return this.tag("SearchComponent").children[this.index];
  }
}
class Key2 extends Key$1 {
  _firstActive() {
    this.label = {
      mountY: 0.45
    };
    this.labelColors = {
      unfocused: Colors("white").get(),
      focused: theme.colors.dark
    };
    this.backgroundColors = {
      unfocused: Colors("white").alpha(0).get(),
      focused: theme.colors.white
    };
    if (this.hasFocus()) {
      this._focus();
    }
  }
  static get width() {
    return 90;
  }
  static get height() {
    return 40;
  }
}
class ActionKey extends Key$1 {
  _active() {
    this.label = {
      mountY: 0.45
    };
    this.labelColors = {
      unfocused: Colors("black").get(),
      focused: Colors("white").get()
    };
    this.backgroundColors = {
      unfocused: Colors("white").get(),
      focused: theme.colors.accentGrey.light
    };
    if (this.hasFocus()) {
      this._focus();
    }
  }
  static get height() {
    return 60;
  }
  static get width() {
    return 160;
  }
}
const keyboardConfig = {
  layouts: {
    "abc": [
      ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"],
      ["k", "l", "m", "n", "o", "p", "q", "r", "s", "t"],
      ["u", "v", "w", "x", "y", "z", "_", "-", "@", "."],
      ["Layout:ABC", "Layout:123", "Space", "Search", "Del"]
    ],
    "ABC": [
      ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"],
      ["K", "L", "M", "N", "O", "P", "Q", "R", "S", "T"],
      ["U", "V", "W", "X", "Y", "Z", "_", "-", "@", "."],
      ["Layout:abc", "Layout:123", "Space", "Search", "Del"]
    ],
    "123": [
      ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
      ["Layout:abc", "Space", "Clear", "Del"]
    ]
  },
  styling: {
    align: "center",
    horizontalSpacing: 5,
    verticalSpacing: 20
  },
  buttonTypes: {
    default: {
      type: Key2
    },
    Del: {
      type: ActionKey,
      icon: "del"
    },
    Layout: {
      type: ActionKey
    },
    Space: {
      type: ActionKey,
      w: 280,
      label: "space"
    },
    Clear: {
      type: ActionKey,
      label: "clear"
    },
    Search: {
      type: ActionKey,
      label: "search"
    }
  }
};
class ContentDetails extends lightning.Component {
  constructor() {
    super(...arguments);
    this.contentId = "";
    this.index = 1;
    this.from = "";
  }
  // readonly contentView = this.getByRef("ContentView")!;
  // readonly spinner = this.contentView.getByRef("Spinner")!;
  // readonly background = this.contentView.getByRef("Background")!;
  // readonly contentDataView = this.contentView.getByRef("ContentData")!;
  // readonly thumbnail = this.contentDataView.getByRef("Thumbnail")!;
  // readonly title = this.contentDataView.getByRef("Title")!;
  // readonly description = this.contentDataView.getByRef("Description")!;
  // readonly genre = this.contentDataView.getByRef("Genre")!;
  // readonly info = this.contentDataView.getByRef("Info")!;
  static _template() {
    return {
      ContentView: {
        w: 1920,
        h: 1080,
        color: theme.colors.black,
        rect: true,
        shader: { x: 100, y: -100, pivot: 0.5, type: lightning.shaders.RadialGradient, outerColor: theme.colors.primaryLight, innerColor: theme.colors.dark, radius: 800 },
        Thumbnail: {
          x: 1e3,
          y: 110,
          scale: 1.5,
          shader: { type: lightning.shaders.FadeOut, innerColor: theme.colors.black, left: 200, bottom: 200 }
        },
        ContentData: {
          shader: null,
          zIndex: 2,
          Title: {
            x: 40,
            y: 165,
            shader: null,
            text: {
              fontSize: 80
            },
            color: theme.colors.white
          },
          Description: {
            x: 40,
            y: 270,
            w: 900,
            shader: null,
            text: {
              wordWrap: true,
              maxLines: 3,
              maxLinesSuffix: "...",
              fontSize: 30
            },
            color: theme.colors.accentGrey.light
          },
          Genre: {
            x: 40,
            y: 380,
            w: 900,
            shader: null,
            text: {
              fontSize: 24
            },
            color: theme.colors.accentGrey.light
          },
          Info: {
            visible: false,
            Director: {
              x: 40,
              y: 440,
              w: 100,
              shader: null,
              text: {
                text: "Director : ",
                fontSize: 24
              },
              color: theme.colors.accentGrey.light
            },
            Starring: {
              x: 40,
              y: 470,
              w: 100,
              shader: null,
              text: {
                text: "Staring  : ",
                fontSize: 24
              },
              color: theme.colors.accentGrey.light
            },
            DirectorList: {
              x: 150,
              y: 440,
              w: 800,
              shader: null,
              text: {
                fontSize: 24
              },
              color: theme.colors.accentGrey.light
            },
            StarringList: {
              x: 150,
              y: 470,
              w: 800,
              shader: null,
              text: {
                fontSize: 24,
                wordWrap: true,
                maxLines: 1,
                maxLinesSuffix: "..."
              },
              color: theme.colors.accentGrey.light
            }
          },
          VideoSpec: {
            visible: false,
            VideoSpec1: {
              x: 70,
              y: 140,
              shader: null,
              type: VideoSpecItem,
              specData: "  16+  "
            },
            VideoSpec2: {
              x: 135,
              y: 140,
              shader: null,
              type: VideoSpecItem,
              specData: "  4k  "
            },
            VideoSpec3: {
              x: 193,
              y: 140,
              shader: null,
              type: VideoSpecItem,
              specData: "  cc  "
            }
          }
        },
        ContentActions: {
          shader: null,
          BackButton: {
            x: 40,
            y: 40,
            type: BackButton
          },
          PlayButton: {
            x: 40,
            y: 570,
            type: Button,
            label: "Play Video"
          },
          PlayTrailer: {
            x: 40,
            y: 700,
            type: Button,
            label: "Play Trailer"
          }
        }
      }
    };
  }
  _inactive() {
    console.log("Inactive");
    this.index = 1;
  }
  set params(args) {
    var _a;
    const { id, from, data } = args;
    this.from = from;
    let imgSrc = (_a = data.images.find((img) => img.width === 828)) == null ? void 0 : _a.url;
    console.log(args);
    this.patch({
      ContentView: {
        shader: { type: lightning.shaders.RadialGradient, x: 300, y: 300, innerColor: 4278190080, radius: 1500 },
        Thumbnail: {
          src: imgSrc
        },
        ContentData: {
          x: 10,
          Title: {
            text: {
              text: data.title
            }
          },
          Description: {
            text: {
              text: data.description
            }
          },
          Genre: {
            text: {
              text: data.genre.join(" . ")
            }
          },
          Info: {
            visible: true,
            DirectorList: {
              text: {
                text: data.director.map((a) => a.personName).join(", ")
              }
            },
            StarringList: {
              text: {
                text: data.actor.map((a) => a.personName).join(", ")
              }
            }
          },
          VideoSpec: {
            visible: true
          }
        }
      }
    });
    this._refocus();
  }
  _init() {
  }
  // animating elements on netering the page (invoked in the transition)
  animateElements() {
    const contentAnimation = this.tag("ContentView.ContentData").animation({
      duration: 1,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 0, 1: 1 } },
        { p: "y", v: { 0: -60, 1: 0 } }
      ]
    });
    const contentActionsAnimation = this.tag("ContentView.ContentActions").animation({
      duration: 1,
      delay: 0,
      actions: [
        { p: "alpha", v: { 0: 0, 1: 1 } },
        { p: "x", v: { 0: -100, 1: 10 } }
      ]
    });
    contentActionsAnimation.start();
    contentAnimation.start();
  }
  // overrides the default up button actions
  _handleUp() {
    if (this.index > 0) {
      this.index -= 1;
    }
  }
  // overrides the default right button actions
  _handleDown() {
    if (this.index < 2) {
      this.index += 1;
    }
  }
  // overrides the default behavior when enter button is clicked
  _handleEnter() {
    console.log(this.from);
    if (this.index === 0) {
      if (this.from == "gridItem" || this.from == "Grid") {
        Router.navigate("grid");
      } else {
        Router.navigate("home");
      }
    } else {
      Router.navigate(`player/${this.contentId}`);
    }
  }
  // returns the focused components
  _getFocused() {
    return this.tag("ContentView.ContentActions").children[this.index];
  }
  // custom page transition
  pageTransition(pageIn, pageOut) {
    if (!pageOut)
      return Promise.resolve();
    return new Promise((resolve, reject) => {
      pageOut.pageTransitionOut(pageOut).then(() => {
        pageIn.visible = true;
        pageIn.animateElements();
        resolve();
      });
    });
  }
}
var shakaPlayer_compiled = {};
/*
 @license
 Shaka Player
 Copyright 2016 Google LLC
 SPDX-License-Identifier: Apache-2.0
*/
(function(exports) {
  (function() {
    var innerGlobal = typeof window != "undefined" ? window : commonjsGlobal;
    var exportTo = {};
    (function(window2, global2, module) {
      /*
       @license
       Shaka Player
       Copyright 2016 Google LLC
       SPDX-License-Identifier: Apache-2.0
      */
      var q;
      function aa(a) {
        var b = 0;
        return function() {
          return b < a.length ? { done: false, value: a[b++] } : { done: true };
        };
      }
      var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
        if (a == Array.prototype || a == Object.prototype)
          return a;
        a[b] = c.value;
        return a;
      };
      function ca(a) {
        a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window2 && window2, "object" == typeof self && self, "object" == typeof global2 && global2];
        for (var b = 0; b < a.length; ++b) {
          var c = a[b];
          if (c && c.Math == Math)
            return c;
        }
        throw Error("Cannot find global object");
      }
      var da = ca(this);
      function ea(a, b) {
        if (b)
          a: {
            var c = da;
            a = a.split(".");
            for (var d = 0; d < a.length - 1; d++) {
              var e = a[d];
              if (!(e in c))
                break a;
              c = c[e];
            }
            a = a[a.length - 1];
            d = c[a];
            b = b(d);
            b != d && null != b && ba(c, a, { configurable: true, writable: true, value: b });
          }
      }
      ea("Symbol", function(a) {
        function b(f) {
          if (this instanceof b)
            throw new TypeError("Symbol is not a constructor");
          return new c(d + (f || "") + "_" + e++, f);
        }
        function c(f, g) {
          this.g = f;
          ba(this, "description", { configurable: true, writable: true, value: g });
        }
        if (a)
          return a;
        c.prototype.toString = function() {
          return this.g;
        };
        var d = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e = 0;
        return b;
      });
      ea("Symbol.iterator", function(a) {
        if (a)
          return a;
        a = Symbol("Symbol.iterator");
        for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
          var d = da[b[c]];
          "function" === typeof d && "function" != typeof d.prototype[a] && ba(d.prototype, a, { configurable: true, writable: true, value: function() {
            return fa(aa(this));
          } });
        }
        return a;
      });
      function fa(a) {
        a = { next: a };
        a[Symbol.iterator] = function() {
          return this;
        };
        return a;
      }
      function r(a) {
        var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
        return b ? b.call(a) : { next: aa(a) };
      }
      function ha(a) {
        if (!(a instanceof Array)) {
          a = r(a);
          for (var b, c = []; !(b = a.next()).done; )
            c.push(b.value);
          a = c;
        }
        return a;
      }
      var ia = "function" == typeof Object.create ? Object.create : function(a) {
        function b() {
        }
        b.prototype = a;
        return new b();
      }, ja;
      if ("function" == typeof Object.setPrototypeOf)
        ja = Object.setPrototypeOf;
      else {
        var ka;
        a: {
          var la = { a: true }, ma = {};
          try {
            ma.__proto__ = la;
            ka = ma.a;
            break a;
          } catch (a) {
          }
          ka = false;
        }
        ja = ka ? function(a, b) {
          a.__proto__ = b;
          if (a.__proto__ !== b)
            throw new TypeError(a + " is not extensible");
          return a;
        } : null;
      }
      var na = ja;
      function oa(a, b) {
        a.prototype = ia(b.prototype);
        a.prototype.constructor = a;
        if (na)
          na(a, b);
        else
          for (var c in b)
            if ("prototype" != c)
              if (Object.defineProperties) {
                var d = Object.getOwnPropertyDescriptor(b, c);
                d && Object.defineProperty(a, c, d);
              } else
                a[c] = b[c];
        a.xh = b.prototype;
      }
      function pa() {
        this.o = false;
        this.l = null;
        this.h = void 0;
        this.g = 1;
        this.j = this.m = 0;
        this.u = this.i = null;
      }
      function qa(a) {
        if (a.o)
          throw new TypeError("Generator is already running");
        a.o = true;
      }
      pa.prototype.s = function(a) {
        this.h = a;
      };
      function ra(a, b) {
        a.i = { Ee: b, Le: true };
        a.g = a.m || a.j;
      }
      pa.prototype.return = function(a) {
        this.i = { return: a };
        this.g = this.j;
      };
      function u(a, b, c) {
        a.g = c;
        return { value: b };
      }
      pa.prototype.A = function(a) {
        this.g = a;
      };
      function A(a) {
        a.g = 0;
      }
      function D(a, b, c) {
        a.m = b;
        void 0 != c && (a.j = c);
      }
      function sa(a) {
        a.m = 0;
        a.j = 2;
      }
      function ta(a, b) {
        a.g = b;
        a.m = 0;
      }
      function ua(a) {
        a.m = 0;
        var b = a.i.Ee;
        a.i = null;
        return b;
      }
      function xa(a) {
        a.u = [a.i];
        a.m = 0;
        a.j = 0;
      }
      function ya(a, b) {
        var c = a.u.splice(0)[0];
        (c = a.i = a.i || c) ? c.Le ? a.g = a.m || a.j : void 0 != c.A && a.j < c.A ? (a.g = c.A, a.i = null) : a.g = a.j : a.g = b;
      }
      function za(a) {
        this.g = new pa();
        this.h = a;
      }
      function Aa(a, b) {
        qa(a.g);
        var c = a.g.l;
        if (c)
          return Ba(a, "return" in c ? c["return"] : function(d) {
            return { value: d, done: true };
          }, b, a.g.return);
        a.g.return(b);
        return Ca(a);
      }
      function Ba(a, b, c, d) {
        try {
          var e = b.call(a.g.l, c);
          if (!(e instanceof Object))
            throw new TypeError("Iterator result " + e + " is not an object");
          if (!e.done)
            return a.g.o = false, e;
          var f = e.value;
        } catch (g) {
          return a.g.l = null, ra(a.g, g), Ca(a);
        }
        a.g.l = null;
        d.call(a.g, f);
        return Ca(a);
      }
      function Ca(a) {
        for (; a.g.g; )
          try {
            var b = a.h(a.g);
            if (b)
              return a.g.o = false, { value: b.value, done: false };
          } catch (c) {
            a.g.h = void 0, ra(a.g, c);
          }
        a.g.o = false;
        if (a.g.i) {
          b = a.g.i;
          a.g.i = null;
          if (b.Le)
            throw b.Ee;
          return { value: b.return, done: true };
        }
        return { value: void 0, done: true };
      }
      function Da(a) {
        this.next = function(b) {
          qa(a.g);
          a.g.l ? b = Ba(a, a.g.l.next, b, a.g.s) : (a.g.s(b), b = Ca(a));
          return b;
        };
        this.throw = function(b) {
          qa(a.g);
          a.g.l ? b = Ba(a, a.g.l["throw"], b, a.g.s) : (ra(a.g, b), b = Ca(a));
          return b;
        };
        this.return = function(b) {
          return Aa(a, b);
        };
        this[Symbol.iterator] = function() {
          return this;
        };
      }
      function Ea(a) {
        function b(d) {
          return a.next(d);
        }
        function c(d) {
          return a.throw(d);
        }
        return new Promise(function(d, e) {
          function f(g) {
            g.done ? d(g.value) : Promise.resolve(g.value).then(b, c).then(f, e);
          }
          f(a.next());
        });
      }
      function G(a) {
        return Ea(new Da(new za(a)));
      }
      function Fa() {
        for (var a = Number(this), b = [], c = a; c < arguments.length; c++)
          b[c - a] = arguments[c];
        return b;
      }
      ea("Promise", function(a) {
        function b(g) {
          this.h = 0;
          this.i = void 0;
          this.g = [];
          this.o = false;
          var h = this.j();
          try {
            g(h.resolve, h.reject);
          } catch (k2) {
            h.reject(k2);
          }
        }
        function c() {
          this.g = null;
        }
        function d(g) {
          return g instanceof b ? g : new b(function(h) {
            h(g);
          });
        }
        if (a)
          return a;
        c.prototype.h = function(g) {
          if (null == this.g) {
            this.g = [];
            var h = this;
            this.i(function() {
              h.l();
            });
          }
          this.g.push(g);
        };
        var e = da.setTimeout;
        c.prototype.i = function(g) {
          e(g, 0);
        };
        c.prototype.l = function() {
          for (; this.g && this.g.length; ) {
            var g = this.g;
            this.g = [];
            for (var h = 0; h < g.length; ++h) {
              var k2 = g[h];
              g[h] = null;
              try {
                k2();
              } catch (l) {
                this.j(l);
              }
            }
          }
          this.g = null;
        };
        c.prototype.j = function(g) {
          this.i(function() {
            throw g;
          });
        };
        b.prototype.j = function() {
          function g(l) {
            return function(m) {
              k2 || (k2 = true, l.call(h, m));
            };
          }
          var h = this, k2 = false;
          return { resolve: g(this.F), reject: g(this.l) };
        };
        b.prototype.F = function(g) {
          if (g === this)
            this.l(new TypeError("A Promise cannot resolve to itself"));
          else if (g instanceof b)
            this.H(g);
          else {
            a:
              switch (typeof g) {
                case "object":
                  var h = null != g;
                  break a;
                case "function":
                  h = true;
                  break a;
                default:
                  h = false;
              }
            h ? this.D(g) : this.m(g);
          }
        };
        b.prototype.D = function(g) {
          var h = void 0;
          try {
            h = g.then;
          } catch (k2) {
            this.l(k2);
            return;
          }
          "function" == typeof h ? this.J(h, g) : this.m(g);
        };
        b.prototype.l = function(g) {
          this.s(2, g);
        };
        b.prototype.m = function(g) {
          this.s(1, g);
        };
        b.prototype.s = function(g, h) {
          if (0 != this.h)
            throw Error("Cannot settle(" + g + ", " + h + "): Promise already settled in state" + this.h);
          this.h = g;
          this.i = h;
          2 === this.h && this.G();
          this.u();
        };
        b.prototype.G = function() {
          var g = this;
          e(function() {
            if (g.B()) {
              var h = da.console;
              "undefined" !== typeof h && h.error(g.i);
            }
          }, 1);
        };
        b.prototype.B = function() {
          if (this.o)
            return false;
          var g = da.CustomEvent, h = da.Event, k2 = da.dispatchEvent;
          if ("undefined" === typeof k2)
            return true;
          "function" === typeof g ? g = new g("unhandledrejection", { cancelable: true }) : "function" === typeof h ? g = new h("unhandledrejection", { cancelable: true }) : (g = da.document.createEvent("CustomEvent"), g.initCustomEvent("unhandledrejection", false, true, g));
          g.promise = this;
          g.reason = this.i;
          return k2(g);
        };
        b.prototype.u = function() {
          if (null != this.g) {
            for (var g = 0; g < this.g.length; ++g)
              f.h(this.g[g]);
            this.g = null;
          }
        };
        var f = new c();
        b.prototype.H = function(g) {
          var h = this.j();
          g.Lc(h.resolve, h.reject);
        };
        b.prototype.J = function(g, h) {
          var k2 = this.j();
          try {
            g.call(h, k2.resolve, k2.reject);
          } catch (l) {
            k2.reject(l);
          }
        };
        b.prototype.then = function(g, h) {
          function k2(p, t) {
            return "function" == typeof p ? function(v) {
              try {
                l(p(v));
              } catch (y) {
                m(y);
              }
            } : t;
          }
          var l, m, n = new b(function(p, t) {
            l = p;
            m = t;
          });
          this.Lc(k2(g, l), k2(h, m));
          return n;
        };
        b.prototype.catch = function(g) {
          return this.then(void 0, g);
        };
        b.prototype.Lc = function(g, h) {
          function k2() {
            switch (l.h) {
              case 1:
                g(l.i);
                break;
              case 2:
                h(l.i);
                break;
              default:
                throw Error("Unexpected state: " + l.h);
            }
          }
          var l = this;
          null == this.g ? f.h(k2) : this.g.push(k2);
          this.o = true;
        };
        b.resolve = d;
        b.reject = function(g) {
          return new b(function(h, k2) {
            k2(g);
          });
        };
        b.race = function(g) {
          return new b(function(h, k2) {
            for (var l = r(g), m = l.next(); !m.done; m = l.next())
              d(m.value).Lc(h, k2);
          });
        };
        b.all = function(g) {
          var h = r(g), k2 = h.next();
          return k2.done ? d([]) : new b(function(l, m) {
            function n(v) {
              return function(y) {
                p[v] = y;
                t--;
                0 == t && l(p);
              };
            }
            var p = [], t = 0;
            do
              p.push(void 0), t++, d(k2.value).Lc(n(p.length - 1), m), k2 = h.next();
            while (!k2.done);
          });
        };
        return b;
      });
      function Ha(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      ea("WeakMap", function(a) {
        function b(k2) {
          this.g = (h += Math.random() + 1).toString();
          if (k2) {
            k2 = r(k2);
            for (var l; !(l = k2.next()).done; )
              l = l.value, this.set(l[0], l[1]);
          }
        }
        function c() {
        }
        function d(k2) {
          var l = typeof k2;
          return "object" === l && null !== k2 || "function" === l;
        }
        function e(k2) {
          if (!Ha(k2, g)) {
            var l = new c();
            ba(k2, g, { value: l });
          }
        }
        function f(k2) {
          var l = Object[k2];
          l && (Object[k2] = function(m) {
            if (m instanceof c)
              return m;
            Object.isExtensible(m) && e(m);
            return l(m);
          });
        }
        if (function() {
          if (!a || !Object.seal)
            return false;
          try {
            var k2 = Object.seal({}), l = Object.seal({}), m = new a([[k2, 2], [l, 3]]);
            if (2 != m.get(k2) || 3 != m.get(l))
              return false;
            m.delete(k2);
            m.set(l, 4);
            return !m.has(k2) && 4 == m.get(l);
          } catch (n) {
            return false;
          }
        }())
          return a;
        var g = "$jscomp_hidden_" + Math.random();
        f("freeze");
        f("preventExtensions");
        f("seal");
        var h = 0;
        b.prototype.set = function(k2, l) {
          if (!d(k2))
            throw Error("Invalid WeakMap key");
          e(k2);
          if (!Ha(k2, g))
            throw Error("WeakMap key fail: " + k2);
          k2[g][this.g] = l;
          return this;
        };
        b.prototype.get = function(k2) {
          return d(k2) && Ha(k2, g) ? k2[g][this.g] : void 0;
        };
        b.prototype.has = function(k2) {
          return d(k2) && Ha(
            k2,
            g
          ) && Ha(k2[g], this.g);
        };
        b.prototype.delete = function(k2) {
          return d(k2) && Ha(k2, g) && Ha(k2[g], this.g) ? delete k2[g][this.g] : false;
        };
        return b;
      });
      ea("Map", function(a) {
        function b() {
          var h = {};
          return h.Qa = h.next = h.head = h;
        }
        function c(h, k2) {
          var l = h.g;
          return fa(function() {
            if (l) {
              for (; l.head != h.g; )
                l = l.Qa;
              for (; l.next != l.head; )
                return l = l.next, { done: false, value: k2(l) };
              l = null;
            }
            return { done: true, value: void 0 };
          });
        }
        function d(h, k2) {
          var l = k2 && typeof k2;
          "object" == l || "function" == l ? f.has(k2) ? l = f.get(k2) : (l = "" + ++g, f.set(k2, l)) : l = "p_" + k2;
          var m = h.h[l];
          if (m && Ha(h.h, l))
            for (h = 0; h < m.length; h++) {
              var n = m[h];
              if (k2 !== k2 && n.key !== n.key || k2 === n.key)
                return { id: l, list: m, index: h, ga: n };
            }
          return {
            id: l,
            list: m,
            index: -1,
            ga: void 0
          };
        }
        function e(h) {
          this.h = {};
          this.g = b();
          this.size = 0;
          if (h) {
            h = r(h);
            for (var k2; !(k2 = h.next()).done; )
              k2 = k2.value, this.set(k2[0], k2[1]);
          }
        }
        if (function() {
          if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal)
            return false;
          try {
            var h = Object.seal({ x: 4 }), k2 = new a(r([[h, "s"]]));
            if ("s" != k2.get(h) || 1 != k2.size || k2.get({ x: 4 }) || k2.set({ x: 4 }, "t") != k2 || 2 != k2.size)
              return false;
            var l = k2.entries(), m = l.next();
            if (m.done || m.value[0] != h || "s" != m.value[1])
              return false;
            m = l.next();
            return m.done || 4 != m.value[0].x || "t" != m.value[1] || !l.next().done ? false : true;
          } catch (n) {
            return false;
          }
        }())
          return a;
        var f = /* @__PURE__ */ new WeakMap();
        e.prototype.set = function(h, k2) {
          h = 0 === h ? 0 : h;
          var l = d(this, h);
          l.list || (l.list = this.h[l.id] = []);
          l.ga ? l.ga.value = k2 : (l.ga = { next: this.g, Qa: this.g.Qa, head: this.g, key: h, value: k2 }, l.list.push(l.ga), this.g.Qa.next = l.ga, this.g.Qa = l.ga, this.size++);
          return this;
        };
        e.prototype.delete = function(h) {
          h = d(this, h);
          return h.ga && h.list ? (h.list.splice(h.index, 1), h.list.length || delete this.h[h.id], h.ga.Qa.next = h.ga.next, h.ga.next.Qa = h.ga.Qa, h.ga.head = null, this.size--, true) : false;
        };
        e.prototype.clear = function() {
          this.h = {};
          this.g = this.g.Qa = b();
          this.size = 0;
        };
        e.prototype.has = function(h) {
          return !!d(this, h).ga;
        };
        e.prototype.get = function(h) {
          return (h = d(this, h).ga) && h.value;
        };
        e.prototype.entries = function() {
          return c(this, function(h) {
            return [h.key, h.value];
          });
        };
        e.prototype.keys = function() {
          return c(this, function(h) {
            return h.key;
          });
        };
        e.prototype.values = function() {
          return c(this, function(h) {
            return h.value;
          });
        };
        e.prototype.forEach = function(h, k2) {
          for (var l = this.entries(), m; !(m = l.next()).done; )
            m = m.value, h.call(k2, m[1], m[0], this);
        };
        e.prototype[Symbol.iterator] = e.prototype.entries;
        var g = 0;
        return e;
      });
      ea("Set", function(a) {
        function b(c) {
          this.g = /* @__PURE__ */ new Map();
          if (c) {
            c = r(c);
            for (var d; !(d = c.next()).done; )
              this.add(d.value);
          }
          this.size = this.g.size;
        }
        if (function() {
          if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal)
            return false;
          try {
            var c = Object.seal({ x: 4 }), d = new a(r([c]));
            if (!d.has(c) || 1 != d.size || d.add(c) != d || 1 != d.size || d.add({ x: 4 }) != d || 2 != d.size)
              return false;
            var e = d.entries(), f = e.next();
            if (f.done || f.value[0] != c || f.value[1] != c)
              return false;
            f = e.next();
            return f.done || f.value[0] == c || 4 != f.value[0].x || f.value[1] != f.value[0] ? false : e.next().done;
          } catch (g) {
            return false;
          }
        }())
          return a;
        b.prototype.add = function(c) {
          c = 0 === c ? 0 : c;
          this.g.set(c, c);
          this.size = this.g.size;
          return this;
        };
        b.prototype.delete = function(c) {
          c = this.g.delete(c);
          this.size = this.g.size;
          return c;
        };
        b.prototype.clear = function() {
          this.g.clear();
          this.size = 0;
        };
        b.prototype.has = function(c) {
          return this.g.has(c);
        };
        b.prototype.entries = function() {
          return this.g.entries();
        };
        b.prototype.values = function() {
          return this.g.values();
        };
        b.prototype.keys = b.prototype.values;
        b.prototype[Symbol.iterator] = b.prototype.values;
        b.prototype.forEach = function(c, d) {
          var e = this;
          this.g.forEach(function(f) {
            return c.call(d, f, f, e);
          });
        };
        return b;
      });
      function Ia(a, b, c) {
        a instanceof String && (a = String(a));
        for (var d = a.length, e = 0; e < d; e++) {
          var f = a[e];
          if (b.call(c, f, e, a))
            return { Je: e, v: f };
        }
        return { Je: -1, v: void 0 };
      }
      ea("Array.prototype.findIndex", function(a) {
        return a ? a : function(b, c) {
          return Ia(this, b, c).Je;
        };
      });
      ea("Object.is", function(a) {
        return a ? a : function(b, c) {
          return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c;
        };
      });
      ea("Array.prototype.includes", function(a) {
        return a ? a : function(b, c) {
          var d = this;
          d instanceof String && (d = String(d));
          var e = d.length;
          c = c || 0;
          for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
            var f = d[c];
            if (f === b || Object.is(f, b))
              return true;
          }
          return false;
        };
      });
      function Ka(a, b, c) {
        if (null == a)
          throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
        if (b instanceof RegExp)
          throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
        return a + "";
      }
      ea("String.prototype.includes", function(a) {
        return a ? a : function(b, c) {
          return -1 !== Ka(this, b, "includes").indexOf(b, c || 0);
        };
      });
      ea("Array.prototype.find", function(a) {
        return a ? a : function(b, c) {
          return Ia(this, b, c).v;
        };
      });
      ea("String.prototype.startsWith", function(a) {
        return a ? a : function(b, c) {
          var d = Ka(this, b, "startsWith"), e = d.length, f = b.length;
          c = Math.max(0, Math.min(c | 0, d.length));
          for (var g = 0; g < f && c < e; )
            if (d[c++] != b[g++])
              return false;
          return g >= f;
        };
      });
      function La(a, b) {
        a instanceof String && (a += "");
        var c = 0, d = false, e = { next: function() {
          if (!d && c < a.length) {
            var f = c++;
            return { value: b(f, a[f]), done: false };
          }
          d = true;
          return { done: true, value: void 0 };
        } };
        e[Symbol.iterator] = function() {
          return e;
        };
        return e;
      }
      ea("Array.prototype.keys", function(a) {
        return a ? a : function() {
          return La(this, function(b) {
            return b;
          });
        };
      });
      var Na = "function" == typeof Object.assign ? Object.assign : function(a, b) {
        for (var c = 1; c < arguments.length; c++) {
          var d = arguments[c];
          if (d)
            for (var e in d)
              Ha(d, e) && (a[e] = d[e]);
        }
        return a;
      };
      ea("Object.assign", function(a) {
        return a || Na;
      });
      ea("Array.from", function(a) {
        return a ? a : function(b, c, d) {
          c = null != c ? c : function(h) {
            return h;
          };
          var e = [], f = "undefined" != typeof Symbol && Symbol.iterator && b[Symbol.iterator];
          if ("function" == typeof f) {
            b = f.call(b);
            for (var g = 0; !(f = b.next()).done; )
              e.push(c.call(d, f.value, g++));
          } else
            for (f = b.length, g = 0; g < f; g++)
              e.push(c.call(d, b[g], g));
          return e;
        };
      });
      ea("Array.prototype.values", function(a) {
        return a ? a : function() {
          return La(this, function(b, c) {
            return c;
          });
        };
      });
      ea("Promise.prototype.finally", function(a) {
        return a ? a : function(b) {
          return this.then(function(c) {
            return Promise.resolve(b()).then(function() {
              return c;
            });
          }, function(c) {
            return Promise.resolve(b()).then(function() {
              throw c;
            });
          });
        };
      });
      ea("Array.prototype.entries", function(a) {
        return a ? a : function() {
          return La(this, function(b, c) {
            return [b, c];
          });
        };
      });
      ea("String.prototype.repeat", function(a) {
        return a ? a : function(b) {
          var c = Ka(this, null, "repeat");
          if (0 > b || 1342177279 < b)
            throw new RangeError("Invalid count value");
          b |= 0;
          for (var d = ""; b; )
            if (b & 1 && (d += c), b >>>= 1)
              c += c;
          return d;
        };
      });
      ea("Number.isNaN", function(a) {
        return a ? a : function(b) {
          return "number" === typeof b && isNaN(b);
        };
      });
      ea("Object.values", function(a) {
        return a ? a : function(b) {
          var c = [], d;
          for (d in b)
            Ha(b, d) && c.push(b[d]);
          return c;
        };
      });
      ea("Math.log2", function(a) {
        return a ? a : function(b) {
          return Math.log(b) / Math.LN2;
        };
      });
      ea("Math.trunc", function(a) {
        return a ? a : function(b) {
          b = Number(b);
          if (isNaN(b) || Infinity === b || -Infinity === b || 0 === b)
            return b;
          var c = Math.floor(Math.abs(b));
          return 0 > b ? -c : c;
        };
      });
      ea("Object.entries", function(a) {
        return a ? a : function(b) {
          var c = [], d;
          for (d in b)
            Ha(b, d) && c.push([d, b[d]]);
          return c;
        };
      });
      var Oa = this || self;
      function K(a, b) {
        a = a.split(".");
        var c = Oa;
        a[0] in c || "undefined" == typeof c.execScript || c.execScript("var " + a[0]);
        for (var d; a.length && (d = a.shift()); )
          a.length || void 0 === b ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
      }
      function Pa(a) {
        this.g = Math.exp(Math.log(0.5) / a);
        this.i = this.h = 0;
      }
      Pa.prototype.sample = function(a, b) {
        var c = Math.pow(this.g, a);
        b = b * (1 - c) + c * this.h;
        isNaN(b) || (this.h = b, this.i += a);
      };
      function Qa(a) {
        return a.h / (1 - Math.pow(a.g, a.i));
      }
      function Ra() {
        this.h = new Pa(2);
        this.j = new Pa(5);
        this.g = 0;
        this.i = 128e3;
        this.l = 16e3;
      }
      Ra.prototype.configure = function(a) {
        this.i = a.minTotalBytes;
        this.l = a.minBytes;
        this.h.g = Math.exp(Math.log(0.5) / a.fastHalfLife);
        this.j.g = Math.exp(Math.log(0.5) / a.slowHalfLife);
      };
      Ra.prototype.sample = function(a, b) {
        if (!(b < this.l)) {
          var c = 8e3 * b / a;
          a /= 1e3;
          this.g += b;
          this.h.sample(a, c);
          this.j.sample(a, c);
        }
      };
      Ra.prototype.getBandwidthEstimate = function(a) {
        return this.g < this.i ? a : Math.min(Qa(this.h), Qa(this.j));
      };
      function Ta() {
      }
      function Va() {
      }
      function Wa() {
      }
      function Xa(a) {
        var b = Fa.apply(1, arguments);
        Ya.has(a) || (Ya.add(a), Wa.apply(Ta, ha(b)));
      }
      function Za() {
      }
      function $a() {
      }
      function ab() {
      }
      function bb() {
      }
      var Ya = /* @__PURE__ */ new Set();
      if (window2.console && window2.console.log.bind) {
        var cb = {}, db = (cb[1] = console.error.bind(console), cb[2] = console.warn.bind(console), cb[3] = console.info.bind(console), cb[4] = console.log.bind(console), cb[5] = console.debug.bind(console), cb[6] = console.debug.bind(console), cb);
        Wa = db[2];
        Va = db[1];
      }
      function eb(a) {
        if (fb.has(a))
          return fb.get(a);
        var b = MediaSource.isTypeSupported(a);
        fb.set(a, b);
        return b;
      }
      var fb = /* @__PURE__ */ new Map();
      function gb(a, b) {
        return "number" === typeof a && "number" === typeof b && isNaN(a) && isNaN(b) ? true : a === b;
      }
      function hb(a, b) {
        b = a.indexOf(b);
        -1 < b && a.splice(b, 1);
      }
      function ib(a, b, c) {
        c || (c = gb);
        if (a.length != b.length)
          return false;
        b = b.slice();
        var d = {};
        a = r(a);
        for (var e = a.next(); !e.done; d = { md: d.md }, e = a.next()) {
          d.md = e.value;
          e = b.findIndex(function(f) {
            return function(g) {
              return c(f.md, g);
            };
          }(d));
          if (-1 == e)
            return false;
          b[e] = b[b.length - 1];
          b.pop();
        }
        return 0 == b.length;
      }
      function jb(a, b, c) {
        c || (c = gb);
        if (a.length != b.length)
          return false;
        for (var d = 0; d < a.length; d++)
          if (!c(a[d], b[d]))
            return false;
        return true;
      }
      function kb(a, b, c) {
        this.startTime = a;
        this.direction = lb;
        this.endTime = b;
        this.payload = c;
        this.region = new mb();
        this.position = null;
        this.positionAlign = nb;
        this.size = 0;
        this.textAlign = ob;
        this.writingMode = qb;
        this.lineInterpretation = rb;
        this.line = null;
        this.lineHeight = "";
        this.lineAlign = sb;
        this.displayAlign = tb;
        this.fontSize = this.textStrokeWidth = this.textStrokeColor = this.textShadow = this.border = this.backgroundImage = this.backgroundColor = this.color = "";
        this.fontWeight = ub;
        this.fontStyle = vb;
        this.linePadding = this.letterSpacing = this.fontFamily = "";
        this.opacity = 1;
        this.textDecoration = [];
        this.wrapLine = true;
        this.id = "";
        this.nestedCues = [];
        this.lineBreak = this.isContainer = false;
        this.cellResolution = { columns: 32, rows: 15 };
      }
      kb.prototype.clone = function() {
        var a = new kb(0, 0, ""), b;
        for (b in this)
          a[b] = this[b], a[b] && a[b].constructor == Array && (a[b] = a[b].slice());
        return a;
      };
      function wb(a, b) {
        if (a.startTime != b.startTime || a.endTime != b.endTime || a.payload != b.payload)
          return false;
        for (var c in a)
          if ("startTime" != c && "endTime" != c && "payload" != c) {
            if ("nestedCues" == c) {
              if (!jb(a.nestedCues, b.nestedCues, wb))
                return false;
            } else if ("region" == c || "cellResolution" == c)
              for (var d in a[c]) {
                if (a[c][d] != b[c][d])
                  return false;
              }
            else if (Array.isArray(a[c])) {
              if (!jb(a[c], b[c]))
                return false;
            } else if (a[c] != b[c])
              return false;
          }
        return true;
      }
      K("shaka.text.Cue", kb);
      var nb = "auto";
      kb.positionAlign = { LEFT: "line-left", RIGHT: "line-right", CENTER: "center", AUTO: nb };
      var ob = "center", xb = { LEFT: "left", RIGHT: "right", CENTER: ob, START: "start", END: "end" };
      kb.textAlign = xb;
      var tb = "after", yb = { BEFORE: "before", CENTER: "center", AFTER: tb };
      kb.displayAlign = yb;
      var lb = "ltr";
      kb.direction = { HORIZONTAL_LEFT_TO_RIGHT: lb, HORIZONTAL_RIGHT_TO_LEFT: "rtl" };
      var qb = "horizontal-tb";
      kb.writingMode = { HORIZONTAL_TOP_TO_BOTTOM: qb, VERTICAL_LEFT_TO_RIGHT: "vertical-lr", VERTICAL_RIGHT_TO_LEFT: "vertical-rl" };
      var rb = 0;
      kb.lineInterpretation = { LINE_NUMBER: rb, PERCENTAGE: 1 };
      var sb = "start", zb = { CENTER: "center", START: sb, END: "end" };
      kb.lineAlign = zb;
      var Ab = { white: "#FFF", lime: "#0F0", cyan: "#0FF", red: "#F00", yellow: "#FF0", magenta: "#F0F", blue: "#00F", black: "#000" };
      kb.defaultTextColor = Ab;
      var Bb = { bg_white: "#FFF", bg_lime: "#0F0", bg_cyan: "#0FF", bg_red: "#F00", bg_yellow: "#FF0", bg_magenta: "#F0F", bg_blue: "#00F", bg_black: "#000" };
      kb.defaultTextBackgroundColor = Bb;
      var ub = 400;
      kb.fontWeight = { NORMAL: ub, BOLD: 700 };
      var vb = "normal", Cb = { NORMAL: vb, ITALIC: "italic", OBLIQUE: "oblique" };
      kb.fontStyle = Cb;
      kb.textDecoration = { UNDERLINE: "underline", LINE_THROUGH: "lineThrough", OVERLINE: "overline" };
      function mb() {
        this.id = "";
        this.regionAnchorY = this.regionAnchorX = this.viewportAnchorY = this.viewportAnchorX = 0;
        this.height = this.width = 100;
        this.viewportAnchorUnits = this.widthUnits = this.heightUnits = Db;
        this.scroll = Eb;
      }
      K("shaka.text.CueRegion", mb);
      var Db = 1;
      mb.units = { PX: 0, PERCENTAGE: Db, LINES: 2 };
      var Eb = "";
      mb.scrollMode = { NONE: Eb, UP: "up" };
      function Fb() {
      }
      function Gb(a, b) {
        if (!a && !b)
          return true;
        if (!a || !b || a.byteLength != b.byteLength)
          return false;
        if (Hb(a) == Hb(b) && (a.byteOffset || 0) == (b.byteOffset || 0))
          return true;
        var c = M(a);
        b = M(b);
        for (var d = 0; d < a.byteLength; d++)
          if (c[d] != b[d])
            return false;
        return true;
      }
      function Hb(a) {
        return a instanceof ArrayBuffer ? a : a.buffer;
      }
      function Ib(a) {
        return a instanceof ArrayBuffer ? a : 0 == a.byteOffset && a.byteLength == a.buffer.byteLength ? a.buffer : new Uint8Array(a).buffer;
      }
      function M(a, b, c) {
        c = void 0 === c ? Infinity : c;
        return Jb(a, void 0 === b ? 0 : b, c, Uint8Array);
      }
      function Lb(a, b, c) {
        c = void 0 === c ? Infinity : c;
        return Jb(a, void 0 === b ? 0 : b, c, DataView);
      }
      function Jb(a, b, c, d) {
        var e = (a.byteOffset || 0) + a.byteLength;
        b = Math.max(0, Math.min((a.byteOffset || 0) + b, e));
        return new d(Hb(a), b, Math.min(b + Math.max(c, 0), e) - b);
      }
      K("shaka.util.BufferUtils", Fb);
      Fb.toDataView = Lb;
      Fb.toUint8 = M;
      Fb.toArrayBuffer = Ib;
      Fb.equal = Gb;
      function O(a, b, c) {
        var d = Fa.apply(3, arguments);
        this.severity = a;
        this.category = b;
        this.code = c;
        this.data = d;
        this.handled = false;
      }
      O.prototype.toString = function() {
        return "shaka.util.Error " + JSON.stringify(this, null, "  ");
      };
      K("shaka.util.Error", O);
      O.Severity = { RECOVERABLE: 1, CRITICAL: 2 };
      O.Category = { NETWORK: 1, TEXT: 2, MEDIA: 3, MANIFEST: 4, STREAMING: 5, DRM: 6, PLAYER: 7, CAST: 8, STORAGE: 9, ADS: 10 };
      O.Code = {
        UNSUPPORTED_SCHEME: 1e3,
        BAD_HTTP_STATUS: 1001,
        HTTP_ERROR: 1002,
        TIMEOUT: 1003,
        MALFORMED_DATA_URI: 1004,
        REQUEST_FILTER_ERROR: 1006,
        RESPONSE_FILTER_ERROR: 1007,
        MALFORMED_TEST_URI: 1008,
        UNEXPECTED_TEST_REQUEST: 1009,
        ATTEMPTS_EXHAUSTED: 1010,
        SEGMENT_MISSING: 1011,
        INVALID_TEXT_HEADER: 2e3,
        INVALID_TEXT_CUE: 2001,
        UNABLE_TO_DETECT_ENCODING: 2003,
        BAD_ENCODING: 2004,
        INVALID_XML: 2005,
        INVALID_MP4_TTML: 2007,
        INVALID_MP4_VTT: 2008,
        UNABLE_TO_EXTRACT_CUE_START_TIME: 2009,
        INVALID_MP4_CEA: 2010,
        TEXT_COULD_NOT_GUESS_MIME_TYPE: 2011,
        CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS: 2012,
        TEXT_ONLY_WEBVTT_SRC_EQUALS: 2013,
        MISSING_TEXT_PLUGIN: 2014,
        CHAPTERS_TRACK_FAILED: 2015,
        CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS: 2016,
        UNSUPPORTED_EXTERNAL_THUMBNAILS_URI: 2017,
        BUFFER_READ_OUT_OF_BOUNDS: 3e3,
        JS_INTEGER_OVERFLOW: 3001,
        EBML_OVERFLOW: 3002,
        EBML_BAD_FLOATING_POINT_SIZE: 3003,
        MP4_SIDX_WRONG_BOX_TYPE: 3004,
        MP4_SIDX_INVALID_TIMESCALE: 3005,
        MP4_SIDX_TYPE_NOT_SUPPORTED: 3006,
        WEBM_CUES_ELEMENT_MISSING: 3007,
        WEBM_EBML_HEADER_ELEMENT_MISSING: 3008,
        WEBM_SEGMENT_ELEMENT_MISSING: 3009,
        WEBM_INFO_ELEMENT_MISSING: 3010,
        WEBM_DURATION_ELEMENT_MISSING: 3011,
        WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING: 3012,
        WEBM_CUE_TIME_ELEMENT_MISSING: 3013,
        MEDIA_SOURCE_OPERATION_FAILED: 3014,
        MEDIA_SOURCE_OPERATION_THREW: 3015,
        VIDEO_ERROR: 3016,
        QUOTA_EXCEEDED_ERROR: 3017,
        TRANSMUXING_FAILED: 3018,
        CONTENT_TRANSFORMATION_FAILED: 3019,
        UNABLE_TO_GUESS_MANIFEST_TYPE: 4e3,
        DASH_INVALID_XML: 4001,
        DASH_NO_SEGMENT_INFO: 4002,
        DASH_EMPTY_ADAPTATION_SET: 4003,
        DASH_EMPTY_PERIOD: 4004,
        DASH_WEBM_MISSING_INIT: 4005,
        DASH_UNSUPPORTED_CONTAINER: 4006,
        DASH_PSSH_BAD_ENCODING: 4007,
        DASH_NO_COMMON_KEY_SYSTEM: 4008,
        DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED: 4009,
        DASH_CONFLICTING_KEY_IDS: 4010,
        RESTRICTIONS_CANNOT_BE_MET: 4012,
        HLS_PLAYLIST_HEADER_MISSING: 4015,
        INVALID_HLS_TAG: 4016,
        HLS_INVALID_PLAYLIST_HIERARCHY: 4017,
        DASH_DUPLICATE_REPRESENTATION_ID: 4018,
        HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND: 4020,
        HLS_REQUIRED_ATTRIBUTE_MISSING: 4023,
        HLS_REQUIRED_TAG_MISSING: 4024,
        HLS_COULD_NOT_GUESS_CODECS: 4025,
        HLS_KEYFORMATS_NOT_SUPPORTED: 4026,
        DASH_UNSUPPORTED_XLINK_ACTUATE: 4027,
        DASH_XLINK_DEPTH_LIMIT: 4028,
        CONTENT_UNSUPPORTED_BY_BROWSER: 4032,
        CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM: 4033,
        NO_VARIANTS: 4036,
        PERIOD_FLATTENING_FAILED: 4037,
        INCONSISTENT_DRM_ACROSS_PERIODS: 4038,
        HLS_VARIABLE_NOT_FOUND: 4039,
        HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED: 4040,
        HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED: 4041,
        NO_WEB_CRYPTO_API: 4042,
        HLS_AES_128_INVALID_IV_LENGTH: 4043,
        HLS_AES_128_INVALID_KEY_LENGTH: 4044,
        CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM: 4045,
        STREAMING_ENGINE_STARTUP_INVALID_STATE: 5006,
        NO_RECOGNIZED_KEY_SYSTEMS: 6e3,
        REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE: 6001,
        FAILED_TO_CREATE_CDM: 6002,
        FAILED_TO_ATTACH_TO_VIDEO: 6003,
        INVALID_SERVER_CERTIFICATE: 6004,
        FAILED_TO_CREATE_SESSION: 6005,
        FAILED_TO_GENERATE_LICENSE_REQUEST: 6006,
        LICENSE_REQUEST_FAILED: 6007,
        LICENSE_RESPONSE_REJECTED: 6008,
        ENCRYPTED_CONTENT_WITHOUT_DRM_INFO: 6010,
        NO_LICENSE_SERVER_GIVEN: 6012,
        OFFLINE_SESSION_REMOVED: 6013,
        EXPIRED: 6014,
        SERVER_CERTIFICATE_REQUIRED: 6015,
        INIT_DATA_TRANSFORM_ERROR: 6016,
        SERVER_CERTIFICATE_REQUEST_FAILED: 6017,
        LOAD_INTERRUPTED: 7e3,
        OPERATION_ABORTED: 7001,
        NO_VIDEO_ELEMENT: 7002,
        OBJECT_DESTROYED: 7003,
        CONTENT_NOT_LOADED: 7004,
        CAST_API_UNAVAILABLE: 8e3,
        NO_CAST_RECEIVERS: 8001,
        ALREADY_CASTING: 8002,
        UNEXPECTED_CAST_ERROR: 8003,
        CAST_CANCELED_BY_USER: 8004,
        CAST_CONNECTION_TIMED_OUT: 8005,
        CAST_RECEIVER_APP_UNAVAILABLE: 8006,
        STORAGE_NOT_SUPPORTED: 9e3,
        INDEXED_DB_ERROR: 9001,
        DEPRECATED_OPERATION_ABORTED: 9002,
        REQUESTED_ITEM_NOT_FOUND: 9003,
        MALFORMED_OFFLINE_URI: 9004,
        CANNOT_STORE_LIVE_OFFLINE: 9005,
        NO_INIT_DATA_FOR_OFFLINE: 9007,
        LOCAL_PLAYER_INSTANCE_REQUIRED: 9008,
        NEW_KEY_OPERATION_NOT_SUPPORTED: 9011,
        KEY_NOT_FOUND: 9012,
        MISSING_STORAGE_CELL: 9013,
        STORAGE_LIMIT_REACHED: 9014,
        DOWNLOAD_SIZE_CALLBACK_ERROR: 9015,
        MODIFY_OPERATION_NOT_SUPPORTED: 9016,
        INDEXED_DB_INIT_TIMED_OUT: 9017,
        CS_IMA_SDK_MISSING: 1e4,
        CS_AD_MANAGER_NOT_INITIALIZED: 10001,
        SS_IMA_SDK_MISSING: 10002,
        SS_AD_MANAGER_NOT_INITIALIZED: 10003,
        CURRENT_DAI_REQUEST_NOT_FINISHED: 10004
      };
      /*
       @license
       Copyright 2008 The Closure Library Authors
       SPDX-License-Identifier: Apache-2.0
      */
      var Mb = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
      /*
       @license
       Copyright 2006 The Closure Library Authors
       SPDX-License-Identifier: Apache-2.0
      */
      function Nb(a) {
        var b;
        a instanceof Nb ? (Ob(this, a.Ea), this.pb = a.pb, this.Ha = a.Ha, Pb(this, a.Kb), this.qa = a.qa, Qb(this, a.g.clone()), this.fb = a.fb) : a && (b = String(a).match(Mb)) ? (Ob(this, b[1] || "", true), this.pb = Rb(b[2] || ""), this.Ha = Rb(b[3] || "", true), Pb(this, b[4]), this.qa = Rb(b[5] || "", true), Qb(this, b[6] || "", true), this.fb = Rb(b[7] || "")) : this.g = new Sb(null);
      }
      q = Nb.prototype;
      q.Ea = "";
      q.pb = "";
      q.Ha = "";
      q.Kb = null;
      q.qa = "";
      q.fb = "";
      q.toString = function() {
        var a = [], b = this.Ea;
        b && a.push(Tb(b, Ub, true), ":");
        if (b = this.Ha) {
          a.push("//");
          var c = this.pb;
          c && a.push(Tb(c, Ub, true), "@");
          a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g, "%$1"));
          b = this.Kb;
          null != b && a.push(":", String(b));
        }
        if (b = this.qa)
          this.Ha && "/" != b.charAt(0) && a.push("/"), a.push(Tb(b, "/" == b.charAt(0) ? Vb : Wb, true));
        (b = this.g.toString()) && a.push("?", b);
        (b = this.fb) && a.push("#", Tb(b, Xb));
        return a.join("");
      };
      q.resolve = function(a) {
        var b = this.clone();
        "data" === b.Ea && (b = new Nb());
        var c = !!a.Ea;
        c ? Ob(b, a.Ea) : c = !!a.pb;
        c ? b.pb = a.pb : c = !!a.Ha;
        c ? b.Ha = a.Ha : c = null != a.Kb;
        var d = a.qa;
        if (c)
          Pb(b, a.Kb);
        else if (c = !!a.qa) {
          if ("/" != d.charAt(0))
            if (this.Ha && !this.qa)
              d = "/" + d;
            else {
              var e = b.qa.lastIndexOf("/");
              -1 != e && (d = b.qa.substr(0, e + 1) + d);
            }
          if (".." == d || "." == d)
            d = "";
          else if (-1 != d.indexOf("./") || -1 != d.indexOf("/.")) {
            e = 0 == d.lastIndexOf("/", 0);
            d = d.split("/");
            for (var f = [], g = 0; g < d.length; ) {
              var h = d[g++];
              "." == h ? e && g == d.length && f.push("") : ".." == h ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), e && g == d.length && f.push("")) : (f.push(h), e = true);
            }
            d = f.join("/");
          }
        }
        c ? b.qa = d : c = "" !== a.g.toString();
        c ? Qb(b, a.g.clone()) : c = !!a.fb;
        c && (b.fb = a.fb);
        return b;
      };
      q.clone = function() {
        return new Nb(this);
      };
      function Ob(a, b, c) {
        a.Ea = c ? Rb(b, true) : b;
        a.Ea && (a.Ea = a.Ea.replace(/:$/, ""));
      }
      function Pb(a, b) {
        if (b) {
          b = Number(b);
          if (isNaN(b) || 0 > b)
            throw Error("Bad port number " + b);
          a.Kb = b;
        } else
          a.Kb = null;
      }
      function Qb(a, b, c) {
        b instanceof Sb ? a.g = b : (c || (b = Tb(b, Yb)), a.g = new Sb(b));
      }
      function Rb(a, b) {
        return a ? b ? decodeURI(a) : decodeURIComponent(a) : "";
      }
      function Tb(a, b, c) {
        return null != a ? (a = encodeURI(a).replace(b, $b), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
      }
      function $b(a) {
        a = a.charCodeAt(0);
        return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
      }
      var Ub = /[#\/\?@]/g, Wb = /[#\?:]/g, Vb = /[#\?]/g, Yb = /[#\?@]/g, Xb = /#/g;
      function Sb(a) {
        this.g = a || null;
      }
      function ac(a) {
        if (!a.la && (a.la = {}, a.Oc = 0, a.g))
          for (var b = a.g.split("&"), c = 0; c < b.length; c++) {
            var d = b[c].indexOf("="), e = null;
            if (0 <= d) {
              var f = b[c].substring(0, d);
              e = b[c].substring(d + 1);
            } else
              f = b[c];
            f = decodeURIComponent(f.replace(/\+/g, " "));
            e = e || "";
            a.add(f, decodeURIComponent(e.replace(/\+/g, " ")));
          }
      }
      q = Sb.prototype;
      q.la = null;
      q.Oc = null;
      q.add = function(a, b) {
        ac(this);
        this.g = null;
        var c = this.la.hasOwnProperty(a) ? this.la[a] : null;
        c || (this.la[a] = c = []);
        c.push(b);
        this.Oc++;
        return this;
      };
      q.set = function(a, b) {
        ac(this);
        this.g = null;
        this.la.hasOwnProperty(a) ? this.la[a] = [b] : this.add(a, b);
        return this;
      };
      q.toString = function() {
        if (this.g)
          return this.g;
        if (!this.la)
          return "";
        var a = [], b;
        for (b in this.la)
          for (var c = encodeURIComponent(b), d = this.la[b], e = 0; e < d.length; e++) {
            var f = c;
            "" !== d[e] && (f += "=" + encodeURIComponent(d[e]));
            a.push(f);
          }
        return this.g = a.join("&");
      };
      q.clone = function() {
        var a = new Sb();
        a.g = this.g;
        if (this.la) {
          var b = {}, c;
          for (c in this.la)
            b[c] = this.la[c].concat();
          a.la = b;
          a.Oc = this.Oc;
        }
        return a;
      };
      function bc(a, b) {
        return a.concat(b);
      }
      function cc() {
      }
      function dc(a) {
        return null != a;
      }
      function ec(a, b) {
        if (0 == b.length)
          return a;
        var c = b.map(function(d) {
          return new Nb(d);
        });
        return a.map(function(d) {
          return new Nb(d);
        }).map(function(d) {
          return c.map(function(e) {
            return d.resolve(e);
          });
        }).reduce(bc, []).map(function(d) {
          return d.toString();
        });
      }
      function fc(a, b) {
        return { keySystem: a, licenseServerUri: "", distinctiveIdentifierRequired: false, persistentStateRequired: false, audioRobustness: "", videoRobustness: "", serverCertificate: null, serverCertificateUri: "", sessionType: "", initData: b || [], keyIds: /* @__PURE__ */ new Set() };
      }
      function gc(a, b) {
        if (1 == b.length)
          return b[0];
        a = hc(a, b);
        if (null != a)
          return a;
        throw new O(2, 4, 4025, b);
      }
      function hc(a, b) {
        for (var c = r(ic[a]), d = c.next(); !d.done; d = c.next()) {
          d = d.value;
          for (var e = r(b), f = e.next(); !f.done; f = e.next())
            if (f = f.value, d.test(f.trim()))
              return f.trim();
        }
        return a == jc ? "" : null;
      }
      var jc = "text", kc = { va: "video", Hc: "audio", X: jc, Wb: "image", Gg: "application" }, ic = { audio: [/^vorbis$/, /^opus$/, /^flac$/, /^mp4a/, /^[ae]c-3$/, /^ac-4$/, /^dts[cx]$/, /^[du]dts$/], video: [/^avc/, /^hev/, /^hvc/, /^vp0?[89]/, /^av01/, /^dvhe/], text: [/^vtt$/, /^wvtt/, /^stpp/] };
      function lc2() {
        var a, b, c = new Promise(function(d, e) {
          a = d;
          b = e;
        });
        c.resolve = a;
        c.reject = b;
        return c;
      }
      lc2.prototype.resolve = function() {
      };
      lc2.prototype.reject = function() {
      };
      function mc(a) {
        this.h = a;
        this.g = void 0;
      }
      mc.prototype.value = function() {
        void 0 == this.g && (this.g = this.h());
        return this.g;
      };
      function nc(a) {
        this.h = a;
        this.g = null;
      }
      nc.prototype.N = function(a) {
        var b = this;
        this.stop();
        var c = true, d = null;
        this.g = function() {
          window2.clearTimeout(d);
          c = false;
        };
        d = window2.setTimeout(function() {
          c && b.h();
        }, 1e3 * a);
        return this;
      };
      nc.prototype.stop = function() {
        this.g && (this.g(), this.g = null);
      };
      function P(a) {
        this.h = a;
        this.g = null;
      }
      P.prototype.Mb = function() {
        this.stop();
        this.h();
        return this;
      };
      P.prototype.N = function(a) {
        var b = this;
        this.stop();
        this.g = new nc(function() {
          b.h();
        }).N(a);
        return this;
      };
      P.prototype.Ca = function(a) {
        var b = this;
        this.stop();
        this.g = new nc(function() {
          b.g.N(a);
          b.h();
        }).N(a);
        return this;
      };
      P.prototype.stop = function() {
        this.g && (this.g.stop(), this.g = null);
      };
      K("shaka.util.Timer", P);
      P.prototype.stop = P.prototype.stop;
      P.prototype.tickEvery = P.prototype.Ca;
      P.prototype.tickAfter = P.prototype.N;
      P.prototype.tickNow = P.prototype.Mb;
      function oc() {
        return window2.MediaSource && MediaSource.isTypeSupported ? true : false;
      }
      function pc(a) {
        return "" != qc().canPlayType(a);
      }
      function rc() {
        return navigator.userAgent.match(/Edge?\//) ? true : false;
      }
      function sc() {
        return tc("Xbox One");
      }
      function uc() {
        return tc("Tizen");
      }
      function vc() {
        return tc("Web0S") && tc("Chrome/38.0.2125.122 Safari/537.36");
      }
      function wc() {
        return !!navigator.vendor && navigator.vendor.includes("Apple") && !uc() && !tc("PC=EOS") && !tc("VirginMedia") && !xc() && !tc("AFT");
      }
      function xc() {
        return tc("PlayStation 4");
      }
      function yc() {
        if (!wc())
          return null;
        var a = navigator.userAgent.match(/Version\/(\d+)/);
        return a ? parseInt(a[1], 10) : (a = navigator.userAgent.match(/OS (\d+)(?:_\d+)?/)) ? parseInt(a[1], 10) : null;
      }
      function tc(a) {
        return (navigator.userAgent || "").includes(a);
      }
      function qc() {
        if (zc)
          return zc;
        Ac || (Ac = new P(function() {
          zc = null;
        }));
        (zc = document.getElementsByTagName("video")[0] || document.getElementsByTagName("audio")[0]) || (zc = document.createElement("video"));
        Ac.N(1);
        return zc;
      }
      var Ac = null, zc = null;
      function Bc() {
      }
      function Cc(a) {
        if (!a)
          return "";
        a = M(a);
        239 == a[0] && 187 == a[1] && 191 == a[2] && (a = a.subarray(3));
        if (window2.TextDecoder && !xc())
          return a = new TextDecoder().decode(a), a.includes("�") && Va('Decoded string contains an "unknown character" codepoint.  That probably means the UTF8 encoding was incorrect!'), a;
        for (var b = "", c = 0; c < a.length; ++c) {
          var d = 65533;
          0 == (a[c] & 128) ? d = a[c] : a.length >= c + 2 && 192 == (a[c] & 224) && 128 == (a[c + 1] & 192) ? (d = (a[c] & 31) << 6 | a[c + 1] & 63, c += 1) : a.length >= c + 3 && 224 == (a[c] & 240) && 128 == (a[c + 1] & 192) && 128 == (a[c + 2] & 192) ? (d = (a[c] & 15) << 12 | (a[c + 1] & 63) << 6 | a[c + 2] & 63, c += 2) : a.length >= c + 4 && 240 == (a[c] & 241) && 128 == (a[c + 1] & 192) && 128 == (a[c + 2] & 192) && 128 == (a[c + 3] & 192) && (d = (a[c] & 7) << 18 | (a[c + 1] & 63) << 12 | (a[c + 2] & 63) << 6 | a[c + 3] & 63, c += 3);
          if (65535 >= d)
            b += String.fromCharCode(d);
          else {
            d -= 65536;
            var e = d & 1023;
            b += String.fromCharCode(55296 + (d >> 10));
            b += String.fromCharCode(56320 + e);
          }
        }
        return b;
      }
      function Dc(a, b, c) {
        if (!a)
          return "";
        if (!c && 0 != a.byteLength % 2)
          throw new O(2, 2, 2004);
        c = Math.floor(a.byteLength / 2);
        var d = new Uint16Array(c);
        a = Lb(a);
        for (var e = 0; e < c; e++)
          d[e] = a.getUint16(2 * e, b);
        return Ec.value()(d);
      }
      function Fc(a) {
        function b(d) {
          return c.byteLength <= d || 32 <= c[d] && 126 >= c[d];
        }
        if (!a)
          return "";
        var c = M(a);
        if (239 == c[0] && 187 == c[1] && 191 == c[2])
          return Cc(c);
        if (254 == c[0] && 255 == c[1])
          return Dc(c.subarray(2), false);
        if (255 == c[0] && 254 == c[1])
          return Dc(c.subarray(2), true);
        if (0 == c[0] && 0 == c[2])
          return Dc(a, false);
        if (0 == c[1] && 0 == c[3])
          return Dc(a, true);
        if (b(0) && b(1) && b(2) && b(3))
          return Cc(a);
        throw new O(2, 2, 2003);
      }
      function Gc(a) {
        if (window2.TextEncoder && !xc()) {
          var b = new TextEncoder();
          return Ib(b.encode(a));
        }
        a = encodeURIComponent(a);
        a = unescape(a);
        b = new Uint8Array(a.length);
        for (var c = 0; c < a.length; c++)
          b[c] = a[c].charCodeAt(0);
        return Ib(b);
      }
      function Hc(a, b) {
        for (var c = new ArrayBuffer(2 * a.length), d = new DataView(c), e = 0; e < a.length; ++e)
          d.setUint16(2 * e, a.charCodeAt(e), b);
        return c;
      }
      K("shaka.util.StringUtils", Bc);
      Bc.resetFromCharCode = function() {
        Ec.g = void 0;
      };
      Bc.toUTF16 = Hc;
      Bc.toUTF8 = Gc;
      Bc.fromBytesAutoDetect = Fc;
      Bc.fromUTF16 = Dc;
      Bc.fromUTF8 = Cc;
      var Ec = new mc(function() {
        function a(c) {
          try {
            var d = new Uint8Array(c);
            return 0 < String.fromCharCode.apply(null, d).length;
          } catch (e) {
            return false;
          }
        }
        for (var b = { Ua: 65536 }; 0 < b.Ua; b = { Ua: b.Ua }, b.Ua /= 2)
          if (a(b.Ua))
            return function(c) {
              return function(d) {
                for (var e = "", f = 0; f < d.length; f += c.Ua)
                  e += String.fromCharCode.apply(null, d.subarray(f, f + c.Ua));
                return e;
              };
            }(b);
        return null;
      });
      function Ic() {
      }
      function Jc(a) {
        a = M(a);
        a = Ec.value()(a);
        return btoa(a);
      }
      function Kc(a, b) {
        b = void 0 == b ? true : b;
        a = Jc(a).replace(/\+/g, "-").replace(/\//g, "_");
        return b ? a : a.replace(/[=]*$/, "");
      }
      function Lc(a) {
        a = window2.atob(a.replace(/-/g, "+").replace(/_/g, "/"));
        for (var b = new Uint8Array(a.length), c = 0; c < a.length; ++c)
          b[c] = a.charCodeAt(c);
        return b;
      }
      function Mc(a) {
        for (var b = a.length / 2, c = new Uint8Array(b), d = 0; d < b; d++)
          c[d] = window2.parseInt(a.substr(2 * d, 2), 16);
        return c;
      }
      function Nc(a) {
        var b = M(a);
        a = "";
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next())
          c = c.value, c = c.toString(16), 1 == c.length && (c = "0" + c), a += c;
        return a;
      }
      function Oc() {
        for (var a = Fa.apply(0, arguments), b = 0, c = r(a), d = c.next(); !d.done; d = c.next())
          b += d.value.byteLength;
        b = new Uint8Array(b);
        c = 0;
        a = r(a);
        for (d = a.next(); !d.done; d = a.next())
          d = d.value, b.set(M(d), c), c += d.byteLength;
        return b;
      }
      K("shaka.util.Uint8ArrayUtils", Ic);
      Ic.concat = Oc;
      Ic.toHex = Nc;
      Ic.fromHex = Mc;
      Ic.fromBase64 = Lc;
      Ic.toBase64 = Kc;
      Ic.toStandardBase64 = Jc;
      function Pc() {
      }
      K("shaka.dependencies", Pc);
      Pc.has = function(a) {
        return Qc.has(a);
      };
      Pc.add = function(a, b) {
        if (!Rc[a])
          throw Error(a + " is not supported");
        Qc.set(a, function() {
          return b;
        });
      };
      var Rc = { muxjs: "muxjs" };
      Pc.Allowed = Rc;
      var Qc = /* @__PURE__ */ new Map([["muxjs", function() {
        return window2.muxjs;
      }]]);
      function Sc(a) {
        var b = this;
        this.o = a;
        this.m = Qc.get("muxjs")();
        this.h = this.g = null;
        this.l = [];
        this.i = [];
        this.j = false;
        this.m && (this.g = new this.m.mp4.Transmuxer({ keepOriginalTimestamps: true }), this.g.on("data", function(c) {
          b.i = c.captions;
          b.l.push(Oc(c.initSegment, c.data));
        }), this.g.on("done", function() {
          var c = { data: Oc.apply(Ic, ha(b.l)), captions: b.i };
          b.h.resolve(c);
          b.j = false;
        }));
      }
      Sc.prototype.destroy = function() {
        this.g && this.g.dispose();
        this.g = null;
        return Promise.resolve();
      };
      function Tc(a, b) {
        var c = Uc(a), d = "audio/aac" == a.toLowerCase().split(";")[0];
        if (!Qc.get("muxjs")() || !c && !d)
          return false;
        if (d)
          return eb('audio/mp4; codecs="mp4a.40.2"');
        if (b)
          return eb(Vc(b, a));
        b = Vc("audio", a);
        a = Vc("video", a);
        return eb(b) || eb(a);
      }
      function Uc(a) {
        return "mp2t" == a.toLowerCase().split(";")[0].split("/")[1];
      }
      function Wc(a, b) {
        return "audio/aac" == b.toLowerCase().split(";")[0] ? 'audio/mp4; codecs="mp4a.40.2"' : Uc(b) ? Vc(a, b) : b;
      }
      function Vc(a, b) {
        b = b.replace(/mp2t/i, "mp4");
        "audio" == a && (b = b.replace("video", "audio"));
        if (a = /avc1\.(66|77|100)\.(\d+)/.exec(b)) {
          var c = "avc1.", d = a[1], e = Number(a[2]);
          c = ("66" == d ? c + "4200" : "77" == d ? c + "4d00" : c + "6400") + (e >> 4).toString(16);
          c += (e & 15).toString(16);
          b = b.replace(a[0], c);
        }
        return b;
      }
      function Xc(a, b) {
        a.j = true;
        a.h = new lc2();
        a.l = [];
        a.i = [];
        b = M(b);
        a.g.push(b);
        a.g.flush();
        a.j && a.h.reject(new O(2, 3, 3018));
        return a.h;
      }
      function Yc() {
      }
      function Zc(a, b) {
        b && (a += '; codecs="' + b + '"');
        return a;
      }
      function $c(a, b, c) {
        b = Zc(a, b);
        return Tc(b, c) ? Wc(c, b) : "video/mp2t" != a && "audio" == c ? b.replace("video", "audio") : b;
      }
      function ad(a) {
        var b = bd(a);
        a = b[0];
        b = b[1].toLowerCase();
        switch (true) {
          case ("mp4a" === a && "69" === b):
          case ("mp4a" === a && "6b" === b):
            return "mp3";
          case ("mp4a" === a && "66" === b):
          case ("mp4a" === a && "67" === b):
          case ("mp4a" === a && "68" === b):
          case ("mp4a" === a && "40.2" === b):
          case ("mp4a" === a && "40.02" === b):
          case ("mp4a" === a && "40.5" === b):
          case ("mp4a" === a && "40.05" === b):
          case ("mp4a" === a && "40.29" === b):
          case ("mp4a" === a && "40.42" === b):
            return "aac";
          case ("mp4a" === a && "a5" === b):
            return "ac-3";
          case ("mp4a" === a && "a6" === b):
            return "ec-3";
          case ("mp4a" === a && "b2" === b):
            return "dtsx";
          case ("mp4a" === a && "a9" === b):
            return "dtsc";
          case "avc1" === a:
          case "avc3" === a:
            return "avc";
          case "hvc1" === a:
          case "hev1" === a:
            return "hevc";
          case "dvh1" === a:
          case "dvhe" === a:
            return "dovi";
        }
        return a;
      }
      function cd(a) {
        a = a.split(/ *; */);
        a.shift();
        return (a = a.find(function(b) {
          return b.startsWith("codecs=");
        })) ? a.split("=")[1].replace(/^"|"$/g, "") : "";
      }
      function bd(a) {
        a = a.split(".");
        var b = a[0];
        a.shift();
        return [b, a.join(".")];
      }
      K("shaka.util.MimeUtils", Yc);
      Yc.getFullType = Zc;
      (/* @__PURE__ */ new Map()).set("codecs", "codecs").set("frameRate", "framerate").set("bandwidth", "bitrate").set("width", "width").set("height", "height").set("channelsCount", "channels");
      function dd(a) {
        this.j = null;
        this.i = a;
        this.u = false;
        this.l = this.s = 0;
        this.m = Infinity;
        this.h = this.g = null;
        this.B = "";
        this.o = /* @__PURE__ */ new Map();
      }
      function ed(a) {
        return fd[a] || "application/cea-608" == a || "application/cea-708" == a ? true : false;
      }
      dd.prototype.destroy = function() {
        this.i = this.j = null;
        this.o.clear();
        return Promise.resolve();
      };
      function gd(a, b, c, d) {
        var e, f, g, h;
        return G(function(k2) {
          if (1 == k2.g)
            return u(k2, Promise.resolve(), 2);
          if (!a.j || !a.i)
            return k2.return();
          if (null == c || null == d)
            return a.j.parseInit(M(b)), k2.return();
          e = a.u ? c : a.s;
          f = { periodStart: a.s, segmentStart: c, segmentEnd: d, vttOffset: e };
          g = a.j.parseMedia(M(b), f);
          h = g.filter(function(l) {
            return l.startTime >= a.l && l.startTime < a.m;
          });
          a.i.append(h);
          null == a.g && (a.g = Math.max(c, a.l));
          a.h = Math.min(d, a.m);
          A(k2);
        });
      }
      dd.prototype.remove = function(a, b) {
        var c = this;
        return G(function(d) {
          if (1 == d.g)
            return u(d, Promise.resolve(), 2);
          !c.i || !c.i.remove(a, b) || null == c.g || b <= c.g || a >= c.h || (a <= c.g && b >= c.h ? c.g = c.h = null : a <= c.g && b < c.h ? c.g = b : a > c.g && b >= c.h && (c.h = a));
          A(d);
        });
      };
      function hd(a, b, c) {
        a.l = b;
        a.m = c;
      }
      function id(a, b, c) {
        a.B = b;
        if (b = a.o.get(b))
          for (var d = r(b.keys()), e = d.next(); !e.done; e = d.next())
            (e = b.get(e.value).filter(function(f) {
              return f.endTime <= c;
            })) && a.i.append(e);
      }
      function jd(a) {
        var b = [];
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          c = c.value, b.push({ stream: c.stream, cue: new kb(c.startTime, c.endTime, c.text) });
        return b;
      }
      function kd(a, b, c) {
        b.startTime += c;
        b.endTime += c;
        b = r(b.nestedCues);
        for (var d = b.next(); !d.done; d = b.next())
          kd(a, d.value, c);
      }
      function ld(a, b, c, d, e) {
        var f = c + " " + d, g = /* @__PURE__ */ new Map();
        b = r(b);
        for (var h = b.next(); !h.done; h = b.next()) {
          var k2 = h.value;
          h = k2.stream;
          k2 = k2.cue;
          g.has(h) || g.set(h, /* @__PURE__ */ new Map());
          g.get(h).has(f) || g.get(h).set(f, []);
          kd(a, k2, e);
          k2.startTime >= a.l && k2.startTime < a.m && (g.get(h).get(f).push(k2), h == a.B && a.i.append([k2]));
        }
        e = r(g.keys());
        for (f = e.next(); !f.done; f = e.next())
          for (f = f.value, a.o.has(f) || a.o.set(f, /* @__PURE__ */ new Map()), b = r(g.get(f).keys()), h = b.next(); !h.done; h = b.next())
            h = h.value, k2 = g.get(f).get(h), a.o.get(f).set(h, k2);
        a.g = null == a.g ? Math.max(
          c,
          a.l
        ) : Math.min(a.g, Math.max(c, a.l));
        a.h = Math.max(a.h, Math.min(d, a.m));
      }
      K("shaka.text.TextEngine", dd);
      dd.prototype.destroy = dd.prototype.destroy;
      dd.findParser = function(a) {
        return fd[a];
      };
      dd.unregisterParser = function(a) {
        delete fd[a];
      };
      dd.registerParser = function(a, b) {
        fd[a] = b;
      };
      var fd = {};
      function md() {
      }
      function nd(a, b) {
        a = od(a);
        b = od(b);
        return a.split("-")[0] == b.split("-")[0];
      }
      function pd(a, b) {
        a = od(a);
        b = od(b);
        a = a.split("-");
        b = b.split("-");
        return a[0] == b[0] && 1 == a.length && 2 == b.length;
      }
      function qd(a, b) {
        a = od(a);
        b = od(b);
        a = a.split("-");
        b = b.split("-");
        return 2 == a.length && 2 == b.length && a[0] == b[0];
      }
      function od(a) {
        var b = a.split("-");
        a = b[0] || "";
        b = b[1] || "";
        a = a.toLowerCase();
        a = rd.get(a) || a;
        return (b = b.toUpperCase()) ? a + "-" + b : a;
      }
      function sd(a, b) {
        a = od(a);
        b = od(b);
        return b == a ? 4 : pd(b, a) ? 3 : qd(b, a) ? 2 : pd(a, b) ? 1 : 0;
      }
      function td(a) {
        var b = a.indexOf("-");
        a = 0 <= b ? a.substring(0, b) : a;
        a = a.toLowerCase();
        return a = rd.get(a) || a;
      }
      function ud(a) {
        return a.language ? od(a.language) : a.audio && a.audio.language ? od(a.audio.language) : a.video && a.video.language ? od(a.video.language) : "und";
      }
      function vd(a, b) {
        a = od(a);
        var c = /* @__PURE__ */ new Set(), d = r(b);
        for (b = d.next(); !b.done; b = d.next())
          c.add(od(b.value));
        d = r(c);
        for (b = d.next(); !b.done; b = d.next())
          if (b = b.value, b == a)
            return b;
        d = r(c);
        for (b = d.next(); !b.done; b = d.next())
          if (b = b.value, pd(b, a))
            return b;
        d = r(c);
        for (b = d.next(); !b.done; b = d.next())
          if (b = b.value, qd(b, a))
            return b;
        c = r(c);
        for (b = c.next(); !b.done; b = c.next())
          if (b = b.value, pd(a, b))
            return b;
        return null;
      }
      K("shaka.util.LanguageUtils", md);
      md.findClosestLocale = vd;
      md.getLocaleForVariant = ud;
      md.getLocaleForText = function(a) {
        return od(a.language || "und");
      };
      md.getBase = td;
      md.relatedness = sd;
      md.areSiblings = function(a, b) {
        var c = td(a), d = td(b);
        return a != c && b != d && c == d;
      };
      md.normalize = od;
      md.isSiblingOf = qd;
      md.isParentOf = pd;
      md.areLanguageCompatible = nd;
      md.areLocaleCompatible = function(a, b) {
        a = od(a);
        b = od(b);
        return a == b;
      };
      var rd = /* @__PURE__ */ new Map([["aar", "aa"], ["abk", "ab"], ["afr", "af"], ["aka", "ak"], ["alb", "sq"], ["amh", "am"], ["ara", "ar"], ["arg", "an"], ["arm", "hy"], ["asm", "as"], ["ava", "av"], ["ave", "ae"], ["aym", "ay"], ["aze", "az"], ["bak", "ba"], ["bam", "bm"], ["baq", "eu"], ["bel", "be"], ["ben", "bn"], ["bih", "bh"], ["bis", "bi"], ["bod", "bo"], ["bos", "bs"], ["bre", "br"], ["bul", "bg"], ["bur", "my"], ["cat", "ca"], ["ces", "cs"], ["cha", "ch"], ["che", "ce"], ["chi", "zh"], ["chu", "cu"], ["chv", "cv"], ["cor", "kw"], ["cos", "co"], ["cre", "cr"], ["cym", "cy"], [
        "cze",
        "cs"
      ], ["dan", "da"], ["deu", "de"], ["div", "dv"], ["dut", "nl"], ["dzo", "dz"], ["ell", "el"], ["eng", "en"], ["epo", "eo"], ["est", "et"], ["eus", "eu"], ["ewe", "ee"], ["fao", "fo"], ["fas", "fa"], ["fij", "fj"], ["fin", "fi"], ["fra", "fr"], ["fre", "fr"], ["fry", "fy"], ["ful", "ff"], ["geo", "ka"], ["ger", "de"], ["gla", "gd"], ["gle", "ga"], ["glg", "gl"], ["glv", "gv"], ["gre", "el"], ["grn", "gn"], ["guj", "gu"], ["hat", "ht"], ["hau", "ha"], ["heb", "he"], ["her", "hz"], ["hin", "hi"], ["hmo", "ho"], ["hrv", "hr"], ["hun", "hu"], ["hye", "hy"], ["ibo", "ig"], [
        "ice",
        "is"
      ], ["ido", "io"], ["iii", "ii"], ["iku", "iu"], ["ile", "ie"], ["ina", "ia"], ["ind", "id"], ["ipk", "ik"], ["isl", "is"], ["ita", "it"], ["jav", "jv"], ["jpn", "ja"], ["kal", "kl"], ["kan", "kn"], ["kas", "ks"], ["kat", "ka"], ["kau", "kr"], ["kaz", "kk"], ["khm", "km"], ["kik", "ki"], ["kin", "rw"], ["kir", "ky"], ["kom", "kv"], ["kon", "kg"], ["kor", "ko"], ["kua", "kj"], ["kur", "ku"], ["lao", "lo"], ["lat", "la"], ["lav", "lv"], ["lim", "li"], ["lin", "ln"], ["lit", "lt"], ["ltz", "lb"], ["lub", "lu"], ["lug", "lg"], ["mac", "mk"], ["mah", "mh"], ["mal", "ml"], [
        "mao",
        "mi"
      ], ["mar", "mr"], ["may", "ms"], ["mkd", "mk"], ["mlg", "mg"], ["mlt", "mt"], ["mon", "mn"], ["mri", "mi"], ["msa", "ms"], ["mya", "my"], ["nau", "na"], ["nav", "nv"], ["nbl", "nr"], ["nde", "nd"], ["ndo", "ng"], ["nep", "ne"], ["nld", "nl"], ["nno", "nn"], ["nob", "nb"], ["nor", "no"], ["nya", "ny"], ["oci", "oc"], ["oji", "oj"], ["ori", "or"], ["orm", "om"], ["oss", "os"], ["pan", "pa"], ["per", "fa"], ["pli", "pi"], ["pol", "pl"], ["por", "pt"], ["pus", "ps"], ["que", "qu"], ["roh", "rm"], ["ron", "ro"], ["rum", "ro"], ["run", "rn"], ["rus", "ru"], ["sag", "sg"], [
        "san",
        "sa"
      ], ["sin", "si"], ["slk", "sk"], ["slo", "sk"], ["slv", "sl"], ["sme", "se"], ["smo", "sm"], ["sna", "sn"], ["snd", "sd"], ["som", "so"], ["sot", "st"], ["spa", "es"], ["sqi", "sq"], ["srd", "sc"], ["srp", "sr"], ["ssw", "ss"], ["sun", "su"], ["swa", "sw"], ["swe", "sv"], ["tah", "ty"], ["tam", "ta"], ["tat", "tt"], ["tel", "te"], ["tgk", "tg"], ["tgl", "tl"], ["tha", "th"], ["tib", "bo"], ["tir", "ti"], ["ton", "to"], ["tsn", "tn"], ["tso", "ts"], ["tuk", "tk"], ["tur", "tr"], ["twi", "tw"], ["uig", "ug"], ["ukr", "uk"], ["urd", "ur"], ["uzb", "uz"], ["ven", "ve"], [
        "vie",
        "vi"
      ], ["vol", "vo"], ["wel", "cy"], ["wln", "wa"], ["wol", "wo"], ["xho", "xh"], ["yid", "yi"], ["yor", "yo"], ["zha", "za"], ["zho", "zh"], ["zul", "zu"]]);
      function wd() {
        this.g = {};
      }
      q = wd.prototype;
      q.push = function(a, b) {
        this.g.hasOwnProperty(a) ? this.g[a].push(b) : this.g[a] = [b];
      };
      q.get = function(a) {
        return (a = this.g[a]) ? a.slice() : null;
      };
      q.remove = function(a, b) {
        a in this.g && (this.g[a] = this.g[a].filter(function(c) {
          return c != b;
        }), 0 == this.g[a].length && delete this.g[a]);
      };
      q.forEach = function(a) {
        for (var b in this.g)
          a(b, this.g[b]);
      };
      q.size = function() {
        return Object.keys(this.g).length;
      };
      q.keys = function() {
        return Object.keys(this.g);
      };
      function xd(a, b, c, d, e) {
        var f = a.variants;
        if (b.length || c.length)
          f = yd(f, b, c);
        f = zd(f, d);
        b = Ad(f);
        b = Bd(b);
        var g = Cd(b, e);
        a.variants = a.variants.filter(function(h) {
          return Dd(h) == g ? true : false;
        });
      }
      function Ad(a) {
        var b = new wd();
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next()) {
          c = c.value;
          var d = Dd(c);
          b.push(d, c);
        }
        return b;
      }
      function Bd(a) {
        var b = 0, c = /* @__PURE__ */ new Map(), d = a.size();
        a.forEach(function(e, f) {
          f = r(f);
          for (var g = f.next(); !g.done; g = f.next()) {
            g = g.value;
            var h = g.video;
            if (h && h.width && h.height) {
              h = h.width * h.height * (h.frameRate || 1);
              c.has(h) || c.set(h, new wd());
              var k2 = c.get(h);
              k2.push(e, g);
              k2.size() === d && (b = Math.max(b, h));
            }
          }
        });
        return b ? c.get(b) : a;
      }
      function yd(a, b, c) {
        var d = {};
        b = r(b);
        for (var e = b.next(); !e.done; d = { xd: d.xd }, e = b.next())
          if (d.xd = e.value, e = a.filter(function(f) {
            return function(g) {
              return g.video && g.video.codecs.startsWith(f.xd);
            };
          }(d)), e.length) {
            a = e;
            break;
          }
        d = {};
        c = r(c);
        for (b = c.next(); !b.done; d = { jd: d.jd }, b = c.next())
          if (d.jd = b.value, b = a.filter(function(f) {
            return function(g) {
              return g.audio && g.audio.codecs.startsWith(f.jd);
            };
          }(d)), b.length) {
            a = b;
            break;
          }
        return a;
      }
      function Cd(a, b) {
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next())
          if (c = c.value, c == Ed || c == Fd) {
            if (a = Gd(a, c), 1 == a.size())
              return a.keys()[0];
          } else if (c == Hd)
            break;
        return Id(a);
      }
      function Gd(a, b) {
        var c = 0, d = new wd();
        a.forEach(function(e, f) {
          for (var g = 0, h = 0, k2 = r(f), l = k2.next(); !l.done; l = k2.next())
            l = l.value, l.decodingInfos.length && (g += l.decodingInfos[0][b] ? 1 : 0, h++);
          g /= h;
          g > c ? (d.g = {}, d.push(e, f), c = g) : g == c && d.push(e, f);
        });
        return d;
      }
      function Id(a) {
        var b = "", c = Infinity;
        a.forEach(function(d, e) {
          var f = 0, g = 0;
          e = r(e);
          for (var h = e.next(); !h.done; h = e.next())
            f += h.value.bandwidth || 0, ++g;
          f /= g;
          f < c && (b = d, c = f);
        });
        return b;
      }
      function Dd(a) {
        var b = "";
        a.video && (b = ad(a.video.codecs));
        var c = "";
        a.audio && (c = ad(a.audio.codecs));
        return b + "-" + c;
      }
      function Jd(a, b, c) {
        a.variants = a.variants.filter(function(d) {
          return Kd(d, b, c);
        });
      }
      function Kd(a, b, c) {
        function d(f, g, h) {
          return f >= g && f <= h;
        }
        var e = a.video;
        if (0 != a.disabledUntilTime) {
          if (a.disabledUntilTime > Date.now() / 1e3)
            return false;
          a.disabledUntilTime = 0;
        }
        return e && e.width && e.height && (!d(e.width, b.minWidth, Math.min(b.maxWidth, c.width)) || !d(e.height, b.minHeight, Math.min(b.maxHeight, c.height)) || !d(e.width * e.height, b.minPixels, b.maxPixels)) || a && a.video && a.video.frameRate && !d(a.video.frameRate, b.minFrameRate, b.maxFrameRate) || !d(a.bandwidth, b.minBandwidth, b.maxBandwidth) ? false : true;
      }
      function Ld(a, b, c) {
        var d = false;
        a = r(a);
        for (var e = a.next(); !e.done; e = a.next()) {
          e = e.value;
          var f = e.allowedByApplication;
          e.allowedByApplication = Kd(e, b, c);
          f != e.allowedByApplication && (d = true);
        }
        return d;
      }
      function Md(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return u(c, Nd(b, 0 < b.offlineSessionIds.length), 2);
          Od(a, b);
          Pd(b);
          return u(c, Qd(b), 0);
        });
      }
      function Nd(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return u(c, Rd(a.variants, b, false), 2);
          a.variants = a.variants.filter(function(d) {
            var e = d.video;
            if (e) {
              var f = Sd(e.codecs);
              if (e.codecs.includes(",")) {
                var g = e.codecs.split(",");
                f = gc("video", g);
                f = Sd(f);
                g = gc("audio", g);
                g = Td(g);
                var h = $c(e.mimeType, g, "audio");
                if (!eb(h))
                  return false;
                f = [f, g].join();
              }
              g = $c(e.mimeType, f, "video");
              if (!eb(g))
                return false;
              e.codecs = f;
            }
            if (f = d.audio) {
              g = Td(f.codecs);
              h = $c(f.mimeType, g, "audio");
              if (!eb(h))
                return false;
              f.codecs = g;
            }
            if (sc() && e && (e.width && 1920 < e.width || e.height && 1080 < e.height) && (e.codecs.includes("avc1.") || e.codecs.includes("avc3.")))
              return $a(Ud(d)), false;
            (e = d.decodingInfos.some(function(k2) {
              return k2.supported;
            })) || $a(Ud(d));
            return e;
          });
          A(c);
        });
      }
      function Rd(a, b, c) {
        var e, f, g, h, k2, l, m, n, p, t;
        return G(function(v) {
          if (a.some(function(y) {
            return y.decodingInfos.length;
          }))
            return v.return();
          e = navigator.mediaCapabilities;
          f = [];
          g = function(y, w) {
            var x;
            return G(function(C) {
              if (1 == C.g)
                return D(C, 2), u(C, e.decodingInfo(w), 4);
              if (2 != C.g)
                return x = C.h, y.decodingInfos.push(x), ta(C, 0);
              ua(C);
              JSON.stringify(w);
              A(C);
            });
          };
          h = r(a);
          for (k2 = h.next(); !k2.done; k2 = h.next())
            for (l = k2.value, m = Vd(l, b, c), n = r(m), p = n.next(); !p.done; p = n.next())
              t = p.value, f.push(g(l, t));
          return u(
            v,
            Promise.all(f),
            0
          );
        });
      }
      function Vd(a, b, c) {
        var d = a.audio, e = a.video;
        c = { type: c ? "file" : "media-source" };
        if (e) {
          var f = e.codecs;
          if (e.codecs.includes(",")) {
            var g = e.codecs.split(",");
            f = gc("video", g);
            f = Sd(f);
            g = gc("audio", g);
            g = $c(e.mimeType, g, "audio");
            c.audio = { contentType: g, channels: 2, bitrate: a.bandwidth || 1, samplerate: 1, spatialRendering: false };
          }
          f = Sd(f);
          f = $c(e.mimeType, f, "video");
          c.video = { contentType: f, width: e.width || 64, height: e.height || 64, bitrate: e.bandwidth || a.bandwidth || 1, framerate: e.frameRate || 1 };
          if (e.hdr)
            switch (e.hdr) {
              case "SDR":
                c.video.transferFunction = "srgb";
                break;
              case "PQ":
                c.video.transferFunction = "pq";
                break;
              case "HLG":
                c.video.transferFunction = "hlg";
            }
        }
        d && (f = Td(d.codecs), f = $c(d.mimeType, f, "audio"), c.audio = { contentType: f, channels: d.channelsCount || 2, bitrate: d.bandwidth || a.bandwidth || 1, samplerate: d.audioSamplingRate || 1, spatialRendering: d.spatialAudio });
        g = (a.video ? a.video.drmInfos : []).concat(a.audio ? a.audio.drmInfos : []);
        if (!g.length)
          return [c];
        a = [];
        f = /* @__PURE__ */ new Map();
        g = r(g);
        for (var h = g.next(); !h.done; h = g.next()) {
          var k2 = h.value;
          f.get(k2.keySystem) || f.set(k2.keySystem, []);
          f.get(k2.keySystem).push(k2);
        }
        g = b ? "required" : "optional";
        b = b ? ["persistent-license"] : ["temporary"];
        k2 = r(f.keys());
        for (var l = k2.next(); !l.done; l = k2.next()) {
          var m = l.value;
          l = Object.assign({}, c);
          var n = f.get(m);
          m = { keySystem: m, initDataType: "cenc", persistentState: g, distinctiveIdentifier: "optional", sessionTypes: b };
          n = r(n);
          for (h = n.next(); !h.done; h = n.next()) {
            h = h.value;
            if (h.initData && h.initData.length) {
              for (var p = /* @__PURE__ */ new Set(), t = r(h.initData), v = t.next(); !v.done; v = t.next())
                p.add(v.value.initDataType);
              m.initDataType = h.initData[0].initDataType;
            }
            h.distinctiveIdentifierRequired && (m.distinctiveIdentifier = "required");
            h.persistentStateRequired && (m.persistentState = "required");
            h.sessionType && (m.sessionTypes = [h.sessionType]);
            d && ("" != h.audioRobustness ? m.audio ? m.audio.robustness = m.audio.robustness || h.audioRobustness : m.audio = { robustness: h.audioRobustness } : m.audio || (m.audio = {}));
            e && ("" != h.videoRobustness ? m.video ? m.video.robustness = m.video.robustness || h.videoRobustness : m.video = { robustness: h.videoRobustness } : m.video || (m.video = {}));
          }
          l.keySystemConfiguration = m;
          a.push(l);
        }
        return a;
      }
      function Td(a) {
        return uc() ? "ac-3" == a.toLowerCase() ? "ec-3" : a : a;
      }
      function Sd(a) {
        if (a.includes("avc1")) {
          var b = a.split(".");
          if (3 == b.length)
            return a = b.shift() + ".", a += parseInt(b.shift(), 10).toString(16), a += ("000" + parseInt(b.shift(), 10).toString(16)).slice(-4);
        } else if ("vp9" == a)
          return "vp09.00.41.08";
        return a;
      }
      function Od(a, b) {
        b.variants = b.variants.filter(function(c) {
          var d = c.audio;
          c = c.video;
          return d && a && a.audio && !Wd(d, a.audio) || c && a && a.video && !Wd(c, a.video) ? false : true;
        });
      }
      function Pd(a) {
        a.textStreams = a.textStreams.filter(function(b) {
          return ed(Zc(b.mimeType, b.codecs));
        });
      }
      function Qd(a) {
        var b, c, d, e, f, g, h;
        return G(function(l) {
          switch (l.g) {
            case 1:
              b = [], c = r(a.imageStreams), d = c.next();
            case 2:
              if (d.done) {
                l.A(4);
                break;
              }
              e = d.value;
              f = e.mimeType;
              if (Xd.has(f)) {
                l.A(5);
                break;
              }
              g = Yd.get(f);
              if (!g) {
                Xd.set(f, false);
                l.A(5);
                break;
              }
              return u(l, Zd(g), 7);
            case 7:
              h = l.h, Xd.set(f, h);
            case 5:
              Xd.get(f) && b.push(e);
              d = c.next();
              l.A(2);
              break;
            case 4:
              a.imageStreams = b, A(l);
          }
        });
      }
      function Zd(a) {
        return new Promise(function(b) {
          var c = new Image();
          c.src = a;
          "decode" in c ? c.decode().then(function() {
            b(true);
          }).catch(function() {
            b(false);
          }) : c.onload = c.onerror = function() {
            b(2 === c.height);
          };
        });
      }
      function Wd(a, b) {
        return a.mimeType != b.mimeType || a.codecs.split(".")[0] != b.codecs.split(".")[0] ? false : true;
      }
      function $d(a) {
        var b = a.audio, c = a.video, d = b ? b.mimeType : null, e = c ? c.mimeType : null, f = b ? b.codecs : null, g = c ? c.codecs : null, h = [];
        g && h.push(g);
        f && h.push(f);
        var k2 = [];
        c && k2.push(c.mimeType);
        b && k2.push(b.mimeType);
        k2 = k2[0] || null;
        var l = [];
        b && l.push(b.kind);
        c && l.push(c.kind);
        l = l[0] || null;
        var m = /* @__PURE__ */ new Set();
        if (b)
          for (var n = r(b.roles), p = n.next(); !p.done; p = n.next())
            m.add(p.value);
        if (c)
          for (n = r(c.roles), p = n.next(); !p.done; p = n.next())
            m.add(p.value);
        a = {
          id: a.id,
          active: false,
          type: "variant",
          bandwidth: a.bandwidth,
          language: a.language,
          label: null,
          kind: l,
          width: null,
          height: null,
          frameRate: null,
          pixelAspectRatio: null,
          hdr: null,
          mimeType: k2,
          audioMimeType: d,
          videoMimeType: e,
          codecs: h.join(", "),
          audioCodec: f,
          videoCodec: g,
          primary: a.primary,
          roles: Array.from(m),
          audioRoles: null,
          forced: false,
          videoId: null,
          audioId: null,
          channelsCount: null,
          audioSamplingRate: null,
          spatialAudio: false,
          tilesLayout: null,
          audioBandwidth: null,
          videoBandwidth: null,
          originalVideoId: null,
          originalAudioId: null,
          originalTextId: null,
          originalImageId: null
        };
        c && (a.videoId = c.id, a.originalVideoId = c.originalId, a.width = c.width || null, a.height = c.height || null, a.frameRate = c.frameRate || null, a.pixelAspectRatio = c.pixelAspectRatio || null, a.videoBandwidth = c.bandwidth || null);
        b && (a.audioId = b.id, a.originalAudioId = b.originalId, a.channelsCount = b.channelsCount, a.audioSamplingRate = b.audioSamplingRate, a.audioBandwidth = b.bandwidth || null, a.spatialAudio = b.spatialAudio, a.label = b.label, a.audioRoles = b.roles);
        return a;
      }
      function ae(a) {
        return {
          id: a.id,
          active: false,
          type: jc,
          bandwidth: 0,
          language: a.language,
          label: a.label,
          kind: a.kind || null,
          width: null,
          height: null,
          frameRate: null,
          pixelAspectRatio: null,
          hdr: null,
          mimeType: a.mimeType,
          audioMimeType: null,
          videoMimeType: null,
          codecs: a.codecs || null,
          audioCodec: null,
          videoCodec: null,
          primary: a.primary,
          roles: a.roles,
          audioRoles: null,
          forced: a.forced,
          videoId: null,
          audioId: null,
          channelsCount: null,
          audioSamplingRate: null,
          spatialAudio: false,
          tilesLayout: null,
          audioBandwidth: null,
          videoBandwidth: null,
          originalVideoId: null,
          originalAudioId: null,
          originalTextId: a.originalId,
          originalImageId: null
        };
      }
      function be(a) {
        var b = a.width || null, c = a.height || null, d = null;
        a.segmentIndex && (d = a.segmentIndex.get(0));
        var e = a.tilesLayout;
        d && (e = d.tilesLayout || e);
        e && null != b && (b /= Number(e.split("x")[0]));
        e && null != c && (c /= Number(e.split("x")[1]));
        return {
          id: a.id,
          active: false,
          type: "image",
          bandwidth: a.bandwidth || 0,
          language: "",
          label: null,
          kind: null,
          width: b,
          height: c,
          frameRate: null,
          pixelAspectRatio: null,
          hdr: null,
          mimeType: a.mimeType,
          audioMimeType: null,
          videoMimeType: null,
          codecs: null,
          audioCodec: null,
          videoCodec: null,
          primary: false,
          roles: [],
          audioRoles: null,
          forced: false,
          videoId: null,
          audioId: null,
          channelsCount: null,
          audioSamplingRate: null,
          spatialAudio: false,
          tilesLayout: e || null,
          audioBandwidth: null,
          videoBandwidth: null,
          originalVideoId: null,
          originalAudioId: null,
          originalTextId: null,
          originalImageId: a.originalId
        };
      }
      function ce(a) {
        a.__shaka_id || (a.__shaka_id = de++);
        return a.__shaka_id;
      }
      function ee(a) {
        var b = fe(a);
        b.active = "disabled" != a.mode;
        b.type = "text";
        b.originalTextId = a.id;
        "captions" == a.kind && (b.mimeType = "application/cea-608");
        a.kind && (b.roles = [a.kind]);
        "forced" == a.kind && (b.forced = true);
        return b;
      }
      function ge(a) {
        var b = fe(a);
        b.active = a.enabled;
        b.type = "variant";
        b.originalAudioId = a.id;
        "main" == a.kind && (b.primary = true);
        a.kind && (b.roles = [a.kind], b.audioRoles = [a.kind], b.label = a.label);
        return b;
      }
      function fe(a) {
        return {
          id: ce(a),
          active: false,
          type: "",
          bandwidth: 0,
          language: od(a.language),
          label: a.label,
          kind: a.kind,
          width: null,
          height: null,
          frameRate: null,
          pixelAspectRatio: null,
          hdr: null,
          mimeType: null,
          audioMimeType: null,
          videoMimeType: null,
          codecs: null,
          audioCodec: null,
          videoCodec: null,
          primary: false,
          roles: [],
          forced: false,
          audioRoles: null,
          videoId: null,
          audioId: null,
          channelsCount: null,
          audioSamplingRate: null,
          spatialAudio: false,
          tilesLayout: null,
          audioBandwidth: null,
          videoBandwidth: null,
          originalVideoId: null,
          originalAudioId: null,
          originalTextId: null,
          originalImageId: null
        };
      }
      function he(a) {
        return a.allowedByApplication && a.allowedByKeySystem;
      }
      function ie(a) {
        return a.filter(function(b) {
          return he(b);
        });
      }
      function zd(a, b) {
        var c = a.filter(function(g) {
          return g.audio && g.audio.channelsCount;
        }), d = /* @__PURE__ */ new Map();
        c = r(c);
        for (var e = c.next(); !e.done; e = c.next()) {
          e = e.value;
          var f = e.audio.channelsCount;
          d.has(f) || d.set(f, []);
          d.get(f).push(e);
        }
        c = Array.from(d.keys());
        if (0 == c.length)
          return a;
        a = c.filter(function(g) {
          return g <= b;
        });
        return a.length ? d.get(Math.max.apply(Math, ha(a))) : d.get(Math.min.apply(Math, ha(c)));
      }
      function je(a, b, c, d) {
        var e = a, f = a.filter(function(k2) {
          return k2.primary;
        });
        f.length && (e = f);
        var g = e.length ? e[0].language : "";
        e = e.filter(function(k2) {
          return k2.language == g;
        });
        if (b) {
          var h = vd(od(b), a.map(function(k2) {
            return k2.language;
          }));
          h && (e = a.filter(function(k2) {
            return od(k2.language) == h;
          }));
        }
        e = e.filter(function(k2) {
          return k2.forced == d;
        });
        if (c) {
          if (a = ke(e, c), a.length)
            return a;
        } else if (a = e.filter(function(k2) {
          return 0 == k2.roles.length;
        }), a.length)
          return a;
        a = e.map(function(k2) {
          return k2.roles;
        }).reduce(bc, []);
        return a.length ? ke(e, a[0]) : e;
      }
      function ke(a, b) {
        return a.filter(function(c) {
          return c.roles.includes(b);
        });
      }
      function Ud(a) {
        var b = [];
        a.audio && b.push(le(a.audio));
        a.video && b.push(le(a.video));
        return b.join(", ");
      }
      function le(a) {
        return "audio" == a.type ? "type=audio codecs=" + a.codecs + " bandwidth=" + a.bandwidth + " channelsCount=" + a.channelsCount + " audioSamplingRate=" + a.audioSamplingRate : "video" == a.type ? "type=video codecs=" + a.codecs + " bandwidth=" + a.bandwidth + " frameRate=" + a.frameRate + " width=" + a.width + " height=" + a.height : "unexpected stream type";
      }
      var de = 0, Ed = "smooth", Fd = "powerEfficient", Hd = "bandwidth", Xd = (/* @__PURE__ */ new Map()).set("image/svg+xml", true).set("image/png", true).set("image/jpeg", true).set("image/jpg", true), Yd = (/* @__PURE__ */ new Map()).set("image/webp", "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA").set("image/avif", "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=");
      function me() {
        var a = this;
        this.l = null;
        this.o = false;
        this.i = new Ra();
        navigator.connection && navigator.connection.addEventListener("change", function() {
          if (a.g.useNetworkInformation && a.o) {
            a.i = new Ra();
            a.g && a.i.configure(a.g.advanced);
            var b = a.chooseVariant();
            b && a.l(b);
          }
        });
        this.m = [];
        this.u = 1;
        this.B = false;
        this.h = this.j = this.g = this.s = null;
        this.D = new P(function() {
          if (a.g.restrictToElementSize) {
            var b = a.chooseVariant();
            b && a.l(b);
          }
        });
      }
      q = me.prototype;
      q.stop = function() {
        this.l = null;
        this.o = false;
        this.m = [];
        this.u = 1;
        this.j = this.s = null;
        this.h && (this.h.disconnect(), this.h = null);
        this.D.stop();
      };
      q.init = function(a) {
        this.l = a;
      };
      q.chooseVariant = function() {
        var a = Infinity, b = Infinity;
        this.g.restrictToScreenSize && (b = this.g.ignoreDevicePixelRatio ? 1 : window2.devicePixelRatio, a = window2.screen.height * b, b *= window2.screen.width);
        this.h && this.g.restrictToElementSize && (b = this.g.ignoreDevicePixelRatio ? 1 : window2.devicePixelRatio, a = this.j.clientWidth * b, b *= this.j.clientHeight);
        a = ne(this.g.restrictions, this.m, a, b);
        b = this.i.getBandwidthEstimate(oe(this));
        this.m.length && !a.length && (a = ne(null, this.m, Infinity, Infinity), a = [a[0]]);
        for (var c = a[0] || null, d = 0; d < a.length; d++) {
          for (var e = a[d], f = isNaN(this.u) ? 1 : Math.abs(this.u), g = f * e.bandwidth / this.g.bandwidthDowngradeTarget, h = { bandwidth: Infinity }, k2 = d + 1; k2 < a.length; k2++)
            if (e.bandwidth != a[k2].bandwidth) {
              h = a[k2];
              break;
            }
          f = f * h.bandwidth / this.g.bandwidthUpgradeTarget;
          b >= g && b <= f && c.bandwidth != e.bandwidth && (c = e);
        }
        this.s = Date.now();
        return c;
      };
      q.enable = function() {
        this.o = true;
      };
      q.disable = function() {
        this.o = false;
      };
      q.segmentDownloaded = function(a, b) {
        this.i.sample(a, b);
        if (null != this.s && this.o)
          a: {
            if (!this.B) {
              a = this.i;
              if (!(a.g >= a.i))
                break a;
              this.B = true;
            } else if (Date.now() - this.s < 1e3 * this.g.switchInterval)
              break a;
            a = this.chooseVariant();
            this.i.getBandwidthEstimate(oe(this));
            a && this.l(a);
          }
      };
      q.getBandwidthEstimate = function() {
        return this.i.getBandwidthEstimate(oe(this));
      };
      q.setVariants = function(a) {
        this.m = a;
      };
      q.playbackRateChanged = function(a) {
        this.u = a;
      };
      q.setMediaElement = function(a) {
        var b = this;
        this.j = a;
        this.h && (this.h.disconnect(), this.h = null);
        this.j && "ResizeObserver" in window2 && (this.h = new ResizeObserver(function() {
          b.D.N(pe);
        }), this.h.observe(this.j));
      };
      q.configure = function(a) {
        this.g = a;
        this.i && this.g && this.i.configure(this.g.advanced);
      };
      function oe(a) {
        var b = a.g.defaultBandwidthEstimate;
        navigator.connection && navigator.connection.downlink && a.g.useNetworkInformation && (b = 1e6 * navigator.connection.downlink);
        return b;
      }
      function ne(a, b, c, d) {
        a && (b = b.filter(function(e) {
          return Kd(e, a, { width: d, height: c });
        }));
        return b.sort(function(e, f) {
          return e.bandwidth - f.bandwidth;
        });
      }
      K("shaka.abr.SimpleAbrManager", me);
      me.prototype.configure = me.prototype.configure;
      me.prototype.setMediaElement = me.prototype.setMediaElement;
      me.prototype.playbackRateChanged = me.prototype.playbackRateChanged;
      me.prototype.setVariants = me.prototype.setVariants;
      me.prototype.getBandwidthEstimate = me.prototype.getBandwidthEstimate;
      me.prototype.segmentDownloaded = me.prototype.segmentDownloaded;
      me.prototype.disable = me.prototype.disable;
      me.prototype.enable = me.prototype.enable;
      me.prototype.chooseVariant = me.prototype.chooseVariant;
      me.prototype.init = me.prototype.init;
      me.prototype.stop = me.prototype.stop;
      var pe = 1;
      function qe(a, b) {
        this.g = a;
        this.h = b;
      }
      qe.prototype.toString = function() {
        return "v" + this.g + "." + this.h;
      };
      function re(a, b) {
        var c = new qe(5, 0), d = se, e = d.g, f = c.h - e.h;
        (0 < (c.g - e.g || f) ? d.i : d.h)(d.g, c, a, b);
      }
      function te(a, b, c, d) {
        Wa([c, "has been deprecated and will be removed in", b, ". We are currently at version", a, ". Additional information:", d].join(" "));
      }
      function ue(a, b, c, d) {
        Va([c, "has been deprecated and has been removed in", b, ". We are now at version", a, ". Additional information:", d].join(""));
      }
      var se = null;
      K("shaka.config.AutoShowText", { NEVER: 0, ALWAYS: 1, IF_PREFERRED_TEXT_LANGUAGE: 2, IF_SUBTITLES_MAY_BE_NEEDED: 3 });
      function ve(a, b) {
        this.h = a;
        this.g = /* @__PURE__ */ new Set([a]);
        b = b || [];
        a = r(b);
        for (b = a.next(); !b.done; b = a.next())
          this.add(b.value);
      }
      ve.prototype.add = function(a) {
        return we(this.h, a) ? (this.g.add(a), true) : false;
      };
      function we(a, b) {
        var c;
        if (!(c = !!a.audio != !!b.audio || !!a.video != !!b.video || a.language != b.language) && (c = a.audio && b.audio)) {
          c = a.audio;
          var d = b.audio;
          c = !((!(!c.channelsCount || !d.channelsCount || 2 < c.channelsCount || 2 < d.channelsCount) || c.channelsCount == d.channelsCount) && xe(c, d) && ye(c.roles, d.roles));
        }
        !c && (c = a.video && b.video) && (a = a.video, b = b.video, c = !(xe(a, b) && ye(a.roles, b.roles)));
        return c ? false : true;
      }
      ve.prototype.values = function() {
        return this.g.values();
      };
      function xe(a, b) {
        if (a.mimeType != b.mimeType)
          return false;
        a = a.codecs.split(",").map(function(d) {
          return bd(d)[0];
        });
        b = b.codecs.split(",").map(function(d) {
          return bd(d)[0];
        });
        if (a.length != b.length)
          return false;
        a.sort();
        b.sort();
        for (var c = 0; c < a.length; c++)
          if (a[c] != b[c])
            return false;
        return true;
      }
      function ye(a, b) {
        a = new Set(a);
        b = new Set(b);
        a.delete("main");
        b.delete("main");
        if (a.size != b.size)
          return false;
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          if (!b.has(c.value))
            return false;
        return true;
      }
      function ze(a) {
        this.g = a;
        this.h = new Ae(a.language, "", a.audio && a.audio.channelsCount ? a.audio.channelsCount : 0, "");
      }
      ze.prototype.create = function(a) {
        var b = this, c = a.filter(function(d) {
          return we(b.g, d);
        });
        return c.length ? new ve(c[0], c) : this.h.create(a);
      };
      function Ae(a, b, c, d) {
        this.i = a;
        this.j = b;
        this.g = c;
        this.h = void 0 === d ? "" : d;
      }
      Ae.prototype.create = function(a) {
        var b = [];
        b = Be(a, this.i);
        var c = a.filter(function(d) {
          return d.primary;
        });
        b = b.length ? b : c.length ? c : a;
        a = Ce(b, this.j);
        a.length && (b = a);
        this.g && (a = zd(b, this.g), a.length && (b = a));
        this.h && (a = De(b, this.h), a.length && (b = a));
        a = new ve(b[0]);
        b = r(b);
        for (c = b.next(); !c.done; c = b.next())
          c = c.value, we(a.h, c) && a.add(c);
        return a;
      };
      function Be(a, b) {
        b = od(b);
        var c = vd(b, a.map(function(d) {
          return ud(d);
        }));
        return c ? a.filter(function(d) {
          return c == ud(d);
        }) : [];
      }
      function Ce(a, b) {
        return a.filter(function(c) {
          return c.audio ? b ? c.audio.roles.includes(b) : 0 == c.audio.roles.length : false;
        });
      }
      function De(a, b) {
        return a.filter(function(c) {
          return c.audio ? c.audio.label.toLowerCase() == b.toLowerCase() : false;
        });
      }
      function Ee() {
        this.g = Fe;
        this.h = (/* @__PURE__ */ new Map()).set(Fe, 2).set(Ge, 1);
      }
      function He(a, b, c) {
        a.h.set(Fe, c).set(Ge, b);
      }
      var Ge = 0, Fe = 1;
      function Ie(a, b) {
        var c = Je();
        this.l = null == a.maxAttempts ? c.maxAttempts : a.maxAttempts;
        this.j = null == a.baseDelay ? c.baseDelay : a.baseDelay;
        this.o = null == a.fuzzFactor ? c.fuzzFactor : a.fuzzFactor;
        this.m = null == a.backoffFactor ? c.backoffFactor : a.backoffFactor;
        this.g = 0;
        this.h = this.j;
        if (this.i = void 0 === b ? false : b)
          this.g = 1;
      }
      function Ke(a) {
        var b, c;
        return G(function(d) {
          if (1 == d.g) {
            if (a.g >= a.l)
              if (a.i)
                a.g = 1, a.h = a.j;
              else
                throw new O(2, 7, 1010);
            b = a.g;
            a.g++;
            if (0 == b)
              return d.return();
            c = a.h * (1 + (2 * Math.random() - 1) * a.o);
            return u(d, new Promise(function(e) {
              new P(e).N(c / 1e3);
            }), 2);
          }
          a.h *= a.m;
          A(d);
        });
      }
      function Je() {
        return { maxAttempts: 2, baseDelay: 1e3, backoffFactor: 2, fuzzFactor: 0.5, timeout: 3e4, stallTimeout: 5e3, connectionTimeout: 1e4 };
      }
      function Le(a, b) {
        this.promise = a;
        this.i = b;
        this.g = false;
      }
      function Me(a) {
        return new Le(Promise.reject(a), function() {
          return Promise.resolve();
        });
      }
      function Ne() {
        var a = Promise.reject(new O(2, 7, 7001));
        a.catch(function() {
        });
        return new Le(a, function() {
          return Promise.resolve();
        });
      }
      function Oe(a) {
        return new Le(Promise.resolve(a), function() {
          return Promise.resolve();
        });
      }
      function Pe(a) {
        return new Le(a, function() {
          return a.catch(function() {
          });
        });
      }
      Le.prototype.abort = function() {
        this.g = true;
        return this.i();
      };
      function Qe(a) {
        return new Le(Promise.all(a.map(function(b) {
          return b.promise;
        })), function() {
          return Promise.all(a.map(function(b) {
            return b.abort();
          }));
        });
      }
      Le.prototype.finally = function(a) {
        this.promise.then(function() {
          return a(true);
        }, function() {
          return a(false);
        });
        return this;
      };
      Le.prototype.Y = function(a, b) {
        function c(h) {
          return function(k2) {
            if (e.g && h)
              f.reject(g);
            else {
              var l = h ? a : b;
              l ? d = Re(l, k2, f) : (h ? f.resolve : f.reject)(k2);
            }
          };
        }
        function d() {
          f.reject(g);
          return e.abort();
        }
        var e = this, f = new lc2(), g = new O(2, 7, 7001);
        this.promise.then(c(true), c(false));
        return new Le(f, function() {
          return d();
        });
      };
      function Re(a, b, c) {
        try {
          var d = a(b);
          if (d && d.promise && d.abort)
            return c.resolve(d.promise), function() {
              return d.abort();
            };
          c.resolve(d);
          return function() {
            return Promise.resolve(d).then(function() {
            }, function() {
            });
          };
        } catch (e) {
          return c.reject(e), function() {
            return Promise.resolve();
          };
        }
      }
      K("shaka.util.AbortableOperation", Le);
      Le.prototype.chain = Le.prototype.Y;
      Le.prototype["finally"] = Le.prototype.finally;
      Le.all = Qe;
      Le.prototype.abort = Le.prototype.abort;
      Le.notAbortable = Pe;
      Le.completed = Oe;
      Le.aborted = Ne;
      Le.failed = Me;
      function S(a, b) {
        if (b)
          if (b instanceof Map)
            for (var c = r(b.keys()), d = c.next(); !d.done; d = c.next())
              d = d.value, Object.defineProperty(this, d, { value: b.get(d), writable: true, enumerable: true });
          else
            for (c in b)
              Object.defineProperty(this, c, { value: b[c], writable: true, enumerable: true });
        this.defaultPrevented = this.cancelable = this.bubbles = false;
        this.timeStamp = window2.performance && window2.performance.now ? window2.performance.now() : Date.now();
        this.type = a;
        this.isTrusted = false;
        this.target = this.currentTarget = null;
        this.g = false;
      }
      function Se(a) {
        var b = new S(a.type), c;
        for (c in a)
          Object.defineProperty(b, c, { value: a[c], writable: true, enumerable: true });
        return b;
      }
      S.prototype.preventDefault = function() {
        this.cancelable && (this.defaultPrevented = true);
      };
      S.prototype.stopImmediatePropagation = function() {
        this.g = true;
      };
      S.prototype.stopPropagation = function() {
      };
      K("shaka.util.FakeEvent", S);
      var Te = {
        Ig: "abrstatuschanged",
        Jg: "adaptation",
        Kg: "buffering",
        Lg: "downloadfailed",
        Mg: "downloadheadersreceived",
        Ng: "drmsessionupdate",
        Pg: "emsg",
        ah: "prft",
        Error: "error",
        Qg: "expirationupdated",
        Rg: "gapjumped",
        Tg: "loaded",
        Ug: "loading",
        Wg: "manifestparsed",
        Xg: "mediaqualitychanged",
        Metadata: "metadata",
        Zg: "onstatechange",
        $g: "onstateidle",
        bh: "ratechange",
        eh: "segmentappended",
        fh: "sessiondata",
        gh: "stalldetected",
        hh: "streaming",
        ih: "textchanged",
        jh: "texttrackvisibility",
        kh: "timelineregionadded",
        lh: "timelineregionenter",
        mh: "timelineregionexit",
        nh: "trackschanged",
        ph: "unloading",
        qh: "variantchanged"
      };
      function Ue() {
        this.da = new wd();
        this.Wc = this;
      }
      Ue.prototype.addEventListener = function(a, b) {
        this.da && this.da.push(a, b);
      };
      Ue.prototype.removeEventListener = function(a, b) {
        this.da && this.da.remove(a, b);
      };
      Ue.prototype.dispatchEvent = function(a) {
        if (!this.da)
          return true;
        var b = this.da.get(a.type) || [], c = this.da.get("All");
        c && (b = b.concat(c));
        b = r(b);
        for (c = b.next(); !c.done; c = b.next()) {
          c = c.value;
          a.target = this.Wc;
          a.currentTarget = this.Wc;
          try {
            c.handleEvent ? c.handleEvent(a) : c.call(this, a);
          } catch (d) {
          }
          if (a.g)
            break;
        }
        return a.defaultPrevented;
      };
      Ue.prototype.release = function() {
        this.da = null;
      };
      function Ve(a) {
        function b(d) {
          switch (typeof d) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
              return d;
            default:
              if (!d || d.buffer && d.buffer.constructor == ArrayBuffer)
                return d;
              if (c.has(d))
                return null;
              var e = d.constructor == Array;
              if (d.constructor != Object && !e)
                return null;
              c.add(d);
              var f = e ? [] : {}, g;
              for (g in d)
                f[g] = b(d[g]);
              e && (f.length = d.length);
              return f;
          }
        }
        var c = /* @__PURE__ */ new Set();
        return b(a);
      }
      function We(a) {
        var b = {}, c;
        for (c in a)
          b[c] = a[c];
        return b;
      }
      function Xe() {
        this.g = [];
      }
      function Ye(a, b) {
        a.g.push(b.finally(function() {
          hb(a.g, b);
        }));
      }
      Xe.prototype.destroy = function() {
        for (var a = [], b = r(this.g), c = b.next(); !c.done; c = b.next())
          c = c.value, c.promise.catch(function() {
          }), a.push(c.abort());
        this.g = [];
        return Promise.all(a);
      };
      function Ze(a, b, c) {
        Ue.call(this);
        this.i = false;
        this.m = new Xe();
        this.g = /* @__PURE__ */ new Set();
        this.h = /* @__PURE__ */ new Set();
        this.l = a || null;
        this.j = b || null;
        this.s = c || null;
        this.o = false;
      }
      oa(Ze, Ue);
      q = Ze.prototype;
      q.je = function(a) {
        this.o = a;
      };
      function $e(a, b, c, d) {
        c = c || af;
        var e = bf[a];
        if (!e || c >= e.priority)
          bf[a] = { priority: c, jg: b, kg: void 0 === d ? false : d };
      }
      q.lg = function(a) {
        this.g.add(a);
      };
      q.Bg = function(a) {
        this.g.delete(a);
      };
      q.rf = function() {
        this.g.clear();
      };
      q.mg = function(a) {
        this.h.add(a);
      };
      q.Cg = function(a) {
        this.h.delete(a);
      };
      q.tf = function() {
        this.h.clear();
      };
      function cf(a, b, c) {
        return { uris: a, method: "GET", body: null, headers: {}, allowCrossSiteCredentials: false, retryParameters: b, licenseRequestType: null, sessionId: null, drmInfo: null, initData: null, initDataType: null, streamDataCallback: void 0 === c ? null : c };
      }
      q.destroy = function() {
        this.i = true;
        this.g.clear();
        this.h.clear();
        Ue.prototype.release.call(this);
        return this.m.destroy();
      };
      q.request = function(a, b) {
        var c = this, d = new df();
        if (this.i) {
          var e = Promise.reject(new O(2, 7, 7001));
          e.catch(function() {
          });
          return new ef(e, function() {
            return Promise.resolve();
          }, d);
        }
        b.method = b.method || "GET";
        b.headers = b.headers || {};
        b.retryParameters = b.retryParameters ? Ve(b.retryParameters) : Je();
        b.uris = Ve(b.uris);
        e = ff(this, a, b);
        var f = e.Y(function() {
          return gf(c, a, b, new Ie(b.retryParameters, false), 0, null, d);
        }), g = f.Y(function(n) {
          return hf(c, a, n);
        }), h = Date.now(), k2 = 0;
        e.promise.then(function() {
          k2 = Date.now() - h;
        }, function() {
        });
        var l = 0;
        f.promise.then(function() {
          l = Date.now();
        }, function() {
        });
        var m = g.Y(function(n) {
          var p = Date.now() - l, t = n.response;
          t.timeMs += k2;
          t.timeMs += p;
          n.Yf || !c.l || t.fromCache || a != jf || c.l(t.timeMs, t.data.byteLength);
          return t;
        }, function(n) {
          n && (n.severity = 2);
          throw n;
        });
        e = new ef(m.promise, function() {
          return m.abort();
        }, d);
        Ye(this.m, e);
        return e;
      };
      function ff(a, b, c) {
        var d = Oe(void 0), e = {};
        a = r(a.g);
        for (var f = a.next(); !f.done; e = { sd: e.sd }, f = a.next())
          e.sd = f.value, d = d.Y(function(g) {
            return function() {
              c.body && (c.body = Ib(c.body));
              return g.sd(b, c);
            };
          }(e));
        return d.Y(void 0, function(g) {
          if (g instanceof O && 7001 == g.code)
            throw g;
          throw new O(2, 1, 1006, g);
        });
      }
      function gf(a, b, c, d, e, f, g) {
        a.o && (c.uris[e] = c.uris[e].replace("http://", "https://"));
        var h = new Nb(c.uris[e]), k2 = h.Ea, l = false;
        k2 || (k2 = location.protocol, k2 = k2.slice(0, -1), Ob(h, k2), c.uris[e] = h.toString());
        k2 = k2.toLowerCase();
        var m = (k2 = bf[k2]) ? k2.jg : null;
        if (!m)
          return Me(new O(2, 1, 1e3, h));
        var n = k2.kg, p = null, t = null, v = false, y = false, w;
        return Pe(Ke(d)).Y(function() {
          if (a.i)
            return Ne();
          w = Date.now();
          var x = m(c.uris[e], c, b, function(B, E, F) {
            p && p.stop();
            t && t.N(z / 1e3);
            a.l && b == jf && (a.l(B, E), l = true, g.g = F);
          }, function(B) {
            a.j && a.j(B, c, b);
            y = true;
          });
          if (!n)
            return x;
          var C = c.retryParameters.connectionTimeout;
          C && (p = new P(function() {
            v = true;
            x.abort();
          }), p.N(C / 1e3));
          var z = c.retryParameters.stallTimeout;
          z && (t = new P(function() {
            v = true;
            x.abort();
          }));
          return x;
        }).Y(function(x) {
          p && p.stop();
          t && t.stop();
          void 0 == x.timeMs && (x.timeMs = Date.now() - w);
          var C = { response: x, Yf: l };
          !y && a.j && a.j(x.headers, c, b);
          return C;
        }, function(x) {
          p && p.stop();
          t && t.stop();
          if (a.s) {
            var C = null, z = 0;
            x instanceof O && (C = x, 1001 == x.code && (z = x.data[1]));
            a.s(c, C, z, v);
          }
          if (a.i)
            return Ne();
          v && (x = new O(
            1,
            1,
            1003,
            c.uris[e],
            b
          ));
          if (x instanceof O) {
            if (7001 == x.code)
              throw x;
            if (1010 == x.code)
              throw f;
            if (1 == x.severity)
              return C = (/* @__PURE__ */ new Map()).set("error", x), C = new S("retry", C), a.dispatchEvent(C), e = (e + 1) % c.uris.length, gf(a, b, c, d, e, x, g);
          }
          throw x;
        });
      }
      function hf(a, b, c) {
        var d = Oe(void 0), e = {};
        a = r(a.h);
        for (var f = a.next(); !f.done; e = { td: e.td }, f = a.next())
          e.td = f.value, d = d.Y(function(g) {
            return function() {
              var h = c.response;
              h.data && (h.data = Ib(h.data));
              return g.td(b, h);
            };
          }(e));
        return d.Y(function() {
          return c;
        }, function(g) {
          var h = 2;
          if (g instanceof O) {
            if (7001 == g.code)
              throw g;
            h = g.severity;
          }
          throw new O(h, 1, 1007, g);
        });
      }
      K("shaka.net.NetworkingEngine", Ze);
      Ze.prototype.request = Ze.prototype.request;
      Ze.prototype.destroy = Ze.prototype.destroy;
      Ze.makeRequest = cf;
      Ze.defaultRetryParameters = function() {
        return Je();
      };
      Ze.prototype.clearAllResponseFilters = Ze.prototype.tf;
      Ze.prototype.unregisterResponseFilter = Ze.prototype.Cg;
      Ze.prototype.registerResponseFilter = Ze.prototype.mg;
      Ze.prototype.clearAllRequestFilters = Ze.prototype.rf;
      Ze.prototype.unregisterRequestFilter = Ze.prototype.Bg;
      Ze.prototype.registerRequestFilter = Ze.prototype.lg;
      Ze.unregisterScheme = function(a) {
        delete bf[a];
      };
      Ze.registerScheme = $e;
      Ze.prototype.setForceHTTPS = Ze.prototype.je;
      function df() {
        this.g = 0;
      }
      Ze.NumBytesRemainingClass = df;
      function ef(a, b, c) {
        Le.call(this, a, b);
        this.h = c;
      }
      oa(ef, Le);
      Ze.PendingRequest = ef;
      var jf = 1;
      Ze.RequestType = { MANIFEST: 0, SEGMENT: jf, LICENSE: 2, APP: 3, TIMING: 4, SERVER_CERTIFICATE: 5, KEY: 6 };
      var af = 3;
      Ze.PluginPriority = { FALLBACK: 1, PREFERRED: 2, APPLICATION: af };
      var bf = {};
      function kf(a) {
        this.g = false;
        this.h = new lc2();
        this.i = a;
      }
      kf.prototype.destroy = function() {
        var a = this;
        if (this.g)
          return this.h;
        this.g = true;
        return this.i().then(function() {
          a.h.resolve();
        }, function() {
          a.h.resolve();
        });
      };
      function lf(a, b) {
        if (a.g) {
          if (b instanceof O && 7003 == b.code)
            throw b;
          throw new O(2, 7, 7003, b);
        }
      }
      function mf() {
        this.g = new wd();
      }
      q = mf.prototype;
      q.release = function() {
        this.nb();
        this.g = null;
      };
      q.C = function(a, b, c, d) {
        this.g && (a = new nf(a, b, c, d), this.g.push(b, a));
      };
      q.ma = function(a, b, c, d) {
        function e(g) {
          f.zc(a, b, e);
          c(g);
        }
        var f = this;
        this.C(a, b, e, d);
      };
      q.zc = function(a, b, c) {
        if (this.g) {
          var d = this.g.get(b) || [];
          d = r(d);
          for (var e = d.next(); !e.done; e = d.next())
            e = e.value, e.target != a || c != e.listener && c || (e.zc(), this.g.remove(b, e));
        }
      };
      q.nb = function() {
        if (this.g) {
          var a = this.g, b = [], c;
          for (c in a.g)
            b.push.apply(b, ha(a.g[c]));
          a = r(b);
          for (b = a.next(); !b.done; b = a.next())
            b.value.zc();
          this.g.g = {};
        }
      };
      K("shaka.util.EventManager", mf);
      mf.prototype.removeAll = mf.prototype.nb;
      mf.prototype.unlisten = mf.prototype.zc;
      mf.prototype.listenOnce = mf.prototype.ma;
      mf.prototype.listen = mf.prototype.C;
      mf.prototype.release = mf.prototype.release;
      function nf(a, b, c, d) {
        this.target = a;
        this.type = b;
        this.listener = c;
        this.g = of(a, d);
        this.target.addEventListener(b, c, this.g);
      }
      nf.prototype.zc = function() {
        this.target.removeEventListener(this.type, this.listener, this.g);
        this.listener = this.target = null;
        this.g = false;
      };
      function of(a, b) {
        if (void 0 == b)
          return false;
        if ("boolean" == typeof b)
          return b;
        var c = /* @__PURE__ */ new Set(["passive", "capture"]);
        Object.keys(b).filter(function(d) {
          return !c.has(d);
        });
        return pf(a) ? b : b.capture || false;
      }
      function pf(a) {
        var b = qf;
        if (void 0 == b) {
          b = false;
          try {
            var c = {}, d = { get: function() {
              b = true;
              return false;
            } };
            Object.defineProperty(c, "passive", d);
            Object.defineProperty(c, "capture", d);
            d = function() {
            };
            a.addEventListener("test", d, c);
            a.removeEventListener("test", d, c);
          } catch (e) {
            b = false;
          }
          qf = b;
        }
        return b || false;
      }
      var qf = void 0;
      function rf(a, b) {
        var c = [];
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next())
          c.push(b(d.value));
        return c;
      }
      function sf(a, b) {
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          if (!b(c.value))
            return false;
        return true;
      }
      function tf(a) {
        for (var b = /* @__PURE__ */ new Map(), c = r(Object.keys(a)), d = c.next(); !d.done; d = c.next())
          d = d.value, b.set(d, a[d]);
        return b;
      }
      function uf(a) {
        var b = {};
        a.forEach(function(c, d) {
          b[d] = c;
        });
        return b;
      }
      function vf(a, b) {
        if (a || b) {
          if (a && !b || b && !a)
            return false;
        } else
          return true;
        if (a.size != b.size)
          return false;
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next()) {
          var d = r(c.value);
          c = d.next().value;
          d = d.next().value;
          if (!b.has(c))
            return false;
          c = b.get(c);
          if (c != d || void 0 == c)
            return false;
        }
        return true;
      }
      function wf(a, b) {
        this.S = Lb(a);
        this.h = b == xf;
        this.g = 0;
      }
      q = wf.prototype;
      q.ha = function() {
        return this.g < this.S.byteLength;
      };
      q.Z = function() {
        return this.g;
      };
      q.Gf = function() {
        return this.S.byteLength;
      };
      q.Ra = function() {
        try {
          var a = this.S.getUint8(this.g);
          this.g += 1;
          return a;
        } catch (b) {
          throw yf();
        }
      };
      q.$d = function() {
        try {
          var a = this.S.getUint16(this.g, this.h);
          this.g += 2;
          return a;
        } catch (b) {
          throw yf();
        }
      };
      q.K = function() {
        try {
          var a = this.S.getUint32(this.g, this.h);
          this.g += 4;
          return a;
        } catch (b) {
          throw yf();
        }
      };
      q.Pe = function() {
        try {
          var a = this.S.getInt32(this.g, this.h);
          this.g += 4;
          return a;
        } catch (b) {
          throw yf();
        }
      };
      q.$a = function() {
        try {
          if (this.h) {
            var a = this.S.getUint32(this.g, true);
            var b = this.S.getUint32(this.g + 4, true);
          } else
            b = this.S.getUint32(this.g, false), a = this.S.getUint32(this.g + 4, false);
        } catch (c) {
          throw yf();
        }
        if (2097151 < b)
          throw new O(2, 3, 3001);
        this.g += 8;
        return b * Math.pow(2, 32) + a;
      };
      q.Za = function(a) {
        if (this.g + a > this.S.byteLength)
          throw yf();
        var b = M(this.S, this.g, a);
        this.g += a;
        return b;
      };
      q.skip = function(a) {
        if (this.g + a > this.S.byteLength)
          throw yf();
        this.g += a;
      };
      q.sg = function(a) {
        if (this.g < a)
          throw yf();
        this.g -= a;
      };
      q.seek = function(a) {
        if (0 > a || a > this.S.byteLength)
          throw yf();
        this.g = a;
      };
      q.sc = function() {
        for (var a = this.g; this.ha() && 0 != this.S.getUint8(this.g); )
          this.g += 1;
        a = M(this.S, a, this.g - a);
        this.g += 1;
        return Cc(a);
      };
      function yf() {
        return new O(2, 3, 3e3);
      }
      K("shaka.util.DataViewReader", wf);
      wf.prototype.readTerminatedString = wf.prototype.sc;
      wf.prototype.seek = wf.prototype.seek;
      wf.prototype.rewind = wf.prototype.sg;
      wf.prototype.skip = wf.prototype.skip;
      wf.prototype.readBytes = wf.prototype.Za;
      wf.prototype.readUint64 = wf.prototype.$a;
      wf.prototype.readInt32 = wf.prototype.Pe;
      wf.prototype.readUint32 = wf.prototype.K;
      wf.prototype.readUint16 = wf.prototype.$d;
      wf.prototype.readUint8 = wf.prototype.Ra;
      wf.prototype.getLength = wf.prototype.Gf;
      wf.prototype.getPosition = wf.prototype.Z;
      wf.prototype.hasMoreData = wf.prototype.ha;
      var xf = 1;
      wf.Endianness = { BIG_ENDIAN: 0, LITTLE_ENDIAN: xf };
      function zf() {
        this.i = [];
        this.h = [];
        this.g = false;
      }
      q = zf.prototype;
      q.box = function(a, b) {
        a = Af(a);
        this.i[a] = Bf;
        this.h[a] = b;
        return this;
      };
      q.P = function(a, b) {
        a = Af(a);
        this.i[a] = Cf;
        this.h[a] = b;
        return this;
      };
      q.stop = function() {
        this.g = true;
      };
      q.parse = function(a, b, c) {
        a = new wf(a, 0);
        for (this.g = false; a.ha() && !this.g; )
          this.qc(0, a, b, c);
      };
      q.qc = function(a, b, c, d) {
        var e = b.Z();
        if (d && e + 8 > b.S.byteLength)
          this.g = true;
        else {
          var f = b.K(), g = b.K(), h = Df(g), k2 = false;
          switch (f) {
            case 0:
              f = b.S.byteLength - e;
              break;
            case 1:
              if (d && b.Z() + 8 > b.S.byteLength) {
                this.g = true;
                return;
              }
              f = b.$a();
              k2 = true;
          }
          var l = this.h[g];
          if (l) {
            var m = null, n = null;
            if (this.i[g] == Cf) {
              if (d && b.Z() + 4 > b.S.byteLength) {
                this.g = true;
                return;
              }
              n = b.K();
              m = n >>> 24;
              n &= 16777215;
            }
            g = e + f;
            c && g > b.S.byteLength && (g = b.S.byteLength);
            d && g > b.S.byteLength ? this.g = true : (d = g - b.Z(), b = 0 < d ? b.Za(d) : new Uint8Array(0), b = new wf(b, 0), l({
              name: h,
              parser: this,
              partialOkay: c || false,
              version: m,
              flags: n,
              reader: b,
              size: f,
              start: e + a,
              has64BitSize: k2
            }));
          } else
            b.skip(Math.min(e + f - b.Z(), b.S.byteLength - b.Z()));
        }
      };
      function Ef(a) {
        for (var b = Ff(a); a.reader.ha() && !a.parser.g; )
          a.parser.qc(a.start + b, a.reader, a.partialOkay);
      }
      function Gf(a) {
        for (var b = Ff(a), c = a.reader.K(), d = 0; d < c && (a.parser.qc(a.start + b, a.reader, a.partialOkay), !a.parser.g); d++)
          ;
      }
      function Hf(a) {
        var b = Ff(a);
        for (a.reader.skip(78); a.reader.ha() && !a.parser.g; )
          a.parser.qc(a.start + b, a.reader, a.partialOkay);
      }
      function If(a) {
        return function(b) {
          a(b.reader.Za(b.reader.S.byteLength - b.reader.Z()));
        };
      }
      function Af(a) {
        var b = 0;
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          b = b << 8 | c.value.charCodeAt(0);
        return b;
      }
      function Df(a) {
        return String.fromCharCode(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, a & 255);
      }
      function Ff(a) {
        return 8 + (a.has64BitSize ? 8 : 0) + (null != a.flags ? 4 : 0);
      }
      K("shaka.util.Mp4Parser", zf);
      zf.headerSize = Ff;
      zf.typeToString = Df;
      zf.allData = If;
      zf.visualSampleEntry = Hf;
      zf.sampleDescription = Gf;
      zf.children = Ef;
      zf.prototype.parseNext = zf.prototype.qc;
      zf.prototype.parse = zf.prototype.parse;
      zf.prototype.stop = zf.prototype.stop;
      zf.prototype.fullBox = zf.prototype.P;
      zf.prototype.box = zf.prototype.box;
      var Bf = 0, Cf = 1;
      function Jf(a) {
        var b = this;
        this.g = [];
        this.h = [];
        this.data = [];
        new zf().box("moov", Ef).box("moof", Ef).P("pssh", function(c) {
          if (!(1 < c.version)) {
            var d = M(c.reader.S, -12, c.size);
            b.data.push(d);
            b.g.push(Nc(c.reader.Za(16)));
            if (0 < c.version) {
              d = c.reader.K();
              for (var e = 0; e < d; e++) {
                var f = Nc(c.reader.Za(16));
                b.h.push(f);
              }
            }
          }
        }).parse(a);
      }
      function Kf(a, b, c, d) {
        var e = a.length, f = b.length + 16 + e;
        0 < d && (f += 4 + 16 * c.size);
        var g = new Uint8Array(f), h = Lb(g), k2 = 0;
        h.setUint32(k2, f);
        k2 += 4;
        h.setUint32(k2, 1886614376);
        k2 += 4;
        1 > d ? h.setUint32(k2, 0) : h.setUint32(k2, 16777216);
        k2 += 4;
        g.set(b, k2);
        k2 += b.length;
        if (0 < d)
          for (h.setUint32(k2, c.size), k2 += 4, b = r(c), c = b.next(); !c.done; c = b.next())
            c = Mc(c.value), g.set(c, k2), k2 += c.length;
        h.setUint32(k2, e);
        g.set(a, k2 + 4);
        return g;
      }
      function Lf(a, b) {
        a = Mf(a, b);
        return 1 != a.length ? null : a[0];
      }
      function Nf(a, b, c) {
        a = Of(a, b, c);
        return 1 != a.length ? null : a[0];
      }
      function Mf(a, b) {
        var c = [];
        a = r(a.childNodes);
        for (var d = a.next(); !d.done; d = a.next())
          d = d.value, d instanceof Element && d.tagName == b && c.push(d);
        return c;
      }
      function Pf(a) {
        return Array.from(a.childNodes).filter(function(b) {
          return b instanceof Element;
        });
      }
      function Of(a, b, c) {
        var d = [];
        a = r(a.childNodes);
        for (var e = a.next(); !e.done; e = a.next())
          e = e.value, e instanceof Element && e.localName == c && e.namespaceURI == b && d.push(e);
        return d;
      }
      function Qf(a, b, c) {
        return a.hasAttributeNS(b, c) ? a.getAttributeNS(b, c) : null;
      }
      function Rf(a, b, c) {
        b = r(b);
        for (var d = b.next(); !d.done; d = b.next())
          if (d = d.value, a.hasAttributeNS(d, c))
            return a.getAttributeNS(d, c);
        return null;
      }
      function Sf(a) {
        return Array.from(a.childNodes).every(Tf) ? a.textContent.trim() : null;
      }
      function Tf(a) {
        return a.nodeType == Node.TEXT_NODE || a.nodeType == Node.CDATA_SECTION_NODE;
      }
      function Uf(a, b, c, d) {
        d = void 0 === d ? null : d;
        var e = null;
        a = a.getAttribute(b);
        null != a && (e = c(a));
        return null == e ? d : e;
      }
      function Vf(a) {
        if (!a)
          return null;
        /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(a) && (a += "Z");
        a = Date.parse(a);
        return isNaN(a) ? null : a / 1e3;
      }
      function Wf(a) {
        if (!a)
          return null;
        a = RegExp("^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$").exec(a);
        if (!a)
          return null;
        a = 31536e3 * Number(a[1] || null) + 2592e3 * Number(a[2] || null) + 86400 * Number(a[3] || null) + 3600 * Number(a[4] || null) + 60 * Number(a[5] || null) + Number(a[6] || null);
        return isFinite(a) ? a : null;
      }
      function Xf(a) {
        var b = /([0-9]+)-([0-9]+)/.exec(a);
        if (!b)
          return null;
        a = Number(b[1]);
        if (!isFinite(a))
          return null;
        b = Number(b[2]);
        return isFinite(b) ? { start: a, end: b } : null;
      }
      function Yf(a) {
        a = Number(a);
        return 0 === a % 1 ? a : null;
      }
      function Zf(a) {
        a = Number(a);
        return 0 === a % 1 && 0 < a ? a : null;
      }
      function $f(a) {
        a = Number(a);
        return 0 === a % 1 && 0 <= a ? a : null;
      }
      function ag(a) {
        a = Number(a);
        return isNaN(a) ? null : a;
      }
      function bg(a) {
        var b;
        var c = (b = a.match(/^(\d+)\/(\d+)$/)) ? Number(b[1]) / Number(b[2]) : Number(a);
        return isNaN(c) ? null : c;
      }
      function cg(a, b) {
        var c = new DOMParser(), d = dg.value()(a);
        a = null;
        try {
          a = c.parseFromString(d, "text/xml");
        } catch (e) {
          return null;
        }
        c = a.documentElement;
        if (!c || c.getElementsByTagName("parsererror").length || c.tagName != b)
          return null;
        for (b = document.createNodeIterator(a, NodeFilter.SHOW_ALL); a = b.nextNode(); )
          if (a instanceof HTMLElement || a instanceof SVGElement)
            return null;
        return c;
      }
      function eg(a, b) {
        try {
          var c = Cc(a);
          return cg(c, b);
        } catch (d) {
          return null;
        }
      }
      var dg = new mc(function() {
        if ("undefined" !== typeof trustedTypes) {
          var a = trustedTypes.createPolicy("shaka-player#xml", { createHTML: function(b) {
            return b;
          } });
          return function(b) {
            return a.createHTML(b);
          };
        }
        return function(b) {
          return b;
        };
      });
      function fg(a, b) {
        var c = this;
        b = void 0 === b ? 1 : b;
        this.D = a;
        this.G = /* @__PURE__ */ new Set();
        this.l = this.u = null;
        this.da = this.W = false;
        this.H = 0;
        this.g = null;
        this.s = new mf();
        this.i = /* @__PURE__ */ new Map();
        this.B = [];
        this.o = new lc2();
        this.h = null;
        this.m = function(d) {
          c.o.reject(d);
          a.onError(d);
        };
        this.ea = /* @__PURE__ */ new Map();
        this.ba = /* @__PURE__ */ new Map();
        this.O = new P(function() {
          return gg(c);
        });
        this.L = false;
        this.J = [];
        this.M = false;
        this.ca = new P(function() {
          hg(c);
        }).Ca(b);
        this.o.catch(function() {
        });
        this.j = new kf(function() {
          return ig(c);
        });
        this.V = false;
        this.F = null;
      }
      q = fg.prototype;
      q.destroy = function() {
        return this.j.destroy();
      };
      function ig(a) {
        return G(function(b) {
          switch (b.g) {
            case 1:
              return a.s.release(), a.s = null, a.o.reject(), a.ca.stop(), a.ca = null, a.O.stop(), a.O = null, u(b, jg(a), 2);
            case 2:
              if (!a.l) {
                b.A(3);
                break;
              }
              D(b, 4);
              return u(b, a.l.setMediaKeys(null), 6);
            case 6:
              ta(b, 5);
              break;
            case 4:
              ua(b);
            case 5:
              a.l = null;
            case 3:
              a.g = null, a.G.clear(), a.u = null, a.B = [], a.h = null, a.m = function() {
              }, a.D = null, a.V = false, a.F = null, A(b);
          }
        });
      }
      q.configure = function(a) {
        this.h = a;
      };
      function kg(a, b, c) {
        a.da = true;
        a.B = [];
        a.L = c;
        return lg(a, b);
      }
      function mg(a, b, c) {
        a.B = c;
        a.L = 0 < c.length;
        return lg(a, b);
      }
      function ng(a, b, c, d, e, f) {
        var g = /* @__PURE__ */ new Map();
        e = { audioCapabilities: e, videoCapabilities: f, distinctiveIdentifier: "optional", persistentState: "required", sessionTypes: ["persistent-license"], label: b };
        e.drmInfos = [{ keySystem: b, licenseServerUri: c, distinctiveIdentifierRequired: false, persistentStateRequired: true, audioRobustness: "", videoRobustness: "", serverCertificate: d, serverCertificateUri: "", initData: null, keyIds: null }];
        g.set(b, e);
        return og(a, g, []);
      }
      function lg(a, b) {
        var c, d, e, f, g, h, k2, l, m, n, p, t, v, y;
        return G(function(w) {
          if (1 == w.g) {
            if (c = pg(a))
              for (d = r(b), e = d.next(); !e.done; e = d.next())
                f = e.value, f.video && (f.video.drmInfos = [c]), f.audio && (f.audio.drmInfos = [c]);
            g = b.some(function(x) {
              return x.video && x.video.drmInfos.length || x.audio && x.audio.drmInfos.length ? true : false;
            });
            g || (h = tf(a.h.servers), qg(b, h));
            k2 = r(b);
            for (e = k2.next(); !e.done; e = k2.next())
              for (l = e.value, m = rg(l), n = r(m), p = n.next(); !p.done; p = n.next())
                t = p.value, sg(t, tf(a.h.servers), tf(a.h.advanced || {}), a.h.keySystemsMapping);
            return u(w, Rd(b, a.L, a.V), 2);
          }
          v = g || Object.keys(a.h.servers).length;
          if (!v)
            return a.W = true, w.return(Promise.resolve());
          y = og(a, void 0, b);
          return w.return(g ? y : y.catch(function() {
          }));
        });
      }
      function tg(a) {
        var b;
        return G(function(c) {
          switch (c.g) {
            case 1:
              if (a.l.mediaKeys)
                return c.return();
              if (!a.F) {
                c.A(2);
                break;
              }
              return u(c, a.F, 3);
            case 3:
              return lf(a.j), c.return();
            case 2:
              return D(c, 4), a.F = a.l.setMediaKeys(a.u), u(c, a.F, 6);
            case 6:
              ta(c, 5);
              break;
            case 4:
              b = ua(c), a.m(new O(2, 6, 6003, b.message));
            case 5:
              lf(a.j), A(c);
          }
        });
      }
      function ug(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return u(c, tg(a), 2);
          vg(a, b.initDataType, M(b.initData));
          A(c);
        });
      }
      q.Yb = function(a) {
        var b = this, c;
        return G(function(d) {
          if (1 == d.g) {
            if (!b.u)
              return b.s.ma(a, "encrypted", function() {
                b.m(new O(2, 6, 6010));
              }), d.return();
            b.l = a;
            b.s.ma(b.l, "play", function() {
              for (var e = r(b.J), f = e.next(); !f.done; f = e.next())
                wg(b, f.value);
              b.M = true;
              b.J = [];
            });
            "webkitCurrentPlaybackTargetIsWireless" in b.l && b.s.C(b.l, "webkitcurrentplaybacktargetiswirelesschanged", function() {
              return jg(b);
            });
            return (c = b.g ? b.g.initData.find(function(e) {
              return 0 < e.initData.length;
            }) : null) || "com.apple.fps" !== b.g.keySystem || b.B.length ? u(d, tg(b), 2) : d.A(2);
          }
          xg(b);
          c || b.B.length || b.h.parseInbandPsshEnabled || b.s.C(b.l, "encrypted", function(e) {
            return ug(b, e);
          });
          A(d);
        });
      };
      function yg(a) {
        var b, c, d, e, f;
        return G(function(g) {
          switch (g.g) {
            case 1:
              if (!a.u || !a.g)
                return g.return();
              if (!a.g.serverCertificateUri || a.g.serverCertificate && a.g.serverCertificate.length) {
                g.A(2);
                break;
              }
              b = cf([a.g.serverCertificateUri], a.h.retryParameters);
              D(g, 3);
              c = a.D.kb.request(5, b);
              return u(g, c.promise, 5);
            case 5:
              d = g.h;
              a.g.serverCertificate = M(d.data);
              ta(g, 4);
              break;
            case 3:
              throw e = ua(g), new O(2, 6, 6017, e);
            case 4:
              if (a.j.g)
                return g.return();
            case 2:
              if (!a.g.serverCertificate || !a.g.serverCertificate.length)
                return g.return();
              D(g, 6);
              return u(g, a.u.setServerCertificate(a.g.serverCertificate), 8);
            case 8:
              ta(g, 0);
              break;
            case 6:
              throw f = ua(g), new O(2, 6, 6004, f.message);
          }
        });
      }
      function zg(a, b) {
        var c, d, e;
        return G(function(f) {
          if (1 == f.g)
            return u(f, Ag(a, b), 2);
          if (3 != f.g) {
            c = f.h;
            if (!c)
              return f.return();
            d = [];
            if (e = a.i.get(c))
              e.Ja = new lc2(), d.push(e.Ja);
            d.push(c.remove());
            return u(f, Promise.all(d), 3);
          }
          a.i.delete(c);
          A(f);
        });
      }
      function xg(a) {
        for (var b = (a.g ? a.g.initData : []) || [], c = r(b), d = c.next(); !d.done; d = c.next())
          d = d.value, vg(a, d.initDataType, d.initData);
        c = r(a.B);
        for (d = c.next(); !d.done; d = c.next())
          Ag(a, d.value);
        b.length || a.B.length || a.o.resolve();
        return a.o;
      }
      function vg(a, b, c) {
        if (c.length) {
          var d = a.i.values();
          d = r(d);
          for (var e = d.next(); !e.done; e = d.next())
            if (Gb(c, e.value.initData) && !tc("Tizen 2"))
              return;
          0 < a.i.size && Bg(a) && (a.o.resolve(), a.o = new lc2(), a.o.catch(function() {
          }));
          Cg(a, b, c, a.g.sessionType);
        }
      }
      function Dg(a) {
        return a ? !!a.match(/^com\.(microsoft|chromecast)\.playready/) : false;
      }
      function Eg(a) {
        a = a.i.keys();
        a = rf(a, function(b) {
          return b.sessionId;
        });
        return Array.from(a);
      }
      q.ic = function() {
        var a = Infinity, b = this.i.keys();
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next())
          c = c.value, isNaN(c.expiration) || (a = Math.min(a, c.expiration));
        return a;
      };
      q.Qc = function() {
        return uf(this.ba);
      };
      function og(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p, t, v, y;
        return G(function(w) {
          switch (w.g) {
            case 1:
              d = /* @__PURE__ */ new Map();
              if (c.length) {
                e = Fg(a, c, d);
                w.A(2);
                break;
              }
              return u(w, Gg(a, b), 3);
            case 3:
              e = w.h;
            case 2:
              f = e;
              if (!f)
                throw new O(2, 6, 6001);
              lf(a.j);
              D(w, 4);
              a.G.clear();
              g = f.getConfiguration();
              h = g.audioCapabilities || [];
              k2 = g.videoCapabilities || [];
              l = r(h);
              for (m = l.next(); !m.done; m = l.next())
                n = m.value, a.G.add(n.contentType.toLowerCase());
              p = r(k2);
              for (m = p.next(); !m.done; m = p.next())
                t = m.value, a.G.add(t.contentType.toLowerCase());
              if (c.length) {
                var x = f.keySystem;
                var C = d.get(f.keySystem);
                var z = [], B = [], E = [], F = [], H = /* @__PURE__ */ new Set();
                Hg(C, z, E, B, F, H);
                var I = a.L ? "persistent-license" : "temporary";
                x = { keySystem: x, licenseServerUri: z[0], distinctiveIdentifierRequired: C[0].distinctiveIdentifierRequired, persistentStateRequired: C[0].persistentStateRequired, sessionType: C[0].sessionType || I, audioRobustness: C[0].audioRobustness || "", videoRobustness: C[0].videoRobustness || "", serverCertificate: E[0], serverCertificateUri: B[0], initData: F, keyIds: H };
                C = r(C);
                for (z = C.next(); !z.done; z = C.next())
                  z = z.value, z.distinctiveIdentifierRequired && (x.distinctiveIdentifierRequired = z.distinctiveIdentifierRequired), z.persistentStateRequired && (x.persistentStateRequired = z.persistentStateRequired);
                C = x;
              } else
                C = f.keySystem, x = b.get(f.keySystem), z = [], B = [], E = [], F = [], H = /* @__PURE__ */ new Set(), Hg(x.drmInfos, z, E, B, F, H), C = { keySystem: C, licenseServerUri: z[0], distinctiveIdentifierRequired: "required" == x.distinctiveIdentifier, persistentStateRequired: "required" == x.persistentState, sessionType: x.sessionTypes[0] || "temporary", audioRobustness: (x.audioCapabilities ? x.audioCapabilities[0].robustness : "") || "", videoRobustness: (x.videoCapabilities ? x.videoCapabilities[0].robustness : "") || "", serverCertificate: E[0], serverCertificateUri: B[0], initData: F, keyIds: H };
              a.g = C;
              if (!a.g.licenseServerUri)
                throw new O(2, 6, 6012, a.g.keySystem);
              return u(w, f.createMediaKeys(), 6);
            case 6:
              return v = w.h, lf(a.j), a.u = v, a.W = true, u(w, yg(a), 7);
            case 7:
              lf(a.j);
              ta(w, 0);
              break;
            case 4:
              y = ua(w);
              lf(a.j, y);
              a.g = null;
              a.G.clear();
              if (y instanceof O)
                throw y;
              throw new O(2, 6, 6002, y.message);
          }
        });
      }
      function Fg(a, b, c) {
        for (var d = r(b), e = d.next(); !e.done; e = d.next()) {
          var f = r(rg(e.value));
          for (e = f.next(); !e.done; e = f.next())
            e = e.value, c.has(e.keySystem) || c.set(e.keySystem, []), c.get(e.keySystem).push(e);
        }
        if (1 == c.size && c.has(""))
          throw new O(2, 6, 6e3);
        d = {};
        a = r(a.h.preferredKeySystems);
        for (e = a.next(); !e.done; d = { qd: d.qd }, e = a.next())
          for (d.qd = e.value, f = r(b), e = f.next(); !e.done; e = f.next())
            if (e = e.value.decodingInfos.find(function(l) {
              return function(m) {
                return m.supported && null != m.keySystemAccess && m.keySystemAccess.keySystem == l.qd;
              };
            }(d)))
              return e.keySystemAccess;
        a = r([true, false]);
        for (e = a.next(); !e.done; e = a.next())
          for (d = e.value, f = r(b), e = f.next(); !e.done; e = f.next()) {
            var g = r(e.value.decodingInfos);
            for (e = g.next(); !e.done; e = g.next()) {
              var h = e.value;
              if (h.supported && h.keySystemAccess) {
                e = c.get(h.keySystemAccess.keySystem);
                var k2 = r(e);
                for (e = k2.next(); !e.done; e = k2.next())
                  if (!!e.value.licenseServerUri == d)
                    return h.keySystemAccess;
              }
            }
          }
        return null;
      }
      function Gg(a, b) {
        var c, d, e, f, g, h, k2, l, m, n, p, t, v, y, w;
        return G(function(x) {
          switch (x.g) {
            case 1:
              if (1 == b.size && b.has(""))
                throw new O(2, 6, 6e3);
              d = r(b.values());
              for (e = d.next(); !e.done; e = d.next())
                f = e.value, 0 == f.audioCapabilities.length && delete f.audioCapabilities, 0 == f.videoCapabilities.length && delete f.videoCapabilities;
              g = r(a.h.preferredKeySystems);
              h = g.next();
            case 2:
              if (h.done) {
                x.A(4);
                break;
              }
              k2 = h.value;
              if (!b.has(k2)) {
                x.A(3);
                break;
              }
              l = b.get(k2);
              D(x, 6);
              return u(x, navigator.requestMediaKeySystemAccess(k2, [l]), 8);
            case 8:
              return c = x.h, x.return(c);
            case 6:
              ua(x);
            case 7:
              lf(a.j);
            case 3:
              h = g.next();
              x.A(2);
              break;
            case 4:
              m = r([true, false]), n = m.next();
            case 9:
              if (n.done) {
                x.A(11);
                break;
              }
              p = n.value;
              t = r(b.keys());
              h = t.next();
            case 12:
              if (h.done) {
                n = m.next();
                x.A(9);
                break;
              }
              v = h.value;
              y = b.get(v);
              w = y.drmInfos.some(function(C) {
                return !!C.licenseServerUri;
              });
              if (w != p) {
                x.A(13);
                break;
              }
              D(x, 15);
              return u(x, navigator.requestMediaKeySystemAccess(v, [y]), 17);
            case 17:
              return c = x.h, x.return(c);
            case 15:
              ua(x);
            case 16:
              lf(a.j);
            case 13:
              h = t.next();
              x.A(12);
              break;
            case 11:
              return x.return(c);
          }
        });
      }
      function pg(a) {
        a = tf(a.h.clearKeys);
        if (0 == a.size)
          return null;
        var b = [], c = [];
        a.forEach(function(e, f) {
          var g = f;
          22 != g.length && (g = Kc(Mc(f), false));
          f = e;
          22 != f.length && (f = Kc(Mc(e), false));
          e = { kty: "oct", kid: g, k: f };
          b.push(e);
          c.push(e.kid);
        });
        a = JSON.stringify({ keys: b });
        var d = JSON.stringify({ kids: c });
        d = [{ initData: M(Gc(d)), initDataType: "keyids" }];
        return {
          keySystem: "org.w3.clearkey",
          licenseServerUri: "data:application/json;base64," + window2.btoa(a),
          distinctiveIdentifierRequired: false,
          persistentStateRequired: false,
          audioRobustness: "",
          videoRobustness: "",
          serverCertificate: null,
          serverCertificateUri: "",
          sessionType: "",
          initData: d,
          keyIds: new Set(c)
        };
      }
      function Ag(a, b) {
        var c, d, e, f, g;
        return G(function(h) {
          switch (h.g) {
            case 1:
              try {
                c = a.u.createSession("persistent-license");
              } catch (k2) {
                return d = new O(2, 6, 6005, k2.message), a.m(d), h.return(Promise.reject(d));
              }
              a.s.C(c, "message", function(k2) {
                a.l && a.h.delayLicenseRequestUntilPlayed && a.l.paused && !a.M ? a.J.push(k2) : wg(a, k2);
              });
              a.s.C(c, "keystatuseschange", function(k2) {
                return Ig(a, k2);
              });
              e = { initData: null, initDataType: null, loaded: false, Vd: Infinity, Ja: null, type: "persistent-license" };
              a.i.set(c, e);
              D(h, 2);
              return u(h, c.load(b), 4);
            case 4:
              f = h.h;
              lf(a.j);
              if (!f)
                return a.i.delete(c), a.m(new O(2, 6, 6013)), h.return(Promise.resolve());
              e.loaded = true;
              Bg(a) && a.o.resolve();
              return h.return(c);
            case 2:
              g = ua(h), lf(a.j, g), a.i.delete(c), a.m(new O(2, 6, 6005, g.message));
            case 3:
              return h.return(Promise.resolve());
          }
        });
      }
      function Cg(a, b, c, d) {
        try {
          var e = a.u.createSession(d);
        } catch (f) {
          a.m(new O(2, 6, 6005, f.message));
          return;
        }
        a.s.C(e, "message", function(f) {
          a.l && a.h.delayLicenseRequestUntilPlayed && a.l.paused && !a.M ? a.J.push(f) : wg(a, f);
        });
        a.s.C(e, "keystatuseschange", function(f) {
          return Ig(a, f);
        });
        a.i.set(e, { initData: c, initDataType: b, loaded: false, Vd: Infinity, Ja: null, type: d });
        try {
          c = a.h.initDataTransform(c, b, a.g);
        } catch (f) {
          b = f;
          f instanceof O || (b = new O(2, 6, 6016, f));
          a.m(b);
          return;
        }
        a.h.logLicenseExchange && Kc(c);
        e.generateRequest(b, c).catch(function(f) {
          if (!a.j.g) {
            a.i.delete(e);
            var g = f.errorCode;
            if (g && g.systemCode) {
              var h = g.systemCode;
              0 > h && (h += Math.pow(2, 32));
              h = "0x" + h.toString(16);
            }
            a.m(new O(2, 6, 6006, f.message, f, h));
          }
        });
      }
      function wg(a, b) {
        var c, d, e, f, g, h, k2, l, m, n, p, t, v, y;
        G(function(w) {
          switch (w.g) {
            case 1:
              return c = b.target, a.h.logLicenseExchange && Kc(b.message), d = a.i.get(c), e = a.g.licenseServerUri, f = a.h.advanced[a.g.keySystem], "individualization-request" == b.messageType && f && f.individualizationServer && (e = f.individualizationServer), g = cf([e], a.h.retryParameters), g.body = b.message, g.method = "POST", g.licenseRequestType = b.messageType, g.sessionId = c.sessionId, g.drmInfo = a.g, d && (g.initData = d.initData, g.initDataType = d.initDataType), Dg(a.g.keySystem) && Jg(g), h = Date.now(), D(w, 2), l = a.D.kb.request(2, g), u(w, l.promise, 4);
            case 4:
              k2 = w.h;
              ta(w, 3);
              break;
            case 2:
              return m = ua(w), n = new O(2, 6, 6007, m), a.m(n), d && d.Ja && d.Ja.reject(n), w.return();
            case 3:
              if (a.j.g)
                return w.return();
              a.H += (Date.now() - h) / 1e3;
              a.h.logLicenseExchange && Kc(k2.data);
              D(w, 5);
              return u(w, c.update(k2.data), 7);
            case 7:
              ta(w, 6);
              break;
            case 5:
              return p = ua(w), t = new O(2, 6, 6008, p.message), a.m(t), d && d.Ja && d.Ja.reject(t), w.return();
            case 6:
              if (a.j.g)
                return w.return();
              v = new S("drmsessionupdate");
              a.D.onEvent(v);
              d && (d.Ja && d.Ja.resolve(), y = new P(function() {
                d.loaded = true;
                Bg(a) && a.o.resolve();
              }), y.N(Kg));
              A(w);
          }
        });
      }
      function Jg(a) {
        var b = Dc(a.body, true, true);
        if (b.includes("PlayReadyKeyMessage")) {
          b = cg(b, "PlayReadyKeyMessage");
          for (var c = r(b.getElementsByTagName("HttpHeader")), d = c.next(); !d.done; d = c.next())
            d = d.value, a.headers[d.getElementsByTagName("name")[0].textContent] = d.getElementsByTagName("value")[0].textContent;
          a.body = Lc(b.getElementsByTagName("Challenge")[0].textContent);
        } else
          a.headers["Content-Type"] = "text/xml; charset=utf-8";
      }
      function Ig(a, b) {
        b = b.target;
        var c = a.i.get(b), d = false;
        b.keyStatuses.forEach(function(f, g) {
          if ("string" == typeof g) {
            var h = g;
            g = f;
            f = h;
          }
          if (Dg(a.g.keySystem) && 16 == g.byteLength && (rc() || xc())) {
            h = Lb(g);
            var k2 = h.getUint32(0, true), l = h.getUint16(4, true), m = h.getUint16(6, true);
            h.setUint32(0, k2, false);
            h.setUint16(4, l, false);
            h.setUint16(6, m, false);
          }
          "status-pending" != f && (c.loaded = true);
          "expired" == f && (d = true);
          g = Nc(g).slice(0, 32);
          a.ea.set(g, f);
        });
        var e = b.expiration - Date.now();
        (0 > e || d && 1e3 > e) && c && !c.Ja && (a.i.delete(b), b.close().catch(function() {
        }));
        Bg(a) && (a.o.resolve(), a.O.N(Lg));
      }
      function gg(a) {
        var b = a.ea, c = a.ba;
        c.clear();
        b.forEach(function(d, e) {
          return c.set(e, d);
        });
        b = Array.from(c.values());
        b.length && b.every(function(d) {
          return "expired" == d;
        }) && a.m(new O(2, 6, 6014));
        a.D.cd(uf(c));
      }
      function Mg() {
        var a, b, c, d, e, f, g, h;
        return G(function(k2) {
          return 1 == k2.g ? (a = "org.w3.clearkey com.widevine.alpha com.microsoft.playready com.microsoft.playready.recommendation com.apple.fps.1_0 com.apple.fps com.adobe.primetime".split(" "), b = [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }, { contentType: 'video/webm; codecs="vp8"' }], c = { initDataTypes: ["cenc"], videoCapabilities: b }, d = { videoCapabilities: b, persistentState: "required", sessionTypes: ["persistent-license"] }, e = [d, c], f = /* @__PURE__ */ new Map(), g = function(l) {
            var m, n, p;
            return G(function(t) {
              switch (t.g) {
                case 1:
                  D(t, 2);
                  if ("org.w3.clearkey" === l && yc())
                    throw Error("Unsupported keySystem");
                  return u(t, navigator.requestMediaKeySystemAccess(l, e), 4);
                case 4:
                  return m = t.h, p = (n = m.getConfiguration().sessionTypes) ? n.includes("persistent-license") : false, tc("Tizen 3") && (p = false), f.set(l, { persistentState: p }), u(t, m.createMediaKeys(), 5);
                case 5:
                  ta(t, 0);
                  break;
                case 2:
                  ua(t), f.set(l, null), A(t);
              }
            });
          }, h = a.map(function(l) {
            return g(l);
          }), u(k2, Promise.all(h), 2)) : k2.return(uf(f));
        });
      }
      function Ng(a) {
        var b;
        return G(function(c) {
          if (1 == c.g)
            return b = new Promise(function(d, e) {
              new P(e).N(Og);
            }), D(c, 2), u(c, Promise.race([Promise.all([a.close(), a.closed]), b]), 4);
          if (2 != c.g)
            return ta(c, 0);
          ua(c);
          A(c);
        });
      }
      function jg(a) {
        var b;
        return G(function(c) {
          b = Array.from(a.i.entries());
          a.i.clear();
          return u(c, Promise.all(b.map(function(d) {
            d = r(d);
            var e = d.next().value, f = d.next().value;
            return G(function(g) {
              if (1 == g.g)
                return D(g, 2), a.da || a.B.includes(e.sessionId) || "persistent-license" !== f.type ? u(g, Ng(e), 5) : u(g, e.remove(), 5);
              if (2 != g.g)
                return ta(g, 0);
              ua(g);
              A(g);
            });
          })), 0);
        });
      }
      function Pg(a, b) {
        if (!a.length)
          return b;
        if (!b.length)
          return a;
        var c = [];
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next()) {
          d = d.value;
          for (var e = {}, f = r(b), g = f.next(); !g.done; e = { Da: e.Da }, g = f.next())
            if (g = g.value, d.keySystem == g.keySystem) {
              e.Da = [];
              e.Da = e.Da.concat(d.initData || []);
              e.Da = e.Da.concat(g.initData || []);
              e.Da = e.Da.filter(function(h) {
                return function(k2, l) {
                  return void 0 === k2.keyId || l === h.Da.findIndex(function(m) {
                    return m.keyId === k2.keyId;
                  });
                };
              }(e));
              f = d.keyIds && g.keyIds ? new Set([].concat(ha(d.keyIds), ha(g.keyIds))) : d.keyIds || g.keyIds;
              c.push({
                keySystem: d.keySystem,
                licenseServerUri: d.licenseServerUri || g.licenseServerUri,
                distinctiveIdentifierRequired: d.distinctiveIdentifierRequired || g.distinctiveIdentifierRequired,
                persistentStateRequired: d.persistentStateRequired || g.persistentStateRequired,
                videoRobustness: d.videoRobustness || g.videoRobustness,
                audioRobustness: d.audioRobustness || g.audioRobustness,
                serverCertificate: d.serverCertificate || g.serverCertificate,
                serverCertificateUri: d.serverCertificateUri || g.serverCertificateUri,
                initData: e.Da,
                keyIds: f
              });
              break;
            }
        }
        return c;
      }
      function rg(a) {
        return (a.video ? a.video.drmInfos : []).concat(a.audio ? a.audio.drmInfos : []);
      }
      function hg(a) {
        a.i.forEach(function(b, c) {
          var d = b.Vd, e = c.expiration;
          isNaN(e) && (e = Infinity);
          e != d && (a.D.onExpirationUpdated(c.sessionId, e), b.Vd = e);
        });
      }
      function Bg(a) {
        a = a.i.values();
        return sf(a, function(b) {
          return b.loaded;
        });
      }
      function qg(a, b) {
        var c = [];
        b.forEach(function(d, e) {
          c.push({ keySystem: e, licenseServerUri: d, distinctiveIdentifierRequired: false, persistentStateRequired: false, audioRobustness: "", videoRobustness: "", serverCertificate: null, serverCertificateUri: "", initData: [], keyIds: /* @__PURE__ */ new Set() });
        });
        a = r(a);
        for (b = a.next(); !b.done; b = a.next())
          b = b.value, b.video && (b.video.drmInfos = c), b.audio && (b.audio.drmInfos = c);
      }
      function Hg(a, b, c, d, e, f) {
        var g = {};
        a = r(a);
        for (var h = a.next(); !h.done; g = { oa: g.oa }, h = a.next()) {
          g.oa = h.value;
          b.includes(g.oa.licenseServerUri) || b.push(g.oa.licenseServerUri);
          d.includes(g.oa.serverCertificateUri) || d.push(g.oa.serverCertificateUri);
          g.oa.serverCertificate && (c.some(function(m) {
            return function(n) {
              return Gb(n, m.oa.serverCertificate);
            };
          }(g)) || c.push(g.oa.serverCertificate));
          if (g.oa.initData) {
            h = {};
            for (var k2 = r(g.oa.initData), l = k2.next(); !l.done; h = { Dc: h.Dc }, l = k2.next())
              h.Dc = l.value, e.some(function(m) {
                return function(n) {
                  var p = m.Dc;
                  return n.keyId && n.keyId == p.keyId ? true : n.initDataType == p.initDataType && Gb(n.initData, p.initData);
                };
              }(h)) || e.push(h.Dc);
          }
          if (g.oa.keyIds)
            for (h = r(g.oa.keyIds), k2 = h.next(); !k2.done; k2 = h.next())
              f.add(k2.value);
        }
      }
      function sg(a, b, c, d) {
        var e = a.keySystem;
        if (e && ("org.w3.clearkey" != e || !a.licenseServerUri)) {
          b.size && (b = b.get(e) || "", a.licenseServerUri = b);
          a.keyIds || (a.keyIds = /* @__PURE__ */ new Set());
          if (c = c.get(e))
            a.distinctiveIdentifierRequired || (a.distinctiveIdentifierRequired = c.distinctiveIdentifierRequired), a.persistentStateRequired || (a.persistentStateRequired = c.persistentStateRequired), a.videoRobustness || (a.videoRobustness = c.videoRobustness), a.audioRobustness || (a.audioRobustness = c.audioRobustness), a.serverCertificate || (a.serverCertificate = c.serverCertificate), c.sessionType && (a.sessionType = c.sessionType), a.serverCertificateUri || (a.serverCertificateUri = c.serverCertificateUri);
          d[e] && (a.keySystem = d[e]);
          window2.cast && window2.cast.__platform__ && "com.microsoft.playready" == e && (a.keySystem = "com.chromecast.playready");
        }
      }
      var Og = 1, Kg = 5, Lg = 0.5, Qg = new mc(function() {
        return Ib(new Uint8Array([0]));
      });
      function Rg() {
      }
      function Sg(a, b, c, d) {
        var e, f, g, h;
        return G(function(k2) {
          if (1 == k2.g) {
            if (d && (e = Tg[d.toLowerCase()]))
              return k2.return(e);
            if (f = Ug(a)) {
              if (g = Vg[f])
                return k2.return(g);
            }
            return d ? k2.A(2) : u(k2, Wg(a, b, c), 3);
          }
          if (2 != k2.g && (d = k2.h) && (h = Tg[d]))
            return k2.return(h);
          throw new O(2, 4, 4e3, a);
        });
      }
      function Wg(a, b, c) {
        var d, e, f;
        return G(function(g) {
          if (1 == g.g)
            return d = cf([a], c), d.method = "HEAD", u(g, b.request(0, d).promise, 2);
          e = g.h;
          f = e.headers["content-type"];
          return g.return(f ? f.toLowerCase().split(";").shift() : "");
        });
      }
      function Ug(a) {
        a = new Nb(a).qa.split("/").pop().split(".");
        return 1 == a.length ? "" : a.pop().toLowerCase();
      }
      K("shaka.media.ManifestParser", Rg);
      Rg.unregisterParserByMime = function(a) {
        delete Tg[a];
      };
      Rg.registerParserByMime = function(a, b) {
        Tg[a] = b;
      };
      Rg.registerParserByExtension = function(a, b) {
        Vg[a] = b;
      };
      var Tg = {}, Vg = {};
      function Xg(a) {
        function b() {
          d = true;
        }
        function c(l) {
          f.push(l);
          Ef(l);
        }
        a = M(a);
        var d = false, e, f = [], g = [];
        new zf().box("moov", c).box("trak", c).box("mdia", c).box("minf", c).box("stbl", c).P("stsd", function(l) {
          e = l;
          f.push(l);
          Gf(l);
        }).P("encv", b).P("enca", b).P("hev1", function(l) {
          g.push({ box: l, lb: 1701733238 });
        }).P("hvc1", function(l) {
          g.push({ box: l, lb: 1701733238 });
        }).P("avc1", function(l) {
          g.push({ box: l, lb: 1701733238 });
        }).P("avc3", function(l) {
          g.push({ box: l, lb: 1701733238 });
        }).P("ac-3", function(l) {
          g.push({ box: l, lb: 1701733217 });
        }).P(
          "ec-3",
          function(l) {
            g.push({ box: l, lb: 1701733217 });
          }
        ).P("mp4a", function(l) {
          g.push({ box: l, lb: 1701733217 });
        }).parse(a);
        if (d)
          return a;
        if (0 == g.length || !e)
          throw bb(Nc(a)), new O(2, 3, 3019);
        g.reverse();
        for (var h = r(g), k2 = h.next(); !k2.done; k2 = h.next())
          k2 = k2.value, a = Yg(a, e, k2.box, f, k2.lb);
        return a;
      }
      function Yg(a, b, c, d, e) {
        var f = Zg.value(), g = a.subarray(c.start, c.start + c.size), h = Lb(g), k2 = new Uint8Array(c.size + f.byteLength);
        k2.set(g, 0);
        g = Lb(k2);
        g.setUint32(4, e);
        k2.set(f, c.size);
        e = h.getUint32(4);
        g.setUint32(c.size + 16, e);
        $g(k2, 0, k2.byteLength);
        e = new Uint8Array(a.byteLength + k2.byteLength);
        c = sc() ? c.start : c.start + c.size;
        f = a.subarray(c);
        e.set(a.subarray(0, c));
        e.set(k2, c);
        e.set(f, c + k2.byteLength);
        a = r(d);
        for (d = a.next(); !d.done; d = a.next())
          d = d.value, $g(e, d.start, d.size + k2.byteLength);
        k2 = Lb(e, b.start);
        b = Ff(b);
        a = k2.getUint32(b);
        k2.setUint32(b, a + 1);
        return e;
      }
      function $g(a, b, c) {
        a = Lb(a, b);
        b = a.getUint32(0);
        0 != b && (1 == b ? (a.setUint32(8, c >> 32), a.setUint32(12, c & 4294967295)) : a.setUint32(0, c));
      }
      var Zg = new mc(function() {
        return new Uint8Array([0, 0, 0, 80, 115, 105, 110, 102, 0, 0, 0, 12, 102, 114, 109, 97, 0, 0, 0, 0, 0, 0, 0, 20, 115, 99, 104, 109, 0, 0, 0, 0, 99, 101, 110, 99, 0, 1, 0, 0, 0, 0, 0, 40, 115, 99, 104, 105, 0, 0, 0, 32, 116, 101, 110, 99, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      });
      function ah(a, b, c, d, e) {
        if (d >= e)
          return null;
        for (var f = -1, g = -1, h = 0; h < c.length; h++)
          if (c[h].some(function(B) {
            return null != B && "" != B.g.trim();
          })) {
            f = h;
            break;
          }
        for (h = c.length - 1; 0 <= h; h--)
          if (c[h].some(function(B) {
            return null != B && "" != B.g.trim();
          })) {
            g = h;
            break;
          }
        if (-1 === f || -1 === g)
          return null;
        for (var k2 = h = false, l = "white", m = "black", n = bh(d, e, h, k2, l, m); f <= g; f++) {
          for (var p = c[f], t = -1, v = -1, y = 0; y < p.length; y++)
            if (null != p[y] && "" !== p[y].g.trim()) {
              t = y;
              break;
            }
          for (y = p.length - 1; 0 <= y; y--)
            if (null != p[y] && "" !== p[y].g.trim()) {
              v = y;
              break;
            }
          if (-1 === t || -1 === v)
            p = ch(d, e), a.nestedCues.push(p);
          else {
            for (; t <= v; t++)
              if (y = p[t]) {
                var w = y.l, x = y.i, C = y.j, z = y.h;
                if (w != h || x != k2 || C != l || z != m)
                  n.payload && a.nestedCues.push(n), n = bh(d, e, w, x, C, z), h = w, k2 = x, l = C, m = z;
                n.payload += y.g;
              } else
                n.payload += " ";
            n.payload && a.nestedCues.push(n);
            f !== g && (n = ch(d, e), a.nestedCues.push(n));
            n = bh(d, e, h, k2, l, m);
          }
        }
        return a.nestedCues.length ? { cue: a, stream: b } : null;
      }
      function bh(a, b, c, d, e, f) {
        a = new kb(a, b, "");
        c && a.textDecoration.push("underline");
        d && (a.fontStyle = "italic");
        a.color = e;
        a.backgroundColor = f;
        return a;
      }
      function ch(a, b) {
        a = new kb(a, b, "");
        a.lineBreak = true;
        return a;
      }
      function dh(a, b, c, d, e) {
        this.g = a;
        this.l = b;
        this.i = c;
        this.h = d;
        this.j = e;
      }
      function eh(a, b) {
        this.i = [];
        this.g = 1;
        this.h = 0;
        this.u = a;
        this.s = b;
        this.j = this.m = false;
        this.l = "white";
        this.o = "black";
        fh(this);
      }
      function gh(a, b, c) {
        return ah(new kb(b, c, ""), "CC" + (a.u << 1 | a.s + 1), a.i, b, c);
      }
      function fh(a) {
        hh(a, 0, 15);
        a.g = 1;
      }
      function ih(a, b, c) {
        if (!(32 > c || 127 < c)) {
          var d = "";
          switch (b) {
            case jh:
              d = kh.has(c) ? kh.get(c) : String.fromCharCode(c);
              break;
            case lh:
              d = mh.get(c);
              break;
            case nh:
              a.i[a.g].pop();
              d = oh.get(c);
              break;
            case ph:
              a.i[a.g].pop(), d = qh.get(c);
          }
          d && a.i[a.g].push(new dh(d, a.m, a.j, a.o, a.l));
        }
      }
      function rh(a, b, c, d) {
        if (!(0 > c || 0 > b))
          if (b >= c)
            for (--d; 0 <= d; d--)
              a.i[b + d] = a.i[c + d].map(function(f) {
                return f;
              });
          else
            for (var e = 0; e < d; e++)
              a.i[b + e] = a.i[c + e].map(function(f) {
                return f;
              });
      }
      function hh(a, b, c) {
        for (var d = 0; d <= c; d++)
          a.i[b + d] = [];
      }
      var jh = 0, lh = 1, nh = 2, ph = 3, kh = /* @__PURE__ */ new Map([[39, "’"], [42, "á"], [92, "é"], [92, "é"], [94, "í"], [95, "ó"], [96, "ú"], [123, "ç"], [124, "÷"], [125, "Ñ"], [126, "ñ"], [127, "█"]]), mh = /* @__PURE__ */ new Map([[48, "®"], [49, "°"], [50, "½"], [51, "¿"], [52, "™"], [53, "¢"], [54, "£"], [55, "♪"], [56, "à"], [57, "⠀"], [58, "è"], [59, "â"], [60, "ê"], [61, "î"], [62, "ô"], [63, "û"]]), oh = /* @__PURE__ */ new Map([
        [32, "Á"],
        [33, "É"],
        [34, "Ó"],
        [35, "Ú"],
        [36, "Ü"],
        [37, "ü"],
        [38, "‘"],
        [39, "¡"],
        [40, "*"],
        [41, "'"],
        [42, "─"],
        [43, "©"],
        [44, "℠"],
        [45, "·"],
        [46, "“"],
        [47, "”"],
        [48, "À"],
        [49, "Â"],
        [50, "Ç"],
        [51, "È"],
        [52, "Ê"],
        [53, "Ë"],
        [54, "ë"],
        [55, "Î"],
        [56, "Ï"],
        [57, "ï"],
        [58, "Ô"],
        [59, "Ù"],
        [60, "ù"],
        [61, "Û"],
        [62, "«"],
        [63, "»"]
      ]), qh = /* @__PURE__ */ new Map([
        [32, "Ã"],
        [33, "ã"],
        [34, "Í"],
        [35, "Ì"],
        [36, "ì"],
        [37, "Ò"],
        [38, "ò"],
        [39, "Õ"],
        [40, "õ"],
        [41, "{"],
        [42, "}"],
        [43, "\\"],
        [44, "^"],
        [45, "_"],
        [46, "|"],
        [47, "~"],
        [48, "Ä"],
        [49, "ä"],
        [50, "Ö"],
        [51, "ö"],
        [52, "ß"],
        [53, "¥"],
        [54, "¤"],
        [55, "│"],
        [56, "Å"],
        [57, "å"],
        [58, "Ø"],
        [59, "ø"],
        [60, "┌"],
        [61, "┐"],
        [62, "└"],
        [63, "┘"]
      ]);
      function sh(a, b) {
        this.h = th;
        this.o = new eh(a, b);
        this.i = new eh(a, b);
        this.l = new eh(a, b);
        this.g = this.i;
        this.j = 0;
        this.m = null;
      }
      function uh(a, b, c) {
        a.g = a.i;
        var d = a.g, e = null;
        a.h !== vh && a.h !== wh && (e = gh(d, a.j, c), c = a.i, c.g = 0 < c.h ? c.h : 0, hh(c, 0, 15), c = a.l, c.g = 0 < c.h ? c.h : 0, hh(c, 0, 15), d.g = 15);
        a.h = vh;
        d.h = b;
        return e;
      }
      function xh(a) {
        a.h = yh;
        a.g = a.l;
        a.g.h = 0;
      }
      function zh(a) {
        Xa("Cea608DataChannel", "CEA-608 text mode entered, but is unsupported");
        a.g = a.o;
        a.h = wh;
      }
      var th = 0, yh = 1, vh = 3, wh = 4, Ah = "black green blue cyan red yellow magenta black".split(" "), Bh = "white green blue cyan red yellow magenta white_italics".split(" ");
      function Ch() {
        this.l = false;
        this.B = this.F = 0;
        this.D = Dh;
        this.i = [];
        this.g = this.h = this.j = 0;
        this.u = this.o = false;
        this.s = "white";
        this.m = "black";
        Eh(this);
      }
      function Eh(a) {
        a.i = [];
        for (var b = 0; 16 > b; b++)
          a.i.push(Fh());
      }
      function Fh() {
        for (var a = [], b = 0; 42 > b; b++)
          a.push(null);
        return a;
      }
      function Gh(a, b) {
        Hh(a) && (a.i[a.h][a.g] = new dh(b, a.u, a.o, a.m, a.s), a.g++);
      }
      function Hh(a) {
        var b = a.g < a.B && 0 <= a.g;
        return a.h < a.F && 0 <= a.h && b;
      }
      Ch.prototype.isVisible = function() {
        return this.l;
      };
      function Ih(a, b, c) {
        var d = new kb(a.j, b, "");
        d.textAlign = a.D === Jh ? "left" : a.D === Kh ? "right" : ob;
        if (c = ah(d, "svc" + c, a.i, a.j, b))
          a.j = b;
        return c;
      }
      var Jh = 0, Kh = 1, Dh = 2;
      function Lh() {
        this.i = [];
        this.h = null;
        this.g = 0;
      }
      function Mh(a, b) {
        3 === b.type ? (a.g = 2 * (b.value & 63) - 1, a.h = []) : a.h && (0 < a.g && (a.h.push(b), a.g--), 0 === a.g && (a.i.push(new Nh(a.h)), a.h = null, a.g = 0));
      }
      function Nh(a) {
        this.g = 0;
        this.h = a;
      }
      Nh.prototype.ha = function() {
        return this.g < this.h.length;
      };
      Nh.prototype.Z = function() {
        return this.g;
      };
      function Oh(a) {
        if (!a.ha())
          throw new O(2, 2, 3e3);
        return a.h[a.g++];
      }
      Nh.prototype.skip = function(a) {
        if (this.g + a > this.h.length)
          throw new O(2, 2, 3e3);
        this.g += a;
      };
      function Ph(a) {
        this.i = a;
        this.h = [null, null, null, null, null, null, null, null];
        this.g = null;
      }
      function Qh(a, b, c, d) {
        if (128 <= c && 135 >= c)
          d = c & 7, a.h[d] && (a.g = a.h[d]);
        else {
          if (136 === c) {
            c = Oh(b).value;
            b = null;
            c = r(Rh(a, c));
            for (var e = c.next(); !e.done; e = c.next())
              e = a.h[e.value], e.isVisible() && (b = Ih(e, d, a.i)), Eh(e);
            return b;
          }
          if (137 === c)
            for (b = Oh(b).value, b = r(Rh(a, b)), c = b.next(); !c.done; c = b.next())
              c = a.h[c.value], c.isVisible() || (c.j = d), c.l = true;
          else {
            if (138 === c) {
              c = Oh(b).value;
              b = null;
              c = r(Rh(a, c));
              for (e = c.next(); !e.done; e = c.next())
                e = a.h[e.value], e.isVisible() && (b = Ih(e, d, a.i)), e.l = false;
              return b;
            }
            if (139 === c) {
              c = Oh(b).value;
              b = null;
              c = r(Rh(a, c));
              for (e = c.next(); !e.done; e = c.next())
                e = a.h[e.value], e.isVisible() ? b = Ih(e, d, a.i) : e.j = d, e.l = !e.l;
              return b;
            }
            if (140 === c)
              return b = Oh(b).value, Sh(a, b, d);
            if (143 === c)
              return d = Sh(a, 255, d), Th(a), d;
            if (144 === c)
              b.skip(1), d = Oh(b).value, a.g && (a.g.o = 0 < (d & 128), a.g.u = 0 < (d & 64));
            else if (145 === c)
              d = Oh(b).value, c = Oh(b).value, b.skip(1), a.g && (b = Uh((c & 48) >> 4, (c & 12) >> 2, c & 3), a.g.s = Uh((d & 48) >> 4, (d & 12) >> 2, d & 3), a.g.m = b);
            else if (146 === c)
              d = Oh(b).value, b = Oh(b).value, a.g && (a = a.g, a.h = d & 15, a.g = b & 63);
            else if (151 === c)
              b.skip(1), b.skip(1), d = Oh(b).value, b.skip(1), a.g && (a.g.D = d & 3);
            else if (152 <= c && 159 >= c) {
              c = (c & 15) - 8;
              e = null !== a.h[c];
              if (!e) {
                var f = new Ch();
                f.j = d;
                a.h[c] = f;
              }
              d = Oh(b).value;
              Oh(b);
              Oh(b);
              f = Oh(b).value;
              var g = Oh(b).value;
              b = Oh(b).value;
              e && 0 === (b & 7) || (b = a.h[c], b.h = 0, b.g = 0, b.u = false, b.o = false, b.s = "white", b.m = "black");
              b = a.h[c];
              b.l = 0 < (d & 32);
              b.F = (f & 15) + 1;
              b.B = (g & 63) + 1;
              a.g = a.h[c];
            }
          }
        }
        return null;
      }
      function Rh(a, b) {
        for (var c = [], d = 0; 8 > d; d++)
          1 === (b & 1) && a.h[d] && c.push(d), b >>= 1;
        return c;
      }
      function Sh(a, b, c) {
        var d = null;
        b = r(Rh(a, b));
        for (var e = b.next(); !e.done; e = b.next()) {
          e = e.value;
          var f = a.h[e];
          f.isVisible() && (d = Ih(f, c, a.i));
          a.h[e] = null;
        }
        return d;
      }
      function Th(a) {
        a.g = null;
        a.h = [null, null, null, null, null, null, null, null];
      }
      function Uh(a, b, c) {
        var d = { 0: 0, 1: 0, 2: 1, 3: 1 };
        a = d[a];
        b = d[b];
        c = d[c];
        return Vh[a << 2 | b << 1 | c];
      }
      var Wh = /* @__PURE__ */ new Map([[32, " "], [33, " "], [37, "…"], [42, "Š"], [44, "Œ"], [48, "█"], [49, "‘"], [50, "’"], [51, "“"], [52, "”"], [53, "•"], [57, "™"], [58, "š"], [60, "œ"], [61, "℠"], [63, "Ÿ"], [118, "⅛"], [119, "⅜"], [120, "⅝"], [121, "⅞"], [122, "│"], [123, "┐"], [124, "└"], [125, "─"], [126, "┘"], [127, "┌"]]), Vh = "black blue green cyan red magenta yellow white".split(" ");
      function Xh() {
        this.h = [];
        this.g = [];
        this.i = new Lh();
        this.l = 0;
        this.s = /* @__PURE__ */ new Map([["CC1", new sh(0, 0)], ["CC2", new sh(0, 1)], ["CC3", new sh(1, 0)], ["CC4", new sh(1, 1)]]);
        this.o = this.m = 0;
        this.j = /* @__PURE__ */ new Map();
        Yh(this);
      }
      function Yh(a) {
        a.m = 0;
        a.o = 0;
        a = r(a.s.values());
        for (var b = a.next(); !b.done; b = a.next())
          b = b.value, b.h = 2, b.g = b.i, b.m = null, fh(b.i), fh(b.l), fh(b.o);
      }
      function Zh(a) {
        function b(f, g) {
          return f.pts - g.pts || f.order - g.order;
        }
        var c = [];
        a.h.sort(b);
        a.g.sort(b);
        for (var d = r(a.h), e = d.next(); !e.done; e = d.next())
          (e = $h(a, e.value)) && c.push(e);
        d = r(a.g);
        for (e = d.next(); !e.done; e = d.next())
          Mh(a.i, e.value);
        d = r(a.i.i);
        for (e = d.next(); !e.done; e = d.next())
          e = ai(a, e.value), c.push.apply(c, ha(e));
        a.i.i = [];
        a.h = [];
        a.g = [];
        return c;
      }
      function $h(a, b) {
        var c = b.type;
        if (16 === (b.xa & 112)) {
          var d = b.xa >> 3 & 1;
          0 === c ? a.m = d : a.o = d;
        }
        c = a.s.get("CC" + (c << 1 | (c ? a.o : a.m) + 1));
        if (255 === b.xa && 255 === b.La || !b.xa && !b.La || !bi(b.xa) || !bi(b.La))
          return 45 <= ++a.l && Yh(a), null;
        a.l = 0;
        b.xa &= 127;
        b.La &= 127;
        if (!b.xa && !b.La)
          return null;
        a = null;
        if (16 === (b.xa & 112))
          a: {
            d = b.xa;
            a = b.La;
            if (c.m === (d << 8 | a))
              c.m = null;
            else if (c.m = d << 8 | a, 16 === (d & 240) && 64 === (a & 192)) {
              b = [11, 11, 1, 2, 3, 4, 12, 13, 14, 15, 5, 6, 7, 8, 9, 10][(d & 7) << 1 | a >> 5 & 1];
              var e = (a & 30) >> 1;
              d = "white";
              var f = false;
              7 > e ? d = Bh[e] : 7 === e && (f = true);
              a = 1 === (a & 1);
              if (c.h !== wh) {
                e = c.g;
                if (c.h === vh && b !== e.g) {
                  var g = 1 + b - e.h;
                  rh(e, g, 1 + e.g - e.h, e.h);
                  hh(e, 0, g - 1);
                  hh(e, b + 1, 15 - b);
                }
                e.g = b;
                c.g.m = a;
                c.g.j = f;
                c.g.l = d;
                c.g.o = "black";
              }
            } else if (17 === (d & 247) && 32 === (a & 240))
              c.g.m = false, c.g.j = false, c.g.l = "white", ih(c.g, jh, 32), d = false, b = Bh[(a & 14) >> 1], "white_italics" === b && (b = "white", d = true), c.g.m = 1 === (a & 1), c.g.j = d, c.g.l = b;
            else if (16 === (d & 247) && 32 === (a & 240) || 23 === (d & 247) && 45 === (a & 255))
              b = "black", 0 === (d & 7) && (b = Ah[(a & 14) >> 1]), c.g.o = b;
            else if (17 === (d & 247) && 48 === (a & 240))
              ih(c.g, lh, a);
            else if (18 === (d & 246) && 32 === (a & 224))
              ih(c.g, d & 1 ? ph : nh, a);
            else if (20 === (d & 246) && 32 === (a & 240)) {
              a = b.pts;
              d = null;
              switch (b.La) {
                case 32:
                  xh(c);
                  break;
                case 33:
                  c = c.g;
                  c.i[c.g].pop();
                  break;
                case 37:
                  d = uh(c, 2, a);
                  break;
                case 38:
                  d = uh(c, 3, a);
                  break;
                case 39:
                  d = uh(c, 4, a);
                  break;
                case 40:
                  ih(c.g, jh, 32);
                  break;
                case 41:
                  c.h = 2;
                  c.g = c.i;
                  c.g.h = 0;
                  c.j = a;
                  break;
                case 42:
                  fh(c.o);
                  zh(c);
                  break;
                case 43:
                  zh(c);
                  break;
                case 44:
                  b = c.i;
                  d = null;
                  c.h !== wh && (d = gh(b, c.j, a));
                  hh(b, 0, 15);
                  break;
                case 45:
                  b = c.g;
                  c.h !== vh ? d = null : (d = gh(b, c.j, a), f = b.g - b.h + 1, rh(b, f - 1, f, b.h), hh(
                    b,
                    0,
                    f - 1
                  ), hh(b, b.g, 15 - b.g), c.j = a);
                  break;
                case 46:
                  hh(c.l, 0, 15);
                  break;
                case 47:
                  b = null, c.h !== wh && (b = gh(c.i, c.j, a)), d = c.l, c.l = c.i, c.i = d, xh(c), c.j = a, d = b;
              }
              a = d;
              break a;
            }
            a = null;
          }
        else
          d = b.La, ih(c.g, jh, b.xa), ih(c.g, jh, d);
        return a;
      }
      function ai(a, b) {
        var c = [];
        try {
          for (; b.ha(); ) {
            var d = Oh(b).value, e = (d & 224) >> 5, f = d & 31;
            7 === e && 0 != f && (e = Oh(b).value & 63);
            if (0 != e) {
              a.j.has(e) || a.j.set(e, new Ph(e));
              for (var g = a.j.get(e), h = b.Z(); b.Z() - h < f; ) {
                e = b;
                var k2 = Oh(e), l = k2.value, m = k2.pts;
                if (16 === l) {
                  var n = Oh(e);
                  l = l << 16 | n.value;
                }
                if (0 <= l && 31 >= l) {
                  var p = m;
                  if (g.g) {
                    var t = g.g;
                    e = null;
                    switch (l) {
                      case 8:
                        !Hh(t) || 0 >= t.g && 0 >= t.h || (0 >= t.g ? (t.g = t.B - 1, t.h--) : t.g--, t.i[t.h][t.g] = null);
                        break;
                      case 13:
                        t.isVisible() && (e = Ih(t, p, g.i));
                        if (t.h + 1 >= t.F) {
                          p = t;
                          for (var v = 0, y = 1; 16 > y; y++, v++)
                            p.i[v] = p.i[y];
                          for (y = 0; 1 > y; y++, v++)
                            p.i[v] = Fh();
                        } else
                          t.h++;
                        t.g = 0;
                        break;
                      case 14:
                        t.isVisible() && (e = Ih(t, p, g.i));
                        t.i[t.h] = Fh();
                        t.g = 0;
                        break;
                      case 12:
                        t.isVisible() && (e = Ih(t, p, g.i)), Eh(t), p = t, p.h = 0, p.g = 0;
                    }
                    var w = e;
                  } else
                    w = null;
                } else if (128 <= l && 159 >= l)
                  w = Qh(g, e, l, m);
                else {
                  if (4096 <= l && 4127 >= l)
                    p = l & 255, 8 <= p && 15 >= p ? e.skip(1) : 16 <= p && 23 >= p ? e.skip(2) : 24 <= p && 31 >= p && e.skip(3);
                  else if (4224 <= l && 4255 >= l)
                    p = l & 255, 128 <= p && 135 >= p ? e.skip(4) : 136 <= p && 143 >= p && e.skip(5);
                  else if (32 <= l && 127 >= l)
                    e = l, g.g && (127 === e ? Gh(g.g, "♪") : Gh(
                      g.g,
                      String.fromCharCode(e)
                    ));
                  else if (160 <= l && 255 >= l)
                    g.g && Gh(g.g, String.fromCharCode(l));
                  else if (4128 <= l && 4223 >= l) {
                    if (e = l & 255, g.g)
                      if (Wh.has(e)) {
                        var x = Wh.get(e);
                        Gh(g.g, x);
                      } else
                        Gh(g.g, "_");
                  } else
                    4256 <= l && 4351 >= l && g.g && (160 != (l & 255) ? Gh(g.g, "_") : Gh(g.g, "[CC]"));
                  w = null;
                }
                (e = w) && c.push(e);
              }
            }
          }
        } catch (C) {
          if (C instanceof O && 3e3 === C.code)
            Xa("CEA708_INVALID_DATA", "Buffer read out of bounds / invalid CEA-708 Data.");
          else
            throw C;
        }
        return c;
      }
      function bi(a) {
        for (var b = 0; a; )
          b ^= a & 1, a >>= 1;
        return 1 === b;
      }
      function ci() {
      }
      ci.prototype.init = function() {
      };
      ci.prototype.parse = function() {
        return [];
      };
      function di(a, b) {
        var c = null, d = null, e = null, f = a.K();
        b & 1 && (e = a.$a());
        b & 2 && a.skip(4);
        b & 8 && (c = a.K());
        b & 16 && (d = a.K());
        return { trackId: f, Ce: c, xf: d, rh: e };
      }
      function ei(a, b) {
        return { we: 1 == b ? a.$a() : a.K() };
      }
      function fi(a, b) {
        1 == b ? (a.skip(8), a.skip(8)) : (a.skip(4), a.skip(4));
        return { timescale: a.K() };
      }
      function gi(a, b, c) {
        var d = a.K(), e = [], f = null;
        c & 1 && (f = a.K());
        c & 4 && a.skip(4);
        for (var g = 0; g < d; g++) {
          var h = { ee: null, sampleSize: null, ed: null };
          c & 256 && (h.ee = a.K());
          c & 512 && (h.sampleSize = a.K());
          c & 1024 && a.skip(4);
          c & 2048 && (h.ed = 0 == b ? a.K() : a.Pe());
          e.push(h);
        }
        return { wh: d, Re: e, wf: f };
      }
      function hi() {
        this.j = /* @__PURE__ */ new Map();
        this.i = this.h = 0;
        this.g = ii;
      }
      hi.prototype.init = function(a) {
        function b(f) {
          f = f.name;
          f in ji && (c.g = ji[f]);
        }
        var c = this, d = [], e = [];
        new zf().box("moov", Ef).box("mvex", Ef).P("trex", function(f) {
          var g = f.reader;
          g.skip(4);
          g.skip(4);
          f = g.K();
          g = g.K();
          c.h = f;
          c.i = g;
        }).box("trak", Ef).P("tkhd", function(f) {
          var g = f.reader;
          1 == f.version ? (g.skip(8), g.skip(8)) : (g.skip(4), g.skip(4));
          f = g.K();
          d.push(f);
        }).box("mdia", Ef).P("mdhd", function(f) {
          f = fi(f.reader, f.version);
          e.push(f.timescale);
        }).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("avc1", b).box("avc3", b).box(
          "hev1",
          b
        ).box("hvc1", b).box("dvh1", b).box("dvhe", b).box("encv", Hf).box("sinf", Ef).box("frma", function(f) {
          f = f.reader.K();
          f = Df(f);
          f in ji && (c.g = ji[f]);
        }).parse(a, true);
        if (!d.length || !e.length || d.length != e.length)
          throw new O(2, 2, 2010);
        this.g == ii && Wa("Unable to determine bitstream format for CEA parsing!");
        d.forEach(function(f, g) {
          c.j.set(f, e[g]);
        });
      };
      hi.prototype.parse = function(a) {
        var b = this;
        if (this.g == ii)
          return [];
        var c = [], d = this.h, e = this.i, f = [], g = null, h = null, k2 = null, l = 9e4;
        new zf().box("moof", function(m) {
          g = m.start;
          Ef(m);
        }).box("traf", Ef).P("trun", function(m) {
          m = gi(m.reader, m.version, m.flags);
          f = m.Re;
          h = m.wf;
        }).P("tfhd", function(m) {
          m = di(m.reader, m.flags);
          d = m.Ce || b.h;
          e = m.xf || b.i;
          m = m.trackId;
          b.j.has(m) && (l = b.j.get(m));
        }).P("tfdt", function(m) {
          k2 = ei(m.reader, m.version).we;
        }).box("mdat", function(m) {
          if (null === k2)
            throw new O(2, 2, 2010);
          a: {
            var n = m.reader, p = k2, t = l, v = d, y = e, w = f, x = 0, C = y;
            w.length && (C = w[0].sampleSize || y);
            for (n.skip((g || 0) + (h || 0) - m.start - 8); n.ha(); ) {
              m = n.K();
              var z = n.Ra();
              switch (b.g) {
                case ki:
                  z &= 31;
                  z = 6 == z;
                  break;
                case li:
                  z = z >> 1 & 63;
                  z = 39 == z || 40 == z;
                  break;
                default:
                  break a;
              }
              if (z) {
                z = 0;
                w.length > x && (z = w[x].ed || 0);
                z = (p + z) / t;
                for (var B = [], E, F = n.Za(m - 1), H = E = 0; H < F.length; )
                  2 == E && 3 == F[H] ? (E = 0, F = [].concat(ha(F)), F.splice(H, 1), F = new Uint8Array(F)) : 0 == F[H] ? E++ : E = 0, H++;
                E = F;
                for (H = 0; H < E.length; ) {
                  for (F = 0; 255 == E[H]; )
                    F += 255, H++;
                  F += E[H++];
                  for (var I = 0; 255 == E[H]; )
                    I += 255, H++;
                  I += E[H++];
                  4 == F && B.push(E.subarray(H, H + I));
                  H += I;
                }
                B = r(B);
                for (E = B.next(); !E.done; E = B.next())
                  c.push({ ig: E.value, pts: z });
              } else
                try {
                  n.skip(m - 1);
                } catch (J) {
                  break;
                }
              C -= m + 4;
              0 == C && (p = w.length > x ? p + (w[x].ee || v) : p + v, x++, C = w.length > x ? w[x].sampleSize || y : y);
            }
          }
        }).parse(a, false);
        return c;
      };
      var ii = 0, ki = 1, li = 2, ji = { avc1: ki, avc3: ki, hev1: li, hvc1: li, dvh1: li, dvhe: li };
      function mi(a) {
        this.h = new ci();
        a.includes("video/mp4") && (this.h = new hi());
        this.g = new Xh();
      }
      mi.prototype.init = function(a) {
        this.h.init(a);
      };
      function ni(a, b) {
        b = a.h.parse(b);
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next()) {
          var d = c.value, e = M(d.ig);
          if (0 < e.length && (c = a.g, d = d.pts, e = new wf(e, 0), 181 === e.Ra() && 49 === e.$d() && 1195456820 === e.K() && 3 === e.Ra())) {
            var f = e.Ra();
            if (0 !== (f & 64)) {
              f &= 31;
              e.skip(1);
              for (var g = 0; g < f; g++) {
                var h = e.Ra(), k2 = (h & 4) >> 2, l = e.Ra(), m = e.Ra();
                k2 && (h &= 3, 0 === h || 1 === h ? c.h.push({ pts: d, type: h, xa: l, La: m, order: c.h.length }) : (c.g.push({ pts: d, type: h, value: l, order: c.g.length }), c.g.push({ pts: d, type: 2, value: m, order: c.g.length })));
              }
            }
          }
        }
        return Zh(a.g);
      }
      function oi(a, b, c, d, e) {
        this.ya = a;
        this.Ba = b;
        this.ka = c;
        this.Od = void 0 === d ? null : d;
        this.timescale = e;
      }
      oi.prototype.lc = function() {
        return this.Ba;
      };
      oi.prototype.hc = function() {
        return this.ka;
      };
      function pi(a, b) {
        return a && b ? a.lc() == b.lc() && a.hc() == b.hc() && jb(a.ya(), b.ya()) : a == b;
      }
      K("shaka.media.InitSegmentReference", oi);
      oi.prototype.getEndByte = oi.prototype.hc;
      oi.prototype.getStartByte = oi.prototype.lc;
      function qi(a, b, c, d, e, f, g, h, k2, l, m, n, p, t, v) {
        l = void 0 === l ? [] : l;
        t = void 0 === t ? ri : t;
        this.startTime = a;
        this.j = this.endTime = b;
        this.u = c;
        this.Ba = d;
        this.ka = e;
        this.h = f;
        this.timestampOffset = g;
        this.appendWindowStart = h;
        this.appendWindowEnd = k2;
        this.i = l;
        this.tilesLayout = void 0 === m ? "" : m;
        this.s = void 0 === n ? null : n;
        this.g = void 0 === p ? null : p;
        this.status = t;
        this.l = void 0 === v ? null : v;
        this.o = null;
        this.m = 0;
      }
      q = qi.prototype;
      q.ya = function() {
        return this.u();
      };
      q.getStartTime = function() {
        return this.startTime;
      };
      q.Ef = function() {
        return this.endTime;
      };
      q.lc = function() {
        return this.Ba;
      };
      q.hc = function() {
        return this.ka;
      };
      q.Vf = function() {
        return this.tilesLayout;
      };
      q.Uf = function() {
        return this.s;
      };
      q.Eb = function() {
        return this.status;
      };
      q.bg = function() {
        this.status = si;
      };
      q.Ye = function(a) {
        this.o = a;
      };
      q.Sf = function() {
        return this.o;
      };
      q.offset = function(a) {
        this.startTime += a;
        this.endTime += a;
        this.j += a;
        for (var b = r(this.i), c = b.next(); !c.done; c = b.next())
          c = c.value, c.startTime += a, c.endTime += a, c.j += a;
      };
      q.oe = function(a) {
        null == this.g ? Va("Sync attempted without sync time!") : (a = this.g - a - this.startTime, 1e-3 <= Math.abs(a) && this.offset(a));
      };
      K("shaka.media.SegmentReference", qi);
      qi.prototype.syncAgainst = qi.prototype.oe;
      qi.prototype.offset = qi.prototype.offset;
      qi.prototype.getThumbnailSprite = qi.prototype.Sf;
      qi.prototype.setThumbnailSprite = qi.prototype.Ye;
      qi.prototype.markAsUnavailable = qi.prototype.bg;
      qi.prototype.getStatus = qi.prototype.Eb;
      qi.prototype.getTileDuration = qi.prototype.Uf;
      qi.prototype.getTilesLayout = qi.prototype.Vf;
      qi.prototype.getEndByte = qi.prototype.hc;
      qi.prototype.getStartByte = qi.prototype.lc;
      qi.prototype.getEndTime = qi.prototype.Ef;
      qi.prototype.getStartTime = qi.prototype.getStartTime;
      qi.prototype.getUris = qi.prototype.ya;
      var ri = 0, si = 1;
      qi.Status = { Hg: ri, oh: si, Vg: 2 };
      function ti(a) {
        return !a || 1 == a.length && 1e-6 > a.end(0) - a.start(0) ? null : 1 == a.length && 0 > a.start(0) ? 0 : a.length ? a.start(0) : null;
      }
      function ui(a) {
        return !a || 1 == a.length && 1e-6 > a.end(0) - a.start(0) ? null : a.length ? a.end(a.length - 1) : null;
      }
      function vi(a, b) {
        return !a || !a.length || 1 == a.length && 1e-6 > a.end(0) - a.start(0) || b > a.end(a.length - 1) ? false : b >= a.start(0);
      }
      function wi(a, b) {
        if (!a || !a.length || 1 == a.length && 1e-6 > a.end(0) - a.start(0))
          return 0;
        var c = 0;
        a = r(xi(a));
        for (var d = a.next(); !d.done; d = a.next()) {
          var e = d.value;
          d = e.start;
          e = e.end;
          e > b && (c += e - Math.max(d, b));
        }
        return c;
      }
      function yi(a, b, c) {
        if (!a || !a.length || 1 == a.length && 1e-6 > a.end(0) - a.start(0))
          return null;
        a = xi(a).findIndex(function(d, e, f) {
          return d.start > b && (0 == e || f[e - 1].end - b <= c);
        });
        return 0 <= a ? a : null;
      }
      function xi(a) {
        if (!a)
          return [];
        for (var b = [], c = 0; c < a.length; c++)
          b.push({ start: a.start(c), end: a.end(c) });
        return b;
      }
      function zi() {
      }
      function Ai(a, b) {
        var c = (a[b] & 127) << 21;
        c |= (a[b + 1] & 127) << 14;
        c |= (a[b + 2] & 127) << 7;
        return c |= a[b + 3] & 127;
      }
      function Bi(a) {
        var b = { key: a.type, description: "", data: "" };
        if ("TXXX" === a.type) {
          if (2 > a.size || 3 !== a.data[0])
            return null;
          var c = a.data.subarray(1).indexOf(0);
          if (-1 === c)
            return null;
          var d = Cc(M(a.data, 1, c));
          a = Cc(M(a.data, 2 + c)).replace(/\0*$/, "");
          b.description = d;
          b.data = a;
          return b;
        }
        if ("WXXX" === a.type) {
          if (2 > a.size || 3 !== a.data[0])
            return null;
          c = a.data.subarray(1).indexOf(0);
          if (-1 === c)
            return null;
          d = Cc(M(a.data, 1, c));
          a = Cc(M(a.data, 2 + c)).replace(/\0*$/, "");
          b.description = d;
          b.data = a;
          return b;
        }
        if ("PRIV" === a.type) {
          if (2 > a.size)
            return null;
          d = a.data.indexOf(0);
          if (-1 === d)
            return null;
          d = Cc(M(a.data, 0, d));
          a = Ib(a.data.subarray(d.length + 1));
          b.description = d;
          b.data = a;
          return b;
        }
        if ("T" === a.type[0]) {
          if (2 > a.size || 3 !== a.data[0])
            return null;
          a = Cc(a.data.subarray(1)).replace(/\0*$/, "");
          b.data = a;
          return b;
        }
        return "W" === a.type[0] ? (a = Cc(a.data).replace(/\0*$/, ""), b.data = a, b) : a.data ? (b.data = Ib(a.data), b) : null;
      }
      function Ci(a) {
        for (var b = 0, c = []; b + 10 <= a.length && 73 === a[b] && 68 === a[b + 1] && 51 === a[b + 2] && 255 > a[b + 3] && 255 > a[b + 4] && 128 > a[b + 6] && 128 > a[b + 7] && 128 > a[b + 8] && 128 > a[b + 9]; ) {
          var d = Ai(a, b + 6);
          a[b + 5] >> 6 & 1 && (b += 10);
          b += 10;
          for (d = b + d; b + 10 < d; ) {
            var e = a.subarray(b), f = Ai(e, 4);
            e = { type: String.fromCharCode(e[0], e[1], e[2], e[3]), size: f, data: e.subarray(10, 10 + f) };
            (f = Bi(e)) && c.push(f);
            b += e.size + 10;
          }
          b + 10 <= a.length && 51 === a[b] && 68 === a[b + 1] && 73 === a[b + 2] && 255 > a[b + 3] && 255 > a[b + 4] && 128 > a[b + 6] && 128 > a[b + 7] && 128 > a[b + 8] && 128 > a[b + 9] && (b += 10);
        }
        return c;
      }
      K("shaka.util.Id3Utils", zi);
      zi.getID3Frames = Ci;
      function Di() {
        this.o = null;
        this.s = false;
        this.l = this.m = null;
        this.B = [];
        this.g = this.h = null;
        this.u = [];
        this.j = null;
        this.i = [];
      }
      Di.prototype.parse = function(a) {
        if (564 > a.length)
          return this;
        for (var b = Math.max(0, Ei(a)), c = a.length - (a.length + b) % 188, d = false, e = b; e < c; e += 188)
          if (71 === a[e]) {
            var f = !!(a[e + 1] & 64), g = ((a[e + 1] & 31) << 8) + a[e + 2];
            if (1 < (a[e + 3] & 48) >> 4) {
              var h = e + 5 + a[e + 4];
              if (h === e + 188)
                continue;
            } else
              h = e + 4;
            switch (g) {
              case 0:
                f && (h += a[h] + 1);
                this.o = (a[h + 10] & 31) << 8 | a[h + 11];
                break;
              case 17:
              case 8191:
                break;
              case this.o:
                f && (h += a[h] + 1);
                f = a;
                g = { audio: -1, video: -1, Ed: -1, audioCodec: "", videoCodec: "" };
                var k2 = h + 3 + ((f[h + 1] & 15) << 8 | f[h + 2]) - 4;
                for (h += 12 + ((f[h + 10] & 15) << 8 | f[h + 11]); h < k2; ) {
                  var l = (f[h + 1] & 31) << 8 | f[h + 2];
                  switch (f[h]) {
                    case 15:
                      -1 === g.audio && (g.audio = l, g.audioCodec = "aac");
                      break;
                    case 21:
                      -1 === g.Ed && (g.Ed = l);
                      break;
                    case 27:
                      -1 === g.video && (g.video = l, g.videoCodec = "avc");
                      break;
                    case 3:
                    case 4:
                      -1 === g.audio && (g.audio = l, g.audioCodec = "mp3");
                      break;
                    case 36:
                      -1 === g.video && (g.video = l, g.videoCodec = "hvc");
                  }
                  h += ((f[h + 3] & 15) << 8 | f[h + 4]) + 5;
                }
                f = g;
                null == this.l && (this.l = f.video);
                null == this.g && (this.g = f.audio);
                null == this.j && (this.j = f.Ed);
                d && !this.s && (d = false, e = b - 188);
                this.s = true;
                break;
              case this.l:
                f = a.subarray(h, e + 188);
                null == this.m && (h = Fi(f)) && null != h.pts && (this.m = h.pts / 9e4);
                this.B.push(f);
                break;
              case this.g:
                f = a.subarray(h, e + 188);
                null == this.h && (h = Fi(f)) && null != h.pts && (this.h = h.pts / 9e4);
                this.u.push(f);
                break;
              case this.j:
                this.i.push(a.subarray(h, e + 188));
                break;
              default:
                d = true;
            }
          }
        return this;
      };
      function Fi(a) {
        if (1 !== (a[0] << 16 | a[1] << 8 | a[2]))
          return null;
        var b = { data: new Uint8Array(0), vh: 6 + (a[4] << 8 | a[5]), pts: null, dts: null }, c = a[7];
        c & 192 && (b.pts = 536870912 * (a[9] & 14) + 4194304 * (a[10] & 255) + 16384 * (a[11] & 254) + 128 * (a[12] & 255) + (a[13] & 254) / 2, b.dts = b.pts, c & 64 && (b.dts = 536870912 * (a[14] & 14) + 4194304 * (a[15] & 255) + 16384 * (a[16] & 254) + 128 * (a[17] & 255) + (a[18] & 254) / 2));
        b.data = a.subarray(9 + a[8]);
        return b;
      }
      function Gi(a) {
        for (var b = [], c = new Uint8Array(0), d = a.i.length - 1; 0 <= d; d--) {
          c = Oc(a.i[d], c);
          var e = Fi(c);
          e && (b.unshift({ cueTime: e.pts ? e.pts / 9e4 : null, data: e.data, frames: Ci(e.data), dts: e.dts, pts: e.pts }), c = new Uint8Array(0));
        }
        return b;
      }
      Di.prototype.getStartTime = function() {
        return { audio: this.h, video: this.m };
      };
      function Ei(a) {
        for (var b = Math.min(1e3, a.length - 564), c = 0; c < b; ) {
          if (71 === a[c] && 71 === a[c + 188] && 71 === a[c + 376])
            return c;
          c++;
        }
        return -1;
      }
      K("shaka.util.TsParser", Di);
      function Hi(a, b, c) {
        this.g = null;
        this.i = -1;
        this.j = a;
        this.h = b;
        this.l = c;
        "undefined" === typeof libDPIModule && Wa("Could not Find LCEVC Library dependencies on this page");
        "undefined" === typeof LcevcDil ? Wa("Could not Find LCEVC Library on this page") : LcevcDil.SupportObject.SupportStatus || Wa(LcevcDil.SupportObject.SupportError);
        "undefined" !== typeof LcevcDil && "undefined" !== typeof libDPIModule && this.h instanceof HTMLCanvasElement && LcevcDil.SupportObject.SupportStatus && !this.g && LcevcDil.SupportObject.webGLSupport(this.h) && (this.h.classList.remove("shaka-hidden"), this.g = new LcevcDil.LcevcDil(this.j, this.h, this.l));
      }
      Hi.prototype.release = function() {
        this.g && (this.g.close(), this.g = null);
      };
      function Ii(a, b) {
        var c = Ji;
        switch (b.mimeType) {
          case "video/webm":
            c = Ki;
            break;
          case "video/mp4":
            c = Li;
        }
        a.g && (a.i = b.id, a.g.setLevelSwitching(b.id, true), a.g.setContainerFormat(c));
      }
      K("shaka.lcevc.Dil", Hi);
      Hi.prototype.release = Hi.prototype.release;
      var Ji = 0, Ki = 1, Li = 2;
      function Mi(a, b, c, d) {
        var e = this;
        this.j = a;
        this.F = null;
        this.m = b;
        this.h = {};
        this.L = {};
        this.O = {};
        this.g = null;
        this.H = false;
        this.V = c || function() {
        };
        this.D = d || null;
        this.i = {};
        this.u = new mf();
        this.o = {};
        this.s = null;
        this.J = new lc2();
        this.l = Ni(this, this.J);
        this.G = new kf(function() {
          return Oi(e);
        });
        this.M = "";
        this.B = false;
        this.W = new lc2();
      }
      function Ni(a, b) {
        var c = new MediaSource();
        a.u.ma(c, "sourceopen", function() {
          URL.revokeObjectURL(a.M);
          b.resolve();
        });
        a.M = Pi(c);
        a.j.src = a.M;
        return c;
      }
      q = Mi.prototype;
      q.destroy = function() {
        return this.G.destroy();
      };
      function Oi(a) {
        var b, c, d, e, f, g, h, k2;
        return G(function(l) {
          if (1 == l.g) {
            b = [];
            for (c in a.i)
              for (d = a.i[c], e = d[0], a.i[c] = d.slice(0, 1), e && b.push(e.p.catch(cc)), f = r(d.slice(1)), g = f.next(); !g.done; g = f.next())
                h = g.value, h.p.reject(new O(2, 7, 7003, void 0));
            a.g && b.push(a.g.destroy());
            a.m && b.push(a.m.destroy());
            for (k2 in a.o)
              b.push(a.o[k2].destroy());
            return u(l, Promise.all(b), 2);
          }
          a.u && (a.u.release(), a.u = null);
          a.j && (a.j.removeAttribute("src"), a.j.load(), a.j = null);
          a.F = null;
          a.l = null;
          a.g = null;
          a.m = null;
          a.h = {};
          a.o = {};
          a.s = null;
          a.i = {};
          a.D = null;
          A(l);
        });
      }
      q.init = function(a, b, c) {
        c = void 0 === c ? false : c;
        var d = this, e, f, g, h, k2, l, m, n;
        return G(function(p) {
          if (1 == p.g)
            return e = kc, u(p, d.J, 2);
          d.B = c;
          f = {};
          g = r(a.keys());
          for (h = g.next(); !h.done; f = { na: f.na }, h = g.next())
            f.na = h.value, k2 = a.get(f.na), l = Zc(k2.mimeType, k2.codecs), f.na == e.X ? Qi(d, l, c) : (!b && eb(l) || !Tc(l, f.na) || (d.o[f.na] = new Sc(l), l = Wc(f.na, l)), m = l + d.F.sourceBufferExtraFeatures, n = d.l.addSourceBuffer(m), d.u.C(n, "error", function(t) {
              return function() {
                d.i[t.na][0].p.reject(new O(2, 3, 3014, d.j.error ? d.j.error.code : 0));
              };
            }(f)), d.u.C(n, "updateend", function(t) {
              return function() {
                return Ri(d, t.na);
              };
            }(f)), d.h[f.na] = n, d.L[f.na] = l, d.i[f.na] = [], d.O[f.na] = !!k2.drmInfos.length);
          A(p);
        });
      };
      q.configure = function(a) {
        this.F = a;
      };
      function Qi(a, b, c) {
        a.g || (a.g = new dd(a.m));
        var d = a.g;
        a = a.H;
        "application/cea-608" != b && "application/cea-708" != b && (d.j = (0, fd[b])(), d.j.setSequenceMode ? d.j.setSequenceMode(c) : Wa('Text parsers should have a "setSequenceMode" method!'), d.u = a);
      }
      function Si(a) {
        return a.l ? "ended" == a.l.readyState : true;
      }
      function Ti(a, b) {
        return b == jc ? a.g.g : ti(Ui(a, b));
      }
      function Vi(a, b) {
        return b == jc ? a.g.h : ui(Ui(a, b));
      }
      function Wi(a, b, c) {
        if (b == jc)
          return a = a.g, null == a.h || a.h < c ? 0 : a.h - Math.max(c, a.g);
        a = Ui(a, b);
        return wi(a, c);
      }
      q.Na = function() {
        var a = { total: xi(this.j.buffered), audio: xi(Ui(this, "audio")), video: xi(Ui(this, "video")), text: [] };
        if (this.g) {
          var b = this.g.g, c = this.g.h;
          null != b && null != c && a.text.push({ start: b, end: c });
        }
        return a;
      };
      function Ui(a, b) {
        try {
          return a.h[b].buffered;
        } catch (c) {
          return null;
        }
      }
      function Xi(a, b, c, d, e, f, g) {
        f = void 0 === f ? false : f;
        g = void 0 === g ? false : g;
        var h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U;
        return G(function(N) {
          switch (N.g) {
            case 1:
              h = kc;
              if (b != h.X) {
                N.A(2);
                break;
              }
              if (!a.B) {
                N.A(3);
                break;
              }
              return u(N, a.W, 4);
            case 4:
              k2 = N.h, a.g.s = k2;
            case 3:
              return u(N, gd(a.g, c, d ? d.startTime : null, d ? d.endTime : null), 5);
            case 5:
              return N.return();
            case 2:
              l = M(c);
              m = a.L[b];
              a.o[b] && (m = a.o[b].o);
              0 > Ei(l) ? Yi.includes(m) && (v = Ci(l), v.length && d && (y = { cueTime: d.startTime, data: l, frames: v, dts: d.startTime, pts: d.startTime }, a.V(
                [y],
                0,
                d.endTime
              ))) : (n = new Di().parse(l), p = d.startTime - (n.getStartTime()[b] || 0), t = Gi(n), t.length && a.V(t, p, d ? d.endTime : null));
              if (!a.o[b]) {
                e && b == h.va && (a.g || Qi(a, "text/vtt", a.B), a.s || (a.s = new mi(m)), d ? (w = ni(a.s, c), w.length && (x = a.h[h.va].timestampOffset, ld(a.g, w, d.startTime, d.endTime, x))) : a.s.init(c));
                N.A(6);
                break;
              }
              f && a.o[b].g.resetCaptions();
              return u(N, Xc(a.o[b], c), 7);
            case 7:
              C = N.h, a.g || Qi(a, "text/vtt", a.B), C.captions && C.captions.length && (z = a.h[h.va].timestampOffset, B = jd(C.captions), ld(a.g, B, d ? d.startTime : null, d ? d.endTime : null, z)), c = C.data;
            case 6:
              c = Zi(a, c, d ? d.startTime : null, b);
              E = a.h[b];
              F = $i;
              if (!a.B || E.mode == F || !d) {
                N.A(8);
                break;
              }
              H = a.l.duration;
              I = b == h.va || !(h.va in a.h);
              if (!I) {
                N.A(9);
                break;
              }
              J = [E.appendWindowStart, E.appendWindowEnd];
              E.appendWindowStart = 0;
              E.appendWindowEnd = Infinity;
              L = E.timestampOffset;
              E.timestampOffset = 0;
              return u(N, aj(a, b, function() {
                return bj(a, b, c);
              }), 10);
            case 10:
              return u(N, aj(a, b, function() {
                return cj(a, b);
              }), 11);
            case 11:
              return E.timestampOffset = L, E.appendWindowStart = J[0], E.appendWindowEnd = J[1], R = ti(Ui(a, b)), Q = (d.startTime || 0) - (R || 0), a.W.resolve(Q), u(N, aj(a, b, function() {
                return dj(a, b, 0, H);
              }), 12);
            case 12:
              if (b != h.va) {
                N.A(9);
                break;
              }
              return u(N, aj(a, b, function() {
                a.j.currentTime -= 1e-3;
                Ri(a, b);
              }), 9);
            case 9:
              return E.mode = F, u(N, a.Aa(H), 8);
            case 8:
              return d && a.B && b != h.X && (f || g) && (U = d.startTime, aj(a, b, function() {
                return cj(a, b);
              }), aj(a, b, function() {
                return ej(a, b, U);
              })), u(N, aj(a, b, function() {
                bj(a, b, c);
              }), 16);
            case 16:
              A(N);
          }
        });
      }
      function fj(a, b) {
        var c = Vi(a, "video") || 0;
        id(a.g, b, c);
      }
      function gj(a) {
        a.g && id(a.g, "", 0);
      }
      q.remove = function(a, b, c) {
        var d = this, e;
        return G(function(f) {
          e = kc;
          return a == e.X ? u(f, d.g.remove(b, c), 0) : u(f, aj(d, a, function() {
            return dj(d, a, b, c);
          }), 0);
        });
      };
      function hj(a, b) {
        var c;
        return G(function(d) {
          c = kc;
          return b == c.X ? a.g ? u(d, a.g.remove(0, Infinity), 0) : d.return() : u(d, aj(a, b, function() {
            return dj(a, b, 0, a.l.duration);
          }), 0);
        });
      }
      q.flush = function(a) {
        var b = this, c;
        return G(function(d) {
          c = kc;
          return a == c.X ? d.return() : u(d, aj(b, a, function() {
            b.j.currentTime -= 1e-3;
            Ri(b, a);
          }), 0);
        });
      };
      function ij(a, b, c, d, e, f) {
        var g;
        return G(function(h) {
          g = kc;
          return b == g.X ? (f || (a.g.s = c), hd(a.g, d, e), h.return()) : u(h, Promise.all([aj(a, b, function() {
            return cj(a, b);
          }), f ? Promise.resolve() : aj(a, b, function() {
            return ej(a, b, c);
          }), aj(a, b, function() {
            a.h[b].appendWindowStart = 0;
            a.h[b].appendWindowEnd = e;
            a.h[b].appendWindowStart = d;
            Ri(a, b);
          })]), 0);
        });
      }
      function jj(a, b, c) {
        var d;
        return G(function(e) {
          d = kc;
          if (b == d.X)
            return e.return();
          aj(a, b, function() {
            return cj(a, b);
          });
          return u(e, aj(a, b, function() {
            return ej(a, b, c);
          }), 0);
        });
      }
      q.endOfStream = function(a) {
        var b = this;
        return G(function(c) {
          return u(c, kj(b, function() {
            Si(b) || (a ? b.l.endOfStream(a) : b.l.endOfStream());
          }), 0);
        });
      };
      q.Aa = function(a) {
        var b = this;
        return G(function(c) {
          return u(c, kj(b, function() {
            if (a < b.l.duration)
              for (var d in b.h) {
                var e = { start: function() {
                }, p: new lc2() };
                b.i[d].unshift(e);
              }
            b.l.duration = a;
          }), 0);
        });
      };
      q.getDuration = function() {
        return this.l.duration;
      };
      function bj(a, b, c) {
        if ("video" == b && a.D) {
          var d = a.D;
          d.g && d.g.appendBuffer(c, "video", d.i);
        }
        a.h[b].appendBuffer(c);
      }
      function dj(a, b, c, d) {
        d <= c ? Ri(a, b) : a.h[b].remove(c, d);
      }
      function cj(a, b) {
        var c = a.h[b].appendWindowStart, d = a.h[b].appendWindowEnd;
        a.h[b].abort();
        a.h[b].appendWindowStart = c;
        a.h[b].appendWindowEnd = d;
        Ri(a, b);
      }
      function ej(a, b, c) {
        0 > c && (c += 1e-3);
        a.h[b].timestampOffset = c;
        Ri(a, b);
      }
      function Ri(a, b) {
        var c = a.i[b][0];
        c && (c.p.resolve(), lj(a, b));
      }
      function aj(a, b, c) {
        lf(a.G);
        c = { start: c, p: new lc2() };
        a.i[b].push(c);
        1 == a.i[b].length && mj(a, b);
        return c.p;
      }
      function kj(a, b) {
        var c, d, e, f, g, h;
        return G(function(k2) {
          switch (k2.g) {
            case 1:
              lf(a.G);
              c = [];
              d = {};
              for (e in a.h)
                d.Ub = new lc2(), f = { start: function(l) {
                  return function() {
                    return l.Ub.resolve();
                  };
                }(d), p: d.Ub }, a.i[e].push(f), c.push(d.Ub), 1 == a.i[e].length && f.start(), d = { Ub: d.Ub };
              D(k2, 2);
              return u(k2, Promise.all(c), 4);
            case 4:
              ta(k2, 3);
              break;
            case 2:
              throw g = ua(k2), g;
            case 3:
              try {
                b();
              } catch (l) {
                throw new O(2, 3, 3015, l);
              } finally {
                for (h in a.h)
                  lj(a, h);
              }
              A(k2);
          }
        });
      }
      function lj(a, b) {
        a.i[b].shift();
        mj(a, b);
      }
      function mj(a, b) {
        var c = a.i[b][0];
        if (c)
          try {
            c.start();
          } catch (d) {
            "QuotaExceededError" == d.name ? c.p.reject(new O(2, 3, 3017, b)) : c.p.reject(new O(2, 3, 3015, d)), lj(a, b);
          }
      }
      function Zi(a, b, c, d) {
        var e = a.O[d];
        null == c && e && (uc() || sc()) && "mp4" == a.L[d].split(";")[0].split("/")[1] && (b = Xg(b));
        return b;
      }
      var Pi = window2.URL.createObjectURL, $i = "sequence", Yi = ["audio/aac", "audio/ac3", "audio/ec3", "audio/mpeg"];
      function T(a, b, c) {
        this.i = a;
        this.m = b;
        this.o = this.j = Infinity;
        this.g = 1;
        this.h = this.l = null;
        this.s = 0;
        this.u = true;
        this.B = 0;
        this.D = void 0 === c ? true : c;
        this.F = 0;
        this.G = false;
      }
      q = T.prototype;
      q.getDuration = function() {
        return this.j;
      };
      q.Kf = function() {
        return this.g;
      };
      q.Xe = function(a) {
        this.i = a;
      };
      q.Aa = function(a) {
        this.j = a;
      };
      q.Pf = function() {
        return this.i;
      };
      q.Ve = function(a) {
        this.s = a;
      };
      q.yc = function(a) {
        this.u = a;
      };
      q.me = function(a) {
        this.o = a;
      };
      q.We = function(a) {
        this.m = a;
      };
      q.Df = function() {
        return this.m;
      };
      q.Ib = function(a) {
        if (0 != a.length) {
          var b = a[0].startTime, c = a[0].endTime;
          a = r(a);
          for (var d = a.next(); !d.done; d = a.next())
            d = d.value, b = Math.min(b, d.startTime), c = Math.max(c, d.endTime), this.g = Math.max(this.g, d.endTime - d.startTime);
          this.Td(b);
          this.h = Math.max(this.h, c);
          null != this.i && this.D && !this.G && (this.i = (Date.now() + this.s) / 1e3 - this.h - this.g);
        }
      };
      q.Md = function() {
        this.G = true;
      };
      q.Td = function(a) {
        this.l = null == this.l ? a : Math.min(this.l, a);
      };
      q.Sd = function(a) {
        this.g = Math.max(this.g, a);
      };
      q.offset = function(a) {
        null != this.l && (this.l += a);
        null != this.h && (this.h += a);
      };
      q.U = function() {
        return Infinity == this.j && !this.u;
      };
      q.jb = function() {
        return Infinity != this.j && !this.u;
      };
      q.Pa = function() {
        return Math.max(this.B, this.gb() - this.o);
      };
      q.Ze = function(a) {
        this.B = a;
      };
      q.gb = function() {
        return this.U() || this.jb() ? Math.min(Math.max(0, (Date.now() + this.s) / 1e3 - this.g - this.i) + this.F, this.j) : this.h ? Math.min(this.h, this.j) : this.j;
      };
      q.kc = function(a) {
        var b = Math.max(this.l, this.B);
        return Infinity == this.o ? Math.ceil(1e3 * b) / 1e3 : Math.max(b, Math.min(this.gb() - this.o + a, this.Oa()));
      };
      q.Db = function() {
        return this.kc(0);
      };
      q.Oa = function() {
        return Math.max(0, this.gb() - (this.U() || this.jb() ? this.m : 0));
      };
      q.df = function() {
        return null == this.i || null != this.h && this.D ? false : true;
      };
      q.Ue = function(a) {
        this.F = a;
      };
      K("shaka.media.PresentationTimeline", T);
      T.prototype.setAvailabilityTimeOffset = T.prototype.Ue;
      T.prototype.usingPresentationStartTime = T.prototype.df;
      T.prototype.getSeekRangeEnd = T.prototype.Oa;
      T.prototype.getSeekRangeStart = T.prototype.Db;
      T.prototype.getSafeSeekRangeStart = T.prototype.kc;
      T.prototype.getSegmentAvailabilityEnd = T.prototype.gb;
      T.prototype.setUserSeekStart = T.prototype.Ze;
      T.prototype.getSegmentAvailabilityStart = T.prototype.Pa;
      T.prototype.isInProgress = T.prototype.jb;
      T.prototype.isLive = T.prototype.U;
      T.prototype.offset = T.prototype.offset;
      T.prototype.notifyMaxSegmentDuration = T.prototype.Sd;
      T.prototype.notifyMinSegmentStartTime = T.prototype.Td;
      T.prototype.lockStartTime = T.prototype.Md;
      T.prototype.notifySegments = T.prototype.Ib;
      T.prototype.getDelay = T.prototype.Df;
      T.prototype.setDelay = T.prototype.We;
      T.prototype.setSegmentAvailabilityDuration = T.prototype.me;
      T.prototype.setStatic = T.prototype.yc;
      T.prototype.setClockOffset = T.prototype.Ve;
      T.prototype.getPresentationStartTime = T.prototype.Pf;
      T.prototype.setDuration = T.prototype.Aa;
      T.prototype.setPresentationStartTime = T.prototype.Xe;
      T.prototype.getMaxSegmentDuration = T.prototype.Kf;
      T.prototype.getDuration = T.prototype.getDuration;
      function nj(a, b, c) {
        this.l = c;
        this.j = a;
        this.s = oj(a);
        this.g = a.g.currentTime;
        this.m = Date.now() / 1e3;
        this.h = false;
        this.o = 0;
        this.u = b;
        this.i = function() {
        };
      }
      nj.prototype.release = function() {
        this.l = this.j = null;
        this.i = function() {
        };
      };
      function pj(a, b) {
        a.i = b;
      }
      function qj(a) {
        this.g = a;
      }
      function oj(a) {
        if (a.g.paused || 0 == a.g.playbackRate || 0 == a.g.buffered.length)
          var b = false;
        else
          a: {
            b = a.g.currentTime;
            a = r(xi(a.g.buffered));
            for (var c = a.next(); !c.done; c = a.next())
              if (c = c.value, !(b < c.start - 0.1 || b > c.end - 0.5)) {
                b = true;
                break a;
              }
            b = false;
          }
        return b;
      }
      function rj(a, b, c, d, e) {
        var f = this;
        this.o = e;
        this.g = a;
        this.s = b;
        this.D = c;
        this.i = new mf();
        this.m = false;
        this.B = a.readyState;
        this.u = 0;
        this.h = d;
        this.l = false;
        this.i.C(a, "waiting", function() {
          return sj(f);
        });
        this.j = new P(function() {
          sj(f);
        }).Ca(0.25);
      }
      rj.prototype.release = function() {
        this.i && (this.i.release(), this.i = null);
        null != this.j && (this.j.stop(), this.j = null);
        this.h && (this.h.release(), this.h = null);
        this.g = this.s = this.o = null;
      };
      rj.prototype.Wd = function() {
        this.l = true;
        sj(this);
      };
      function sj(a) {
        if (0 != a.g.readyState) {
          if (a.g.seeking) {
            if (!a.m)
              return;
          } else
            a.m = false;
          if (!a.g.paused || 0 == a.g.currentTime && (a.g.autoplay || 0 != a.g.currentTime)) {
            a.g.readyState != a.B && (a.B = a.g.readyState);
            var b;
            if (!(b = !a.h)) {
              b = a.h;
              var c = b.j, d = oj(c), e = c.g.currentTime, f = Date.now() / 1e3;
              if (b.g != e || b.s != d)
                b.m = f, b.g = e, b.s = d, b.h = false;
              e = f - b.m;
              if (d = e >= b.u && d && !b.h)
                b.i(b.g, e), b.h = true, b.g = c.g.currentTime, b.o++, b.l(new S("stalldetected"));
              b = !d;
            }
            b && (b = a.g.currentTime, c = a.g.buffered, d = yi(c, b, a.D.gapDetectionThreshold), null == d || 0 == d && !a.l || (e = c.start(d), e >= a.s.Oa() || 1e-3 > e - b || (0 != d && c.end(d - 1), a.g.currentTime = e, a.u++, a.o(new S("gapjumped")))));
          }
        }
      }
      function tj(a, b, c, d) {
        b == HTMLMediaElement.HAVE_NOTHING || a.readyState >= b ? d() : (b = uj.value().get(b), c.ma(a, b, d));
      }
      var uj = new mc(function() {
        return /* @__PURE__ */ new Map([[HTMLMediaElement.HAVE_METADATA, "loadedmetadata"], [HTMLMediaElement.HAVE_CURRENT_DATA, "loadeddata"], [HTMLMediaElement.HAVE_FUTURE_DATA, "canplay"], [HTMLMediaElement.HAVE_ENOUGH_DATA, "canplaythrough"]]);
      });
      function vj(a, b, c) {
        var d = this;
        this.g = a;
        this.l = b;
        this.j = c;
        this.m = false;
        this.h = new mf();
        this.i = new wj(a);
        tj(this.g, HTMLMediaElement.HAVE_METADATA, this.h, function() {
          xj(d, d.j);
        });
      }
      vj.prototype.release = function() {
        this.h && (this.h.release(), this.h = null);
        null != this.i && (this.i.release(), this.i = null);
        this.l = function() {
        };
        this.g = null;
      };
      function yj(a) {
        return a.m ? a.g.currentTime : a.j;
      }
      function zj(a, b) {
        0 < a.g.readyState ? Aj(a.i, b) : tj(a.g, HTMLMediaElement.HAVE_METADATA, a.h, function() {
          xj(a, a.j);
        });
      }
      function xj(a, b) {
        1e-3 > Math.abs(a.g.currentTime - b) ? Bj(a) : (a.h.ma(a.g, "seeking", function() {
          Bj(a);
        }), Aj(a.i, a.g.currentTime && 0 != a.g.currentTime ? a.g.currentTime : b));
      }
      function Bj(a) {
        a.m = true;
        a.h.C(a.g, "seeking", function() {
          return a.l();
        });
      }
      function wj(a) {
        var b = this;
        this.h = a;
        this.m = 10;
        this.l = this.j = this.i = 0;
        this.g = new P(function() {
          0 >= b.i ? b.g.stop() : b.h.currentTime != b.j ? b.g.stop() : (b.h.currentTime = b.l, b.i--);
        });
      }
      wj.prototype.release = function() {
        this.g && (this.g.stop(), this.g = null);
        this.h = null;
      };
      function Aj(a, b) {
        a.j = a.h.currentTime;
        a.l = b;
        a.i = a.m;
        a.h.currentTime = b;
        a.g.Ca(0.1);
      }
      function Cj(a) {
        this.g = a;
        this.j = false;
        this.h = null;
        this.i = new mf();
      }
      q = Cj.prototype;
      q.yd = function() {
        function a() {
          null == b.h || 0 == b.h ? b.j = true : (b.i.ma(b.g, "seeking", function() {
            b.j = true;
          }), b.g.currentTime = Math.max(0, b.g.currentTime + b.h));
        }
        var b = this;
        tj(this.g, HTMLMediaElement.HAVE_CURRENT_DATA, this.i, function() {
          a();
        });
      };
      q.release = function() {
        this.i && (this.i.release(), this.i = null);
        this.g = null;
      };
      q.zd = function(a) {
        this.h = this.j ? this.h : a;
      };
      q.Ic = function() {
        return (this.j ? this.g.currentTime : this.h) || 0;
      };
      q.ue = function() {
        return 0;
      };
      q.te = function() {
        return 0;
      };
      q.Ne = function() {
      };
      function Dj(a, b, c, d, e, f) {
        var g = this;
        this.i = a;
        this.g = b.presentationTimeline;
        this.B = b.minBufferTime || 0;
        this.l = c;
        this.u = e;
        this.s = null;
        this.o = Ej(a, c, f);
        this.j = new rj(a, b.presentationTimeline, c, this.o, f);
        this.h = new vj(a, function() {
          a: {
            var h = g.j;
            h.m = true;
            h.l = false;
            var k2 = yj(g.h);
            h = Fj(g, k2);
            if (1e-3 < Math.abs(h - k2) && (k2 = Date.now() / 1e3, !g.s || g.s < k2 - 1)) {
              g.s = k2;
              zj(g.h, h);
              h = void 0;
              break a;
            }
            g.u();
            h = void 0;
          }
          return h;
        }, Gj(this, d));
        this.m = new P(function() {
          if (0 != g.i.readyState && !g.i.paused) {
            var h = yj(g.h), k2 = g.g.Db(), l = g.g.Oa();
            3 > l - k2 && (k2 = l - 3);
            h < k2 && (h = Fj(g, h), g.i.currentTime = h);
          }
        });
      }
      q = Dj.prototype;
      q.yd = function() {
        this.m.Ca(0.25);
      };
      q.release = function() {
        this.h && (this.h.release(), this.h = null);
        this.j && (this.j.release(), this.j = null);
        this.m && (this.m.stop(), this.m = null);
        this.i = this.h = this.g = this.l = null;
        this.u = function() {
        };
      };
      q.zd = function(a) {
        zj(this.h, a);
      };
      q.Ic = function() {
        var a = yj(this.h);
        return 0 < this.i.readyState && !this.i.paused ? Hj(this, a) : a;
      };
      q.ue = function() {
        return this.o ? this.o.o : 0;
      };
      q.te = function() {
        return this.j.u;
      };
      function Gj(a, b) {
        null == b ? b = Infinity > a.g.getDuration() ? a.g.Db() : a.g.Oa() : 0 > b && (b = a.g.Oa() + b);
        return Ij(a, Hj(a, b));
      }
      q.Ne = function() {
        this.j.Wd();
      };
      function Ij(a, b) {
        var c = a.g.getDuration();
        return b >= c ? c - a.l.durationBackoff : b;
      }
      function Fj(a, b) {
        var c = Math.max(a.B, a.l.rebufferingGoal), d = a.l.safeSeekOffset, e = a.g.Db(), f = a.g.Oa(), g = a.g.getDuration();
        3 > f - e && (e = f - 3);
        var h = a.g.kc(c), k2 = a.g.kc(d);
        c = a.g.kc(c + d);
        return b >= g ? Ij(a, b) : b > f ? f : b < e ? vi(a.i.buffered, k2) ? k2 : c : b >= h || vi(a.i.buffered, b) ? b : c;
      }
      function Hj(a, b) {
        var c = a.g.Db();
        if (b < c)
          return c;
        a = a.g.Oa();
        return b > a ? a : b;
      }
      function Ej(a, b, c) {
        if (!b.stallEnabled)
          return null;
        var d = b.stallSkip;
        b = new nj(new qj(a), b.stallThreshold, c);
        pj(b, function() {
          d ? a.currentTime += d : (a.pause(), a.play());
        });
        return b;
      }
      function Jj(a) {
        this.g = a;
        this.h = null;
        this.i = 0;
        this.j = false;
      }
      q = Jj.prototype;
      q.release = function() {
        this.j || (this.g = [], this.h && this.h.stop(), this.h = null);
      };
      q.cg = function() {
        this.j = true;
      };
      function Kj(a, b) {
        a = r(a.g);
        for (var c = a.next(); !c.done; c = a.next())
          b(c.value);
      }
      q.find = function(a) {
        for (var b = this.g.length - 1, c = b; 0 <= c; --c) {
          var d = this.g[c], e = c < b ? this.g[c + 1].startTime : d.endTime;
          if (a >= d.startTime && a < e)
            return c + this.i;
        }
        return this.g.length && a < this.g[0].startTime ? this.i : null;
      };
      q.get = function(a) {
        if (0 == this.g.length)
          return null;
        a -= this.i;
        return 0 > a || a >= this.g.length ? null : this.g[a];
      };
      q.offset = function(a) {
        if (!this.j)
          for (var b = r(this.g), c = b.next(); !c.done; c = b.next())
            c.value.offset(a);
      };
      q.pc = function(a) {
        if (!this.j && a.length) {
          var b = Math.round(1e3 * a[0].startTime) / 1e3;
          this.g = this.g.filter(function(c) {
            return Math.round(1e3 * c.startTime) / 1e3 < b;
          });
          this.g.push.apply(this.g, ha(a));
        }
      };
      q.Hb = function(a, b) {
        var c = this;
        a = a.filter(function(d) {
          return d.endTime > b && (0 == c.g.length || d.endTime > c.g[0].startTime);
        });
        this.pc(a);
        this.eb(b);
      };
      q.eb = function(a) {
        if (!this.j) {
          var b = this.g.length;
          this.g = this.g.filter(function(c) {
            return c.endTime > a;
          });
          this.i += b - this.g.length;
        }
      };
      q.Wa = function(a, b, c) {
        c = void 0 === c ? false : c;
        if (!this.j) {
          for (; this.g.length; )
            if (this.g[this.g.length - 1].startTime >= b)
              this.g.pop();
            else
              break;
          for (; this.g.length; )
            if (this.g[0].endTime <= a)
              this.g.shift(), c || this.i++;
            else
              break;
          0 != this.g.length && (a = this.g[this.g.length - 1], this.g[this.g.length - 1] = new qi(a.startTime, b, a.u, a.Ba, a.ka, a.h, a.timestampOffset, a.appendWindowStart, a.appendWindowEnd, a.i, a.tilesLayout, a.s, a.g, a.status, a.l));
        }
      };
      q.fd = function(a, b) {
        var c = this;
        this.j || (this.h && this.h.stop(), this.h = new P(function() {
          var d = b();
          d ? c.g.push.apply(c.g, ha(d)) : (c.h.stop(), c.h = null);
        }), this.h.Ca(a));
      };
      Jj.prototype[Symbol.iterator] = function() {
        return this.Cb(0);
      };
      Jj.prototype.Cb = function(a) {
        var b = this.find(a);
        if (null == b)
          return null;
        b--;
        var c = this.get(b + 1), d = -1;
        if (c && 0 < c.i.length)
          for (var e = c.i.length - 1; 0 <= e; --e) {
            var f = c.i[e];
            if (a >= f.startTime && a < f.endTime) {
              b++;
              d = e - 1;
              break;
            }
          }
        return new Lj(this, b, d);
      };
      function Mj(a, b, c) {
        return new Jj([new qi(a, a + b, function() {
          return c;
        }, 0, null, null, a, a, a + b)]);
      }
      K("shaka.media.SegmentIndex", Jj);
      Jj.forSingleSegment = Mj;
      Jj.prototype.getIteratorForTime = Jj.prototype.Cb;
      Jj.prototype.updateEvery = Jj.prototype.fd;
      Jj.prototype.fit = Jj.prototype.Wa;
      Jj.prototype.evict = Jj.prototype.eb;
      Jj.prototype.mergeAndEvict = Jj.prototype.Hb;
      Jj.prototype.offset = Jj.prototype.offset;
      Jj.prototype.get = Jj.prototype.get;
      Jj.prototype.find = Jj.prototype.find;
      Jj.prototype.markImmutable = Jj.prototype.cg;
      Jj.prototype.release = Jj.prototype.release;
      function Lj(a, b, c) {
        this.i = a;
        this.g = b;
        this.h = c;
      }
      Lj.prototype.vf = function() {
        return this.g;
      };
      Lj.prototype.current = function() {
        var a = this.i.get(this.g);
        a && 0 < a.i.length && a.ya().length && this.h >= a.i.length && (this.g++, this.h = 0, a = this.i.get(this.g));
        return a && 0 < a.i.length ? a.i[this.h] : a;
      };
      Lj.prototype.next = function() {
        var a = this.i.get(this.g);
        a && 0 < a.i.length ? (this.h++, a.ya().length && this.h == a.i.length && (this.g++, this.h = 0)) : (this.g++, this.h = 0);
        a = this.current();
        return { value: a, done: !a };
      };
      K("shaka.media.SegmentIterator", Lj);
      Lj.prototype.next = Lj.prototype.next;
      Lj.prototype.current = Lj.prototype.current;
      Lj.prototype.currentPosition = Lj.prototype.vf;
      function Nj() {
        Jj.call(this, []);
        this.l = [];
      }
      oa(Nj, Jj);
      q = Nj.prototype;
      q.clone = function() {
        var a = new Nj();
        a.l = this.l.slice();
        return a;
      };
      q.release = function() {
        for (var a = r(this.l), b = a.next(); !b.done; b = a.next())
          b.value.release();
        this.l = [];
      };
      q.find = function(a) {
        for (var b = 0, c = r(this.l), d = c.next(); !d.done; d = c.next()) {
          d = d.value;
          var e = d.find(a);
          if (null != e)
            return e + b;
          b += d.i + d.g.length;
        }
        return null;
      };
      q.get = function(a) {
        for (var b = 0, c = r(this.l), d = c.next(); !d.done; d = c.next()) {
          d = d.value;
          var e = d.get(a - b);
          if (e)
            return e;
          b += d.i + d.g.length;
        }
        return null;
      };
      q.offset = function() {
      };
      q.pc = function() {
      };
      q.eb = function() {
      };
      q.Hb = function() {
      };
      q.Wa = function() {
      };
      q.fd = function() {
      };
      K("shaka.media.MetaSegmentIndex", Nj);
      Nj.prototype.updateEvery = Nj.prototype.fd;
      Nj.prototype.fit = Nj.prototype.Wa;
      Nj.prototype.mergeAndEvict = Nj.prototype.Hb;
      Nj.prototype.evict = Nj.prototype.eb;
      Nj.prototype.merge = Nj.prototype.pc;
      Nj.prototype.offset = Nj.prototype.offset;
      Nj.prototype.get = Nj.prototype.get;
      Nj.prototype.find = Nj.prototype.find;
      Nj.prototype.release = Nj.prototype.release;
      function Oj(a) {
        var b = this;
        this.g = a;
        this.j = false;
        this.i = this.g.Tc();
        this.h = new P(function() {
          b.g.Me(0.25 * b.i);
        });
      }
      Oj.prototype.release = function() {
        this.h && (this.h.stop(), this.h = null);
        this.g = null;
      };
      Oj.prototype.set = function(a) {
        this.i = a;
        Pj(this);
      };
      Oj.prototype.Pc = function() {
        return this.g.Pc();
      };
      function Pj(a) {
        a.h.stop();
        var b = a.j ? 0 : a.i;
        if (0 <= b)
          try {
            a.g.Tc() != b && a.g.le(b);
            return;
          } catch (c) {
          }
        a.h.Ca(0.25);
        0 != a.g.Tc() && a.g.le(0);
      }
      function Qj(a) {
        var b = this;
        this.h = a;
        this.g = /* @__PURE__ */ new Set();
        this.i = new P(function() {
          Rj(b, false);
        }).Ca(0.25);
      }
      Qj.prototype.release = function() {
        this.i.stop();
        for (var a = r(this.g), b = a.next(); !b.done; b = a.next())
          b.value.release();
        this.g.clear();
      };
      function Rj(a, b) {
        for (var c = r(a.g), d = c.next(); !d.done; d = c.next())
          d.value.j(a.h.currentTime, b);
      }
      function Sj(a) {
        Ue.call(this);
        this.g = /* @__PURE__ */ new Map();
        this.h = a;
      }
      oa(Sj, Ue);
      Sj.prototype.release = function() {
        this.g.clear();
        Ue.prototype.release.call(this);
      };
      function Tj(a, b) {
        var c = a.g.get(b);
        c || (c = { rc: [], Ae: null, contentType: b }, a.g.set(b, c));
        return c;
      }
      function Uj(a, b, c) {
        var d = Tj(a, b.contentType);
        Vj(a, d);
        a = { Od: b, position: c };
        d = d.rc;
        b = d.findIndex(function(e) {
          return e.position >= c;
        });
        0 <= b ? d.splice(b, d[b].position == c ? 1 : 0, a) : d.push(a);
      }
      Sj.prototype.j = function(a) {
        for (var b = r(this.g.values()), c = b.next(); !c.done; c = b.next()) {
          c = c.value;
          a: {
            var d = c.rc;
            for (var e = d.length - 1; 0 <= e; e--) {
              var f = d[e];
              if (f.position <= a) {
                d = f.Od;
                break a;
              }
            }
            d = null;
          }
          if (e = d)
            e = c.Ae, e = !(e === d || e && d && e.bandwidth == d.bandwidth && e.audioSamplingRate == d.audioSamplingRate && e.codecs == d.codecs && e.contentType == d.contentType && e.frameRate == d.frameRate && e.height == d.height && e.mimeType == d.mimeType && e.channelsCount == d.channelsCount && e.pixelAspectRatio == d.pixelAspectRatio && e.width == d.width);
          if (e)
            a: {
              e = a;
              f = d.contentType;
              if ((f = this.h()[f]) && 0 < f.length) {
                var g = f[f.length - 1].end;
                if (e >= f[0].start && e < g) {
                  e = true;
                  break a;
                }
              }
              e = false;
            }
          e && (c.Ae = d, JSON.stringify(d), c = new S("qualitychange", /* @__PURE__ */ new Map([["quality", d], ["position", a]])), this.dispatchEvent(c));
        }
      };
      function Vj(a, b) {
        if ((a = a.h()[b.contentType]) && 0 < a.length) {
          var c = a[0].start, d = a[a.length - 1].end, e = b.rc;
          b.rc = e.filter(function(f, g) {
            return f.position <= c && g + 1 < e.length && e[g + 1].position <= c || f.position >= d ? false : true;
          });
        } else
          b.rc = [];
      }
      function Wj(a) {
        Ue.call(this);
        var b = this;
        this.g = /* @__PURE__ */ new Set();
        this.i = a;
        this.h = new P(function() {
          for (var c = b.i(), d = r(b.g), e = d.next(); !e.done; e = d.next())
            e = e.value, e.endTime < c.start && (b.g.delete(e), e = new S("regionremove", /* @__PURE__ */ new Map([["region", e]])), b.dispatchEvent(e));
        }).Ca(2);
      }
      oa(Wj, Ue);
      Wj.prototype.release = function() {
        this.g.clear();
        this.h.stop();
        Ue.prototype.release.call(this);
      };
      function Xj(a) {
        Ue.call(this);
        var b = this;
        this.i = a;
        this.g = /* @__PURE__ */ new Map();
        this.l = [{ rb: null, qb: Yj, ib: function(c, d) {
          return Zj(b, "enter", c, d);
        } }, { rb: ak, qb: Yj, ib: function(c, d) {
          return Zj(b, "enter", c, d);
        } }, { rb: bk, qb: Yj, ib: function(c, d) {
          return Zj(b, "enter", c, d);
        } }, { rb: Yj, qb: ak, ib: function(c, d) {
          return Zj(b, "exit", c, d);
        } }, { rb: Yj, qb: bk, ib: function(c, d) {
          return Zj(b, "exit", c, d);
        } }, { rb: ak, qb: bk, ib: function(c, d) {
          return Zj(b, "skip", c, d);
        } }, { rb: bk, qb: ak, ib: function(c, d) {
          return Zj(b, "skip", c, d);
        } }];
        this.h = new mf();
        this.h.C(
          this.i,
          "regionremove",
          function(c) {
            b.g.delete(c.region);
          }
        );
      }
      oa(Xj, Ue);
      Xj.prototype.release = function() {
        this.i = null;
        this.g.clear();
        this.h.release();
        this.h = null;
        Ue.prototype.release.call(this);
      };
      Xj.prototype.j = function(a, b) {
        for (var c = r(this.i.g), d = c.next(); !d.done; d = c.next()) {
          d = d.value;
          var e = this.g.get(d), f = a < d.startTime ? ak : a > d.endTime ? bk : Yj;
          this.g.set(d, f);
          for (var g = r(this.l), h = g.next(); !h.done; h = g.next())
            h = h.value, h.rb == e && h.qb == f && h.ib(d, b);
        }
      };
      function Zj(a, b, c, d) {
        b = new S(b, /* @__PURE__ */ new Map([["region", c], ["seeking", d]]));
        a.dispatchEvent(b);
      }
      var ak = 1, Yj = 2, bk = 3;
      function ck(a, b, c, d, e) {
        a = cf(a, d, e);
        if (0 != b || null != c)
          a.headers.Range = c ? "bytes=" + b + "-" + c : "bytes=" + b + "-";
        return a;
      }
      function dk(a, b) {
        var c = this;
        this.g = b;
        this.m = a;
        this.i = null;
        this.u = 1;
        this.o = this.l = null;
        this.D = false;
        this.j = /* @__PURE__ */ new Map();
        this.B = false;
        this.F = null;
        this.s = false;
        this.h = new kf(function() {
          return ek(c);
        });
      }
      q = dk.prototype;
      q.destroy = function() {
        return this.h.destroy();
      };
      function ek(a) {
        var b, c, d, e;
        return G(function(f) {
          if (1 == f.g) {
            b = [];
            c = r(a.j.values());
            for (d = c.next(); !d.done; d = c.next())
              e = d.value, fk(e), b.push(gk(e));
            return u(f, Promise.all(b), 2);
          }
          a.j.clear();
          a.g = null;
          a.m = null;
          a.i = null;
          A(f);
        });
      }
      q.configure = function(a) {
        this.i = a;
        this.F = new Ie({ maxAttempts: Math.max(a.retryParameters.maxAttempts, 2), baseDelay: a.retryParameters.baseDelay, backoffFactor: a.retryParameters.backoffFactor, fuzzFactor: a.retryParameters.fuzzFactor, timeout: 0, stallTimeout: 0, connectionTimeout: 0 }, true);
      };
      q.start = function() {
        var a = this;
        return G(function(b) {
          if (1 == b.g)
            return u(b, hk(a), 2);
          lf(a.h);
          a.B = true;
          A(b);
        });
      };
      function ik(a, b) {
        var c, d, e, f, h;
        G(function(k2) {
          switch (k2.g) {
            case 1:
              return c = kc, D(k2, 2), u(k2, hj(a.g.R, c.X), 4);
            case 4:
              ta(k2, 3);
              break;
            case 2:
              if (d = ua(k2), a.g)
                a.g.onError(d);
            case 3:
              e = Zc(b.mimeType, b.codecs);
              Qi(a.g.R, e, a.m.sequenceMode);
              f = a.g.R.m;
              if (f.isTextVisible() || a.i.alwaysStreamText)
                h = jk(b), a.j.set(c.X, h), kk(a, h, 0);
              A(k2);
          }
        });
      }
      function lk(a) {
        var b = a.j.get(jc);
        b && (fk(b), gk(b).catch(function() {
        }), a.j.delete(jc));
        a.o = null;
      }
      function mk(a, b) {
        var c = a.j.get("video");
        if (c) {
          var d = c.stream;
          if (d) {
            if (b)
              (b = d.trickModeVideo) && !c.ob && (nk(a, b, false, 0, false), c.ob = d);
            else if (d = c.ob)
              c.ob = null, nk(a, d, true, 0, false);
          }
        }
      }
      function ok(a, b, c, d, e, f) {
        c = void 0 === c ? false : c;
        d = void 0 === d ? 0 : d;
        e = void 0 === e ? false : e;
        f = void 0 === f ? false : f;
        a.l = b;
        a.B && (b.video && nk(a, b.video, c, d, e, f), b.audio && nk(a, b.audio, c, d, e, f));
      }
      function pk(a, b) {
        a.o = b;
        a.B && nk(a, b, true, 0, false);
      }
      function nk(a, b, c, d, e, f) {
        var g = a.j.get(b.type);
        g || b.type != jc ? g && (g.ob && (b.trickModeVideo ? (g.ob = b, b = b.trickModeVideo) : g.ob = null), g.stream != b || e) && (b.type == jc && Qi(a.g.R, Zc(b.mimeType, b.codecs), a.m.sequenceMode), g.stream.closeSegmentIndex && g.stream.closeSegmentIndex(), g.stream = b, g.aa = null, g.ve = !!f, c && (g.ac ? g.hd = true : g.ra ? (g.bb = true, g.Nc = d, g.hd = true) : (fk(g), qk(a, g, true, d).catch(function(h) {
          if (a.g)
            a.g.onError(h);
        }))), rk(a, g).catch(function(h) {
          if (a.g)
            a.g.onError(h);
        })) : ik(a, b);
      }
      function rk(a, b) {
        var c, d;
        return G(function(e) {
          if (1 == e.g) {
            if (!b.ta)
              return e.return();
            c = b.stream;
            d = b.ta;
            return c.segmentIndex ? e.A(2) : u(e, c.createSegmentIndex(), 2);
          }
          if (b.ta != d || b.stream != c)
            return e.return();
          var f = a.g.Sc();
          var g = Vi(a.g.R, b.type), h = b.stream.segmentIndex.find(b.pa ? b.pa.endTime : f), k2 = null == h ? null : b.stream.segmentIndex.get(h);
          h = k2 ? k2.ka ? k2.ka - k2.Ba : null : null;
          k2 && !h && (h = (k2.endTime - k2.getStartTime()) * (b.stream.bandwidth || 0) / 8);
          h ? ((k2 = k2.h) && (h += (k2.ka ? k2.ka - k2.Ba : null) || 0), k2 = a.g.getBandwidthEstimate(), f = 8 * h / k2 < (g || 0) - f - Math.max(a.m.minBufferTime || 0, a.i.rebufferingGoal) || b.ta.h.g > h ? true : false) : f = false;
          f && b.ta.abort();
          A(e);
        });
      }
      q.vc = function() {
        if (this.g)
          for (var a = this.g.Sc(), b = r(this.j.keys()), c = b.next(); !c.done; c = b.next()) {
            var d = c.value;
            c = this.j.get(d);
            c.aa = null;
            var e = this.g.R;
            d == jc ? (e = e.g, e = null == e.g || null == e.h ? false : a >= e.g && a < e.h) : (e = Ui(e, d), e = vi(e, a));
            if (!e) {
              (null != Vi(this.g.R, d) || c.ra) && sk(this, c);
              c.ta && (c.ta.abort(), c.ta = null);
              if (d === jc && (d = this.g.R, d.s))
                for (d = d.s.g, d.l = 0, d.h = [], d.g = [], e = d.i, e.i = [], e.h = [], e.g = 0, Yh(d), d = r(d.j.values()), e = d.next(); !e.done; e = d.next())
                  Th(e.value);
              c.vc = true;
            }
          }
      };
      function sk(a, b) {
        b.ac || b.bb || (b.ra ? (b.bb = true, b.Nc = 0) : null == Ti(a.g.R, b.type) ? null == b.Ka && kk(a, b, 0) : (fk(b), qk(a, b, false, 0).catch(function(c) {
          if (a.g)
            a.g.onError(c);
        })));
      }
      function hk(a) {
        var b, c, d, e, f, g, h, k2, l, m;
        return G(function(n) {
          if (1 == n.g) {
            b = kc;
            if (!a.l)
              throw new O(2, 5, 5006);
            c = /* @__PURE__ */ new Map();
            d = /* @__PURE__ */ new Set();
            a.l.audio && (c.set(b.Hc, a.l.audio), d.add(a.l.audio));
            a.l.video && (c.set(b.va, a.l.video), d.add(a.l.video));
            a.o && (c.set(b.X, a.o), d.add(a.o));
            e = a.g.R;
            f = a.i.forceTransmux;
            return u(n, e.init(c, f, a.m.sequenceMode), 2);
          }
          lf(a.h);
          a.updateDuration();
          g = r(c.keys());
          for (h = g.next(); !h.done; h = g.next())
            k2 = h.value, l = c.get(k2), a.j.has(k2) || (m = jk(l), a.j.set(k2, m), kk(a, m, 0));
          A(n);
        });
      }
      function jk(a) {
        return { stream: a, type: a.type, aa: null, pa: null, Zc: null, Kd: null, Jd: null, Id: null, ob: null, endOfStream: false, ra: false, Ka: null, bb: false, Nc: 0, hd: false, ac: false, vc: true, Rd: false, be: false, nc: false, ta: null };
      }
      q.updateDuration = function() {
        var a = this.m.presentationTimeline.getDuration();
        Infinity > a ? this.g.R.Aa(a) : this.g.R.Aa(Math.pow(2, 32));
      };
      function tk(a, b) {
        var c, d, e, f, g;
        return G(function(h) {
          switch (h.g) {
            case 1:
              lf(a.h);
              if (b.ra || null == b.Ka || b.ac)
                return h.return();
              b.Ka = null;
              if (!b.bb) {
                h.A(2);
                break;
              }
              return u(h, qk(a, b, b.hd, b.Nc), 3);
            case 3:
              return h.return();
            case 2:
              if (b.stream.segmentIndex) {
                h.A(4);
                break;
              }
              c = b.stream;
              return u(h, b.stream.createSegmentIndex(), 5);
            case 5:
              if (c != b.stream)
                return c.closeSegmentIndex && c.closeSegmentIndex(), b.ra || b.Ka || kk(a, b, 0), h.return();
            case 4:
              D(h, 6);
              d = uk(a, b);
              null != d && (kk(a, b, d), b.nc = false);
              ta(h, 7);
              break;
            case 6:
              return e = ua(h), u(h, vk(a, e), 8);
            case 8:
              return h.return();
            case 7:
              f = Array.from(a.j.values());
              if (!a.B || !f.every(function(k2) {
                return k2.endOfStream;
              })) {
                h.A(0);
                break;
              }
              return u(h, a.g.R.endOfStream(), 10);
            case 10:
              lf(a.h), g = a.g.R.getDuration(), 0 != g && g < a.m.presentationTimeline.getDuration() && a.m.presentationTimeline.Aa(g), A(h);
          }
        });
      }
      function uk(a, b) {
        if (wk(b))
          return fj(a.g.R, b.stream.originalId || ""), null;
        b.type == jc && gj(a.g.R);
        var c = a.g.Sc(), d = b.pa ? b.pa.endTime : c, e = Wi(a.g.R, b.type, c), f = Math.max(a.m.minBufferTime || 0, a.i.rebufferingGoal, a.i.bufferingGoal) * a.u, g = a.m.presentationTimeline.getDuration() - d, h = Vi(a.g.R, b.type);
        if (1e-6 > g && h)
          return b.endOfStream = true, "video" == b.type && (a = a.j.get(jc)) && wk(a) && (a.endOfStream = true), null;
        b.endOfStream = false;
        if (e >= f)
          return a.i.updateIntervalSeconds / 2;
        e = xk(a, b, c, h);
        if (!e)
          return a.i.updateIntervalSeconds;
        f = Infinity;
        g = Array.from(a.j.values());
        g = r(g);
        for (h = g.next(); !h.done; h = g.next())
          h = h.value, wk(h) || h.aa && !h.aa.current() || (f = Math.min(f, h.pa ? h.pa.endTime : c));
        if (d >= f + a.m.presentationTimeline.g)
          return a.i.updateIntervalSeconds;
        yk(a, b, c, e).catch(function() {
        });
        return null;
      }
      function xk(a, b, c, d) {
        if (b.aa)
          return b.aa.current();
        if (b.pa || d)
          return c = b.pa ? b.pa.endTime : d, b.Rd = true, b.aa = b.stream.segmentIndex.Cb(c), b.aa && b.aa.next().value;
        a = a.i.inaccurateManifestTolerance;
        d = Math.max(c - a, 0);
        var e = null;
        a && (b.aa = b.stream.segmentIndex.Cb(d), e = b.aa && b.aa.next().value);
        e || (b.aa = b.stream.segmentIndex.Cb(c), e = b.aa && b.aa.next().value);
        return e;
      }
      function yk(a, b, c, d) {
        var e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C;
        return G(function(z) {
          switch (z.g) {
            case 1:
              e = kc;
              f = b.stream;
              g = b.aa;
              b.ra = true;
              D(z, 2);
              if (2 == d.Eb())
                throw new O(1, 1, 1011);
              return u(z, zk(a, b, d), 4);
            case 4:
              lf(a.h);
              if (a.s)
                return z.return();
              h = "video/mp4" == f.mimeType || "audio/mp4" == f.mimeType;
              k2 = window2.ReadableStream;
              if (a.i.lowLatencyMode && k2 && h && !d.l)
                return n = new Uint8Array(0), t = p = false, v = function(B) {
                  var E, F, H;
                  return G(function(I) {
                    if (p)
                      return I.return();
                    t = true;
                    lf(a.h);
                    if (a.s)
                      return I.return();
                    n = Ak(n, B);
                    E = false;
                    F = 0;
                    new zf().box(
                      "mdat",
                      function(J) {
                        F = J.size + J.start;
                        E = true;
                      }
                    ).parse(n, false, true);
                    if (!E)
                      return I.A(0);
                    H = n.subarray(0, F);
                    n = n.subarray(F);
                    return u(I, Bk(a, b, c, f, d, H), 0);
                  });
                }, u(z, Ck(a, b, d, v), 11);
              l = Ck(a, b, d);
              return u(z, l, 7);
            case 7:
              m = z.h;
              lf(a.h);
              if (a.s)
                return z.return();
              if (!d.l) {
                z.A(8);
                break;
              }
              return u(z, Dk(m, d, g), 9);
            case 9:
              m = z.h;
            case 8:
              return lf(a.h), b.bb ? (b.ra = false, kk(a, b, 0), z.return()) : u(z, Bk(a, b, c, f, d, m), 6);
            case 11:
              y = z.h;
              if (t) {
                z.A(6);
                break;
              }
              p = true;
              lf(a.h);
              return a.s ? z.return() : b.bb ? (b.ra = false, kk(a, b, 0), z.return()) : u(z, Bk(a, b, c, f, d, y), 6);
            case 6:
              lf(a.h);
              if (a.s)
                return z.return();
              b.pa = d;
              g.next();
              b.ra = false;
              b.be = false;
              w = a.g.R.Na();
              x = w[b.type];
              ab(JSON.stringify(x));
              b.bb || a.g.Wd(d.startTime, d.endTime, b.type);
              kk(a, b, 0);
              ta(z, 0);
              break;
            case 2:
              C = ua(z);
              lf(a.h, C);
              if (a.s)
                return z.return();
              b.ra = false;
              if (7001 == C.code)
                b.ra = false, fk(b), kk(a, b, 0), z.A(0);
              else if (b.type == e.X && a.i.ignoreTextStreamFailures)
                a.j.delete(e.X), z.A(0);
              else if (3017 == C.code)
                Ek(a, b, C), z.A(0);
              else
                return b.nc = true, C.severity = 2, u(z, vk(a, C), 0);
          }
        });
      }
      function Dk(a, b, c) {
        var d, e, f, g;
        return G(function(h) {
          if (1 == h.g)
            return d = b.l, d.cryptoKey ? h.A(2) : u(h, d.fetchKey(), 3);
          e = d.iv;
          if (!e)
            for (e = M(new ArrayBuffer(16)), f = d.firstMediaSequenceNumber + c.g, g = e.byteLength - 1; 0 <= g; g--)
              e[g] = f & 255, f >>= 8;
          return h.return(window2.crypto.subtle.decrypt({ name: "AES-CBC", iv: e }, d.cryptoKey, a));
        });
      }
      function Ak(a, b) {
        var c = new Uint8Array(a.length + b.length);
        c.set(a);
        c.set(b, a.length);
        return c;
      }
      function Ek(a, b, c) {
        if (!Array.from(a.j.values()).some(function(e) {
          return e != b && e.be;
        })) {
          var d = Math.round(100 * a.u);
          if (20 < d)
            a.u -= 0.2;
          else if (4 < d)
            a.u -= 0.04;
          else {
            b.nc = true;
            a.s = true;
            a.g.onError(c);
            return;
          }
          b.be = true;
        }
        kk(a, b, 4);
      }
      function zk(a, b, c) {
        var d, e, f, g, h, k2, l, m;
        return G(function(n) {
          d = [];
          e = Math.max(0, c.appendWindowStart - 0.1);
          f = c.appendWindowEnd + 0.01;
          g = c.timestampOffset;
          if (g != b.Kd || e != b.Jd || f != b.Id)
            h = function() {
              var p;
              return G(function(t) {
                if (1 == t.g)
                  return D(t, 2), b.Jd = e, b.Id = f, b.Kd = g, u(t, ij(a.g.R, b.type, g, e, f, a.m.sequenceMode), 4);
                if (2 != t.g)
                  return ta(t, 0);
                p = ua(t);
                b.Jd = null;
                b.Id = null;
                b.Kd = null;
                throw p;
              });
            }, d.push(h());
          !pi(c.h, b.Zc) && (b.Zc = c.h) && (k2 = Ck(a, b, c.h), l = function() {
            var p, t, v, y;
            return G(function(w) {
              switch (w.g) {
                case 1:
                  return D(
                    w,
                    2
                  ), u(w, k2, 4);
                case 4:
                  return p = w.h, lf(a.h), t = new zf(), t.box("moov", Ef).box("trak", Ef).box("mdia", Ef).P("mdhd", function(x) {
                    x = fi(x.reader || 0, x.version || 0);
                    c.h.timescale = x.timescale;
                  }).parse(p), v = b.stream.closedCaptions && 0 < b.stream.closedCaptions.size, u(w, a.g.xe(b.type, p), 5);
                case 5:
                  return u(w, Xi(a.g.R, b.type, p, null, v), 6);
                case 6:
                  ta(w, 0);
                  break;
                case 2:
                  throw y = ua(w), b.Zc = null, y;
              }
            });
          }, a.g.fg(c.startTime, c.h), d.push(l()));
          a.m.sequenceMode && (m = b.pa ? b.pa.m : null, c.m != m || b.Rd) && (b.Rd = false, d.push(jj(a.g.R, b.type, c.startTime)));
          return u(n, Promise.all(d), 0);
        });
      }
      function Bk(a, b, c, d, e, f) {
        var g, h, k2, l, m, n;
        return G(function(p) {
          switch (p.g) {
            case 1:
              g = d.closedCaptions && 0 < d.closedCaptions.size;
              k2 = null != d.emsgSchemeIdUris && 0 < d.emsgSchemeIdUris.length || a.i.dispatchAllEmsgBoxes;
              l = a.i.parsePrftBox && !a.D;
              if (k2 || l)
                h = new zf();
              k2 && h.P("emsg", function(t) {
                var v = d.emsgSchemeIdUris;
                if (0 === t.version) {
                  var y = t.reader.sc();
                  var w = t.reader.sc();
                  var x = t.reader.K();
                  var C = t.reader.K();
                  var z = t.reader.K();
                  var B = t.reader.K();
                  var E = e.startTime + C / x;
                } else
                  x = t.reader.K(), E = t.reader.$a() / x + e.timestampOffset, C = E - e.startTime, z = t.reader.K(), B = t.reader.K(), y = t.reader.sc(), w = t.reader.sc();
                t = t.reader.Za(t.reader.S.byteLength - t.reader.Z());
                if (v && v.includes(y) || a.i.dispatchAllEmsgBoxes)
                  "urn:mpeg:dash:event:2012" == y ? a.g.gg() : "https://aomedia.org/emsg/ID3" == y ? (v = Ci(t), v.length && e && a.g.hg([{ cueTime: e.startTime, data: t, frames: v, dts: e.startTime, pts: e.startTime }], 0, e.endTime)) : (v = (/* @__PURE__ */ new Map()).set("detail", { startTime: E, endTime: E + z / x, schemeIdUri: y, value: w, timescale: x, presentationTimeDelta: C, eventDuration: z, id: B, messageData: t }), v = new S("emsg", v), a.g.onEvent(v));
              });
              l && h.P("prft", function(t) {
                a: {
                  if (!a.D && e.h.timescale) {
                    t.reader.K();
                    var v = t.reader.K(), y = t.reader.K();
                    v = 1e3 * v + y / Math.pow(2, 32) * 1e3;
                    if (0 === t.version)
                      var w = t.reader.K();
                    else
                      try {
                        w = t.reader.$a();
                      } catch (x) {
                        a.D = true;
                        w = void 0;
                        break a;
                      }
                    t = new Date(new Date(Date.UTC(1900, 0, 1, 0, 0, 0)).getTime() + v).getTime();
                    w = (/* @__PURE__ */ new Map()).set("detail", { wallClockTime: t, programStartDate: new Date(t - w / e.h.timescale * 1e3) });
                    w = new S("prft", w);
                    a.g.onEvent(w);
                    a.D = true;
                  }
                  w = void 0;
                }
                return w;
              });
              (k2 || l) && h.parse(f);
              return u(p, Fk(a, b, c), 2);
            case 2:
              return lf(a.h), m = b.vc, b.vc = false, n = b.ve, b.ve = false, u(p, a.g.xe(b.type, f), 3);
            case 3:
              return u(p, Xi(a.g.R, b.type, f, e, g, m, n), 4);
            case 4:
              lf(a.h), A(p);
          }
        });
      }
      function Fk(a, b, c) {
        var d, e, f, g;
        return G(function(h) {
          if (1 == h.g) {
            d = Math.max(a.i.bufferBehind, a.m.presentationTimeline.g);
            e = Ti(a.g.R, b.type);
            if (null == e)
              return h.return();
            f = c - e;
            g = f - d;
            return 0.01 >= g ? h.return() : u(h, a.g.R.remove(b.type, e, e + g), 2);
          }
          lf(a.h);
          A(h);
        });
      }
      function wk(a) {
        return a && a.type == jc && ("application/cea-608" == a.stream.mimeType || "application/cea-708" == a.stream.mimeType);
      }
      function Ck(a, b, c, d) {
        var e, f, g, h, k2;
        return G(function(l) {
          if (1 == l.g)
            return e = jf, f = ck(c.ya(), c.Ba, c.ka, a.i.retryParameters, d), g = b.stream, a.g.modifySegmentRequest(f, { type: g.type, init: c instanceof oi, duration: c.endTime - c.startTime, mimeType: g.mimeType, codecs: g.codecs, bandwidth: g.bandwidth }), h = a.g.kb.request(e, f), b.ta = h, u(l, h.promise, 2);
          k2 = l.h;
          b.ta = null;
          return l.return(k2.data);
        });
      }
      function qk(a, b, c, d) {
        var e, f;
        return G(function(g) {
          if (1 == g.g)
            return b.bb = false, b.hd = false, b.Nc = 0, b.ac = true, b.pa = null, b.Zc = null, b.aa = null, d ? (e = a.g.Sc(), f = a.g.R.getDuration(), u(g, a.g.R.remove(b.type, e + d, f), 3)) : u(g, hj(a.g.R, b.type), 4);
          if (3 != g.g)
            return lf(a.h), c ? u(g, a.g.R.flush(b.type), 3) : g.A(3);
          lf(a.h);
          b.ac = false;
          b.endOfStream = false;
          b.ra || b.Ka || kk(a, b, 0);
          A(g);
        });
      }
      function kk(a, b, c) {
        var d = b.type;
        if (d != jc || a.j.has(d))
          b.Ka = new nc(function() {
            var e;
            return G(function(f) {
              if (1 == f.g)
                return D(f, 2), u(f, tk(a, b), 4);
              if (2 != f.g)
                return ta(f, 0);
              e = ua(f);
              if (a.g)
                a.g.onError(e);
              A(f);
            });
          }).N(c);
      }
      function fk(a) {
        null != a.Ka && (a.Ka.stop(), a.Ka = null);
      }
      function gk(a) {
        return G(function(b) {
          return a.ta ? u(b, a.ta.abort(), 0) : b.A(0);
        });
      }
      function vk(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return u(c, Ke(a.F), 2);
          lf(a.h);
          a.g.onError(b);
          b.handled || a.i.failureCallback(b);
          A(c);
        });
      }
      function Gk(a, b) {
        var c = Hk(), d = this;
        this.j = b;
        this.i = a;
        this.l = c;
        this.o = null;
        this.m = [];
        this.h = this.g = null;
        this.u = Promise.resolve().then(function() {
          return Ik(d);
        });
        this.s = new kf(function() {
          return Jk(d);
        });
      }
      Gk.prototype.destroy = function() {
        return this.s.destroy();
      };
      function Jk(a) {
        var b, c, d;
        return G(function(e) {
          if (1 == e.g)
            return a.h && a.h.abort(), Kk(a), u(e, a.u, 2);
          a.g && a.g.Ia.mb();
          b = r(a.m);
          for (c = b.next(); !c.done; c = b.next())
            d = c.value, d.Ia.mb();
          a.g = null;
          a.m = [];
          a.j = null;
          A(e);
        });
      }
      function Lk(a, b) {
        var c = { Jb: function() {
        }, bd: function() {
        }, mb: function() {
        }, onError: function() {
        }, dd: function() {
        }, uh: function() {
        } };
        a.m.push({ create: b, Ia: c });
        a.h && a.h.abort();
        Kk(a);
        return c;
      }
      function Ik(a) {
        return G(function(b) {
          if (a.s.g)
            b = b.A(0);
          else {
            if (0 == a.m.length || a.g && !a.g.hb)
              var c = false;
            else {
              a.g && (a.g.Ia.mb(), a.g = null);
              c = a.m.shift();
              var d = c.create(a.l);
              d ? (c.Ia.Jb(), a.g = { node: d.node, payload: d.payload, hb: d.hb, Ia: c.Ia }) : c.Ia.dd();
              c = true;
            }
            c ? c = Promise.resolve() : a.g ? c = Mk(a) : (a.j.eg(a.i), a.o = new lc2(), c = a.o);
            b = u(b, c, 1);
          }
          return b;
        });
      }
      function Mk(a) {
        var b, c;
        return G(function(d) {
          switch (d.g) {
            case 1:
              return a.i = a.j.Mf(a.i, a.l, a.g.node, a.g.payload), D(d, 2), a.h = a.j.yf(a.i, a.l, a.g.payload), u(d, a.h.promise, 4);
            case 4:
              a.h = null;
              a.i == a.g.node && (a.g.Ia.bd(), a.g = null);
              ta(d, 0);
              break;
            case 2:
              b = ua(d);
              if (7001 == b.code)
                a.g.Ia.mb();
              else
                a.g.Ia.onError(b);
              a.g = null;
              a.h = null;
              c = a;
              return u(d, a.j.handleError(a.l, b), 5);
            case 5:
              c.i = d.h, A(d);
          }
        });
      }
      function Kk(a) {
        a.o && (a.o.resolve(), a.o = null);
      }
      function Nk(a) {
        var b = [], c = 700 <= a.fontWeight, d = "italic" == a.fontStyle, e = a.textDecoration.includes("underline");
        c && b.push("b");
        d && b.push("i");
        e && b.push("u");
        c = b.reduce(function(f, g) {
          return f + "<" + g + ">";
        }, "");
        b = b.reduceRight(function(f, g) {
          return f + "</" + g + ">";
        }, "");
        return a.lineBreak ? "\n" : a.nestedCues.length ? a.nestedCues.map(Nk).join("") : c + a.payload + b;
      }
      function Ok(a, b) {
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          if (c = c.value, c.isContainer)
            Ok(c.nestedCues, b);
          else {
            var d = c.clone();
            d.nestedCues = [];
            d.payload = Nk(c);
            b.push(d);
          }
        return b;
      }
      function Pk(a) {
        this.g = null;
        for (var b = r(Array.from(a.textTracks)), c = b.next(); !c.done; c = b.next())
          c = c.value, c.mode = "disabled", "Shaka Player TextTrack" == c.label && (this.g = c);
        this.g || (this.g = a.addTextTrack("subtitles", "Shaka Player TextTrack"));
        this.g.mode = "hidden";
      }
      q = Pk.prototype;
      q.remove = function(a, b) {
        if (!this.g)
          return false;
        Qk(this.g, function(c) {
          return c.startTime < b && c.endTime > a;
        });
        return true;
      };
      q.append = function(a) {
        var b = Ok(a, []), c = [];
        a = this.g.cues ? Array.from(this.g.cues) : [];
        var d = {};
        b = r(b);
        for (var e = b.next(); !e.done; d = { sb: d.sb }, e = b.next())
          d.sb = e.value, a.some(function(f) {
            return function(g) {
              return g.startTime == f.sb.startTime && g.endTime == f.sb.endTime && g.text == f.sb.payload ? true : false;
            };
          }(d)) || (e = Rk(d.sb)) && c.push(e);
        a = c.slice().sort(function(f, g) {
          return f.startTime != g.startTime ? f.startTime - g.startTime : f.endTime != g.endTime ? f.endTime - g.startTime : "line" in VTTCue.prototype ? c.indexOf(g) - c.indexOf(f) : c.indexOf(f) - c.indexOf(g);
        });
        a = r(a);
        for (d = a.next(); !d.done; d = a.next())
          this.g.addCue(d.value);
      };
      q.destroy = function() {
        this.g && (Qk(this.g, function() {
          return true;
        }), this.g.mode = "disabled");
        this.g = null;
        return Promise.resolve();
      };
      q.isTextVisible = function() {
        return "showing" == this.g.mode;
      };
      q.setTextVisibility = function(a) {
        this.g.mode = a ? "showing" : "hidden";
      };
      function Rk(a) {
        if (a.startTime >= a.endTime)
          return null;
        var b = new VTTCue(a.startTime, a.endTime, a.payload);
        b.lineAlign = a.lineAlign;
        b.positionAlign = a.positionAlign;
        a.size && (b.size = a.size);
        try {
          b.align = a.textAlign;
        } catch (c) {
        }
        "center" == a.textAlign && "center" != b.align && (b.align = "middle");
        "vertical-lr" == a.writingMode ? b.vertical = "lr" : "vertical-rl" == a.writingMode && (b.vertical = "rl");
        1 == a.lineInterpretation && (b.snapToLines = false);
        null != a.line && (b.line = a.line);
        null != a.position && (b.position = a.position);
        return b;
      }
      function Qk(a, b) {
        var c = a.mode;
        a.mode = "showing" == c ? "showing" : "hidden";
        for (var d = r(Array.from(a.cues)), e = d.next(); !e.done; e = d.next())
          (e = e.value) && b(e) && a.removeCue(e);
        a.mode = c;
      }
      K("shaka.text.SimpleTextDisplayer", Pk);
      Pk.prototype.setTextVisibility = Pk.prototype.setTextVisibility;
      Pk.prototype.isTextVisible = Pk.prototype.isTextVisible;
      Pk.prototype.destroy = Pk.prototype.destroy;
      Pk.prototype.append = Pk.prototype.append;
      Pk.prototype.remove = Pk.prototype.remove;
      function Sk() {
      }
      function Tk(a) {
        for (; a.firstChild; )
          a.removeChild(a.firstChild);
      }
      K("shaka.util.Dom", Sk);
      Sk.removeAllChildren = Tk;
      function Uk(a, b) {
        var c = this;
        this.j = false;
        this.i = [];
        this.B = a;
        this.m = b;
        this.g = document.createElement("div");
        this.g.classList.add("shaka-text-container");
        this.g.style.textAlign = "center";
        this.g.style.display = "flex";
        this.g.style.flexDirection = "column";
        this.g.style.alignItems = "center";
        this.g.style.justifyContent = "flex-end";
        this.m.appendChild(this.g);
        this.u = new P(function() {
          Vk(c);
        }).Ca(0.25);
        this.h = /* @__PURE__ */ new Map();
        this.s = new mf();
        this.s.C(document, "fullscreenchange", function() {
          Vk(c, true);
        });
        this.l = null;
        "ResizeObserver" in window2 && (this.l = new ResizeObserver(function() {
          Vk(c, true);
        }), this.l.observe(this.g));
        this.o = /* @__PURE__ */ new Map();
      }
      q = Uk.prototype;
      q.append = function(a) {
        var b = [].concat(ha(this.i)), c = {};
        a = r(a);
        for (var d = a.next(); !d.done; c = { Cc: c.Cc }, d = a.next())
          c.Cc = d.value, b.some(function(e) {
            return function(f) {
              return wb(f, e.Cc);
            };
          }(c)) || this.i.push(c.Cc);
        Vk(this);
      };
      q.destroy = function() {
        this.m.removeChild(this.g);
        this.g = null;
        this.j = false;
        this.i = [];
        this.u && this.u.stop();
        this.h.clear();
        this.s && (this.s.release(), this.s = null);
        this.l && (this.l.disconnect(), this.l = null);
      };
      q.remove = function(a, b) {
        if (!this.g)
          return false;
        var c = this.i.length;
        this.i = this.i.filter(function(d) {
          return d.startTime < a || d.endTime >= b;
        });
        Vk(this, c > this.i.length);
        return true;
      };
      q.isTextVisible = function() {
        return this.j;
      };
      q.setTextVisibility = function(a) {
        this.j = a;
      };
      function Wk(a, b) {
        for (; null != b; ) {
          if (b == a.g)
            return true;
          b = b.parentElement;
        }
        return false;
      }
      function Xk(a, b, c, d, e) {
        var f = false, g = [], h = [];
        b = r(b);
        for (var k2 = b.next(); !k2.done; k2 = b.next()) {
          k2 = k2.value;
          e.push(k2);
          var l = a.h.get(k2), m = k2.startTime <= d && k2.endTime > d, n = l ? l.ef : null;
          l && (g.push(l.Bd), l.tc && g.push(l.tc), m || (f = true, a.h.delete(k2), l = null));
          m && (h.push(k2), l ? Wk(a, n) || (f = true) : (Yk(a, k2, e), l = a.h.get(k2), n = l.ef, f = true));
          0 < k2.nestedCues.length && n && Xk(a, k2.nestedCues, n, d, e);
          e.pop();
        }
        if (f) {
          d = r(g);
          for (e = d.next(); !e.done; e = d.next())
            e = e.value, e.parentElement && e.parentElement.removeChild(e);
          h.sort(function(p, t) {
            return p.startTime != t.startTime ? p.startTime - t.startTime : p.endTime - t.endTime;
          });
          h = r(h);
          for (k2 = h.next(); !k2.done; k2 = h.next())
            d = a.h.get(k2.value), d.tc ? (c.appendChild(d.tc), d.tc.appendChild(d.Bd)) : c.appendChild(d.Bd);
        }
      }
      function Vk(a, b) {
        if (a.g) {
          var c = a.B.currentTime;
          if (!a.j || (void 0 === b ? 0 : b)) {
            b = r(a.o.values());
            for (var d = b.next(); !d.done; d = b.next())
              Tk(d.value);
            Tk(a.g);
            a.h.clear();
            a.o.clear();
          }
          if (a.j) {
            b = /* @__PURE__ */ new Map();
            d = r(a.h.keys());
            for (var e = d.next(); !e.done; e = d.next())
              e = e.value, b.set(e, a.h.get(e));
            Xk(a, a.i, a.g, c, []);
          }
        }
      }
      function Yk(a, b, c) {
        var d = 1 < c.length, e = d ? "span" : "div";
        b.lineBreak && (e = "br");
        d = !d && 0 < b.nestedCues.length;
        var f = document.createElement(e);
        "br" != e && Zk(a, f, b, c, d);
        c = null;
        if (b.region && b.region.id)
          if (c = b.region, e = c.id + "_" + c.width + "x" + c.height + (c.heightUnits == Db ? "%" : "px") + "-" + c.viewportAnchorX + "x" + c.viewportAnchorY + (c.viewportAnchorUnits == Db ? "%" : "px"), a.o.has(e))
            c = a.o.get(e);
          else {
            var g = document.createElement("span"), h = c.heightUnits == Db ? "%" : "px", k2 = c.widthUnits == Db ? "%" : "px", l = c.viewportAnchorUnits == Db ? "%" : "px";
            g.id = "shaka-text-region---" + e;
            g.classList.add("shaka-text-region");
            g.style.height = c.height + h;
            g.style.width = c.width + k2;
            g.style.position = "absolute";
            g.style.top = c.viewportAnchorY + l;
            g.style.left = c.viewportAnchorX + l;
            g.style.display = "flex";
            g.style.flexDirection = "column";
            g.style.alignItems = "center";
            g.style.justifyContent = "before" == b.displayAlign ? "flex-start" : "center" == b.displayAlign ? "center" : "flex-end";
            a.o.set(e, g);
            c = g;
          }
        e = f;
        d && (e = document.createElement("span"), e.classList.add("shaka-text-wrapper"), e.style.backgroundColor = b.backgroundColor, e.style.lineHeight = "normal", f.appendChild(e));
        a.h.set(b, { Bd: f, ef: e, tc: c });
      }
      function Zk(a, b, c, d, e) {
        var f = b.style, g = 0 == c.nestedCues.length, h = 1 < d.length;
        f.whiteSpace = "pre-wrap";
        var k2 = c.payload.replace(/\s+$/g, function(m) {
          return " ".repeat(m.length);
        });
        f.webkitTextStrokeColor = c.textStrokeColor;
        f.webkitTextStrokeWidth = c.textStrokeWidth;
        f.color = c.color;
        f.direction = c.direction;
        f.opacity = c.opacity;
        f.paddingLeft = $k(c.linePadding, c, a.m);
        f.paddingRight = $k(c.linePadding, c, a.m);
        f.textShadow = c.textShadow;
        if (c.backgroundImage)
          f.backgroundImage = "url('" + c.backgroundImage + "')", f.backgroundRepeat = "no-repeat", f.backgroundSize = "contain", f.backgroundPosition = "center", f.width = "100%", f.height = "100%";
        else {
          if (c.nestedCues.length)
            var l = b;
          else
            l = document.createElement("span"), b.appendChild(l);
          c.border && (l.style.border = c.border);
          e || ((b = al(d, function(m) {
            return m.backgroundColor;
          })) ? l.style.backgroundColor = b : k2 && (l.style.backgroundColor = "rgba(0, 0, 0, 0.8)"));
          k2 && (l.textContent = k2);
        }
        h && !d[d.length - 1].isContainer ? f.display = "inline" : (f.display = "flex", f.flexDirection = "column", f.alignItems = "center", f.justifyContent = "before" == c.displayAlign ? "flex-start" : "center" == c.displayAlign ? "center" : "flex-end");
        g || (f.margin = "0");
        f.fontFamily = c.fontFamily;
        f.fontWeight = c.fontWeight.toString();
        f.fontStyle = c.fontStyle;
        f.letterSpacing = c.letterSpacing;
        f.fontSize = $k(c.fontSize, c, a.m);
        null != c.line && 1 == c.lineInterpretation && (f.position = "absolute", c.writingMode == qb ? (f.width = "100%", c.lineAlign == sb ? f.top = c.line + "%" : "end" == c.lineAlign && (f.bottom = 100 - c.line + "%")) : "vertical-lr" == c.writingMode ? (f.height = "100%", c.lineAlign == sb ? f.left = c.line + "%" : "end" == c.lineAlign && (f.right = 100 - c.line + "%")) : (f.height = "100%", c.lineAlign == sb ? f.right = c.line + "%" : "end" == c.lineAlign && (f.left = 100 - c.line + "%")));
        f.lineHeight = c.lineHeight;
        null != c.position && (c.writingMode == qb ? f.paddingLeft = c.position : f.paddingTop = c.position);
        "line-left" == c.positionAlign ? f.cssFloat = "left" : "line-right" == c.positionAlign && (f.cssFloat = "right");
        f.textAlign = c.textAlign;
        f.textDecoration = c.textDecoration.join(" ");
        f.writingMode = c.writingMode;
        "writingMode" in document.documentElement.style && f.writingMode == c.writingMode || (f.webkitWritingMode = c.writingMode);
        c.size && (c.writingMode == qb ? f.width = c.size + "%" : f.height = c.size + "%");
      }
      function $k(a, b, c) {
        var d = (d = new RegExp(/(\d*\.?\d+)([a-z]+|%+)/).exec(a)) ? { value: Number(d[1]), unit: d[2] } : null;
        if (!d)
          return a;
        var e = d.value;
        switch (d.unit) {
          case "%":
            return e / 100 * c.clientHeight / b.cellResolution.rows + "px";
          case "c":
            return c.clientHeight * e / b.cellResolution.rows + "px";
          default:
            return a;
        }
      }
      function al(a, b) {
        for (var c = a.length - 1; 0 <= c; c--) {
          var d = b(a[c]);
          if (d || 0 === d)
            return d;
        }
        return null;
      }
      K("shaka.text.UITextDisplayer", Uk);
      Uk.prototype.setTextVisibility = Uk.prototype.setTextVisibility;
      Uk.prototype.isTextVisible = Uk.prototype.isTextVisible;
      Uk.prototype.remove = Uk.prototype.remove;
      Uk.prototype.destroy = Uk.prototype.destroy;
      Uk.prototype.append = Uk.prototype.append;
      function bl(a, b) {
        function c(f) {
          for (var g = f, h = r(b), k2 = h.next(); !k2.done; k2 = h.next())
            k2 = k2.value, k2.end && k2.start < f && (g += k2.end - k2.start);
          f = Math.floor(g / 3600);
          h = Math.floor(g / 60 % 60);
          k2 = Math.floor(g % 60);
          g = Math.floor(1e3 * g % 1e3);
          return (10 > f ? "0" : "") + f + ":" + (10 > h ? "0" : "") + h + ":" + (10 > k2 ? "0" : "") + k2 + "." + (100 > g ? 10 > g ? "00" : "0" : "") + g;
        }
        var d = Ok(a, []);
        a = "WEBVTT\n\n";
        d = r(d);
        for (var e = d.next(); !e.done; e = d.next())
          e = e.value, a += c(e.startTime) + " --> " + c(e.endTime) + function(f) {
            var g = [];
            switch (f.textAlign) {
              case "left":
                g.push("align:left");
                break;
              case "right":
                g.push("align:right");
                break;
              case ob:
                g.push("align:middle");
                break;
              case "start":
                g.push("align:start");
                break;
              case "end":
                g.push("align:end");
            }
            switch (f.writingMode) {
              case "vertical-lr":
                g.push("vertical:lr");
                break;
              case "vertical-rl":
                g.push("vertical:rl");
            }
            return g.length ? " " + g.join(" ") : "";
          }(e) + "\n", a += e.payload + "\n\n";
        return a;
      }
      K("shaka.text.WebVttGenerator", function() {
      });
      function cl(a, b) {
        this.h = a;
        this.g = b;
        this.j = "";
        this.o = void 0;
        this.i = false;
        this.m = true;
        this.l = false;
      }
      function dl(a, b, c) {
        try {
          if (a.g.enabled) {
            var d = { d: 1e3 * c.duration, st: a.h.U() ? el : fl };
            d.ot = gl(c);
            var e = d.ot === hl || d.ot === il || d.ot === jl || d.ot === kl;
            e && (d.bl = ll(a, c.type));
            c.bandwidth && (d.br = c.bandwidth / 1e3);
            e && d.ot !== kl && (d.tb = ml(a, d.ot) / 1e3);
            nl(a, b, d);
          }
        } catch (f) {
          Xa("CMCD_SEGMENT_ERROR", "Could not generate segment CMCD data.", f);
        }
      }
      function ol(a, b, c) {
        try {
          if (!a.g.enabled)
            return b;
          var d = pl(a);
          a: {
            switch (c) {
              case "video/webm":
              case "video/mp4":
                var e = jl;
                break a;
              case "application/x-mpegurl":
                e = ql;
                break a;
            }
            e = void 0;
          }
          d.ot = e;
          d.su = true;
          var f = rl(d);
          return sl(b, f);
        } catch (g) {
          return Xa("CMCD_SRC_ERROR", "Could not generate src CMCD data.", g), b;
        }
      }
      function pl(a) {
        a.j || (a.j = a.g.sessionId || window2.crypto.randomUUID());
        return { v: 1, sf: a.o, sid: a.j, cid: a.g.contentId, mtp: a.h.getBandwidthEstimate() / 1e3 };
      }
      function nl(a, b, c) {
        c = void 0 === c ? {} : c;
        var d = void 0 === d ? a.g.useHeaders : d;
        if (a.g.enabled) {
          Object.assign(c, pl(a));
          c.pr = a.h.Rc();
          var e = c.ot === hl || c.ot === jl;
          a.l && e && (c.bs = true, c.su = true, a.l = false);
          null == c.su && (c.su = a.m);
          if (d)
            a = tl(c), Object.keys(a).length && Object.assign(b.headers, a);
          else {
            var f = rl(c);
            f && (b.uris = b.uris.map(function(g) {
              return sl(g, f);
            }));
          }
        }
      }
      function gl(a) {
        var b = a.type;
        if (a.init)
          return ul;
        if ("video" == b)
          return a.codecs.includes(",") ? jl : hl;
        if ("audio" == b)
          return il;
        if ("text" == b)
          return "application/mp4" === a.mimeType ? kl : vl;
      }
      function ll(a, b) {
        b = a.h.Na()[b];
        if (!b.length)
          return NaN;
        var c = a.h.getCurrentTime();
        return (a = b.find(function(d) {
          return d.start <= c && d.end >= c;
        })) ? 1e3 * (a.end - c) : NaN;
      }
      function ml(a, b) {
        var c = a.h.Xa();
        if (!c.length)
          return NaN;
        a = c[0];
        c = r(c);
        for (var d = c.next(); !d.done; d = c.next())
          d = d.value, "variant" === d.type && d.bandwidth > a.bandwidth && (a = d);
        switch (b) {
          case hl:
            return a.videoBandwidth || NaN;
          case il:
            return a.audioBandwidth || NaN;
          default:
            return a.bandwidth;
        }
      }
      function rl(a) {
        function b(n) {
          return 100 * c(n / 100);
        }
        function c(n) {
          return Math.round(n);
        }
        function d(n) {
          return !Number.isNaN(n) && null != n && "" !== n && false !== n;
        }
        var e = [], f = { br: c, d: c, bl: b, dl: b, mtp: b, nor: function(n) {
          return encodeURIComponent(n);
        }, rtp: b, tb: c }, g = Object.keys(a || {}).sort();
        g = r(g);
        for (var h = g.next(); !h.done; h = g.next()) {
          h = h.value;
          var k2 = a[h];
          if (d(k2) && ("v" !== h || 1 !== k2) && ("pr" != h || 1 !== k2)) {
            var l = f[h];
            l && (k2 = l(k2));
            l = typeof k2;
            var m = void 0;
            m = "string" === l && "ot" !== h && "sf" !== h && "st" !== h ? h + "=" + JSON.stringify(k2) : "boolean" === l ? h : "symbol" === l ? h + "=" + k2.description : h + "=" + k2;
            e.push(m);
          }
        }
        return e.join(",");
      }
      function tl(a) {
        var b = Object.keys(a), c = {}, d = ["Object", "Request", "Session", "Status"], e = [{}, {}, {}, {}], f = { br: 0, d: 0, ot: 0, tb: 0, bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1, cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2, bs: 3, rtp: 3 };
        b = r(b);
        for (var g = b.next(); !g.done; g = b.next())
          g = g.value, e[null != f[g] ? f[g] : 1][g] = a[g];
        for (a = 0; a < e.length; a++)
          (f = rl(e[a])) && (c["CMCD-" + d[a]] = f);
        return c;
      }
      function sl(a, b) {
        if (!b || a.includes("offline:"))
          return a;
        a = new Nb(a);
        a.g.set("CMCD", b);
        return a.toString();
      }
      var ql = "m", il = "a", hl = "v", jl = "av", ul = "i", vl = "c", kl = "tt", fl = "v", el = "l";
      K("shaka.util.CmcdManager.StreamingFormat", { DASH: "d", HLS: "h", dh: "s", Yg: "o" });
      function wl() {
      }
      function xl(a, b, c, d, e) {
        var f = e in d, g = true, h;
        for (h in b) {
          var k2 = e + "." + h, l = f ? d[e] : c[h];
          f || h in c ? void 0 === b[h] ? void 0 === l || f ? delete a[h] : a[h] = Ve(l) : l.constructor == Object && b[h] && b[h].constructor == Object ? (a[h] || (a[h] = Ve(l)), k2 = xl(a[h], b[h], l, d, k2), g = g && k2) : typeof b[h] != typeof l || null == b[h] || "function" != typeof b[h] && b[h].constructor != l.constructor ? (Va("Invalid config, wrong type for " + k2), g = false) : ("function" == typeof c[h] && c[h].length != b[h].length && Wa("Unexpected number of arguments for " + k2), a[h] = b[h]) : (Va("Invalid config, unrecognized key " + k2), g = false);
        }
        return g;
      }
      function yl(a, b) {
        for (var c = {}, d = c, e = 0, f = 0; ; ) {
          e = a.indexOf(".", e);
          if (0 > e)
            break;
          if (0 == e || "\\" != a[e - 1])
            f = a.substring(f, e).replace(/\\\./g, "."), d[f] = {}, d = d[f], f = e + 1;
          e += 1;
        }
        d[a.substring(f).replace(/\\\./g, ".")] = b;
        return c;
      }
      function zl(a, b) {
        return a && b;
      }
      K("shaka.util.ConfigUtils", wl);
      wl.convertToConfigObject = yl;
      wl.mergeConfigObjects = xl;
      function Al() {
      }
      function Bl(a) {
        a = Fc(a);
        return new Nb(a).Ha;
      }
      function Cl(a, b, c) {
        function d(h) {
          Lb(f).setUint32(g, h.byteLength, true);
          g += 4;
          f.set(M(h), g);
          g += h.byteLength;
        }
        if (!c || !c.byteLength)
          throw new O(2, 6, 6015);
        var e;
        "string" == typeof b ? e = Hc(b, true) : e = b;
        a = Fc(a);
        a = Hc(a, true);
        var f = new Uint8Array(12 + a.byteLength + e.byteLength + c.byteLength), g = 0;
        d(a);
        d(e);
        d(c);
        return f;
      }
      K("shaka.util.FairPlayUtils", Al);
      Al.commonFairPlayResponse = function(a, b) {
        if (2 === a) {
          try {
            var c = Cc(b.data);
          } catch (e) {
            return;
          }
          a = false;
          c = c.trim();
          "<ckc>" === c.substr(0, 5) && "</ckc>" === c.substr(-6) && (c = c.slice(5, -6), a = true);
          try {
            var d = JSON.parse(c);
            d.ckc && (c = d.ckc, a = true);
            d.CkcMessage && (c = d.CkcMessage, a = true);
            d.License && (c = d.License, a = true);
          } catch (e) {
          }
          a && (b.data = Ib(Lc(c)));
        }
      };
      Al.conaxFairPlayRequest = function(a, b) {
        2 === a && (b.headers["Content-Type"] = "application/octet-stream");
      };
      Al.ezdrmFairPlayRequest = function(a, b) {
        2 === a && (b.headers["Content-Type"] = "application/octet-stream");
      };
      Al.verimatrixFairPlayRequest = function(a, b) {
        2 === a && (a = M(b.body), a = Kc(a), b.headers["Content-Type"] = "application/x-www-form-urlencoded", b.body = Gc("spc=" + a));
      };
      Al.conaxInitDataTransform = function(a, b, c) {
        if ("skd" !== b)
          return a;
        b = c.serverCertificate;
        c = Fc(a).split("skd://").pop().split("?").shift();
        c = window2.atob(c);
        var d = new ArrayBuffer(2 * c.length);
        d = new Uint16Array(d);
        for (var e = 0, f = c.length; e < f; e++)
          d[e] = c.charCodeAt(e);
        return Cl(a, d, b);
      };
      Al.ezdrmInitDataTransform = function(a, b, c) {
        if ("skd" !== b)
          return a;
        b = c.serverCertificate;
        c = Fc(a).split(";").pop();
        return Cl(a, c, b);
      };
      Al.verimatrixInitDataTransform = function(a, b, c) {
        if ("skd" !== b)
          return a;
        b = c.serverCertificate;
        c = Fc(a).split("skd://").pop();
        return Cl(a, c, b);
      };
      Al.initDataTransform = Cl;
      Al.defaultGetContentId = Bl;
      Al.isFairPlaySupported = function() {
        var a;
        return G(function(b) {
          if (1 == b.g)
            return a = { initDataTypes: ["cenc", "sinf", "skd"], videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }] }, D(b, 2), u(b, navigator.requestMediaKeySystemAccess("com.apple.fps", [a]), 4);
          if (2 != b.g)
            return b.return(true);
          ua(b);
          return b.return(false);
        });
      };
      function Dl() {
      }
      function El() {
        var a = Infinity;
        navigator.connection && navigator.connection.saveData && (a = 360);
        var b = { retryParameters: Je(), servers: {}, clearKeys: {}, advanced: {}, delayLicenseRequestUntilPlayed: false, initDataTransform: function(g, h, k2) {
          "com.apple.fps.1_0" == k2.keySystem && "skd" == h && (h = k2.serverCertificate, k2 = Bl(g), g = Cl(g, k2, h));
          return g;
        }, logLicenseExchange: false, updateExpirationTime: 1, preferredKeySystems: [], keySystemsMapping: {}, parseInbandPsshEnabled: sc() }, c = {
          retryParameters: Je(),
          availabilityWindowOverride: NaN,
          disableAudio: false,
          disableVideo: false,
          disableText: false,
          disableThumbnails: false,
          defaultPresentationDelay: 0,
          segmentRelativeVttTiming: false,
          dash: { clockSyncUri: "", ignoreDrmInfo: false, disableXlinkProcessing: false, xlinkFailGracefully: false, ignoreMinBufferTime: false, autoCorrectDrift: true, initialSegmentLimit: 1e3, ignoreSuggestedPresentationDelay: false, ignoreEmptyAdaptationSet: false, ignoreMaxSegmentDuration: false, keySystemsByURI: {
            "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
            "urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e": "org.w3.clearkey",
            "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
            "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
            "urn:uuid:79f0049a-4098-8642-ab92-e65be0885f95": "com.microsoft.playready",
            "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
          }, manifestPreprocessor: function(g) {
            return zl([g], g);
          }, sequenceMode: false },
          hls: {
            ignoreTextStreamFailures: false,
            ignoreImageStreamFailures: false,
            defaultAudioCodec: "mp4a.40.2",
            defaultVideoCodec: "avc1.42E01E",
            ignoreManifestProgramDateTime: false,
            mediaPlaylistFullMimeType: 'video/mp2t; codecs="avc1.42E01E, mp4a.40.2"',
            useSafariBehaviorForLive: true,
            liveSegmentsDelay: 3
          }
        }, d = {
          retryParameters: Je(),
          failureCallback: function(g) {
            return zl([g]);
          },
          rebufferingGoal: 2,
          bufferingGoal: 10,
          bufferBehind: 30,
          ignoreTextStreamFailures: false,
          alwaysStreamText: false,
          startAtSegmentBoundary: false,
          gapDetectionThreshold: 0.5,
          durationBackoff: 1,
          forceTransmux: false,
          safeSeekOffset: 5,
          stallEnabled: true,
          stallThreshold: 1,
          stallSkip: 0.1,
          useNativeHlsOnSafari: true,
          inaccurateManifestTolerance: 2,
          lowLatencyMode: false,
          autoLowLatencyMode: false,
          forceHTTPS: false,
          preferNativeHls: false,
          updateIntervalSeconds: 1,
          dispatchAllEmsgBoxes: false,
          observeQualityChanges: false,
          maxDisabledTime: 30,
          parsePrftBox: false
        };
        if (tc("Web0S") || uc() || tc("CrKey"))
          d.stallSkip = 0;
        var e = { trackSelectionCallback: function(g) {
          return G(function(h) {
            return h.return(g);
          });
        }, downloadSizeCallback: function(g) {
          var h;
          return G(function(k2) {
            if (1 == k2.g)
              return navigator.storage && navigator.storage.estimate ? u(k2, navigator.storage.estimate(), 3) : k2.return(true);
            h = k2.h;
            return k2.return(h.usage + g < 0.95 * h.quota);
          });
        }, progressCallback: function(g, h) {
          return zl([g, h]);
        }, usePersistentLicense: true, numberOfParallelDownloads: 5 }, f = { drm: b, manifest: c, streaming: d, mediaSource: { sourceBufferExtraFeatures: "" }, offline: e, abrFactory: function() {
          return new me();
        }, abr: { enabled: true, useNetworkInformation: true, defaultBandwidthEstimate: 1e6, switchInterval: 8, bandwidthUpgradeTarget: 0.85, bandwidthDowngradeTarget: 0.95, restrictions: {
          minWidth: 0,
          maxWidth: Infinity,
          minHeight: 0,
          maxHeight: a,
          minPixels: 0,
          maxPixels: Infinity,
          minFrameRate: 0,
          maxFrameRate: Infinity,
          minBandwidth: 0,
          maxBandwidth: Infinity
        }, advanced: { minTotalBytes: 128e3, minBytes: 16e3, fastHalfLife: 2, slowHalfLife: 5 }, restrictToElementSize: false, restrictToScreenSize: false, ignoreDevicePixelRatio: false }, autoShowText: 3, preferredAudioLanguage: "", preferredTextLanguage: "", preferredVariantRole: "", preferredTextRole: "", preferredAudioChannelCount: 2, preferredVideoCodecs: [], preferredAudioCodecs: [], preferForcedSubs: false, preferredDecodingAttributes: [], restrictions: {
          minWidth: 0,
          maxWidth: Infinity,
          minHeight: 0,
          maxHeight: Infinity,
          minPixels: 0,
          maxPixels: Infinity,
          minFrameRate: 0,
          maxFrameRate: Infinity,
          minBandwidth: 0,
          maxBandwidth: Infinity
        }, playRangeStart: 0, playRangeEnd: Infinity, textDisplayFactory: function() {
          return null;
        }, cmcd: { enabled: false, sessionId: "", contentId: "", useHeaders: false }, lcevc: { enabled: false, dynamicPerformanceScaling: true, logLevel: 0, drawLogo: false } };
        e.trackSelectionCallback = function(g) {
          return G(function(h) {
            return h.return(Fl(g, f.preferredAudioLanguage));
          });
        };
        return f;
      }
      function Gl(a, b, c) {
        var d = { ".drm.keySystemsMapping": "", ".drm.servers": "", ".drm.clearKeys": "", ".drm.advanced": { distinctiveIdentifierRequired: false, persistentStateRequired: false, videoRobustness: "", audioRobustness: "", sessionType: "", serverCertificate: new Uint8Array(0), serverCertificateUri: "", individualizationServer: "" } };
        return xl(a, b, c || El(), d, "");
      }
      function Fl(a, b) {
        var c = a.filter(function(g) {
          return "variant" == g.type;
        }), d = [], e = vd(b, c.map(function(g) {
          return g.language;
        }));
        e && (d = c.filter(function(g) {
          return od(g.language) == e;
        }));
        0 == d.length && (d = c.filter(function(g) {
          return g.primary;
        }));
        0 == d.length && (c.map(function(g) {
          return g.language;
        }), d = c);
        var f = d.filter(function(g) {
          return g.height && 480 >= g.height;
        });
        f.length && (f.sort(function(g, h) {
          return h.height - g.height;
        }), d = f.filter(function(g) {
          return g.height == f[0].height;
        }));
        b = [];
        d.length && (c = Math.floor(d.length / 2), d.sort(function(g, h) {
          return g.bandwidth - h.bandwidth;
        }), b.push(d[c]));
        a = r(a);
        for (d = a.next(); !d.done; d = a.next())
          d = d.value, d.type != jc && "image" != d.type || b.push(d);
        return b;
      }
      K("shaka.util.PlayerConfiguration", Dl);
      Dl.mergeConfigObjects = Gl;
      Dl.createDefault = El;
      function Hl() {
        this.g = null;
        this.h = [];
      }
      function Il(a, b) {
        if (null == a.g)
          a.g = { timestamp: Date.now() / 1e3, state: b, duration: 0 };
        else {
          var c = Date.now() / 1e3;
          a.g.duration = c - a.g.timestamp;
          a.g.state != b && (a.h.push(a.g), a.g = { timestamp: c, state: b, duration: 0 });
        }
      }
      function Jl(a, b) {
        var c = 0;
        a.g && a.g.state == b && (c += a.g.duration);
        a = r(a.h);
        for (var d = a.next(); !d.done; d = a.next())
          d = d.value, c += d.state == b ? d.duration : 0;
        return c;
      }
      function Kl(a) {
        function b(f) {
          return { timestamp: f.timestamp, state: f.state, duration: f.duration };
        }
        for (var c = [], d = r(a.h), e = d.next(); !e.done; e = d.next())
          c.push(b(e.value));
        a.g && c.push(b(a.g));
        return c;
      }
      function Ll() {
        this.i = this.h = null;
        this.g = [];
      }
      function Ml(a, b, c) {
        a.i != b && (a.i = b, a.g.push({ timestamp: Date.now() / 1e3, id: b.id, type: "text", fromAdaptation: c, bandwidth: null }));
      }
      function Nl() {
        this.u = this.B = this.G = this.D = this.s = this.j = this.F = this.m = this.i = this.M = this.O = this.H = this.J = this.L = this.l = this.o = NaN;
        this.g = new Hl();
        this.h = new Ll();
      }
      function V(a, b) {
        Ue.call(this);
        var c = this;
        this.l = Ol;
        this.Uc = this.g = null;
        this.ca = false;
        this.Xc = new mf();
        this.Xb = new mf();
        this.s = new mf();
        this.Nb = this.i = this.Yc = this.J = this.j = this.ua = this.L = this.cf = this.V = this.Fa = this.M = this.Vc = this.H = this.xb = this.B = this.G = this.m = this.D = null;
        this.dc = false;
        this.Nd = this.u = null;
        this.Yd = 1e9;
        this.h = Pl(this);
        this.ec = { width: Infinity, height: Infinity };
        this.o = null;
        this.ub = new Ae(this.h.preferredAudioLanguage, this.h.preferredVariantRole, this.h.preferredAudioChannelCount);
        this.vb = this.h.preferredTextLanguage;
        this.cc = this.h.preferredTextRole;
        this.$b = this.h.preferForcedSubs;
        this.Zb = [];
        this.fc = null;
        b && b(this);
        this.D = Ql(this);
        this.D.je(this.h.streaming.forceHTTPS);
        this.F = null;
        Rl && (this.F = Rl());
        this.Xc.C(window2, "online", function() {
          c.ce();
        });
        this.O = { name: "detach" };
        this.W = { name: "attach" };
        this.ea = { name: "unload" };
        this.Zd = { name: "manifest-parser" };
        this.Xd = { name: "manifest" };
        this.wb = { name: "media-source" };
        this.Qd = { name: "drm-engine" };
        this.ba = { name: "load" };
        this.de = { name: "src-equals-drm-engine" };
        this.yb = { name: "src-equals" };
        var d = /* @__PURE__ */ new Map();
        d.set(this.W, function(e, f) {
          return Pe(Sl(c, e, f));
        });
        d.set(this.O, function(e) {
          e.mediaElement && (c.Xb.nb(), e.mediaElement = null);
          c.F && c.F.release();
          c.g = null;
          e = Promise.resolve();
          return Pe(e);
        });
        d.set(this.ea, function(e) {
          return Pe(Tl(c, e));
        });
        d.set(this.wb, function(e) {
          e = Ul(c, e);
          return Pe(e);
        });
        d.set(this.Zd, function(e, f) {
          e = Vl(c, e, f);
          return Pe(e);
        });
        d.set(this.Xd, function(e) {
          return Wl(c, e);
        });
        d.set(this.Qd, function(e) {
          e = Xl(c, e);
          return Pe(e);
        });
        d.set(this.ba, function(e, f) {
          return Pe(Yl(c, e, f));
        });
        d.set(
          this.de,
          function(e, f) {
            e = Zl(c, e, f);
            return Pe(e);
          }
        );
        d.set(this.yb, function(e, f) {
          return $l(c, e, f);
        });
        this.Ga = new Gk(this.O, { Mf: function(e, f, g, h) {
          var k2 = null;
          e == c.O && (k2 = g == c.O ? c.O : c.W);
          e == c.W && (k2 = g == c.O || f.mediaElement != h.mediaElement ? c.O : g == c.W ? c.W : g == c.wb || g == c.ba ? c.wb : g == c.yb ? c.de : null);
          e == c.wb && (k2 = g == c.ba && f.mediaElement == h.mediaElement ? c.Zd : c.ea);
          e == c.Zd && (k2 = am(c.ba, c.Xd, c.ea, g, f, h));
          e == c.Xd && (k2 = am(c.ba, c.Qd, c.ea, g, f, h));
          e == c.Qd && (k2 = am(c.ba, c.ba, c.ea, g, f, h));
          e == c.de && (k2 = g == c.yb && f.mediaElement == h.mediaElement ? c.yb : c.ea);
          if (e == c.ba || e == c.yb)
            k2 = c.ea;
          e == c.ea && (k2 = h.mediaElement && f.mediaElement == h.mediaElement ? c.W : c.O);
          return k2;
        }, yf: function(e, f, g) {
          c.dispatchEvent(bm("onstatechange", (/* @__PURE__ */ new Map()).set("state", e.name)));
          return d.get(e)(f, g);
        }, handleError: function(e) {
          return G(function(f) {
            return 1 == f.g ? u(f, Tl(c, e), 2) : f.return(e.mediaElement ? c.W : c.O);
          });
        }, eg: function(e) {
          c.dispatchEvent(bm("onstateidle", (/* @__PURE__ */ new Map()).set("state", e.name)));
        } });
        this.af = new P(function() {
          Ld(c.i.variants, c.h.restrictions, c.ec) && cm(c);
        });
        a && this.Yb(
          a,
          true
        );
      }
      oa(V, Ue);
      function dm(a) {
        null != a.L && (a.L.release(), a.L = null);
      }
      function em(a, b) {
        if (b.lcevc.enabled) {
          var c = a.Xa();
          c && c[0] && c[0].videoMimeType == fm.ts && (rc() || navigator.userAgent.match(/Edge\//)) && (b.streaming.forceTransmux || Wa("LCEVC Warning: For MPEG-2 TS decoding the config.streaming.forceTransmux must be enabled."));
          dm(a);
          null == a.L && (a.L = new Hi(a.g, a.cf, b.lcevc), a.G && (a.G.D = a.L));
        } else
          dm(a);
      }
      function bm(a, b) {
        return new S(a, b);
      }
      q = V.prototype;
      q.destroy = function() {
        var a = this, b;
        return G(function(c) {
          switch (c.g) {
            case 1:
              if (a.l == gm)
                return c.return();
              dm(a);
              a.l = gm;
              b = Lk(a.Ga, function() {
                return { node: a.O, payload: Hk(), hb: false };
              });
              return u(c, new Promise(function(d) {
                b.Jb = function() {
                };
                b.bd = function() {
                  d();
                };
                b.mb = function() {
                  d();
                };
                b.onError = function() {
                  d();
                };
                b.dd = function() {
                  d();
                };
              }), 2);
            case 2:
              return u(c, a.Ga.destroy(), 3);
            case 3:
              a.Xc && (a.Xc.release(), a.Xc = null);
              a.Xb && (a.Xb.release(), a.Xb = null);
              a.s && (a.s.release(), a.s = null);
              a.Nd = null;
              a.u = null;
              a.h = null;
              a.o = null;
              a.Uc = null;
              a.V = null;
              if (!a.D) {
                c.A(4);
                break;
              }
              return u(c, a.D.destroy(), 5);
            case 5:
              a.D = null;
            case 4:
              Ue.prototype.release.call(a), A(c);
          }
        });
      };
      q.Yb = function(a, b) {
        b = void 0 === b ? true : b;
        if (this.l == gm)
          return Promise.reject(hm());
        var c = Hk();
        c.mediaElement = a;
        oc() || (b = false);
        var d = b ? this.wb : this.W;
        a = Lk(this.Ga, function() {
          return { node: d, payload: c, hb: false };
        });
        a.Jb = function() {
        };
        return im(a);
      };
      q.lf = function(a) {
        this.cf = a;
      };
      q.detach = function() {
        var a = this;
        if (this.l == gm)
          return Promise.reject(hm());
        var b = Lk(this.Ga, function() {
          return { node: a.O, payload: Hk(), hb: false };
        });
        b.Jb = function() {
        };
        return im(b);
      };
      q.re = function(a) {
        var b = this;
        a = void 0 === a ? true : a;
        if (this.l == gm)
          return Promise.reject(hm());
        this.dc = false;
        oc() || (a = false);
        dm(this);
        var c = Hk(), d = Lk(this.Ga, function(e) {
          var f = e.mediaElement && a ? b.wb : e.mediaElement ? b.W : b.O;
          c.mediaElement = e.mediaElement;
          return { node: f, payload: c, hb: false };
        });
        d.Jb = function() {
        };
        return im(d);
      };
      q.Fg = function(a) {
        this.fc = a;
      };
      q.load = function(a, b, c) {
        var d = this;
        this.fc = null;
        this.dc = false;
        if (this.l == gm)
          return Promise.reject(hm());
        this.dispatchEvent(bm("loading"));
        var e = Hk();
        e.uri = a;
        e.ne = Date.now() / 1e3;
        c && (e.mimeType = c);
        void 0 !== b && (e.startTime = b);
        var f = jm(this, e) ? this.yb : this.ba, g = Lk(this.Ga, function(h) {
          if (null == h.mediaElement)
            return null;
          e.mediaElement = h.mediaElement;
          return { node: f, payload: e, hb: true };
        });
        this.o = new Nl();
        this.V = km(this);
        g.Jb = function() {
        };
        return new Promise(function(h, k2) {
          g.dd = function() {
            return k2(new O(2, 7, 7002));
          };
          g.bd = function() {
            h();
            d.dispatchEvent(bm("loaded"));
          };
          g.mb = function() {
            return k2(hm());
          };
          g.onError = function(l) {
            return k2(l);
          };
        });
      };
      function jm(a, b) {
        if (!oc())
          return true;
        var c = b.mimeType, d = b.uri || "";
        c || (c = Ug(d), c = fm[c]);
        if (c) {
          if ("" == (b.mediaElement || qc()).canPlayType(c))
            return false;
          if (!oc() || !(c in Tg || Ug(d) in Vg) || a.h.streaming.preferNativeHls)
            return true;
          if (wc())
            return a.h.streaming.useNativeHlsOnSafari;
        }
        return false;
      }
      function Sl(a, b, c) {
        null == b.mediaElement && (b.mediaElement = c.mediaElement, a.Xb.C(b.mediaElement, "error", function() {
          var d = lm(a);
          d && mm(a, d);
        }));
        a.g = b.mediaElement;
        return Promise.resolve();
      }
      function Tl(a, b) {
        var c, d, e, f, g, h, k2, l, m;
        return G(function(n) {
          switch (n.g) {
            case 1:
              return a.l != gm && (a.l = Ol), c = a.Zb.map(function(p) {
                return p();
              }), a.Zb = [], u(n, Promise.all(c), 2);
            case 2:
              a.dispatchEvent(bm("unloading"));
              b.mimeType = null;
              b.startTime = null;
              b.uri = null;
              a.Fa && (a.Fa.release(), a.Fa = null);
              b.mediaElement && a.s.nb();
              a.af.stop();
              a.xb && (a.xb.release(), a.xb = null);
              a.Vc && (a.Vc.stop(), a.Vc = null);
              if (!a.J) {
                n.A(3);
                break;
              }
              return u(n, a.J.stop(), 4);
            case 4:
              a.J = null, a.Yc = null;
            case 3:
              if (!a.u) {
                n.A(5);
                break;
              }
              return u(
                n,
                a.u.stop(),
                5
              );
            case 5:
              if (!a.j) {
                n.A(7);
                break;
              }
              return u(n, a.j.destroy(), 8);
            case 8:
              a.j = null;
            case 7:
              a.H && (a.H.release(), a.H = null);
              a.B && (a.B.release(), a.B = null);
              if (!a.G) {
                n.A(9);
                break;
              }
              return u(n, a.G.destroy(), 10);
            case 10:
              a.G = null;
            case 9:
              if (a.F)
                a.F.onAssetUnload();
              if (!b.mediaElement || !b.mediaElement.src) {
                n.A(11);
                break;
              }
              return u(n, new Promise(function(p) {
                return new P(p).N(0.1);
              }), 12);
            case 12:
              for (b.mediaElement.removeAttribute("src"), b.mediaElement.load(); b.mediaElement.lastChild; )
                b.mediaElement.removeChild(b.mediaElement.firstChild);
            case 11:
              if (!a.m) {
                n.A(13);
                break;
              }
              return u(n, a.m.destroy(), 14);
            case 14:
              a.m = null;
            case 13:
              a.Nb = null;
              a.M = null;
              if (a.i) {
                d = r(a.i.variants);
                for (e = d.next(); !e.done; e = d.next())
                  for (f = e.value, g = r([f.audio, f.video]), h = g.next(); !h.done; h = g.next())
                    (k2 = h.value) && k2.segmentIndex && k2.segmentIndex.release();
                l = r(a.i.textStreams);
                for (h = l.next(); !h.done; h = l.next())
                  m = h.value, m.segmentIndex && m.segmentIndex.release();
              }
              a.i = null;
              a.o = new Nl();
              a.Ud = null;
              nm(a);
              A(n);
          }
        });
      }
      function Ul(a, b) {
        var c, d, e, f, g;
        return G(function(h) {
          if (1 == h.g)
            return c = a.h.textDisplayFactory, d = c(), a.Ud = c, e = om(b.mediaElement, d, function(k2, l, m) {
              pm(a, k2, l, m);
            }, a.L), e.configure(a.h.mediaSource), f = a.h.manifest, g = f.segmentRelativeVttTiming, e.H = g, u(h, e.J, 2);
          a.G = e;
          A(h);
        });
      }
      function Vl(a, b, c) {
        var d, e, f, g;
        return G(function(h) {
          if (1 == h.g)
            return b.mimeType = c.mimeType, b.uri = c.uri, d = b.uri, e = a.D, a.Nb = d, f = a, u(h, Sg(d, e, a.h.manifest.retryParameters, b.mimeType), 2);
          f.Yc = h.h;
          a.J = a.Yc();
          g = Ve(a.h.manifest);
          c.mediaElement && "AUDIO" === c.mediaElement.nodeName && (g.disableVideo = true);
          a.J.configure(g);
          A(h);
        });
      }
      function Wl(a, b) {
        var c = b.uri;
        b = a.D;
        a.Fa = new Wj(function() {
          return a.uc();
        });
        a.Fa.addEventListener("regionadd", function(f) {
          f = f.region;
          qm(a, "timelineregionadded", f);
          if (a.F)
            a.F.onDashTimedMetadata(f);
        });
        a.ua = null;
        a.h.streaming.observeQualityChanges && (a.ua = new Sj(function() {
          return a.Na();
        }), a.ua.addEventListener("qualitychange", function(f) {
          var g = f.quality;
          f = f.position;
          g = (/* @__PURE__ */ new Map()).set("mediaQuality", {
            bandwidth: g.bandwidth,
            audioSamplingRate: g.audioSamplingRate,
            codecs: g.codecs,
            contentType: g.contentType,
            frameRate: g.frameRate,
            height: g.height,
            mimeType: g.mimeType,
            channelsCount: g.channelsCount,
            pixelAspectRatio: g.pixelAspectRatio,
            width: g.width
          }).set("position", f);
          a.dispatchEvent(bm("mediaqualitychanged", g));
        }));
        var d = {
          networkingEngine: b,
          modifyManifestRequest: function(f, g) {
            var h = a.V;
            try {
              h.g.enabled && (h.o = g.format, nl(h, f, { ot: ql, su: !h.i }));
            } catch (k2) {
              Xa("CMCD_MANIFEST_ERROR", "Could not generate manifest CMCD data.", k2);
            }
          },
          modifySegmentRequest: function(f, g) {
            dl(a.V, f, g);
          },
          filter: function(f) {
            return rm(a, f);
          },
          makeTextStreamsForClosedCaptions: function(f) {
            return sm(
              a,
              f
            );
          },
          onTimelineRegionAdded: function(f) {
            var g = a.Fa;
            a: {
              var h = r(g.g);
              for (var k2 = h.next(); !k2.done; k2 = h.next())
                if (k2 = k2.value, k2.schemeIdUri == f.schemeIdUri && k2.id == f.id && k2.startTime == f.startTime && k2.endTime == f.endTime) {
                  h = k2;
                  break a;
                }
              h = null;
            }
            null == h && (g.g.add(f), f = new S("regionadd", /* @__PURE__ */ new Map([["region", f]])), g.dispatchEvent(f));
          },
          onEvent: function(f) {
            return a.dispatchEvent(f);
          },
          onError: function(f) {
            return mm(a, f);
          },
          isLowLatencyMode: function() {
            return a.h.streaming.lowLatencyMode;
          },
          isAutoLowLatencyMode: function() {
            return a.h.streaming.autoLowLatencyMode;
          },
          enableLowLatencyMode: function() {
            a.configure("streaming.lowLatencyMode", true);
          },
          updateDuration: function() {
            a.j && a.j.updateDuration();
          },
          newDrmInfo: function(f) {
            var g = a.m ? a.m.g : null;
            g && a.m.u && tm(a, g.keySystem, f);
          }
        }, e = Date.now() / 1e3;
        return new Le(function() {
          var f, g, h, k2;
          return G(function(l) {
            if (1 == l.g)
              return f = a, u(l, a.J.start(c, d), 2);
            f.i = l.h;
            g = bm("manifestparsed");
            a.dispatchEvent(g);
            if (0 == a.i.variants.length)
              throw new O(2, 4, 4036);
            um(a.i);
            h = Date.now() / 1e3;
            k2 = h - e;
            a.o.F = k2;
            A(l);
          });
        }(), function() {
          return a.J.stop();
        });
      }
      function Xl(a, b) {
        var c, d;
        return G(function(e) {
          return 1 == e.g ? (c = Date.now() / 1e3, d = true, a.m = vm(a, { kb: a.D, onError: function(f) {
            mm(a, f);
          }, cd: function(f) {
            wm(a, f);
          }, onExpirationUpdated: function(f, g) {
            xm(a, f, g);
          }, onEvent: function(f) {
            a.dispatchEvent(f);
            "drmsessionupdate" == f.type && d && (d = false, a.o.j = Date.now() / 1e3 - c, a.L && (f = a.L, f.g && f.h.classList.add("shaka-hidden")));
          } }), a.m.configure(a.h.drm), u(e, mg(a.m, a.i.variants, a.i.offlineSessionIds), 2)) : 3 != e.g ? u(e, a.m.Yb(b.mediaElement), 3) : u(e, rm(a, a.i), 0);
        });
      }
      function Yl(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z;
        return G(function(B) {
          switch (B.g) {
            case 1:
              b.startTime = c.startTime;
              null != a.fc && (b.startTime = a.fc, a.fc = null);
              d = b.mediaElement;
              e = b.uri;
              a.Nb = e;
              a.H = new Oj({ Tc: function() {
                return d.playbackRate;
              }, Pc: function() {
                return d.defaultPlaybackRate;
              }, le: function(E) {
                d.playbackRate = E;
              }, Me: function(E) {
                d.currentTime += E;
              } });
              f = function() {
                return ym(a);
              };
              g = function() {
                return zm(a);
              };
              a.s.C(d, "playing", f);
              a.s.C(d, "pause", f);
              a.s.C(d, "ended", f);
              a.s.C(d, "ratechange", g);
              em(a, a.h);
              h = a.h.abrFactory;
              a.u && a.Nd == h || (a.Nd = h, a.u = h(), "function" != typeof a.u.setMediaElement && (re("AbrManager", "Please use an AbrManager with setMediaElement function."), a.u.setMediaElement = function() {
              }), a.u.configure(a.h.abr));
              a.ub = new Ae(a.h.preferredAudioLanguage, a.h.preferredVariantRole, a.h.preferredAudioChannelCount);
              a.vb = a.h.preferredTextLanguage;
              a.cc = a.h.preferredTextRole;
              a.$b = a.h.preferForcedSubs;
              Am(a.i.presentationTimeline, a.h.playRangeStart, a.h.playRangeEnd);
              a.u.init(function(E, F, H) {
                a.j && E != a.j.l && Bm(a, E, true, void 0 === F ? false : F, void 0 === H ? 0 : H);
              });
              a.u.setMediaElement(d);
              xd(a.i, a.h.preferredVideoCodecs, a.h.preferredAudioCodecs, a.h.preferredAudioChannelCount, a.h.preferredDecodingAttributes);
              a.j = Cm(a);
              a.j.configure(a.h.streaming);
              a.l = Dm;
              d.textTracks && a.s.C(d.textTracks, "addtrack", function(E) {
                if (E.track)
                  switch (E = E.track, E.kind) {
                    case "chapters":
                      Em(a, E);
                  }
              });
              a.dispatchEvent(bm("streaming"));
              k2 = null;
              (l = a.j.l) || (k2 = cm(a));
              m = [];
              n = l || k2;
              p = r([n.video, n.audio]);
              for (t = p.next(); !t.done; t = p.next())
                (v = t.value) && !v.segmentIndex && m.push(v.createSegmentIndex());
              if (!(0 < m.length)) {
                B.A(2);
                break;
              }
              return u(B, Promise.all(m), 2);
            case 2:
              a.B = Fm(a, b.startTime);
              a.xb = Gm(a);
              y = Math.max(a.i.minBufferTime, a.h.streaming.rebufferingGoal);
              Hm(a, y);
              if (l) {
                B.A(4);
                break;
              }
              Bm(a, k2, true, false, 0);
              if (!a.h.streaming.startAtSegmentBoundary) {
                B.A(5);
                break;
              }
              w = a.B.Ic();
              return u(B, Im(k2, w), 6);
            case 6:
              x = B.h, a.B.zd(x);
            case 5:
              Jm(a, null, $d(k2));
            case 4:
              return a.B.yd(), C = a.Fb().find(function(E) {
                return E.active;
              }), C || ((z = je(a.i.textStreams, a.vb, a.cc, a.$b)[0] || null) && Ml(a.o.h, z, true), k2 && (z ? (k2.audio && Km(a, k2.audio, z) && (a.ca = true), a.ca && a.G.m.setTextVisibility(true), Lm(a)) : a.ca = false), z && (a.h.streaming.alwaysStreamText || a.Hd()) && pk(a.j, z)), u(B, a.j.start(), 7);
            case 7:
              a.h.abr.enabled && (a.u.enable(), Mm(a)), Od(a.j ? a.j.l : null, a.i), Nm(a.i), Om(a), Pm(a), a.i.variants.some(function(E) {
                return E.primary;
              }), a.dc = true, a.s.ma(d, "loadedmetadata", function() {
                a.o.m = Date.now() / 1e3 - c.ne;
              }), A(B);
          }
        });
      }
      function Zl(a, b, c) {
        var d, e, f, g, h, k2, l;
        return G(function(m) {
          return 1 == m.g ? (d = kc, e = Date.now() / 1e3, f = true, a.m = vm(a, { kb: a.D, onError: function(n) {
            mm(a, n);
          }, cd: function(n) {
            wm(a, n);
          }, onExpirationUpdated: function(n, p) {
            xm(a, n, p);
          }, onEvent: function(n) {
            a.dispatchEvent(n);
            "drmsessionupdate" == n.type && f && (f = false, a.o.j = Date.now() / 1e3 - e);
          } }), a.m.configure(a.h.drm), g = c.uri || "", h = Ug(g), k2 = fm[h], "application/x-mpegurl" == k2 && wc() && (k2 = "application/vnd.apple.mpegurl"), k2 || (k2 = "video/mp4"), l = {
            id: 0,
            language: "und",
            disabledUntilTime: 0,
            primary: false,
            audio: null,
            video: { id: 0, originalId: null, createSegmentIndex: function() {
              return Promise.resolve();
            }, segmentIndex: null, mimeType: c.mimeType ? c.mimeType.split(";")[0] : k2, codecs: c.mimeType ? cd(c.mimeType) : "", encrypted: true, drmInfos: [], keyIds: /* @__PURE__ */ new Set(), language: "und", label: null, type: d.va, primary: false, trickModeVideo: null, emsgSchemeIdUris: null, roles: [], forced: false, channelsCount: null, audioSamplingRate: null, spatialAudio: false, closedCaptions: null },
            bandwidth: 100,
            allowedByApplication: true,
            allowedByKeySystem: true,
            decodingInfos: []
          }, a.m.V = true, u(m, mg(a.m, [l], []), 2)) : u(m, a.m.Yb(b.mediaElement), 0);
        });
      }
      function $l(a, b, c) {
        function d() {
          return ym(a);
        }
        b.uri = c.uri;
        b.startTime = c.startTime;
        a.Nb = b.uri;
        var e = b.mediaElement;
        a.B = new Cj(e);
        var f = false;
        a.Zb.push(function() {
          f = true;
        });
        null != b.startTime && a.B.zd(b.startTime);
        a.H = new Oj({ Tc: function() {
          return e.playbackRate;
        }, Pc: function() {
          return e.defaultPlaybackRate;
        }, le: function(k2) {
          e.playbackRate = k2;
        }, Me: function(k2) {
          e.currentTime += k2;
        } });
        Hm(a, a.h.streaming.rebufferingGoal);
        a.s.C(e, "playing", d);
        a.s.C(e, "pause", d);
        a.s.C(e, "ended", d);
        a.s.C(e, "ratechange", function() {
          return zm(a);
        });
        "none" != e.preload && a.s.ma(e, "loadedmetadata", function() {
          a.o.m = Date.now() / 1e3 - c.ne;
        });
        e.audioTracks && (a.s.C(e.audioTracks, "addtrack", function() {
          return Om(a);
        }), a.s.C(e.audioTracks, "removetrack", function() {
          return Om(a);
        }), a.s.C(e.audioTracks, "change", function() {
          return Om(a);
        }));
        e.textTracks && (a.s.C(e.textTracks, "addtrack", function(k2) {
          if (k2.track)
            switch (k2 = k2.track, k2.kind) {
              case "metadata":
                Qm(a, k2);
                break;
              case "chapters":
                Em(a, k2);
                break;
              default:
                Om(a);
            }
        }), a.s.C(e.textTracks, "removetrack", function() {
          return Om(a);
        }), a.s.C(e.textTracks, "change", function() {
          return Om(a);
        }));
        var g = Ug(b.uri);
        e.src = ol(a.V, b.uri, fm[g]);
        (uc() || tc("Web0S")) && e.load();
        a.l = Rm;
        a.dispatchEvent(bm("streaming"));
        var h = new lc2();
        tj(e, HTMLMediaElement.HAVE_METADATA, a.s, function() {
          a.B.yd();
          h.resolve();
        });
        tj(e, HTMLMediaElement.HAVE_CURRENT_DATA, a.s, function() {
          var k2;
          return G(function(l) {
            if (1 == l.g)
              return Sm(a), k2 = Tm(a), k2.find(function(m) {
                return "disabled" != m.mode;
              }) ? (0 < k2.length && (a.ca = true), l.A(2)) : u(l, new Promise(function(m) {
                a.s.ma(
                  e.textTracks,
                  "change",
                  m
                );
                new P(m).N(1);
              }), 2);
            if (f)
              return l.return();
            Um(a);
            A(l);
          });
        });
        e.error ? h.reject(lm(a)) : "none" == e.preload && (Wa('With <video preload="none">, the browser will not load anything until play() is called. We are unable to measure load latency in a meaningful way, and we cannot provide track info yet. Please do not use preload="none" with Shaka Player.'), h.resolve());
        a.s.ma(e, "error", function() {
          h.reject(lm(a));
        });
        return new Le(h, function() {
          h.reject(new O(2, 7, 7001));
          return Promise.resolve();
        }).Y(function() {
          a.dc = true;
        });
      }
      function Sm(a) {
        var b = a.h.preferredAudioLanguage;
        if ("" != b) {
          a.ge(b);
          var c = a.h.preferredVariantRole;
          "" != c && a.ge(b, c);
        }
      }
      function Um(a) {
        var b = a.h.preferredTextLanguage, c = a.h.preferForcedSubs;
        if ("" != b) {
          a.he(b, "", c);
          var d = a.h.preferredTextRole;
          "" != d && a.he(b, d, c);
        }
      }
      function Qm(a, b) {
        if ("metadata" == b.kind) {
          b.mode = "hidden";
          a.s.C(b, "cuechange", function() {
            if (b.activeCues) {
              for (var d = r(b.activeCues), e = d.next(); !e.done; e = d.next())
                if (e = e.value, Vm(a, e.startTime, e.endTime, e.type, e.value), a.F)
                  a.F.onCueMetadataChange(e.value);
            }
          });
          var c = new P(function() {
            var d = Wm(a);
            d = r(d);
            for (var e = d.next(); !e.done; e = d.next())
              e.value.mode = "hidden";
          }).Mb().N(0.5);
          a.Zb.push(function() {
            c.stop();
          });
        }
      }
      function pm(a, b, c, d) {
        b = r(b);
        for (var e = b.next(); !e.done; e = b.next())
          if (e = e.value, e.data && e.cueTime && e.frames) {
            var f = e.cueTime + c, g = d;
            g && f > g && (g = f);
            for (var h = r(e.frames), k2 = h.next(); !k2.done; k2 = h.next())
              Vm(a, f, g, "org.id3", k2.value);
            if (a.F)
              a.F.onHlsTimedMetadata(e, f);
          }
      }
      function Vm(a, b, c, d, e) {
        b = (/* @__PURE__ */ new Map()).set("startTime", b).set("endTime", c).set("metadataType", d).set("payload", e);
        a.dispatchEvent(bm("metadata", b));
      }
      function Em(a, b) {
        if (b && "chapters" == b.kind) {
          b.mode = "hidden";
          var c = new P(function() {
            b.mode = "hidden";
          }).Mb().N(0.5);
          a.Zb.push(function() {
            c.stop();
          });
        }
      }
      function um(a) {
        function b(c) {
          return c.video && c.audio || c.video && c.video.codecs.includes(",");
        }
        a.variants.some(b) && (a.variants = a.variants.filter(b));
      }
      function vm(a, b) {
        return new fg(b, a.h.drm.updateExpirationTime);
      }
      function Ql(a) {
        return new Ze(function(b, c) {
          a.u && a.u.segmentDownloaded(b, c);
        }, function(b, c, d) {
          b = (/* @__PURE__ */ new Map()).set("headers", b).set("request", c).set("requestType", d);
          a.dispatchEvent(bm("downloadheadersreceived", b));
        }, function(b, c, d, e) {
          b = (/* @__PURE__ */ new Map()).set("request", b).set("error", c).set("httpResponseCode", d).set("aborted", e);
          a.dispatchEvent(bm("downloadfailed", b));
        });
      }
      function Fm(a, b) {
        return new Dj(a.g, a.i, a.h.streaming, b, function() {
          a.xb && Rj(a.xb, true);
          a.j && a.j.vc();
          a.M && Xm(a);
        }, function(c) {
          return a.dispatchEvent(c);
        });
      }
      function Gm(a) {
        var b = new Xj(a.Fa);
        b.addEventListener("enter", function(d) {
          qm(a, "timelineregionenter", d.region);
        });
        b.addEventListener("exit", function(d) {
          qm(a, "timelineregionexit", d.region);
        });
        b.addEventListener("skip", function(d) {
          var e = d.region;
          d.seeking || (qm(a, "timelineregionenter", e), qm(a, "timelineregionexit", e));
        });
        var c = new Qj(a.g);
        c.g.add(b);
        a.ua && c.g.add(a.ua);
        return c;
      }
      function Hm(a, b) {
        a.M = new Ee();
        a.M.g = Ge;
        He(a.M, b, Math.min(0.5, b / 2));
        nm(a);
        a.Vc = new P(function() {
          Xm(a);
        }).Ca(0.25);
      }
      function Xm(a) {
        switch (a.l) {
          case Rm:
            if (a.g.ended)
              var b = true;
            else {
              var c = ui(a.g.buffered);
              b = null != c && c >= a.g.duration - 1;
            }
            break;
          case Dm:
            a:
              if (a.g.ended || Si(a.G))
                b = true;
              else {
                if (a.i.presentationTimeline.U()) {
                  c = a.i.presentationTimeline.gb();
                  var d = ui(a.g.buffered);
                  if (null != d && d >= c) {
                    b = true;
                    break a;
                  }
                }
                b = false;
              }
            break;
          default:
            b = false;
        }
        d = wi(a.g.buffered, a.g.currentTime);
        c = a.M;
        var e = b, f = c.h.get(c.g);
        b = c.g;
        d = e || d >= f ? Fe : Ge;
        c.g = d;
        b != d && nm(a);
      }
      function om(a, b, c, d) {
        return new Mi(a, b, c, d);
      }
      function km(a) {
        return new cl({ getBandwidthEstimate: function() {
          return a.u ? a.u.getBandwidthEstimate() : NaN;
        }, Na: function() {
          return a.Na();
        }, getCurrentTime: function() {
          return a.g ? a.g.currentTime : 0;
        }, Xa: function() {
          return a.Xa();
        }, Rc: function() {
          return a.Rc();
        }, U: function() {
          return a.U();
        } }, a.h.cmcd);
      }
      function Cm(a) {
        return new dk(a.i, { Sc: function() {
          return a.B ? a.B.Ic() : 0;
        }, getBandwidthEstimate: function() {
          return a.u.getBandwidthEstimate();
        }, modifySegmentRequest: function(b, c) {
          dl(a.V, b, c);
        }, R: a.G, kb: a.D, onError: function(b) {
          return mm(a, b);
        }, onEvent: function(b) {
          return a.dispatchEvent(b);
        }, gg: function() {
          a.J && a.J.update && a.J.update();
        }, Wd: function(b, c, d) {
          a.B && a.B.Ne();
          Xm(a);
          b = (/* @__PURE__ */ new Map()).set("start", b).set("end", c).set("contentType", d);
          a.dispatchEvent(bm("segmentappended", b));
        }, fg: function(b, c) {
          (c = c.Od) && a.ua && Uj(a.ua, c, b);
        }, xe: function(b, c) {
          var d = a.m;
          if (d.h.parseInbandPsshEnabled && ["audio", "video"].includes(b)) {
            c = new Jf(M(c));
            var e = 0, f = r(c.data);
            for (b = f.next(); !b.done; b = f.next())
              e += b.value.length;
            if (0 == e)
              d = Promise.resolve();
            else {
              e = new Uint8Array(e);
              f = 0;
              c = r(c.data);
              for (b = c.next(); !b.done; b = c.next())
                b = b.value, e.set(b, f), f += b.length;
              vg(d, "cenc", e);
              d = d.o;
            }
          } else
            d = Promise.resolve();
          return d;
        }, hg: function(b, c, d) {
          pm(a, b, c, d);
        } });
      }
      q.configure = function(a, b) {
        2 == arguments.length && "string" == typeof a && (a = yl(a, b));
        a.streaming && "forceTransmuxTS" in a.streaming && (re("streaming.forceTransmuxTS configuration", "Please Use streaming.forceTransmux instead."), a.streaming.forceTransmux = a.streaming.forceTransmuxTS, delete a.streaming.forceTransmuxTS);
        a.streaming && a.streaming.lowLatencyMode && (void 0 == a.streaming.inaccurateManifestTolerance && (a.streaming.inaccurateManifestTolerance = 0), void 0 == a.streaming.rebufferingGoal && (a.streaming.rebufferingGoal = 0.01));
        var c = Gl(this.h, a, Pl(this));
        Ym(this);
        return c;
      };
      function Ym(a) {
        if (a.J) {
          var b = Ve(a.h.manifest);
          a.g && "AUDIO" === a.g.nodeName && (b.disableVideo = true);
          a.J.configure(b);
        }
        a.m && a.m.configure(a.h.drm);
        if (a.j) {
          a.j.configure(a.h.streaming);
          try {
            Zm(a, a.i);
          } catch (f) {
            mm(a, f);
          }
          a.u && Pm(a);
          b = a.j.l;
          !b || b.allowedByApplication && b.allowedByKeySystem || $m(a);
        }
        a.D && a.D.je(a.h.streaming.forceHTTPS);
        if (a.G && (a.G.configure(a.h.mediaSource), a.G.H = a.h.manifest.segmentRelativeVttTiming, b = a.h.textDisplayFactory, a.Ud != b)) {
          var c = b(), d = a.G, e = d.m;
          d.m = c;
          e && (c.setTextVisibility(e.isTextVisible()), e.destroy());
          d.g && (d.g.i = c);
          a.Ud = b;
          a.j && (b = a.j, (c = b.j.get(jc)) && nk(b, c.stream, true, 0, true));
        }
        a.u && (a.u.configure(a.h.abr), a.h.abr.enabled ? a.u.enable() : a.u.disable(), Mm(a));
        a.M && (b = a.h.streaming.rebufferingGoal, a.i && (b = Math.max(b, a.i.minBufferTime)), He(a.M, b, Math.min(0.5, b / 2)));
        a.i && Am(a.i.presentationTimeline, a.h.playRangeStart, a.h.playRangeEnd);
      }
      q.getConfiguration = function() {
        var a = Pl(this);
        Gl(a, this.h, Pl(this));
        return a;
      };
      q.Bf = function() {
        if (this.g) {
          var a = this.g.buffered.length;
          a = a ? this.g.buffered.end(a - 1) : 0;
          var b = this.getConfiguration().streaming.bufferingGoal;
          b = Math.min(this.g.currentTime + b, this.uc().end);
          if (a >= b)
            return 1;
          if (!(a <= this.g.currentTime) && a < b)
            return (a - this.g.currentTime) / (b - this.g.currentTime);
        }
        return 0;
      };
      q.rg = function() {
        for (var a in this.h)
          delete this.h[a];
        Gl(this.h, Pl(this), Pl(this));
        Ym(this);
      };
      q.Hf = function() {
        return this.l;
      };
      q.Lf = function() {
        return this.g;
      };
      q.jc = function() {
        return this.D;
      };
      q.Dd = function() {
        return this.Nb;
      };
      q.Ge = function() {
        return this.F ? this.F : null;
      };
      q.U = function() {
        return this.i ? this.i.presentationTimeline.U() : this.g && this.g.src ? Infinity == this.g.duration : false;
      };
      q.jb = function() {
        return this.i ? this.i.presentationTimeline.jb() : false;
      };
      q.Zf = function() {
        if (this.i) {
          var a = this.i.variants;
          return a.length ? !a[0].video : false;
        }
        return this.g && this.g.src ? this.g.videoTracks ? 0 == this.g.videoTracks.length : 0 == this.g.videoHeight : false;
      };
      q.uc = function() {
        if (!this.dc)
          return { start: 0, end: 0 };
        if (this.i) {
          var a = this.i.presentationTimeline;
          return { start: a.Db(), end: a.Oa() };
        }
        return this.g && this.g.src && (a = this.g.seekable, a.length) ? { start: a.start(0), end: a.end(a.length - 1) } : { start: 0, end: 0 };
      };
      q.Xf = function() {
        this.U() && (this.g.currentTime = this.uc().end);
      };
      q.keySystem = function() {
        var a = this.drmInfo();
        return a ? a.keySystem : "";
      };
      q.drmInfo = function() {
        return this.m ? this.m.g : null;
      };
      q.ic = function() {
        return this.m ? this.m.ic() : Infinity;
      };
      q.Qc = function() {
        return this.m ? this.m.Qc() : {};
      };
      q.Fd = function() {
        return this.M ? this.M.g == Ge : false;
      };
      q.Rc = function() {
        return this.g ? this.H ? this.H.i : 1 : 0;
      };
      q.Ag = function(a) {
        0 == a ? Wa("A trick play rate of 0 is unsupported!") : (this.g.paused && this.g.play(), this.H.set(a), this.l == Dm && (this.u.playbackRateChanged(a), mk(this.j, 1 < Math.abs(a))));
      };
      q.pf = function() {
        var a = this.H.Pc();
        this.l == Rm && this.H.set(a);
        this.l == Dm && (this.H.set(a), this.u.playbackRateChanged(a), mk(this.j, false));
      };
      q.Xa = function() {
        if (this.i) {
          for (var a = this.j ? this.j.l : null, b = [], c = 0, d = r(this.i.variants), e = d.next(); !e.done; e = d.next())
            if (e = e.value, he(e)) {
              var f = $d(e);
              f.active = e == a;
              f.active || 1 == c || null == a || e.video != a.video || e.audio != a.audio || (f.active = true);
              f.active && c++;
              b.push(f);
            }
          return b;
        }
        return this.g && this.g.audioTracks ? Array.from(this.g.audioTracks).map(function(g) {
          return ge(g);
        }) : [];
      };
      q.Fb = function() {
        if (this.i) {
          for (var a = this.j ? this.j.o : null, b = [], c = r(this.i.textStreams), d = c.next(); !d.done; d = c.next()) {
            d = d.value;
            var e = ae(d);
            e.active = d == a;
            b.push(e);
          }
          return b;
        }
        return this.g && this.g.src && this.g.textTracks ? Tm(this).map(function(f) {
          return ee(f);
        }) : [];
      };
      q.Ff = function() {
        return this.i ? this.i.imageStreams.map(function(a) {
          return be(a);
        }) : [];
      };
      q.Tf = function(a, b) {
        var c = this, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F;
        return G(function(H) {
          if (1 == H.g)
            return c.i ? (d = c.i.imageStreams.find(function(I) {
              return I.id == a;
            })) ? d.segmentIndex ? H.A(3) : u(H, d.createSegmentIndex(), 3) : H.return(null) : H.A(2);
          if (2 != H.g) {
            e = d.segmentIndex.find(b);
            if (null == e)
              return H.return(null);
            f = d.segmentIndex.get(e);
            g = f.tilesLayout || d.tilesLayout;
            h = /(\d+)x(\d+)/.exec(g);
            if (!h)
              return H.return(null);
            k2 = d.width || 0;
            l = d.height || 0;
            m = parseInt(h[1], 10);
            n = parseInt(h[2], 10);
            p = k2 / m;
            t = l / n;
            v = m * n;
            y = f.j - f.startTime;
            w = f.s || y / v;
            x = f.startTime;
            z = C = 0;
            1 < v && (B = Math.floor((b - f.startTime) / w), x = f.startTime + B * w, C = B % m * p, z = Math.floor(B / m) * t);
            E = false;
            if (F = f.o)
              E = true, t = F.height, C = F.positionX, z = F.positionY, p = F.width;
            return H.return({ imageHeight: l, imageWidth: k2, height: t, positionX: C, positionY: z, startTime: x, duration: w, uris: f.ya(), width: p, sprite: E });
          }
          return H.return(null);
        });
      };
      q.Se = function(a) {
        if (this.i && this.j) {
          var b = this.i.textStreams.find(function(d) {
            return d.id == a.id;
          });
          b && b != this.j.o && (Ml(this.o.h, b, false), pk(this.j, b), an(this), this.vb = b.language);
        } else if (this.g && this.g.src && this.g.textTracks) {
          b = Tm(this);
          b = r(b);
          for (var c = b.next(); !c.done; c = b.next())
            c = c.value, ce(c) == a.id ? c.mode = this.ca ? "showing" : "hidden" : c.mode = "disabled";
          an(this);
        }
      };
      q.Te = function(a, b, c) {
        b = void 0 === b ? false : b;
        c = void 0 === c ? 0 : c;
        if (this.i && this.j) {
          this.h.abr.enabled && Wa("Changing tracks while abr manager is enabled will likely result in the selected track being overriden. Consider disabling abr before calling selectVariantTrack().");
          var d = this.i.variants.find(function(e) {
            return e.id == a.id;
          });
          d && he(d) && (Bm(this, d, false, b, c), this.ub = new ze(d), Pm(this));
        } else if (this.g && this.g.audioTracks) {
          for (b = Array.from(this.g.audioTracks), b = r(b), c = b.next(); !c.done; c = b.next())
            if (c = c.value, ce(c) == a.id) {
              bn(this, c);
              break;
            }
        }
      };
      q.Af = function() {
        return cn(this.Xa());
      };
      q.Rf = function() {
        return cn(this.Fb());
      };
      q.zf = function() {
        return Array.from(dn(this.Xa()));
      };
      q.Qf = function() {
        return Array.from(dn(this.Fb()));
      };
      q.ge = function(a, b, c) {
        c = void 0 === c ? 0 : c;
        if (this.i && this.B) {
          this.ub = new Ae(a, b || "", c, "");
          b = function(h, k2) {
            return h.video || k2.video ? h.video && k2.video ? Math.abs((h.video.height || 0) - (k2.video.height || 0)) + Math.abs((h.video.width || 0) - (k2.video.width || 0)) : Infinity : 0;
          };
          a = this.j.l;
          var d = this.ub.create(this.i.variants);
          c = null;
          d = r(d.values());
          for (var e = d.next(); !e.done; e = d.next())
            if (e = e.value, !c || b(c, a) > b(e, a))
              c = e;
          c ? (b = $d(c), this.Te(b, true)) : $m(this);
        } else if (this.g && this.g.audioTracks) {
          e = Array.from(this.g.audioTracks);
          a = od(a);
          d = c = null;
          e = r(e);
          for (var f = e.next(); !f.done; f = e.next()) {
            f = f.value;
            var g = ge(f);
            od(g.language) == a && (c = f, b ? g.roles.includes(b) && (d = f) : 0 == g.roles.length && (d = f));
          }
          d ? bn(this, d) : c && bn(this, c);
        }
      };
      q.he = function(a, b, c) {
        c = void 0 === c ? false : c;
        if (this.i && this.B) {
          if (this.vb = a, this.cc = b || "", this.$b = c, (a = je(this.i.textStreams, this.vb, this.cc, this.$b)[0] || null) && a != this.j.o && (Ml(this.o.h, a, false), this.h.streaming.alwaysStreamText || this.Hd()))
            pk(this.j, a), an(this);
        } else {
          var d = od(a);
          (a = this.Fb().find(function(e) {
            return od(e.language) == d && (!b || e.roles.includes(b)) && e.forced == c;
          })) && this.Se(a);
        }
      };
      q.tg = function(a) {
        if (this.i && this.B) {
          for (var b = null, c = r(this.i.variants), d = c.next(); !d.done; d = c.next())
            if (d = d.value, d.audio.label == a) {
              b = d;
              break;
            }
          null != b && (this.ub = new Ae(b.language, "", 0, a), $m(this));
        }
      };
      q.Hd = function() {
        var a = this.ca;
        return this.G ? this.G.m.isTextVisible() : this.g && this.g.src && this.g.textTracks ? Tm(this).some(function(b) {
          return "showing" == b.mode;
        }) : a;
      };
      q.He = function() {
        return this.g && this.g.src && this.g.textTracks ? en(this).map(function(a) {
          return ee(a);
        }) : [];
      };
      q.Cf = function(a) {
        var b = od(a), c = en(this).filter(function(h) {
          return od(h.language) == b;
        });
        if (!c || !c.length)
          return [];
        a = [];
        var d = /* @__PURE__ */ new Set();
        c = r(c);
        for (var e = c.next(); !e.done; e = c.next())
          if ((e = e.value) && e.cues) {
            e = r(e.cues);
            for (var f = e.next(); !f.done; f = e.next()) {
              var g = f.value;
              (f = g.id) && "" != f || (f = g.startTime + "-" + g.endTime + "-" + g.text);
              g = { id: f, title: g.text, startTime: g.startTime, endTime: g.endTime };
              d.has(f) || (a.push(g), d.add(f));
            }
          }
        return a;
      };
      function Tm(a) {
        return Array.from(a.g.textTracks).filter(function(b) {
          return "metadata" != b.kind && "chapters" != b.kind && "Shaka Player TextTrack" != b.label;
        });
      }
      function Wm(a) {
        return Array.from(a.g.textTracks).filter(function(b) {
          return "metadata" == b.kind;
        });
      }
      function en(a) {
        return Array.from(a.g.textTracks).filter(function(b) {
          return "chapters" == b.kind;
        });
      }
      q.yg = function(a) {
        a = !!a;
        if (this.ca != a) {
          this.ca = a;
          if (this.l == Dm)
            this.G.m.setTextVisibility(a), this.h.streaming.alwaysStreamText || (a ? this.j.o || (a = je(this.i.textStreams, this.vb, this.cc, this.$b), 0 < a.length && (pk(this.j, a[0]), an(this))) : lk(this.j));
          else if (this.g && this.g.src && this.g.textTracks) {
            var b = Tm(this);
            b = r(b);
            for (var c = b.next(); !c.done; c = b.next())
              c = c.value, "disabled" != c.mode && (c.mode = a ? "showing" : "hidden");
          }
          Lm(this);
        }
      };
      q.Of = function() {
        if (!this.U())
          return null;
        var a = this.Ga.l, b = 0;
        if (this.B)
          b = this.B.Ic();
        else if (a) {
          if (null == a.startTime)
            return /* @__PURE__ */ new Date();
          b = a.startTime;
        }
        return this.i ? new Date(1e3 * (this.i.presentationTimeline.i + b)) : this.g && this.g.getStartDate ? (a = this.g.getStartDate(), isNaN(a.getTime()) ? null : new Date(a.getTime() + 1e3 * b)) : null;
      };
      q.Ie = function() {
        if (!this.U())
          return null;
        if (this.i)
          return new Date(1e3 * this.i.presentationTimeline.i);
        if (this.g && this.g.getStartDate) {
          var a = this.g.getStartDate();
          return isNaN(a.getTime()) ? null : a;
        }
        return null;
      };
      q.Na = function() {
        if (this.l == Dm)
          return this.G.Na();
        var a = { total: [], audio: [], video: [], text: [] };
        this.l == Rm && (a.total = xi(this.g.buffered));
        return a;
      };
      q.getStats = function() {
        if (this.l != Dm && this.l != Rm)
          return { width: NaN, height: NaN, streamBandwidth: NaN, decodedFrames: NaN, droppedFrames: NaN, corruptedFrames: NaN, stallsDetected: NaN, gapsJumped: NaN, estimatedBandwidth: NaN, completionPercent: NaN, loadLatency: NaN, manifestTimeSeconds: NaN, drmTimeSeconds: NaN, playTime: NaN, pauseTime: NaN, bufferingTime: NaN, licenseTime: NaN, liveLatency: NaN, maxSegmentDuration: NaN, switchHistory: [], stateHistory: [] };
        ym(this);
        var a = this.g, b = a.currentTime / a.duration;
        if (!isNaN(b)) {
          var c = this.o;
          b = Math.round(100 * b);
          c.i = isNaN(c.i) ? b : Math.max(c.i, b);
        }
        this.B && (this.o.M = this.B.te(), this.o.O = this.B.ue());
        if (a.getVideoPlaybackQuality) {
          c = a.getVideoPlaybackQuality();
          b = this.o;
          var d = Number(c.totalVideoFrames);
          b.L = Number(c.droppedVideoFrames);
          b.J = d;
          this.o.H = Number(c.corruptedVideoFrames);
        }
        this.m ? (c = this.m, c = c.H ? c.H : NaN) : c = NaN;
        this.o.s = c;
        if (this.l == Dm) {
          if (c = this.j.l)
            this.o.B = (this.H ? this.H.i : 1) * c.bandwidth;
          c && c.video && (b = this.o, d = c.video.height || NaN, b.o = c.video.width || NaN, b.l = d);
          this.U() && (c = this.Ie().valueOf() + 1e3 * this.uc().end, this.o.D = (Date.now() - c) / 1e3);
          this.i && this.i.presentationTimeline && (this.o.G = this.i.presentationTimeline.g);
          c = this.u.getBandwidthEstimate();
          this.o.u = c;
        }
        this.l == Rm && (c = this.o, b = a.videoHeight || NaN, c.o = a.videoWidth || NaN, c.l = b);
        var e = this.o;
        a = e.o;
        c = e.l;
        b = e.B;
        d = e.J;
        var f = e.L, g = e.H, h = e.O, k2 = e.M, l = e.u, m = e.i, n = e.m, p = e.F, t = e.j, v = Jl(e.g, "playing"), y = Jl(e.g, "paused"), w = Jl(e.g, "buffering"), x = e.s, C = e.D, z = e.G, B = Kl(e.g), E = [];
        e = r(e.h.g);
        for (var F = e.next(); !F.done; F = e.next())
          F = F.value, E.push({
            timestamp: F.timestamp,
            id: F.id,
            type: F.type,
            fromAdaptation: F.fromAdaptation,
            bandwidth: F.bandwidth
          });
        return { width: a, height: c, streamBandwidth: b, decodedFrames: d, droppedFrames: f, corruptedFrames: g, stallsDetected: h, gapsJumped: k2, estimatedBandwidth: l, completionPercent: m, loadLatency: n, manifestTimeSeconds: p, drmTimeSeconds: t, playTime: v, pauseTime: y, bufferingTime: w, licenseTime: x, liveLatency: C, maxSegmentDuration: z, stateHistory: B, switchHistory: E };
      };
      q.hf = function(a, b, c, d, e, f, g) {
        g = void 0 === g ? false : g;
        var h = this, k2, l, m, n, p, t, v, y, w, x, C;
        return G(function(z) {
          switch (z.g) {
            case 1:
              if (h.l != Dm && h.l != Rm)
                throw new O(1, 7, 7004);
              if (d) {
                z.A(2);
                break;
              }
              return u(z, fn(h, a), 3);
            case 3:
              d = z.h;
            case 2:
              k2 = [];
              if (h.F)
                try {
                  k2 = h.F.getServerSideCuePoints();
                } catch (B) {
                }
              if (h.l != Rm) {
                z.A(4);
                break;
              }
              g && (c = "forced");
              return u(z, gn(h, a, b, c, d, f || "", k2), 5);
            case 5:
              l = h.Fb();
              if (m = l.find(function(B) {
                return B.language == b && B.label == (f || "") && B.kind == c;
              }))
                return Om(h), z.return(m);
              throw new O(1, 2, 2012);
            case 4:
              n = kc;
              p = h.i.presentationTimeline.getDuration();
              if (Infinity == p)
                throw new O(1, 4, 4033);
              if (!k2.length) {
                z.A(6);
                break;
              }
              return u(z, hn(h, a, h.D, h.h.streaming.retryParameters), 7);
            case 7:
              t = z.h, v = jn(h, t, d, k2), y = new Blob([v], { type: "text/vtt" }), a = Pi(y), d = "text/vtt";
            case 6:
              w = {
                id: h.Yd++,
                originalId: null,
                createSegmentIndex: function() {
                  return Promise.resolve();
                },
                segmentIndex: Mj(0, p, [a]),
                mimeType: d || "",
                codecs: e || "",
                kind: c,
                encrypted: false,
                drmInfos: [],
                keyIds: /* @__PURE__ */ new Set(),
                language: b,
                label: f || null,
                type: n.X,
                primary: false,
                trickModeVideo: null,
                emsgSchemeIdUris: null,
                roles: [],
                forced: !!g,
                channelsCount: null,
                audioSamplingRate: null,
                spatialAudio: false,
                closedCaptions: null
              };
              x = Zc(w.mimeType, w.codecs);
              C = ed(x);
              if (!C)
                throw new O(2, 2, 2014, d);
              h.i.textStreams.push(w);
              Om(h);
              return z.return(ae(w));
          }
        });
      };
      q.jf = function(a, b) {
        var c = this, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C;
        return G(function(z) {
          switch (z.g) {
            case 1:
              if (c.l != Dm && c.l != Rm)
                throw new O(1, 7, 7004);
              if (c.l == Rm)
                throw new O(1, 2, 2016);
              if (b) {
                z.A(2);
                break;
              }
              return u(z, fn(c, a), 3);
            case 3:
              b = z.h;
            case 2:
              if ("text/vtt" != b)
                throw new O(1, 2, 2017, a);
              d = kc;
              e = c.i.presentationTimeline.getDuration();
              if (Infinity == e)
                throw new O(1, 4, 4045);
              return u(z, hn(c, a, c.D, c.h.streaming.retryParameters), 4);
            case 4:
              f = z.h;
              g = fd[b];
              if (!g)
                throw new O(2, 2, 2014, b);
              h = g();
              k2 = {
                periodStart: 0,
                segmentStart: 0,
                segmentEnd: e,
                vttOffset: 0
              };
              l = M(f);
              m = h.parseMedia(l, k2);
              n = [];
              p = {};
              t = r(m);
              for (v = t.next(); !v.done; p = { Rb: p.Rb }, v = t.next())
                y = v.value, p.Rb = ec([a], [y.payload])[0], w = new qi(y.startTime, y.endTime, function(B) {
                  return function() {
                    return [B.Rb];
                  };
                }(p), 0, null, null, 0, 0, Infinity), p.Rb.includes("#xywh") && (x = p.Rb.split("#xywh=")[1].split(","), 4 === x.length && w.Ye({ height: parseInt(x[3], 10), positionX: parseInt(x[0], 10), positionY: parseInt(x[1], 10), width: parseInt(x[2], 10) })), n.push(w);
              C = {
                id: c.Yd++,
                originalId: null,
                createSegmentIndex: function() {
                  return Promise.resolve();
                },
                segmentIndex: new Jj(n),
                mimeType: b || "",
                codecs: "",
                kind: "",
                encrypted: false,
                drmInfos: [],
                keyIds: /* @__PURE__ */ new Set(),
                language: "und",
                label: null,
                type: d.Wb,
                primary: false,
                trickModeVideo: null,
                emsgSchemeIdUris: null,
                roles: [],
                forced: false,
                channelsCount: null,
                audioSamplingRate: null,
                spatialAudio: false,
                closedCaptions: null,
                tilesLayout: "1x1"
              };
              c.i.imageStreams.push(C);
              Om(c);
              return z.return(be(C));
          }
        });
      };
      q.gf = function(a, b, c) {
        var d = this, e, f, g, h;
        return G(function(k2) {
          switch (k2.g) {
            case 1:
              if (d.l != Dm && d.l != Rm)
                throw new O(1, 7, 7004);
              if (c) {
                k2.A(2);
                break;
              }
              return u(k2, fn(d, a), 3);
            case 3:
              c = k2.h;
            case 2:
              e = [];
              if (d.F)
                try {
                  e = d.F.getServerSideCuePoints();
                } catch (l) {
                }
              return u(k2, gn(d, a, b, "chapters", c, "", e), 4);
            case 4:
              f = k2.h;
              g = d.He();
              h = g.find(function(l) {
                return l.language == b;
              });
              if (!h) {
                k2.A(5);
                break;
              }
              return u(k2, new Promise(function(l, m) {
                d.s.ma(f, "load", l);
                d.s.ma(f, "error", function() {
                  m(new O(1, 2, 2015));
                });
              }), 6);
            case 6:
              return k2.return(h);
            case 5:
              throw new O(1, 2, 2012);
          }
        });
      };
      function fn(a, b) {
        var c, d;
        return G(function(e) {
          switch (e.g) {
            case 1:
              c = Ug(b);
              if (d = kn[c])
                return e.return(d);
              D(e, 2);
              return u(e, Wg(b, a.D, a.h.streaming.retryParameters), 4);
            case 4:
              d = e.h;
              ta(e, 3);
              break;
            case 2:
              ua(e);
            case 3:
              if (d)
                return e.return(d);
              throw new O(1, 2, 2011, c);
          }
        });
      }
      function gn(a, b, c, d, e, f, g) {
        var h, k2, l, m;
        return G(function(n) {
          if (1 == n.g)
            return "text/vtt" != e || g.length ? u(n, hn(a, b, a.D, a.h.streaming.retryParameters), 3) : n.A(2);
          2 != n.g && (h = n.h, k2 = jn(a, h, e, g), l = new Blob([k2], { type: "text/vtt" }), b = Pi(l), e = "text/vtt");
          m = document.createElement("track");
          var p = a.V, t = b;
          try {
            if (p.g.enabled) {
              var v = pl(p);
              v.ot = vl;
              v.su = true;
              var y = rl(v);
              var w = sl(t, y);
            } else
              w = t;
          } catch (x) {
            Xa("CMCD_TEXT_TRACK_ERROR", "Could not generate text track CMCD data.", x), w = t;
          }
          m.src = w;
          m.label = f;
          m.kind = d;
          m.srclang = c;
          a.g.getAttribute("crossorigin") || a.g.setAttribute("crossorigin", "anonymous");
          a.g.appendChild(m);
          return n.return(m);
        });
      }
      function hn(a, b, c, d) {
        var e, f, g;
        return G(function(h) {
          if (1 == h.g) {
            e = jf;
            f = cf([b], d);
            f.method = "GET";
            var k2 = a.V;
            try {
              k2.g.enabled && nl(k2, f, { ot: vl, su: true });
            } catch (l) {
              Xa("CMCD_TEXT_ERROR", "Could not generate text CMCD data.", l);
            }
            return u(h, c.request(e, f).promise, 2);
          }
          g = h.h;
          return h.return(g.data);
        });
      }
      function jn(a, b, c, d) {
        var e = fd[c];
        if (e)
          return c = e(), a = { periodStart: 0, segmentStart: 0, segmentEnd: a.g.duration, vttOffset: 0 }, b = M(b), b = c.parseMedia(b, a), bl(b, d);
        throw new O(2, 2, 2014, c);
      }
      q.ke = function(a, b) {
        this.ec.width = a;
        this.ec.height = b;
      };
      q.ce = function(a) {
        if (this.l == Dm) {
          var b = this.j;
          a = void 0 === a ? 0.1 : a;
          if (b.h.g)
            b = false;
          else if (b.s)
            b = false;
          else {
            for (var c = r(b.j.values()), d = c.next(); !d.done; d = c.next())
              d = d.value, !d.nc || d.ra || d.Ka || (d.nc = false, kk(b, d, a));
            b = true;
          }
        } else
          b = false;
        return b;
      };
      q.If = function() {
        Wa("Shaka Player's internal Manifest structure is NOT covered by semantic versioning compatibility guarantees.  It may change at any time!  Please consider filing a feature request for whatever you use getManifest() for.");
        return this.i;
      };
      q.Jf = function() {
        return this.Yc;
      };
      function Pl(a) {
        var b = El();
        b.streaming.failureCallback = function(c) {
          if (a.U()) {
            var d = null;
            1001 == c.code || 1002 == c.code ? d = 1 : 1003 == c.code && (d = 0.1);
            null != d && (c.severity = 1, a.ce(d));
          }
        };
        b.textDisplayFactory = function() {
          return a.Uc ? new Uk(a.g, a.Uc) : new Pk(a.g);
        };
        return b;
      }
      q.$e = function(a) {
        this.Uc = a;
      };
      function sm(a, b) {
        for (var c = /* @__PURE__ */ new Set(), d = r(b.textStreams), e = d.next(); !e.done; e = d.next())
          e = e.value, "application/cea-608" != e.mimeType && "application/cea-708" != e.mimeType || c.add(e.originalId);
        d = r(b.variants);
        for (e = d.next(); !e.done; e = d.next())
          if ((e = e.value.video) && e.closedCaptions) {
            for (var f = r(e.closedCaptions.keys()), g = f.next(); !g.done; g = f.next())
              if (g = g.value, !c.has(g)) {
                var h = g.startsWith("CC") ? "application/cea-608" : "application/cea-708", k2 = new Nj();
                h = {
                  id: a.Yd++,
                  originalId: g,
                  createSegmentIndex: function() {
                    return Promise.resolve();
                  },
                  segmentIndex: k2,
                  mimeType: h,
                  codecs: "",
                  kind: "caption",
                  encrypted: false,
                  drmInfos: [],
                  keyIds: /* @__PURE__ */ new Set(),
                  language: e.closedCaptions.get(g),
                  label: null,
                  type: jc,
                  primary: false,
                  trickModeVideo: null,
                  emsgSchemeIdUris: null,
                  roles: e.roles,
                  forced: false,
                  channelsCount: null,
                  audioSamplingRate: null,
                  spatialAudio: false,
                  closedCaptions: null
                };
                b.textStreams.push(h);
                c.add(g);
              }
          }
      }
      function rm(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return u(c, ln(a, b), 2);
          Zm(a, b);
          A(c);
        });
      }
      function ln(a, b) {
        var c;
        return G(function(d) {
          if (1 == d.g)
            return c = a.j ? a.j.l : null, u(d, Md(c, b), 2);
          Nm(b);
          A(d);
        });
      }
      function Zm(a, b) {
        if (a.l != gm) {
          Ld(b.variants, a.h.restrictions, a.ec) && a.j && Om(a);
          var c = a.m ? a.m.g : null;
          if (c && a.m.u)
            for (var d = r(b.variants), e = d.next(); !e.done; e = d.next())
              e = e.value, tm(a, c.keySystem, e.video), tm(a, c.keySystem, e.audio);
          mn(a, b);
        }
      }
      function tm(a, b, c) {
        if (c) {
          c = r(c.drmInfos);
          for (var d = c.next(); !d.done; d = c.next())
            if (d = d.value, d.keySystem == b) {
              d = r(d.initData || []);
              for (var e = d.next(); !e.done; e = d.next())
                e = e.value, vg(a.m, e.initDataType, e.initData);
            }
        }
      }
      function Im(a, b) {
        var c, d, e, f, g;
        return G(function(h) {
          if (1 == h.g)
            return c = a.audio, d = a.video, e = function(k2, l) {
              var m, n, p;
              return G(function(t) {
                if (1 == t.g)
                  return k2 ? u(t, k2.createSegmentIndex(), 2) : t.return(null);
                n = (m = k2.segmentIndex.Cb(l)) ? m.next().value : null;
                if (!n)
                  return t.return(null);
                p = n.startTime;
                return t.return(p);
              });
            }, u(h, e(c, b), 2);
          if (3 != h.g)
            return f = h.h, u(h, e(d, b), 3);
          g = h.h;
          return null != g && null != f ? h.return(Math.max(g, f)) : null != g ? h.return(g) : null != f ? h.return(f) : h.return(b);
        });
      }
      function nm(a) {
        var b = a.Fd();
        if (a.o && a.M && a.B) {
          var c = a.H;
          c.j = b;
          Pj(c);
          a.V && (c = a.V, b || c.i || (c.i = true), c.i && b && (c.l = true), c.m = b);
          ym(a);
        }
        b = (/* @__PURE__ */ new Map()).set("buffering", b);
        a.dispatchEvent(bm("buffering", b));
      }
      function zm(a) {
        var b = a.g.playbackRate;
        0 != b && (a.H && a.H.set(b), b = bm("ratechange"), a.dispatchEvent(b));
      }
      function ym(a) {
        if (a.o && a.M) {
          var b = a.o.g;
          a.M.g == Ge ? Il(b, "buffering") : a.g.paused ? Il(b, "paused") : a.g.ended ? Il(b, "ended") : Il(b, "playing");
        }
      }
      function Pm(a) {
        try {
          mn(a, a.i);
        } catch (c) {
          return mm(a, c), false;
        }
        var b = a.i.variants.filter(function(c) {
          return he(c);
        });
        b = a.ub.create(b);
        a.u.setVariants(Array.from(b.values()));
        return true;
      }
      function cm(a) {
        return Pm(a) ? a.u.chooseVariant() : null;
      }
      function $m(a) {
        var b = cm(a);
        b && Bm(a, b, true, true, 0);
      }
      function Bm(a, b, c, d, e) {
        var f = a.j.l;
        if (b == f)
          d && ok(a.j, b, d, e, true);
        else {
          var g = a.o.h;
          g.h != b && (g.h = b, g.g.push({ timestamp: Date.now() / 1e3, id: b.id, type: "variant", fromAdaptation: c, bandwidth: b.bandwidth }));
          ok(a.j, b, d, e, void 0, c);
          d = null;
          f && (d = $d(f));
          b = $d(b);
          c ? Jm(a, d, b) : nn(a, d, b);
        }
      }
      function bn(a, b) {
        var c = Array.from(a.g.audioTracks).find(function(d) {
          return d.enabled;
        });
        b.enabled = true;
        b.id !== c.id && (c.enabled = false);
        c = ge(c);
        b = ge(b);
        nn(a, c, b);
      }
      function Km(a, b, c) {
        if (0 == a.h.autoShowText)
          return false;
        if (1 == a.h.autoShowText)
          return true;
        var d = od(a.h.preferredTextLanguage);
        c = od(c.language);
        if (2 == a.h.autoShowText)
          return nd(c, d);
        if (3 == a.h.autoShowText)
          return a = od(b.language), nd(c, d) && !nd(a, c);
        Wa("Invalid autoShowText setting!");
        return false;
      }
      function Jm(a, b, c) {
        b = (/* @__PURE__ */ new Map()).set("oldTrack", b).set("newTrack", c);
        a.L && Ii(a.L, c);
        c = bm("adaptation", b);
        on(a, c);
      }
      function Om(a) {
        var b = bm("trackschanged");
        on(a, b);
      }
      function nn(a, b, c) {
        b = (/* @__PURE__ */ new Map()).set("oldTrack", b).set("newTrack", c);
        a.L && Ii(a.L, c);
        c = bm("variantchanged", b);
        on(a, c);
      }
      function an(a) {
        var b = bm("textchanged");
        on(a, b);
      }
      function Lm(a) {
        var b = bm("texttrackvisibility");
        on(a, b);
      }
      function Mm(a) {
        var b = (/* @__PURE__ */ new Map()).set("newStatus", a.h.abr.enabled);
        on(a, bm("abrstatuschanged", b));
      }
      function pn(a, b) {
        if (1002 != b.code && 1011 != b.code || 1 != b.category || !navigator.onLine)
          return false;
        var c = a.h.streaming.maxDisabledTime;
        if (0 == c)
          if (1011 == b.code)
            c = 1;
          else
            return false;
        b = a.Xa().find(function(g) {
          return g.active;
        });
        for (var d = a.i, e = r(d.variants), f = e.next(); !f.done; f = e.next())
          f = f.value, f.id === b.id && (f.disabledUntilTime = Date.now() / 1e3 + c);
        Ld(d.variants, a.h.restrictions, a.ec);
        b = cm(a);
        if (!b)
          return false;
        d = a.Na().video.reduce(function(g, h) {
          return g + h.end - h.start;
        }, 0);
        Bm(a, b, false, true, d);
        a.af.N(c);
        return true;
      }
      function mm(a, b) {
        if (a.l != gm)
          if (pn(a, b))
            b.handled = true;
          else {
            var c = bm("error", (/* @__PURE__ */ new Map()).set("detail", b));
            a.dispatchEvent(c);
            c.defaultPrevented && (b.handled = true);
          }
      }
      function qm(a, b, c) {
        c = (/* @__PURE__ */ new Map()).set("detail", { schemeIdUri: c.schemeIdUri, value: c.value, startTime: c.startTime, endTime: c.endTime, id: c.id, eventElement: c.eventElement });
        a.dispatchEvent(bm(b, c));
      }
      function lm(a) {
        if (!a.g.error)
          return null;
        var b = a.g.error.code;
        if (1 == b)
          return null;
        var c = a.g.error.msExtendedCode;
        c && (0 > c && (c += Math.pow(2, 32)), c = c.toString(16));
        return new O(2, 3, 3016, b, c, a.g.error.message);
      }
      function wm(a, b) {
        if (a.j) {
          var c = Object.keys(b), d = 1 == c.length && "00" == c[0], e = false;
          if (c.length) {
            c = r(a.i.variants);
            for (var f = c.next(); !f.done; f = c.next()) {
              f = f.value;
              var g = [];
              f.audio && g.push(f.audio);
              f.video && g.push(f.video);
              g = r(g);
              for (var h = g.next(); !h.done; h = g.next()) {
                var k2 = h.value;
                h = f.allowedByKeySystem;
                if (k2.keyIds.size) {
                  f.allowedByKeySystem = true;
                  k2 = r(k2.keyIds);
                  for (var l = k2.next(); !l.done; l = k2.next())
                    l = l.value, l = b[d ? "00" : l], f.allowedByKeySystem = f.allowedByKeySystem && !!l && !qn.includes(l);
                }
                h != f.allowedByKeySystem && (e = true);
              }
            }
          }
          if (!e || Pm(a))
            (b = a.j.l) && !b.allowedByKeySystem && $m(a), e && Om(a);
        }
      }
      function xm(a, b, c) {
        if (a.J && a.J.onExpirationUpdated)
          a.J.onExpirationUpdated(b, c);
        b = bm("expirationupdated");
        a.dispatchEvent(b);
      }
      function Am(a, b, c) {
        0 < b && (a.U() || a.Ze(b));
        b = a.getDuration();
        c < b && (a.U() || a.Aa(c));
      }
      function mn(a, b) {
        a = a.m ? a.m.Qc() : {};
        var c = Object.keys(a);
        c = c.length && "00" == c[0];
        var d = false, e = false, f = /* @__PURE__ */ new Set(), g = /* @__PURE__ */ new Set();
        b = r(b.variants);
        for (var h = b.next(); !h.done; h = b.next()) {
          h = h.value;
          var k2 = [];
          h.audio && k2.push(h.audio);
          h.video && k2.push(h.video);
          k2 = r(k2);
          for (var l = k2.next(); !l.done; l = k2.next())
            if (l = l.value, l.keyIds.size) {
              l = r(l.keyIds);
              for (var m = l.next(); !m.done; m = l.next()) {
                m = m.value;
                var n = a[c ? "00" : m];
                n ? qn.includes(n) && g.add(n) : f.add(m);
              }
            }
          h.allowedByApplication ? h.allowedByKeySystem && (d = true) : e = true;
        }
        if (!d)
          throw a = {
            hasAppRestrictions: e,
            missingKeys: Array.from(f),
            restrictedKeyStatuses: Array.from(g)
          }, new O(2, 4, 4012, a);
      }
      function Nm(a) {
        if (!a.variants.some(he))
          throw new O(2, 4, 4032);
      }
      function on(a, b) {
        G(function(c) {
          if (1 == c.g)
            return u(c, Promise.resolve(), 2);
          a.l != gm && a.dispatchEvent(b);
          A(c);
        });
      }
      function dn(a) {
        var b = /* @__PURE__ */ new Set();
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          c = c.value, c.language ? b.add(od(c.language)) : b.add("und");
        return b;
      }
      function cn(a) {
        var b = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next()) {
          d = d.value;
          var e = "und", f = [];
          d.language && (e = od(d.language));
          "variant" == d.type ? f = d.audioRoles : f = d.roles;
          f && f.length || (f = [""]);
          b.has(e) || b.set(e, /* @__PURE__ */ new Set());
          f = r(f);
          for (var g = f.next(); !g.done; g = f.next())
            g = g.value, b.get(e).add(g), d.label && (c.has(e) || c.set(e, /* @__PURE__ */ new Map()), c.get(e).set(g, d.label));
        }
        var h = [];
        b.forEach(function(k2, l) {
          k2 = r(k2);
          for (var m = k2.next(); !m.done; m = k2.next()) {
            m = m.value;
            var n = null;
            c.has(l) && c.get(l).has(m) && (n = c.get(l).get(m));
            h.push({ language: l, role: m, label: n });
          }
        });
        return h;
      }
      function hm() {
        return new O(2, 7, 7e3);
      }
      function am(a, b, c, d, e, f) {
        return d == a && e.mediaElement == f.mediaElement && e.uri == f.uri && e.mimeType == f.mimeType ? b : c;
      }
      function Hk() {
        return { mediaElement: null, mimeType: null, startTime: null, ne: NaN, uri: null };
      }
      function im(a) {
        return new Promise(function(b, c) {
          a.mb = function() {
            return c(hm());
          };
          a.bd = function() {
            return b();
          };
          a.onError = function(d) {
            return c(d);
          };
          a.dd = function() {
            return c(hm());
          };
        });
      }
      K("shaka.Player", V);
      V.prototype.setVideoContainer = V.prototype.$e;
      V.prototype.getManifestParserFactory = V.prototype.Jf;
      V.prototype.getManifest = V.prototype.If;
      V.prototype.retryStreaming = V.prototype.ce;
      V.prototype.setMaxHardwareResolution = V.prototype.ke;
      V.prototype.addChaptersTrack = V.prototype.gf;
      V.prototype.addThumbnailsTrack = V.prototype.jf;
      V.prototype.addTextTrackAsync = V.prototype.hf;
      V.prototype.getStats = V.prototype.getStats;
      V.prototype.getBufferedInfo = V.prototype.Na;
      V.prototype.getPresentationStartTimeAsDate = V.prototype.Ie;
      V.prototype.getPlayheadTimeAsDate = V.prototype.Of;
      V.prototype.setTextTrackVisibility = V.prototype.yg;
      V.prototype.getChapters = V.prototype.Cf;
      V.prototype.getChaptersTracks = V.prototype.He;
      V.prototype.isTextTrackVisible = V.prototype.Hd;
      V.prototype.selectVariantsByLabel = V.prototype.tg;
      V.prototype.selectTextLanguage = V.prototype.he;
      V.prototype.selectAudioLanguage = V.prototype.ge;
      V.prototype.getTextLanguages = V.prototype.Qf;
      V.prototype.getAudioLanguages = V.prototype.zf;
      V.prototype.getTextLanguagesAndRoles = V.prototype.Rf;
      V.prototype.getAudioLanguagesAndRoles = V.prototype.Af;
      V.prototype.selectVariantTrack = V.prototype.Te;
      V.prototype.selectTextTrack = V.prototype.Se;
      V.prototype.getThumbnails = V.prototype.Tf;
      V.prototype.getImageTracks = V.prototype.Ff;
      V.prototype.getTextTracks = V.prototype.Fb;
      V.prototype.getVariantTracks = V.prototype.Xa;
      V.prototype.cancelTrickPlay = V.prototype.pf;
      V.prototype.trickPlay = V.prototype.Ag;
      V.prototype.getPlaybackRate = V.prototype.Rc;
      V.prototype.isBuffering = V.prototype.Fd;
      V.prototype.getKeyStatuses = V.prototype.Qc;
      V.prototype.getExpiration = V.prototype.ic;
      V.prototype.drmInfo = V.prototype.drmInfo;
      V.prototype.keySystem = V.prototype.keySystem;
      V.prototype.goToLive = V.prototype.Xf;
      V.prototype.seekRange = V.prototype.uc;
      V.prototype.isAudioOnly = V.prototype.Zf;
      V.prototype.isInProgress = V.prototype.jb;
      V.prototype.isLive = V.prototype.U;
      V.prototype.getAdManager = V.prototype.Ge;
      V.prototype.getAssetUri = V.prototype.Dd;
      V.prototype.getNetworkingEngine = V.prototype.jc;
      V.prototype.getMediaElement = V.prototype.Lf;
      V.prototype.getLoadMode = V.prototype.Hf;
      V.prototype.resetConfiguration = V.prototype.rg;
      V.prototype.getBufferFullness = V.prototype.Bf;
      V.prototype.getConfiguration = V.prototype.getConfiguration;
      V.prototype.configure = V.prototype.configure;
      V.prototype.load = V.prototype.load;
      V.prototype.updateStartTime = V.prototype.Fg;
      V.prototype.unload = V.prototype.re;
      V.prototype.detach = V.prototype.detach;
      V.prototype.attachCanvas = V.prototype.lf;
      V.prototype.attach = V.prototype.Yb;
      V.probeSupport = function(a) {
        a = void 0 === a ? true : a;
        var b, c, d, e, f, g;
        return G(function(h) {
          if (1 == h.g)
            return b = {}, a ? u(h, Mg(), 3) : h.A(2);
          2 != h.g && (b = h.h);
          var k2 = {};
          if (oc()) {
            for (var l in Tg)
              k2[l] = true;
            for (var m in Vg)
              k2[m] = true;
          }
          l = { mpd: "application/dash+xml", m3u8: "application/x-mpegurl", ism: "application/vnd.ms-sstr+xml" };
          m = r(["application/dash+xml", "application/x-mpegurl", "application/vnd.apple.mpegurl", "application/vnd.ms-sstr+xml"]);
          for (var n = m.next(); !n.done; n = m.next())
            n = n.value, k2[n] = oc() ? !!Tg[n] : pc(n);
          for (var p in l)
            k2[p] = oc() ? !!Vg[p] : pc(l[p]);
          c = k2;
          p = 'video/mp4; codecs="avc1.42E01E",video/mp4; codecs="avc3.42E01E",video/mp4; codecs="hev1.1.6.L93.90",video/mp4; codecs="hvc1.1.6.L93.90",video/mp4; codecs="hev1.2.4.L153.B0"; eotf="smpte2084",video/mp4; codecs="hvc1.2.4.L153.B0"; eotf="smpte2084",video/mp4; codecs="vp9",video/mp4; codecs="vp09.00.10.08",video/mp4; codecs="av01.0.01M.08",audio/mp4; codecs="mp4a.40.2",audio/mp4; codecs="ac-3",audio/mp4; codecs="ec-3",audio/mp4; codecs="opus",audio/mp4; codecs="flac",video/webm; codecs="vp8",video/webm; codecs="vp9",video/webm; codecs="vp09.00.10.08",audio/webm; codecs="vorbis",audio/webm; codecs="opus",video/mp2t; codecs="avc1.42E01E",video/mp2t; codecs="avc3.42E01E",video/mp2t; codecs="hvc1.1.6.L93.90",video/mp2t; codecs="mp4a.40.2",video/mp2t; codecs="ac-3",video/mp2t; codecs="ec-3",text/vtt,application/mp4; codecs="wvtt",application/ttml+xml,application/mp4; codecs="stpp"'.split(",").concat(ha(Yi));
          k2 = {};
          p = r(p);
          for (l = p.next(); !l.done; l = p.next())
            l = l.value, k2[l] = oc() ? ed(l) ? true : eb(l) || Tc(l) : pc(l), m = l.split(";")[0], k2[m] = k2[m] || k2[l];
          d = k2;
          e = { manifest: c, media: d, drm: b };
          f = rn;
          for (g in f)
            e[g] = f[g]();
          return h.return(e);
        });
      };
      V.isBrowserSupported = function() {
        window2.Promise || Wa("A Promise implementation or polyfill is required");
        if (!(window2.Promise && window2.Uint8Array && Array.prototype.forEach) || tc("Trident/"))
          return false;
        var a = yc();
        return a && 13 > a || !(window2.MediaKeys && window2.navigator && window2.navigator.requestMediaKeySystemAccess && window2.MediaKeySystemAccess && window2.MediaKeySystemAccess.prototype.getConfiguration) ? false : oc() ? true : pc("application/x-mpegurl");
      };
      V.setAdManagerFactory = function(a) {
        Rl = a;
      };
      V.registerSupportPlugin = function(a, b) {
        rn[a] = b;
      };
      V.prototype.destroy = V.prototype.destroy;
      var gm = 0, Ol = 1, Dm = 2, Rm = 3;
      V.LoadMode = { DESTROYED: gm, NOT_LOADED: Ol, MEDIA_SOURCE: Dm, SRC_EQUALS: Rm };
      V.version = "v4.3.5";
      var sn = ["4", "3"];
      se = new function(a) {
        this.g = a;
        this.i = te;
        this.h = ue;
      }(new qe(Number(sn[0]), Number(sn[1])));
      var qn = ["output-restricted", "internal-error"], rn = {}, Rl = null, fm = { mp4: "video/mp4", m4v: "video/mp4", m4a: "audio/mp4", webm: "video/webm", weba: "audio/webm", mkv: "video/webm", ts: "video/mp2t", ogv: "video/ogg", ogg: "audio/ogg", mpg: "video/mpeg", mpeg: "video/mpeg", m3u8: "application/x-mpegurl", mpd: "application/dash+xml", mp3: "audio/mpeg", aac: "audio/aac", flac: "audio/flac", wav: "audio/wav" }, kn = {
        sbv: "text/x-subviewer",
        srt: "text/srt",
        vtt: "text/vtt",
        webvtt: "text/vtt",
        ttml: "application/ttml+xml",
        lrc: "application/x-subtitle-lrc",
        ssa: "text/x-ssa",
        ass: "text/x-ssa"
      };
      function tn() {
        this.h = [];
        this.j = this.i = this.g = 0;
      }
      function W(a, b, c) {
        var d = this;
        this.h = a;
        this.g = b;
        this.m = c;
        this.i = false;
        this.l = this.g.getVolume();
        this.j = new mf();
        this.j.C(this.g, google.ima.AdEvent.Type.PAUSED, function() {
          d.i = true;
        });
        this.j.C(this.g, google.ima.AdEvent.Type.RESUMED, function() {
          d.i = false;
        });
      }
      q = W.prototype;
      q.getDuration = function() {
        return this.h.getDuration();
      };
      q.getMinSuggestedDuration = function() {
        return this.h.getMinSuggestedDuration();
      };
      q.getRemainingTime = function() {
        return this.g.getRemainingTime();
      };
      q.isPaused = function() {
        return this.i;
      };
      q.isSkippable = function() {
        return 0 <= this.h.getSkipTimeOffset();
      };
      q.getTimeUntilSkippable = function() {
        var a = this.h.getSkipTimeOffset();
        a = this.getRemainingTime() - a;
        return Math.max(a, 0);
      };
      q.canSkipNow = function() {
        return this.g.getAdSkippableState();
      };
      q.skip = function() {
        return this.g.skip();
      };
      q.pause = function() {
        return this.g.pause();
      };
      q.play = function() {
        return this.g.resume();
      };
      q.getVolume = function() {
        return this.g.getVolume();
      };
      q.setVolume = function(a) {
        return this.g.setVolume(a);
      };
      q.isMuted = function() {
        return 0 == this.g.getVolume();
      };
      q.isLinear = function() {
        return this.h.isLinear();
      };
      q.resize = function(a, b) {
        var c = false, d = this.m;
        document.fullscreenEnabled ? c = !!document.fullscreenElement : d.webkitSupportsFullscreen && (c = d.webkitDisplayingFullscreen);
        this.g.resize(a, b, c ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
      };
      q.setMuted = function(a) {
        a ? (this.l = this.getVolume(), this.setVolume(0)) : this.setVolume(this.l);
      };
      q.getSequenceLength = function() {
        var a = this.h.getAdPodInfo();
        return null == a ? 1 : a.getTotalAds();
      };
      q.getPositionInSequence = function() {
        var a = this.h.getAdPodInfo();
        return null == a ? 1 : a.getAdPosition();
      };
      q.getTitle = function() {
        return this.h.getTitle();
      };
      q.getDescription = function() {
        return this.h.getDescription();
      };
      q.release = function() {
        this.g = this.h = null;
      };
      K("shaka.ads.ClientSideAd", W);
      W.prototype.release = W.prototype.release;
      W.prototype.getDescription = W.prototype.getDescription;
      W.prototype.getTitle = W.prototype.getTitle;
      W.prototype.getPositionInSequence = W.prototype.getPositionInSequence;
      W.prototype.getSequenceLength = W.prototype.getSequenceLength;
      W.prototype.setMuted = W.prototype.setMuted;
      W.prototype.resize = W.prototype.resize;
      W.prototype.isLinear = W.prototype.isLinear;
      W.prototype.isMuted = W.prototype.isMuted;
      W.prototype.setVolume = W.prototype.setVolume;
      W.prototype.getVolume = W.prototype.getVolume;
      W.prototype.play = W.prototype.play;
      W.prototype.pause = W.prototype.pause;
      W.prototype.skip = W.prototype.skip;
      W.prototype.canSkipNow = W.prototype.canSkipNow;
      W.prototype.getTimeUntilSkippable = W.prototype.getTimeUntilSkippable;
      W.prototype.isSkippable = W.prototype.isSkippable;
      W.prototype.isPaused = W.prototype.isPaused;
      W.prototype.getRemainingTime = W.prototype.getRemainingTime;
      W.prototype.getMinSuggestedDuration = W.prototype.getMinSuggestedDuration;
      W.prototype.getDuration = W.prototype.getDuration;
      function un(a, b, c, d) {
        var e = this;
        this.o = a;
        this.i = b;
        this.s = null;
        this.u = NaN;
        this.l = d;
        this.j = null;
        this.h = new mf();
        google.ima.settings.setLocale(c);
        a = new google.ima.AdDisplayContainer(this.o, this.i);
        a.initialize();
        this.m = new google.ima.AdsLoader(a);
        this.m.getSettings().setPlayerType("shaka-player");
        this.m.getSettings().setPlayerVersion("v4.3.5");
        this.g = null;
        this.h.ma(this.m, google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function(f) {
          vn(e, f);
        });
        this.h.C(
          this.m,
          google.ima.AdErrorEvent.Type.AD_ERROR,
          function(f) {
            wn(e, f);
          }
        );
        this.h.C(this.i, "ended", function() {
          e.m.contentComplete();
        });
      }
      un.prototype.stop = function() {
        this.g && this.g.stop();
        this.o && Tk(this.o);
      };
      un.prototype.release = function() {
        this.stop();
        this.s && this.s.disconnect();
        this.h && this.h.release();
        this.g && this.g.destroy();
        this.m.destroy();
      };
      function wn(a, b) {
        b.getError();
        xn(a, null);
        a.l(new S("ad-cue-points-changed", (/* @__PURE__ */ new Map()).set("cuepoints", [])));
      }
      function vn(a, b) {
        a.l(new S("ads-loaded", (/* @__PURE__ */ new Map()).set("loadTime", Date.now() / 1e3 - a.u)));
        a.g = b.getAdsManager(a.i);
        a.l(new S("ima-ad-manager-loaded", (/* @__PURE__ */ new Map()).set("imaAdManager", a.g)));
        var c = a.g.getCuePoints();
        if (c.length) {
          b = [];
          c = r(c);
          for (var d = c.next(); !d.done; d = c.next())
            b.push({ start: d.value, end: null });
          a.l(new S("ad-cue-points-changed", (/* @__PURE__ */ new Map()).set("cuepoints", b)));
        }
        yn(a);
        try {
          a.g.init(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL), a.h.C(
            a.i,
            "loadeddata",
            function() {
              a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
            }
          ), "ResizeObserver" in window2 ? (a.s = new ResizeObserver(function() {
            a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
          }), a.s.observe(a.i)) : a.h.C(document, "fullscreenchange", function() {
            a.g.resize(a.i.offsetWidth, a.i.offsetHeight, zn(a) ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL);
          }), a.i.addEventListener(
            "play",
            function() {
              a.g.start();
            },
            { once: true }
          );
        } catch (e) {
          xn(a, null);
        }
      }
      function zn(a) {
        if (document.fullscreenEnabled)
          return !!document.fullscreenElement;
        a = a.i;
        return a.webkitSupportsFullscreen ? a.webkitDisplayingFullscreen : false;
      }
      function yn(a) {
        function b(c, d) {
          c = (/* @__PURE__ */ new Map()).set("originalEvent", c);
          a.l(new S(d, c));
        }
        a.h.C(a.g, google.ima.AdErrorEvent.Type.AD_ERROR, function(c) {
          wn(a, c);
        });
        a.h.C(a.g, google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, function(c) {
          An(a, c);
        });
        a.h.C(a.g, google.ima.AdEvent.Type.STARTED, function(c) {
          An(a, c);
        });
        a.h.C(a.g, google.ima.AdEvent.Type.FIRST_QUARTILE, function(c) {
          b(c, "ad-first-quartile");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.MIDPOINT, function(c) {
          b(c, "ad-midpoint");
        });
        a.h.C(
          a.g,
          google.ima.AdEvent.Type.THIRD_QUARTILE,
          function(c) {
            b(c, "ad-third-quartile");
          }
        );
        a.h.C(a.g, google.ima.AdEvent.Type.COMPLETE, function(c) {
          b(c, "ad-complete");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, function(c) {
          xn(a, c);
        });
        a.h.C(a.g, google.ima.AdEvent.Type.ALL_ADS_COMPLETED, function(c) {
          xn(a, c);
        });
        a.h.C(a.g, google.ima.AdEvent.Type.SKIPPED, function(c) {
          b(c, "ad-skipped");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.VOLUME_CHANGED, function(c) {
          b(c, "ad-volume-changed");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.VOLUME_MUTED, function(c) {
          b(c, "ad-muted");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.PAUSED, function(c) {
          a.j && (a.j.i = true, b(c, "ad-paused"));
        });
        a.h.C(a.g, google.ima.AdEvent.Type.RESUMED, function(c) {
          a.j && (a.j.i = false, b(c, "ad-resumed"));
        });
        a.h.C(a.g, google.ima.AdEvent.Type.SKIPPABLE_STATE_CHANGED, function(c) {
          a.j && b(c, "ad-skip-state-changed");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.CLICK, function(c) {
          b(c, "ad-clicked");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.AD_PROGRESS, function(c) {
          b(c, "ad-progress");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.AD_BUFFERING, function(c) {
          b(c, "ad-buffering");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.IMPRESSION, function(c) {
          b(c, "ad-impression");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.DURATION_CHANGE, function(c) {
          b(c, "ad-duration-changed");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.USER_CLOSE, function(c) {
          b(c, "ad-closed");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.LOADED, function(c) {
          b(c, "ad-loaded");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.ALL_ADS_COMPLETED, function(c) {
          b(c, "all-ads-completed");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.LINEAR_CHANGED, function(c) {
          b(c, "ad-linear-changed");
        });
        a.h.C(
          a.g,
          google.ima.AdEvent.Type.AD_METADATA,
          function(c) {
            b(c, "ad-metadata");
          }
        );
        a.h.C(a.g, google.ima.AdEvent.Type.LOG, function(c) {
          b(c, "ad-recoverable-error");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.AD_BREAK_READY, function(c) {
          b(c, "ad-break-ready");
        });
        a.h.C(a.g, google.ima.AdEvent.Type.INTERACTION, function(c) {
          b(c, "ad-interaction");
        });
      }
      function An(a, b) {
        var c = b.getAd();
        c ? (a.j = new W(c, a.g, a.i), b = (/* @__PURE__ */ new Map()).set("ad", a.j).set("sdkAdObject", c).set("originalEvent", b), a.l(new S("ad-started", b)), a.j.isLinear() && (a.o.setAttribute("ad-active", "true"), a.i.pause(), a.j.setVolume(a.i.muted ? 0 : a.i.volume))) : Wa("The IMA SDK fired a " + b.type + " event with no associated ad. Unable to play ad!");
      }
      function xn(a, b) {
        a.l(new S("ad-stopped", (/* @__PURE__ */ new Map()).set("originalEvent", b)));
        a.j && a.j.isLinear() && (a.o.removeAttribute("ad-active"), a.i.ended || a.i.play());
      }
      function X(a, b) {
        this.i = a;
        this.h = null;
        this.g = b;
      }
      q = X.prototype;
      q.getDuration = function() {
        return this.h ? this.h.duration : -1;
      };
      q.getMinSuggestedDuration = function() {
        return this.getDuration();
      };
      q.getRemainingTime = function() {
        return this.h ? this.h.duration - this.h.currentTime : -1;
      };
      q.isPaused = function() {
        return this.g.paused;
      };
      q.isSkippable = function() {
        return this.i.isSkippable();
      };
      q.getTimeUntilSkippable = function() {
        var a = this.i.getSkipTimeOffset();
        a = this.getRemainingTime() - a;
        return Math.max(a, 0);
      };
      q.canSkipNow = function() {
        return 0 == this.getTimeUntilSkippable();
      };
      q.skip = function() {
        this.g.currentTime += this.getRemainingTime();
      };
      q.pause = function() {
        return this.g.pause();
      };
      q.play = function() {
        return this.g.play();
      };
      q.getVolume = function() {
        return this.g.volume;
      };
      q.setVolume = function(a) {
        this.g.volume = a;
      };
      q.isMuted = function() {
        return this.g.muted;
      };
      q.isLinear = function() {
        return true;
      };
      q.resize = function() {
      };
      q.setMuted = function(a) {
        this.g.muted = a;
      };
      q.getSequenceLength = function() {
        var a = this.i.getAdPodInfo();
        return null == a ? 1 : a.getTotalAds();
      };
      q.getPositionInSequence = function() {
        var a = this.i.getAdPodInfo();
        return null == a ? 1 : a.getAdPosition();
      };
      q.getTitle = function() {
        return this.i.getTitle();
      };
      q.getDescription = function() {
        return this.i.getDescription();
      };
      q.release = function() {
        this.g = this.h = this.i = null;
      };
      K("shaka.ads.ServerSideAd", X);
      X.prototype.release = X.prototype.release;
      X.prototype.getDescription = X.prototype.getDescription;
      X.prototype.getTitle = X.prototype.getTitle;
      X.prototype.getPositionInSequence = X.prototype.getPositionInSequence;
      X.prototype.getSequenceLength = X.prototype.getSequenceLength;
      X.prototype.setMuted = X.prototype.setMuted;
      X.prototype.resize = X.prototype.resize;
      X.prototype.isLinear = X.prototype.isLinear;
      X.prototype.isMuted = X.prototype.isMuted;
      X.prototype.setVolume = X.prototype.setVolume;
      X.prototype.getVolume = X.prototype.getVolume;
      X.prototype.play = X.prototype.play;
      X.prototype.pause = X.prototype.pause;
      X.prototype.skip = X.prototype.skip;
      X.prototype.canSkipNow = X.prototype.canSkipNow;
      X.prototype.getTimeUntilSkippable = X.prototype.getTimeUntilSkippable;
      X.prototype.isSkippable = X.prototype.isSkippable;
      X.prototype.isPaused = X.prototype.isPaused;
      X.prototype.getRemainingTime = X.prototype.getRemainingTime;
      X.prototype.getMinSuggestedDuration = X.prototype.getMinSuggestedDuration;
      X.prototype.getDuration = X.prototype.getDuration;
      function Bn(a, b, c, d) {
        var e = this;
        this.s = a;
        this.l = b;
        this.j = null;
        this.G = NaN;
        this.i = d;
        this.F = false;
        this.u = this.m = this.o = null;
        this.B = "";
        this.D = [];
        this.h = new mf();
        a = new google.ima.dai.api.UiSettings();
        a.setLocale(c);
        this.g = new google.ima.dai.api.StreamManager(this.l, this.s, a);
        this.i(new S("ima-stream-manager-loaded", (/* @__PURE__ */ new Map()).set("imaStreamManager", this.g)));
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.LOADED, function(f) {
          Cn(e, f);
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.ERROR, function() {
          e.B.length ? e.j.resolve(e.B) : e.j.reject("IMA Stream request returned an error and there was no backup asset uri provided.");
          e.j = null;
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_BREAK_STARTED, function() {
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.STARTED, function(f) {
          f = f.getAd();
          e.m = new X(f, e.l);
          e.u && (e.m.h = e.u);
          e.i(new S("ad-started", (/* @__PURE__ */ new Map()).set("ad", e.m)));
          e.s.setAttribute("ad-active", "true");
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_BREAK_ENDED, function() {
          e.s.removeAttribute("ad-active");
          var f = e.l.currentTime;
          e.o && e.o > f && (e.l.currentTime = e.o, e.o = null);
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.AD_PROGRESS, function(f) {
          e.u = f.getStreamData().adProgressData;
          e.m && (e.m.h = e.u);
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.FIRST_QUARTILE, function() {
          e.i(new S("ad-first-quartile"));
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.MIDPOINT, function() {
          e.i(new S("ad-midpoint"));
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.THIRD_QUARTILE, function() {
          e.i(new S("ad-third-quartile"));
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.COMPLETE, function() {
          e.i(new S("ad-complete"));
          e.i(new S("ad-stopped"));
          e.s.removeAttribute("ad-active");
          e.m = null;
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.SKIPPED, function() {
          e.i(new S("ad-skipped"));
          e.i(new S("ad-stopped"));
        });
        this.h.C(this.g, google.ima.dai.api.StreamEvent.Type.CUEPOINTS_CHANGED, function(f) {
          var g = f.getStreamData();
          f = [];
          g = r(g.cuepoints);
          for (var h = g.next(); !h.done; h = g.next())
            h = h.value, f.push({ start: h.start, end: h.end });
          e.D = f;
          e.i(new S("ad-cue-points-changed", (/* @__PURE__ */ new Map()).set("cuepoints", f)));
        });
      }
      Bn.prototype.stop = function() {
        this.B = "";
        this.o = null;
        this.D = [];
      };
      Bn.prototype.release = function() {
        this.stop();
        this.h && this.h.release();
      };
      Bn.prototype.onCueMetadataChange = function(a) {
        if (a.key && a.data) {
          var b = {};
          b[a.key] = a.data;
          this.g.onTimedMetadata(b);
        }
      };
      function Cn(a, b) {
        a.i(new S("ads-loaded", (/* @__PURE__ */ new Map()).set("loadTime", Date.now() / 1e3 - a.G)));
        b = b.getStreamData().url;
        a.j.resolve(b);
        a.j = null;
        a.F || a.h.C(a.l, "seeked", function() {
          var c = a.l.currentTime;
          if (0 != c) {
            a.g.streamTimeForContentTime(c);
            var d = a.g.previousCuePointForStreamTime(c);
            d && !d.played && (a.o = c, a.l.currentTime = d.start);
          }
        });
      }
      function Y() {
        Ue.call(this);
        this.g = this.i = null;
        this.h = new tn();
        this.j = navigator.language;
      }
      oa(Y, Ue);
      q = Y.prototype;
      q.setLocale = function(a) {
        this.j = a;
      };
      q.initClientSide = function(a, b) {
        var c = this;
        if (!window2.google || !google.ima || !google.ima.AdsLoader)
          throw new O(2, 10, 1e4);
        this.i && this.i.release();
        this.i = new un(a, b, this.j, function(d) {
          if (d && d.type)
            switch (d.type) {
              case "ads-loaded":
                c.h.h.push(d.loadTime);
                break;
              case "ad-started":
                c.h.g++;
                break;
              case "ad-complete":
                c.h.i++;
                break;
              case "ad-skipped":
                c.h.j++;
            }
          c.dispatchEvent(d);
        });
      };
      q.release = function() {
        this.i && (this.i.release(), this.i = null);
        this.g && (this.g.release(), this.g = null);
        Ue.prototype.release.call(this);
      };
      q.onAssetUnload = function() {
        this.i && this.i.stop();
        this.g && this.g.stop();
        this.dispatchEvent(new S("ad-stopped"));
        this.h = new tn();
      };
      q.requestClientSideAds = function(a) {
        if (!this.i)
          throw new O(1, 10, 10001);
        var b = this.i;
        b.u = Date.now() / 1e3;
        b.m.requestAds(a);
      };
      q.initServerSide = function(a, b) {
        var c = this;
        if (!window2.google || !google.ima || !google.ima.dai)
          throw new O(2, 10, 10002);
        this.g && this.g.release();
        this.g = new Bn(a, b, this.j, function(d) {
          if (d && d.type)
            switch (d.type) {
              case "ads-loaded":
                c.h.h.push(d.loadTime);
                break;
              case "ad-started":
                c.h.g++;
                break;
              case "ad-complete":
                c.h.i++;
                break;
              case "ad-skipped":
                c.h.j++;
            }
          c.dispatchEvent(d);
        });
      };
      q.requestServerSideStream = function(a, b) {
        b = void 0 === b ? "" : b;
        if (!this.g)
          throw new O(1, 10, 10003);
        a.adTagParameters || (a.adTagParameters = {});
        var c = a.adTagParameters;
        (c.mpt || c.mpv) && Wa('You have attempted to set "mpt" and/or "mpv" parameters of the ad tag. Please note that those parameters are used for Shaka adoption tracking and will be overriden.');
        a.adTagParameters.mpt = "shaka-player";
        a.adTagParameters.mpv = "v4.3.5";
        c = this.g;
        c.j ? a = Promise.reject(new O(1, 10, 10004)) : (a instanceof google.ima.dai.api.LiveStreamRequest && (c.F = true), c.j = new lc2(), c.g.requestStream(a), c.B = b || "", c.G = Date.now() / 1e3, a = c.j);
        return a;
      };
      q.replaceServerSideAdTagParameters = function(a) {
        if (!this.g)
          throw new O(1, 10, 10003);
        (a.mpt || a.mpv) && Wa('You have attempted to set "mpt" and/or "mpv" parameters of the ad tag. Please note that those parameters are used for Shaka adoption tracking and will be overriden.');
        a.mpt = "Shaka Player";
        a.mpv = "v4.3.5";
        this.g.g.replaceAdTagParameters(a);
      };
      q.getServerSideCuePoints = function() {
        if (!this.g)
          throw new O(1, 10, 10003);
        return this.g.D;
      };
      q.getStats = function() {
        var a = this.h;
        return { loadTimes: a.h, started: a.g, playedCompletely: a.i, skipped: a.j };
      };
      q.onDashTimedMetadata = function(a) {
        if (this.g && "urn:google:dai:2018" == a.schemeIdUri) {
          var b = a.schemeIdUri, c = a.eventElement ? a.eventElement.getAttribute("messageData") : null;
          this.g.g.processMetadata(b, c, a.startTime);
        }
      };
      q.onHlsTimedMetadata = function(a, b) {
        this.g && this.g.g.processMetadata("ID3", a.data, b);
      };
      q.onCueMetadataChange = function(a) {
        if (this.g)
          this.g.onCueMetadataChange(a);
      };
      K("shaka.ads.AdManager", Y);
      Y.prototype.onCueMetadataChange = Y.prototype.onCueMetadataChange;
      Y.prototype.onHlsTimedMetadata = Y.prototype.onHlsTimedMetadata;
      Y.prototype.onDashTimedMetadata = Y.prototype.onDashTimedMetadata;
      Y.prototype.getStats = Y.prototype.getStats;
      Y.prototype.getServerSideCuePoints = Y.prototype.getServerSideCuePoints;
      Y.prototype.replaceServerSideAdTagParameters = Y.prototype.replaceServerSideAdTagParameters;
      Y.prototype.requestServerSideStream = Y.prototype.requestServerSideStream;
      Y.prototype.initServerSide = Y.prototype.initServerSide;
      Y.prototype.requestClientSideAds = Y.prototype.requestClientSideAds;
      Y.prototype.onAssetUnload = Y.prototype.onAssetUnload;
      Y.prototype.release = Y.prototype.release;
      Y.prototype.initClientSide = Y.prototype.initClientSide;
      Y.prototype.setLocale = Y.prototype.setLocale;
      Y.ADS_LOADED = "ads-loaded";
      Y.AD_STARTED = "ad-started";
      Y.AD_FIRST_QUARTILE = "ad-first-quartile";
      Y.AD_MIDPOINT = "ad-midpoint";
      Y.AD_THIRD_QUARTILE = "ad-third-quartile";
      Y.AD_COMPLETE = "ad-complete";
      Y.AD_STOPPED = "ad-stopped";
      Y.AD_SKIPPED = "ad-skipped";
      Y.AD_VOLUME_CHANGED = "ad-volume-changed";
      Y.AD_MUTED = "ad-muted";
      Y.AD_PAUSED = "ad-paused";
      Y.AD_RESUMED = "ad-resumed";
      Y.AD_SKIP_STATE_CHANGED = "ad-skip-state-changed";
      Y.CUEPOINTS_CHANGED = "ad-cue-points-changed";
      Y.IMA_AD_MANAGER_LOADED = "ima-ad-manager-loaded";
      Y.IMA_STREAM_MANAGER_LOADED = "ima-stream-manager-loaded";
      Y.AD_CLICKED = "ad-clicked";
      Y.AD_PROGRESS = "ad-progress";
      Y.AD_BUFFERING = "ad-buffering";
      Y.AD_IMPRESSION = "ad-impression";
      Y.AD_DURATION_CHANGED = "ad-duration-changed";
      Y.AD_CLOSED = "ad-closed";
      Y.AD_LOADED = "ad-loaded";
      Y.ALL_ADS_COMPLETED = "all-ads-completed";
      Y.AD_LINEAR_CHANGED = "ad-linear-changed";
      Y.AD_METADATA = "ad-metadata";
      Y.AD_RECOVERABLE_ERROR = "ad-recoverable-error";
      Y.AD_BREAK_READY = "ad-break-ready";
      Y.AD_INTERACTION = "ad-interaction";
      Rl = function() {
        return new Y();
      };
      function Dn(a) {
        return JSON.stringify(a, function(b, c) {
          if ("function" != typeof c) {
            if (c instanceof Event || c instanceof S) {
              var d = {};
              for (e in c)
                (b = c[e]) && "object" == typeof b ? "detail" == e && (d[e] = b) : e in Event || (d[e] = b);
              return d;
            }
            if (c instanceof Error) {
              var e = /* @__PURE__ */ new Set(["name", "message", "stack"]);
              for (d in c)
                e.add(d);
              b = r(Object.getOwnPropertyNames(c));
              for (d = b.next(); !d.done; d = b.next())
                e.add(d.value);
              b = {};
              e = r(e);
              for (d = e.next(); !d.done; d = e.next())
                d = d.value, b[d] = c[d];
              c = { __type__: "Error", contents: b };
            } else if (c instanceof TimeRanges) {
              e = { __type__: "TimeRanges", length: c.length, start: [], end: [] };
              c = r(xi(c));
              for (d = c.next(); !d.done; d = c.next())
                d = d.value, b = d.end, e.start.push(d.start), e.end.push(b);
              c = e;
            } else
              c = c instanceof Uint8Array ? { __type__: "Uint8Array", entries: Array.from(c) } : "number" == typeof c ? isNaN(c) ? "NaN" : isFinite(c) ? c : 0 > c ? "-Infinity" : "Infinity" : c;
            return c;
          }
        });
      }
      function En(a) {
        return JSON.parse(a, function(b, c) {
          if ("NaN" == c)
            var d = NaN;
          else if ("-Infinity" == c)
            d = -Infinity;
          else if ("Infinity" == c)
            d = Infinity;
          else if (c && "object" == typeof c && "TimeRanges" == c.__type__)
            d = Fn(c);
          else if (c && "object" == typeof c && "Uint8Array" == c.__type__)
            d = new Uint8Array(c.entries);
          else if (c && "object" == typeof c && "Error" == c.__type__) {
            b = c.contents;
            c = Error(b.message);
            for (d in b)
              c[d] = b[d];
            d = c;
          } else
            d = c;
          return d;
        });
      }
      function Fn(a) {
        return { length: a.length, start: function(b) {
          return a.start[b];
        }, end: function(b) {
          return a.end[b];
        } };
      }
      var Gn = "ended play playing pause pausing ratechange seeked seeking timeupdate volumechange".split(" "), Hn = "buffered currentTime duration ended loop muted paused playbackRate seeking videoHeight videoWidth volume".split(" "), In = ["loop", "playbackRate"], Jn = ["pause", "play"], Kn = {
        getAssetUri: 2,
        getAudioLanguages: 4,
        getAudioLanguagesAndRoles: 4,
        getBufferFullness: 1,
        getBufferedInfo: 2,
        getExpiration: 2,
        getKeyStatuses: 2,
        getPlaybackRate: 2,
        getTextLanguages: 4,
        getTextLanguagesAndRoles: 4,
        getImageTracks: 2,
        getThumbnails: 2,
        isAudioOnly: 10,
        isBuffering: 1,
        isInProgress: 1,
        isLive: 10,
        isTextTrackVisible: 1,
        keySystem: 10,
        seekRange: 1,
        getLoadMode: 10
      }, Ln = { getConfiguration: 4, getStats: 5, getTextTracks: 2, getVariantTracks: 2 }, Mn = { getPlayheadTimeAsDate: 1, getPresentationStartTimeAsDate: 20 }, Nn = [["getConfiguration", "configure"]], On = [["isTextTrackVisible", "setTextTrackVisibility"]], Pn = "addChaptersTrack addTextTrackAsync addThumbnailsTrack cancelTrickPlay configure getChapters getChaptersTracks resetConfiguration retryStreaming selectAudioLanguage selectTextLanguage selectTextTrack selectVariantTrack selectVariantsByLabel setTextTrackVisibility trickPlay updateStartTime goToLive".split(" "), Qn = ["attach", "attachCanvas", "detach", "load", "unload"];
      function Rn(a, b, c, d, e, f, g) {
        var h = this;
        this.G = a;
        this.M = g;
        this.j = new P(b);
        this.O = c;
        this.u = false;
        this.s = d;
        this.F = e;
        this.J = f;
        this.h = this.m = false;
        this.L = "";
        this.o = null;
        this.B = function() {
          return Sn(h);
        };
        this.D = function(k2, l) {
          k2 = En(l);
          switch (k2.type) {
            case "event":
              var m = k2.targetName, n = Se(k2.event);
              h.s(m, n);
              break;
            case "update":
              m = k2.update;
              for (n in m) {
                k2 = h.g[n] || {};
                for (var p in m[n])
                  k2[p] = m[n][p];
              }
              h.u && (h.O(), h.u = false);
              break;
            case "asyncComplete":
              if (n = k2.id, p = k2.error, k2 = h.i[n], delete h.i[n], k2)
                if (p) {
                  n = new O(
                    p.severity,
                    p.category,
                    p.code
                  );
                  for (m in p)
                    n[m] = p[m];
                  k2.reject(n);
                } else
                  k2.resolve();
          }
        };
        this.g = { video: {}, player: {} };
        this.H = 0;
        this.i = {};
        this.l = null;
        Tn.add(this);
      }
      q = Rn.prototype;
      q.destroy = function() {
        Tn.delete(this);
        Un(this);
        Vn && Xn(this);
        this.j && (this.j.stop(), this.j = null);
        this.F = this.s = null;
        this.h = this.m = false;
        this.D = this.B = this.l = this.i = this.g = this.o = null;
        return Promise.resolve();
      };
      q.sa = function() {
        return this.h;
      };
      q.ae = function() {
        return this.L;
      };
      q.init = function() {
        if (this.G.length)
          if (window2.chrome && chrome.cast && chrome.cast.isAvailable) {
            this.m = true;
            this.j.Mb();
            var a = new chrome.cast.SessionRequest(this.G, [], null, this.M, null);
            a = new chrome.cast.ApiConfig(a, function(b) {
              for (var c = r(Tn), d = c.next(); !d.done; d = c.next())
                Yn(d.value, b);
            }, function(b) {
              for (var c = r(Tn), d = c.next(); !d.done; d = c.next())
                d = d.value, Zn = "available" == b, d.j.Mb();
            }, "origin_scoped");
            chrome.cast.initialize(a, function() {
            }, function() {
            });
            Zn && this.j.N($n);
            (a = Vn) && a.status != chrome.cast.SessionStatus.STOPPED ? Yn(this, a) : Vn = null;
          } else
            window2.__onGCastApiAvailable !== ao && (bo = window2.__onGCastApiAvailable || null, window2.__onGCastApiAvailable = ao);
      };
      q.ie = function(a) {
        this.o = a;
        this.h && co(this, { type: "appData", appData: this.o });
      };
      q.cast = function(a) {
        var b = this;
        return G(function(c) {
          if (!b.m)
            throw new O(1, 8, 8e3);
          if (!Zn)
            throw new O(1, 8, 8001);
          if (b.h)
            throw new O(1, 8, 8002);
          b.l = new lc2();
          chrome.cast.requestSession(function(d) {
            return eo(b, a, d);
          }, function(d) {
            return fo(b, d);
          });
          return u(c, b.l, 0);
        });
      };
      function go(a) {
        if (a.h) {
          var b = a.J();
          chrome.cast.requestSession(function(c) {
            return eo(a, b, c);
          }, function(c) {
            return fo(a, c);
          });
        }
      }
      q.Ab = function() {
        if (this.h) {
          Un(this);
          if (Vn) {
            Xn(this);
            try {
              Vn.stop(function() {
              }, function() {
              });
            } catch (a) {
            }
            Vn = null;
          }
          Sn(this);
        }
      };
      q.get = function(a, b) {
        var c = this;
        if ("video" == a) {
          if (Jn.includes(b))
            return function() {
              return c.Qe.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
            };
        } else if ("player" == a) {
          if (Mn[b] && !this.get("player", "isLive")())
            return function() {
            };
          if (Pn.includes(b))
            return function() {
              return c.Qe.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
            };
          if (Qn.includes(b))
            return function() {
              return c.og.apply(c, [a, b].concat(ha(Fa.apply(0, arguments))));
            };
          if (Kn[b] || Ln[b])
            return function() {
              return c.g[a][b];
            };
        }
        return this.g[a][b];
      };
      q.set = function(a, b, c) {
        this.g[a][b] = c;
        co(this, { type: "set", targetName: a, property: b, value: c });
      };
      function eo(a, b, c) {
        Vn = c;
        c.addUpdateListener(a.B);
        c.addMessageListener("urn:x-cast:com.google.shaka.v2", a.D);
        Sn(a);
        co(a, { type: "init", initState: b, appData: a.o });
        a.l.resolve();
      }
      function fo(a, b) {
        var c = 8003;
        switch (b.code) {
          case "cancel":
            c = 8004;
            break;
          case "timeout":
            c = 8005;
            break;
          case "receiver_unavailable":
            c = 8006;
        }
        a.l.reject(new O(2, 8, c, b));
      }
      q.Qe = function(a, b) {
        co(this, { type: "call", targetName: a, methodName: b, args: Fa.apply(2, arguments) });
      };
      q.og = function(a, b) {
        var c = Fa.apply(2, arguments), d = new lc2(), e = this.H.toString();
        this.H++;
        this.i[e] = d;
        try {
          co(this, { type: "asyncCall", targetName: a, methodName: b, args: c, id: e });
        } catch (f) {
          d.reject(f);
        }
        return d;
      };
      function Yn(a, b) {
        var c = a.J();
        a.l = new lc2();
        a.u = true;
        eo(a, c, b);
      }
      function Xn(a) {
        var b = Vn;
        b.removeUpdateListener(a.B);
        b.removeMessageListener("urn:x-cast:com.google.shaka.v2", a.D);
      }
      function Sn(a) {
        var b = Vn ? "connected" == Vn.status : false;
        if (a.h && !b) {
          a.F();
          for (var c in a.g)
            a.g[c] = {};
          Un(a);
        }
        a.h = b;
        a.L = b ? Vn.receiver.friendlyName : "";
        a.j.Mb();
      }
      function Un(a) {
        for (var b in a.i) {
          var c = a.i[b];
          delete a.i[b];
          c.reject(new O(1, 7, 7e3));
        }
      }
      function co(a, b) {
        b = Dn(b);
        var c = Vn;
        try {
          c.sendMessage("urn:x-cast:com.google.shaka.v2", b, function() {
          }, Za);
        } catch (d) {
          throw b = new O(2, 8, 8005, d), c = new S("error", (/* @__PURE__ */ new Map()).set("detail", b)), a.s("player", c), a.Ab(), b;
        }
      }
      var $n = 0.02, Zn = false, Vn = null, bo = null, Tn = /* @__PURE__ */ new Set();
      function ao(a) {
        bo ? window2.__onGCastApiAvailable = bo : delete window2.__onGCastApiAvailable;
        bo = null;
        if (a)
          for (var b = r(Tn), c = b.next(); !c.done; c = b.next())
            c.value.init();
        "function" === typeof window2.__onGCastApiAvailable && window2.__onGCastApiAvailable(a);
      }
      function ho(a, b, c, d) {
        d = void 0 === d ? false : d;
        Ue.call(this);
        var e = this;
        this.i = a;
        this.h = b;
        this.m = this.o = this.j = this.s = this.l = null;
        this.D = c;
        this.B = d;
        this.u = /* @__PURE__ */ new Map();
        this.g = new Rn(c, function() {
          return io(e);
        }, function() {
          return jo(e);
        }, function(f, g) {
          return ko(e, f, g);
        }, function() {
          return lo(e);
        }, function() {
          return mo(e);
        }, d);
        no(this);
      }
      oa(ho, Ue);
      q = ho.prototype;
      q.destroy = function(a) {
        a && this.g.Ab();
        this.m && (this.m.release(), this.m = null);
        a = [];
        this.h && (a.push(this.h.destroy()), this.h = null);
        this.g && (a.push(this.g.destroy()), this.g = null);
        this.s = this.l = this.i = null;
        Ue.prototype.release.call(this);
        return Promise.all(a);
      };
      q.Wf = function() {
        return this.l;
      };
      q.Nf = function() {
        return this.s;
      };
      q.nf = function() {
        return this.g.m && Zn;
      };
      q.sa = function() {
        return this.g.sa();
      };
      q.ae = function() {
        return this.g.ae();
      };
      q.cast = function() {
        var a = this, b;
        return G(function(c) {
          return 1 == c.g ? (b = mo(a), u(c, a.g.cast(b), 2)) : a.h ? u(c, a.h.re(), 0) : c.return();
        });
      };
      q.ie = function(a) {
        this.g.ie(a);
      };
      q.zg = function() {
        go(this.g);
      };
      q.Ab = function() {
        this.g.Ab();
      };
      q.qf = function(a, b) {
        b = void 0 === b ? false : b;
        var c = this;
        return G(function(d) {
          if (1 == d.g) {
            if (a == c.D && b == c.B)
              return d.return();
            c.D = a;
            c.B = b;
            c.g.Ab();
            return u(d, c.g.destroy(), 2);
          }
          c.g = null;
          c.g = new Rn(a, function() {
            return io(c);
          }, function() {
            return jo(c);
          }, function(e, f) {
            return ko(c, e, f);
          }, function() {
            return lo(c);
          }, function() {
            return mo(c);
          }, b);
          c.g.init();
          A(d);
        });
      };
      function no(a) {
        a.g.init();
        a.m = new mf();
        for (var b = r(Gn), c = b.next(); !c.done; c = b.next())
          a.m.C(a.i, c.value, function(f) {
            a.g.sa() || (f = Se(f), a.j.dispatchEvent(f));
          });
        for (var d in Te)
          a.m.C(a.h, Te[d], function(f) {
            a.g.sa() || a.o.dispatchEvent(f);
          });
        a.l = {};
        b = {};
        for (var e in a.i)
          b.Sb = e, Object.defineProperty(a.l, b.Sb, { configurable: false, enumerable: true, get: function(f) {
            return function() {
              return oo(a, f.Sb);
            };
          }(b), set: function(f) {
            return function(g) {
              var h = f.Sb;
              a.g.sa() ? a.g.set("video", h, g) : a.i[h] = g;
            };
          }(b) }), b = { Sb: b.Sb };
        a.s = {};
        po(
          a,
          function(f) {
            Object.defineProperty(a.s, f, { configurable: false, enumerable: true, get: function() {
              return qo(a, f);
            } });
          }
        );
        ro(a);
        a.j = new Ue();
        a.j.Wc = a.l;
        a.o = new Ue();
        a.o.Wc = a.s;
      }
      function ro(a) {
        var b = /* @__PURE__ */ new Map();
        po(a, function(c, d) {
          b.has(d) ? (d = b.get(d), c.length < d.length ? a.u.set(c, d) : a.u.set(d, c)) : b.set(d, c);
        });
      }
      function po(a, b) {
        function c(k2) {
          return "constructor" == k2 || "function" != typeof d[k2] ? false : !e.has(k2);
        }
        var d = a.h, e = /* @__PURE__ */ new Set(), f;
        for (f in d)
          c(f) && (e.add(f), b(f, d[f]));
        a = Object.getPrototypeOf(d);
        for (f = Object.getPrototypeOf({}); a && a != f; ) {
          for (var g = r(Object.getOwnPropertyNames(a)), h = g.next(); !h.done; h = g.next())
            h = h.value, c(h) && (e.add(h), b(h, d[h]));
          a = Object.getPrototypeOf(a);
        }
      }
      function mo(a) {
        var b = { video: {}, player: {}, playerAfterLoad: {}, manifest: a.h.Dd(), startTime: null };
        a.i.pause();
        for (var c = r(In), d = c.next(); !d.done; d = c.next())
          d = d.value, b.video[d] = a.i[d];
        a.i.ended || (b.startTime = a.i.currentTime);
        c = r(Nn);
        for (d = c.next(); !d.done; d = c.next()) {
          var e = d.value;
          d = e[1];
          e = a.h[e[0]]();
          b.player[d] = e;
        }
        c = r(On);
        for (d = c.next(); !d.done; d = c.next())
          e = d.value, d = e[1], e = a.h[e[0]](), b.playerAfterLoad[d] = e;
        return b;
      }
      function io(a) {
        var b = new S("caststatuschanged");
        a.dispatchEvent(b);
      }
      function jo(a) {
        var b = new S(a.l.paused ? "pause" : "play");
        a.j.dispatchEvent(b);
      }
      function lo(a) {
        for (var b = r(Nn), c = b.next(); !c.done; c = b.next()) {
          var d = c.value;
          c = d[1];
          d = a.g.get("player", d[0])();
          a.h[c](d);
        }
        var e = a.g.get("player", "getAssetUri")();
        c = a.g.get("video", "ended");
        b = Promise.resolve();
        var f = a.i.autoplay;
        d = null;
        c || (d = a.g.get("video", "currentTime"));
        e && (a.i.autoplay = false, b = a.h.load(e, d));
        var g = {};
        c = r(In);
        for (d = c.next(); !d.done; d = c.next())
          d = d.value, g[d] = a.g.get("video", d);
        b.then(function() {
          if (a.i) {
            for (var h = r(In), k2 = h.next(); !k2.done; k2 = h.next())
              k2 = k2.value, a.i[k2] = g[k2];
            h = r(On);
            for (k2 = h.next(); !k2.done; k2 = h.next()) {
              var l = k2.value;
              k2 = l[1];
              l = a.g.get("player", l[0])();
              a.h[k2](l);
            }
            a.i.autoplay = f;
            e && a.i.play();
          }
        }, function(h) {
          h = (/* @__PURE__ */ new Map()).set("detail", h);
          h = new S("error", h);
          a.h.dispatchEvent(h);
        });
      }
      function oo(a, b) {
        if ("addEventListener" == b)
          return function(d, e, f) {
            return a.j.addEventListener(d, e, f);
          };
        if ("removeEventListener" == b)
          return function(d, e, f) {
            return a.j.removeEventListener(d, e, f);
          };
        if (a.g.sa() && 0 == Object.keys(a.g.g.video).length) {
          var c = a.i[b];
          if ("function" != typeof c)
            return c;
        }
        return a.g.sa() ? a.g.get("video", b) : (b = a.i[b], "function" == typeof b && (b = b.bind(a.i)), b);
      }
      function qo(a, b) {
        a.u.has(b) && (b = a.u.get(b));
        if ("addEventListener" == b)
          return function(c, d, e) {
            return a.o.addEventListener(c, d, e);
          };
        if ("removeEventListener" == b)
          return function(c, d, e) {
            return a.o.removeEventListener(c, d, e);
          };
        if ("getMediaElement" == b)
          return function() {
            return a.l;
          };
        if ("getSharedConfiguration" == b)
          return a.g.get("player", "getConfiguration");
        if ("getNetworkingEngine" == b)
          return function() {
            return a.h.jc();
          };
        if ("getDrmEngine" == b)
          return function() {
            return a.h.m;
          };
        if ("getAdManager" == b)
          return function() {
            return a.h.Ge();
          };
        if ("setVideoContainer" == b)
          return function(c) {
            return a.h.$e(c);
          };
        if (a.g.sa()) {
          if ("getManifest" == b || "drmInfo" == b)
            return function() {
              Wa(b + "() does not work while casting!");
              return null;
            };
          if ("attach" == b || "detach" == b)
            return function() {
              Wa(b + "() does not work while casting!");
              return Promise.resolve();
            };
        }
        return a.g.sa() && 0 == Object.keys(a.g.g.video).length && (Kn[b] || Ln[b]) || !a.g.sa() ? a.h[b].bind(a.h) : a.g.get("player", b);
      }
      function ko(a, b, c) {
        a.g.sa() && ("video" == b ? a.j.dispatchEvent(c) : "player" == b && a.o.dispatchEvent(c));
      }
      K("shaka.cast.CastProxy", ho);
      ho.prototype.changeReceiverId = ho.prototype.qf;
      ho.prototype.forceDisconnect = ho.prototype.Ab;
      ho.prototype.suggestDisconnect = ho.prototype.zg;
      ho.prototype.setAppData = ho.prototype.ie;
      ho.prototype.cast = ho.prototype.cast;
      ho.prototype.receiverName = ho.prototype.ae;
      ho.prototype.isCasting = ho.prototype.sa;
      ho.prototype.canCast = ho.prototype.nf;
      ho.prototype.getPlayer = ho.prototype.Nf;
      ho.prototype.getVideo = ho.prototype.Wf;
      ho.prototype.destroy = ho.prototype.destroy;
      function so(a, b, c, d) {
        Ue.call(this);
        var e = this;
        this.g = a;
        this.h = b;
        this.j = new mf();
        this.H = { video: a, player: b };
        this.D = c || function() {
        };
        this.J = d || function(f) {
          return f;
        };
        this.i = null;
        this.F = false;
        this.o = true;
        this.m = 0;
        this.B = false;
        this.u = true;
        this.s = this.l = null;
        this.G = new P(function() {
          to(e);
        });
        uo(this);
      }
      oa(so, Ue);
      q = so.prototype;
      q.isConnected = function() {
        return this.F;
      };
      q.$f = function() {
        return this.o;
      };
      q.wg = function(a) {
        this.i = a;
      };
      q.uf = function() {
        this.i = null;
      };
      q.xg = function(a) {
        this.i || (this.i = { metadataType: cast.receiver.media.MetadataType.GENERIC });
        this.i.title = a;
      };
      q.vg = function(a) {
        this.i || (this.i = { metadataType: cast.receiver.media.MetadataType.GENERIC });
        this.i.images = [{ url: a }];
      };
      q.ug = function(a) {
        this.i || (this.i = {});
        this.i.artist = a;
        this.i.metadataType = cast.receiver.media.MetadataType.MUSIC_TRACK;
      };
      q.destroy = function() {
        var a = this, b, c;
        return G(function(d) {
          if (1 == d.g)
            return a.j && (a.j.release(), a.j = null), b = [], a.h && (b.push(a.h.destroy()), a.h = null), a.G && (a.G.stop(), a.G = null), a.g = null, a.H = null, a.D = null, a.F = false, a.o = true, a.l = null, a.s = null, Ue.prototype.release.call(a), u(d, Promise.all(b), 2);
          c = cast.receiver.CastReceiverManager.getInstance();
          c.stop();
          A(d);
        });
      };
      function uo(a) {
        var b = cast.receiver.CastReceiverManager.getInstance();
        b.onSenderConnected = function() {
          return vo(a);
        };
        b.onSenderDisconnected = function() {
          return vo(a);
        };
        b.onSystemVolumeChanged = function() {
          var e = cast.receiver.CastReceiverManager.getInstance().getSystemVolume();
          e && wo(a, { type: "update", update: { video: { volume: e.level, muted: e.muted } } }, a.l);
          wo(a, { type: "event", targetName: "video", event: { type: "volumechange" } }, a.l);
        };
        a.s = b.getCastMessageBus("urn:x-cast:com.google.cast.media");
        a.s.onMessage = function(e) {
          return xo(
            a,
            e
          );
        };
        a.l = b.getCastMessageBus("urn:x-cast:com.google.shaka.v2");
        a.l.onMessage = function(e) {
          return yo(a, e);
        };
        b.start();
        b = r(Gn);
        for (var c = b.next(); !c.done; c = b.next())
          a.j.C(a.g, c.value, function(e) {
            return zo(a, "video", e);
          });
        for (var d in Te)
          a.j.C(a.h, Te[d], function(e) {
            return zo(a, "player", e);
          });
        cast.__platform__ && cast.__platform__.canDisplayType('video/mp4; codecs="avc1.640028"; width=3840; height=2160') ? a.h.ke(3840, 2160) : a.h.ke(1920, 1080);
        a.j.C(a.g, "loadeddata", function() {
          a.B = true;
        });
        a.j.C(a.h, "loading", function() {
          a.o = false;
          Ao(a);
        });
        a.j.C(a.g, "playing", function() {
          a.o = false;
          Ao(a);
        });
        a.j.C(a.g, "pause", function() {
          Ao(a);
        });
        a.j.C(a.h, "unloading", function() {
          a.o = true;
          Ao(a);
        });
        a.j.C(a.g, "ended", function() {
          new P(function() {
            a.g && a.g.ended && (a.o = true, Ao(a));
          }).N(Bo);
        });
      }
      function vo(a) {
        a.m = 0;
        a.u = true;
        a.F = 0 != cast.receiver.CastReceiverManager.getInstance().getSenders().length;
        Ao(a);
      }
      function Ao(a) {
        var b;
        G(function(c) {
          if (1 == c.g)
            return u(c, Promise.resolve(), 2);
          if (!a.h)
            return c.return();
          b = new S("caststatuschanged");
          a.dispatchEvent(b);
          Co(a) || Do(a);
          A(c);
        });
      }
      function Eo(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p;
        G(function(t) {
          switch (t.g) {
            case 1:
              for (d in b.player)
                e = b.player[d], a.h[d](e);
              a.D(c);
              f = a.g.autoplay;
              return b.manifest ? (a.g.autoplay = false, D(t, 5), u(t, a.h.load(b.manifest, b.startTime), 7)) : u(t, Promise.resolve(), 3);
            case 7:
              ta(t, 3);
              break;
            case 5:
              return g = ua(t), h = (/* @__PURE__ */ new Map()).set("detail", g), k2 = new S("error", h), a.h && a.h.dispatchEvent(k2), t.return();
            case 3:
              if (!a.h)
                return t.return();
              for (l in b.video)
                m = b.video[l], a.g[l] = m;
              for (n in b.playerAfterLoad)
                p = b.playerAfterLoad[n], a.h[n](p);
              a.g.autoplay = f;
              b.manifest && (a.g.play(), Do(a));
              A(t);
          }
        });
      }
      function zo(a, b, c) {
        a.h && (to(a), wo(a, { type: "event", targetName: b, event: c }, a.l));
      }
      function to(a) {
        a.G.N(Fo);
        for (var b = { video: {}, player: {} }, c = r(Hn), d = c.next(); !d.done; d = c.next())
          d = d.value, b.video[d] = a.g[d];
        if (a.h.U())
          for (var e in Mn)
            0 == a.m % Mn[e] && (b.player[e] = a.h[e]());
        for (var f in Kn)
          0 == a.m % Kn[f] && (b.player[f] = a.h[f]());
        if (c = cast.receiver.CastReceiverManager.getInstance().getSystemVolume())
          b.video.volume = c.level, b.video.muted = c.muted;
        wo(a, { type: "update", update: b }, a.l);
        for (var g in Ln)
          0 == a.m % Ln[g] && (b = { player: {} }, b.player[g] = a.h[g](), wo(a, { type: "update", update: b }, a.l));
        a.B && (a.m += 1);
        Co(a);
      }
      function Co(a) {
        return a.u && (a.g.duration || a.h.U()) ? (Go(a), a.u = false, true) : false;
      }
      function Go(a, b) {
        var c = { contentId: a.h.Dd(), streamType: a.h.U() ? "LIVE" : "BUFFERED", contentType: "" };
        a.h.U() || (c.duration = a.g.duration);
        a.i && (c.metadata = a.i);
        Do(a, void 0 === b ? 0 : b, c);
      }
      function yo(a, b) {
        var c = En(b.data);
        switch (c.type) {
          case "init":
            a.m = 0;
            a.B = false;
            a.u = true;
            Eo(a, c.initState, c.appData);
            to(a);
            break;
          case "appData":
            a.D(c.appData);
            break;
          case "set":
            var d = c.targetName, e = c.property;
            c = c.value;
            if ("video" == d) {
              if (b = cast.receiver.CastReceiverManager.getInstance(), "volume" == e) {
                b.setSystemVolumeLevel(c);
                break;
              } else if ("muted" == e) {
                b.setSystemVolumeMuted(c);
                break;
              }
            }
            a.H[d][e] = c;
            break;
          case "call":
            d = a.H[c.targetName];
            d[c.methodName].apply(d, c.args);
            break;
          case "asyncCall":
            d = c.targetName;
            e = c.methodName;
            "player" == d && "load" == e && (a.m = 0, a.B = false);
            var f = c.id, g = b.senderId;
            b = a.H[d];
            c = b[e].apply(b, c.args);
            "player" == d && "load" == e && (c = c.then(function() {
              a.u = true;
            }));
            c.then(function() {
              return Ho(a, g, f, null);
            }, function(h) {
              return Ho(a, g, f, h);
            });
        }
      }
      function xo(a, b) {
        var c = En(b.data);
        switch (c.type) {
          case "PLAY":
            a.g.play();
            Do(a);
            break;
          case "PAUSE":
            a.g.pause();
            Do(a);
            break;
          case "SEEK":
            b = c.currentTime;
            var d = c.resumeState;
            null != b && (a.g.currentTime = Number(b));
            d && "PLAYBACK_START" == d ? (a.g.play(), Do(a)) : d && "PLAYBACK_PAUSE" == d && (a.g.pause(), Do(a));
            break;
          case "STOP":
            a.h.re().then(function() {
              a.h && Do(a);
            });
            break;
          case "GET_STATUS":
            Go(a, Number(c.requestId));
            break;
          case "VOLUME":
            d = c.volume;
            b = d.level;
            d = d.muted;
            var e = a.g.volume, f = a.g.muted;
            null != b && (a.g.volume = Number(b));
            null != d && (a.g.muted = d);
            e == a.g.volume && f == a.g.muted || Do(a);
            break;
          case "LOAD":
            a.m = 0;
            a.B = false;
            a.u = false;
            b = c.media;
            d = c.currentTime;
            e = a.J(b.contentId);
            f = c.autoplay || true;
            a.D(b.customData);
            f && (a.g.autoplay = true);
            a.h.load(e, d).then(function() {
              a.h && Go(a);
            }).catch(function(g) {
              var h = "LOAD_FAILED";
              7 == g.category && 7e3 == g.code && (h = "LOAD_CANCELLED");
              wo(a, { requestId: Number(c.requestId), type: h }, a.s);
            });
            break;
          default:
            wo(a, { requestId: Number(c.requestId), type: "INVALID_REQUEST", reason: "INVALID_COMMAND" }, a.s);
        }
      }
      function Ho(a, b, c, d) {
        a.h && wo(a, { type: "asyncComplete", id: c, error: d }, a.l, b);
      }
      function wo(a, b, c, d) {
        a.F && (a = Dn(b), d ? c.getCastChannel(d).send(a) : c.broadcast(a));
      }
      function Do(a, b, c) {
        c = void 0 === c ? null : c;
        var d = { mediaSessionId: 0, playbackRate: a.g.playbackRate, playerState: a.o ? Io : a.h.Fd() ? Jo : a.g.paused ? Ko : Lo, currentTime: a.g.currentTime, supportedMediaCommands: 63, volume: { level: a.g.volume, muted: a.g.muted } };
        c && (d.media = c);
        wo(a, { requestId: void 0 === b ? 0 : b, type: "MEDIA_STATUS", status: [d] }, a.s);
      }
      K("shaka.cast.CastReceiver", so);
      so.prototype.destroy = so.prototype.destroy;
      so.prototype.setContentArtist = so.prototype.ug;
      so.prototype.setContentImage = so.prototype.vg;
      so.prototype.setContentTitle = so.prototype.xg;
      so.prototype.clearContentMetadata = so.prototype.uf;
      so.prototype.setContentMetadata = so.prototype.wg;
      so.prototype.isIdle = so.prototype.$f;
      so.prototype.isConnected = so.prototype.isConnected;
      var Fo = 0.5, Bo = 5, Io = "IDLE", Lo = "PLAYING", Jo = "BUFFERING", Ko = "PAUSED";
      function Mo(a, b, c) {
        var d = No(a), e = null;
        a = [];
        var f = [], g = new Set(d.map(function(h) {
          return h.keyId;
        }));
        g.delete(null);
        if (1 < g.size)
          throw new O(2, 4, 4010);
        b || (f = d.filter(function(h) {
          return "urn:mpeg:dash:mp4protection:2011" == h.fe ? (e = h.init || e, false) : true;
        }), f.length && (a = Oo(e, f, c, g), 0 == a.length && (a = [fc("", e)])));
        if (d.length && (b || !f.length))
          for (a = [], b = r(Object.values(c)), c = b.next(); !c.done; c = b.next())
            c = c.value, "org.w3.clearkey" != c && a.push(fc(c, e));
        if (g = Array.from(g)[0] || null)
          for (b = r(a), c = b.next(); !c.done; c = b.next())
            for (c = r(c.value.initData), d = c.next(); !d.done; d = c.next())
              d.value.keyId = g;
        return { Be: g, sh: e, drmInfos: a, Fe: true };
      }
      function Po(a, b, c, d) {
        var e = Mo(a, c, d);
        if (b.Fe) {
          a = 1 == b.drmInfos.length && !b.drmInfos[0].keySystem;
          c = 0 == e.drmInfos.length;
          if (0 == b.drmInfos.length || a && !c)
            b.drmInfos = e.drmInfos;
          b.Fe = false;
        } else if (0 < e.drmInfos.length && (b.drmInfos = b.drmInfos.filter(function(f) {
          return e.drmInfos.some(function(g) {
            return g.keySystem == f.keySystem;
          });
        }), 0 == b.drmInfos.length))
          throw new O(2, 4, 4008);
        return e.Be || b.Be;
      }
      function Qo(a) {
        var b = 0, c = Lb(a), d = c.getUint32(b, true);
        if (d != a.byteLength)
          return [];
        a: {
          a = b + 6;
          for (b = []; a < c.byteLength - 1; ) {
            d = c.getUint16(a, true);
            a += 2;
            var e = c.getUint16(a, true);
            a += 2;
            if (0 != (e & 1) || e + a > c.byteLength) {
              c = [];
              break a;
            }
            var f = M(c, a, e);
            b.push({ type: d, value: f });
            a += e;
          }
          c = b;
        }
        return c;
      }
      function Ro(a) {
        a = r(a.getElementsByTagName("DATA"));
        for (var b = a.next(); !b.done; b = a.next()) {
          b = r(b.value.childNodes);
          for (var c = b.next(); !c.done; c = b.next())
            if (c = c.value, c instanceof Element && "LA_URL" == c.tagName)
              return c.textContent;
        }
        return "";
      }
      function So(a) {
        a = Nf(a.node, "urn:microsoft:playready", "pro");
        if (!a)
          return "";
        a = Lc(a.textContent);
        a = Qo(a).filter(function(b) {
          return b.type === To;
        })[0];
        if (!a)
          return "";
        a = Dc(a.value, true);
        return (a = cg(a, "WRMHEADER")) ? Ro(a) : "";
      }
      function Oo(a, b, c, d) {
        var e = [];
        b = r(b);
        for (var f = b.next(); !f.done; f = b.next()) {
          f = f.value;
          var g = c[f.fe];
          if (g) {
            var h;
            if (h = Nf(f.node, "urn:microsoft:playready", "pro")) {
              h = Lc(h.textContent);
              var k2 = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
              h = [{ initData: Kf(h, k2, /* @__PURE__ */ new Set(), 0), initDataType: "cenc", keyId: f.keyId }];
            } else
              h = null;
            k2 = null;
            if ("urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e" === f.fe)
              if (k2 = d, 0 == k2.size)
                k2 = null;
              else {
                var l = new Uint8Array([
                  16,
                  119,
                  239,
                  236,
                  192,
                  178,
                  77,
                  2,
                  172,
                  227,
                  60,
                  30,
                  82,
                  226,
                  251,
                  75
                ]), m = new Uint8Array([]);
                k2 = [{ initData: Kf(m, l, k2, 1), initDataType: "cenc", keyId: f.keyId }];
              }
            h = fc(g, f.init || a || h || k2);
            if (g = Uo.get(g))
              h.licenseServerUri = g(f);
            e.push(h);
          }
        }
        return e;
      }
      function No(a) {
        var b = [];
        a = r(a);
        for (var c = a.next(); !c.done; c = a.next())
          (c = Vo(c.value)) && b.push(c);
        return b;
      }
      function Vo(a) {
        var b = a.getAttribute("schemeIdUri"), c = Qf(a, "urn:mpeg:cenc:2013", "default_KID"), d = Of(a, "urn:mpeg:cenc:2013", "pssh").map(Sf);
        if (!b)
          return null;
        b = b.toLowerCase();
        if (c && (c = c.replace(/-/g, "").toLowerCase(), c.includes(" ")))
          throw new O(2, 4, 4009);
        var e = [];
        try {
          e = d.map(function(f) {
            return { initDataType: "cenc", initData: Lc(f), keyId: null };
          });
        } catch (f) {
          throw new O(2, 4, 4007);
        }
        return { node: a, fe: b, keyId: c, init: 0 < e.length ? e : null };
      }
      var To = 1, Uo = (/* @__PURE__ */ new Map()).set("com.widevine.alpha", function(a) {
        return (a = Nf(a.node, "urn:microsoft", "laurl")) ? a.getAttribute("licenseUrl") || "" : "";
      }).set("com.microsoft.playready", So).set("com.microsoft.playready.recommendation", So).set("com.microsoft.playready.software", So).set("com.microsoft.playready.hardware", So).set("org.w3.clearkey", function(a) {
        return (a = Nf(a.node, "http://dashif.org/guidelines/clearKey", "Laurl")) && "EME-1.0" === a.getAttribute("Lic_type") && a.textContent ? a.textContent : "";
      });
      function Wo(a, b, c, d, e) {
        var f = { RepresentationID: b, Number: c, Bandwidth: d, Time: e };
        return a.replace(/\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\$/g, function(g, h, k2, l) {
          if ("$$" == g)
            return "$";
          var m = f[h];
          if (null == m)
            return g;
          "RepresentationID" == h && k2 && (k2 = void 0);
          "Time" == h && (m = Math.round(m));
          switch (l) {
            case void 0:
            case "d":
            case "i":
            case "u":
              g = m.toString();
              break;
            case "o":
              g = m.toString(8);
              break;
            case "x":
              g = m.toString(16);
              break;
            case "X":
              g = m.toString(16).toUpperCase();
              break;
            default:
              g = m.toString();
          }
          k2 = window2.parseInt(k2, 10) || 1;
          return Array(Math.max(0, k2 - g.length) + 1).join("0") + g;
        });
      }
      function Xo(a, b) {
        var c = Yo(a, b, "timescale"), d = 1;
        c && (d = Zf(c) || 1);
        var e = Yo(a, b, "duration");
        c = Zf(e || "");
        "image" == a.I.contentType && (c = ag(e || ""));
        c && (c /= d);
        var f = Yo(a, b, "startNumber");
        e = Number(Yo(a, b, "presentationTimeOffset")) || 0;
        var g = $f(f || "");
        if (null == f || null == g)
          g = 1;
        f = Zo(a, b, "SegmentTimeline");
        b = null;
        if (f) {
          b = d;
          a = a.T.duration || Infinity;
          f = Mf(f, "S");
          for (var h = [], k2 = -e, l = 0; l < f.length; ++l) {
            var m = f[l], n = f[l + 1], p = Uf(m, "t", $f), t = Uf(m, "d", $f);
            m = Uf(m, "r", Yf);
            null != p && (p -= e);
            if (!t)
              break;
            p = null != p ? p : k2;
            m = m || 0;
            if (0 > m)
              if (n) {
                n = Uf(n, "t", $f);
                if (null == n)
                  break;
                else if (p >= n)
                  break;
                m = Math.ceil((n - p) / t) - 1;
              } else {
                if (Infinity == a)
                  break;
                else if (p / b >= a)
                  break;
                m = Math.ceil((a * b - p) / t) - 1;
              }
            0 < h.length && p != k2 && (h[h.length - 1].end = p / b);
            for (n = 0; n <= m; ++n)
              k2 = p + t, h.push({ start: p / b, end: k2 / b, Dg: p }), p = k2;
          }
          b = h;
        }
        return { timescale: d, ia: c, Lb: g, Sa: e / d || 0, se: e, timeline: b };
      }
      function Yo(a, b, c) {
        return [b(a.I), b(a.fa), b(a.$)].filter(dc).map(function(d) {
          return d.getAttribute(c);
        }).reduce(function(d, e) {
          return d || e;
        });
      }
      function Zo(a, b, c) {
        return [b(a.I), b(a.fa), b(a.$)].filter(dc).map(function(d) {
          return Lf(d, c);
        }).reduce(function(d, e) {
          return d || e;
        });
      }
      function $o(a, b, c, d, e, f) {
        for (var g = Qf(a, "http://www.w3.org/1999/xlink", "href"), h = Qf(a, "http://www.w3.org/1999/xlink", "actuate") || "onRequest", k2 = r(Array.from(a.attributes)), l = k2.next(); !l.done; l = k2.next())
          l = l.value, "http://www.w3.org/1999/xlink" == l.namespaceURI && a.removeAttributeNS(l.namespaceURI, l.localName);
        if (5 <= f)
          return Me(new O(2, 4, 4028));
        if ("onLoad" != h)
          return Me(new O(2, 4, 4027));
        var m = ec([d], [g]);
        return e.request(0, cf(m, b)).Y(function(n) {
          n = eg(n.data, a.tagName);
          if (!n)
            return Me(new O(2, 4, 4001, g));
          for (; a.childNodes.length; )
            a.removeChild(a.childNodes[0]);
          for (; n.childNodes.length; ) {
            var p = n.childNodes[0];
            n.removeChild(p);
            a.appendChild(p);
          }
          n = r(Array.from(n.attributes));
          for (p = n.next(); !p.done; p = n.next())
            a.setAttributeNode(p.value.cloneNode(false));
          return ap(a, b, c, m[0], e, f + 1);
        });
      }
      function ap(a, b, c, d, e, f) {
        f = void 0 === f ? 0 : f;
        if (Qf(a, "http://www.w3.org/1999/xlink", "href")) {
          var g = $o(a, b, c, d, e, f);
          c && (g = g.Y(void 0, function() {
            return ap(a, b, c, d, e, f);
          }));
          return g;
        }
        g = [];
        for (var h = r(Array.from(a.childNodes)), k2 = h.next(); !k2.done; k2 = h.next())
          k2 = k2.value, k2 instanceof Element && ("urn:mpeg:dash:resolve-to-zero:2013" == Qf(k2, "http://www.w3.org/1999/xlink", "href") ? a.removeChild(k2) : "SegmentTimeline" != k2.tagName && g.push(ap(k2, b, c, d, e, f)));
        return Qe(g).Y(function() {
          return a;
        });
      }
      function bp(a, b, c, d, e, f, g) {
        var h, k2 = new zf().P("sidx", function(l) {
          h = cp(b, d, e, f, g, c, l);
        });
        a && k2.parse(a);
        if (h)
          return h;
        throw new O(2, 3, 3004);
      }
      function cp(a, b, c, d, e, f, g) {
        var h = [];
        g.reader.skip(4);
        var k2 = g.reader.K();
        if (0 == k2)
          throw new O(2, 3, 3005);
        if (0 == g.version) {
          var l = g.reader.K();
          var m = g.reader.K();
        } else
          l = g.reader.$a(), m = g.reader.$a();
        g.reader.skip(2);
        var n = g.reader.$d();
        a = a + g.size + m;
        for (m = 0; m < n; m++) {
          var p = g.reader.K(), t = (p & 2147483648) >>> 31;
          p &= 2147483647;
          var v = g.reader.K();
          g.reader.skip(4);
          if (1 == t)
            throw new O(2, 3, 3006);
          h.push(new qi(l / k2 + c, (l + v) / k2 + c, function() {
            return f;
          }, a, a + p - 1, b, c, d, e));
          l += v;
          a += p;
        }
        g.parser.stop();
        return h;
      }
      function dp(a) {
        this.h = Lb(a);
        this.g = new wf(this.h, 0);
      }
      dp.prototype.ha = function() {
        return this.g.ha();
      };
      function ep(a) {
        var b = fp(a);
        if (7 < b.length)
          throw new O(2, 3, 3002);
        var c = 0;
        b = r(b);
        for (var d = b.next(); !d.done; d = b.next())
          c = 256 * c + d.value;
        b = fp(a);
        a: {
          d = r(gp);
          for (var e = d.next(); !e.done; e = d.next())
            if (Gb(b, new Uint8Array(e.value))) {
              d = true;
              break a;
            }
          d = false;
        }
        if (d)
          b = a.h.byteLength - a.g.Z();
        else {
          if (8 == b.length && b[1] & 224)
            throw new O(2, 3, 3001);
          for (e = d = 0; e < b.length; e++) {
            var f = b[e];
            d = 0 == e ? f & (1 << 8 - b.length) - 1 : 256 * d + f;
          }
          b = d;
        }
        b = a.g.Z() + b <= a.h.byteLength ? b : a.h.byteLength - a.g.Z();
        d = Lb(a.h, a.g.Z(), b);
        a.g.skip(b);
        return new hp(c, d);
      }
      function fp(a) {
        var b = a.g.Z(), c = a.g.Ra();
        if (0 == c)
          throw new O(2, 3, 3002);
        c = 8 - Math.floor(Math.log2(c));
        a.g.skip(c - 1);
        return M(a.h, b, c);
      }
      var gp = [[255], [127, 255], [63, 255, 255], [31, 255, 255, 255], [15, 255, 255, 255, 255], [7, 255, 255, 255, 255, 255], [3, 255, 255, 255, 255, 255, 255], [1, 255, 255, 255, 255, 255, 255, 255]];
      function hp(a, b) {
        this.id = a;
        this.g = b;
      }
      function ip(a) {
        if (8 < a.g.byteLength)
          throw new O(2, 3, 3002);
        if (8 == a.g.byteLength && a.g.getUint8(0) & 224)
          throw new O(2, 3, 3001);
        for (var b = 0, c = 0; c < a.g.byteLength; c++) {
          var d = a.g.getUint8(c);
          b = 256 * b + d;
        }
        return b;
      }
      function jp(a, b, c, d, e, f, g, h, k2) {
        function l() {
          return e;
        }
        var m = [];
        a = new dp(a.g);
        for (var n = null, p = null; a.ha(); ) {
          var t = ep(a);
          if (187 == t.id) {
            var v = kp(t);
            v && (t = c * v.Eg, v = b + v.ng, null != n && m.push(new qi(n + g, t + g, l, p, v - 1, f, g, h, k2)), n = t, p = v);
          }
        }
        null != n && m.push(new qi(n + g, d + g, l, p, null, f, g, h, k2));
        return m;
      }
      function kp(a) {
        var b = new dp(a.g);
        a = ep(b);
        if (179 != a.id)
          throw new O(2, 3, 3013);
        a = ip(a);
        b = ep(b);
        if (183 != b.id)
          throw new O(2, 3, 3012);
        b = new dp(b.g);
        for (var c = 0; b.ha(); ) {
          var d = ep(b);
          if (241 == d.id) {
            c = ip(d);
            break;
          }
        }
        return { Eg: a, ng: c };
      }
      function lp(a, b) {
        b = Zo(a, b, "Initialization");
        if (!b)
          return null;
        var c = a.I.wa, d = b.getAttribute("sourceURL");
        d && (c = ec(a.I.wa, [d]));
        d = 0;
        var e = null;
        if (b = Uf(b, "range", Xf))
          d = b.start, e = b.end;
        return new oi(function() {
          return c;
        }, d, e, mp(a));
      }
      function np(a, b) {
        var c = Number(Yo(a, op, "presentationTimeOffset")) || 0, d = Yo(a, op, "timescale"), e = 1;
        d && (e = Zf(d) || 1);
        var f = c / e || 0, g = lp(a, op);
        pp(a, g);
        var h = We(a);
        return { Bb: function() {
          var k2 = Zo(h, op, "RepresentationIndex");
          var l = h.I.wa;
          k2 && (k2 = k2.getAttribute("sourceURL")) && (l = ec(h.I.wa, [k2]));
          k2 = qp(h);
          return rp(h, b, g, l, k2.start, k2.end, f);
        } };
      }
      function rp(a, b, c, d, e, f, g) {
        var h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E;
        return G(function(F) {
          if (1 == F.g)
            return h = a.presentationTimeline, k2 = !a.Ma || !a.T.Gd, l = a.T.start, m = a.T.duration, n = a.I.mimeType.split("/")[1], p = b, t = null, v = [p(d, e, f), "webm" == n ? p(c.ya(), c.Ba, c.ka) : null], p = null, u(F, Promise.all(v), 2);
          y = F.h;
          w = y[0];
          x = y[1] || null;
          C = null;
          z = l - g;
          B = l;
          E = m ? l + m : Infinity;
          if ("mp4" == n)
            var H = bp(w, e, d, c, z, B, E);
          else {
            H = new dp(x);
            if (440786851 != ep(H).id)
              throw new O(2, 3, 3008);
            var I = ep(H);
            if (408125543 != I.id)
              throw new O(2, 3, 3009);
            H = I.g.byteOffset;
            I = new dp(I.g);
            for (var J = null; I.ha(); ) {
              var L = ep(I);
              if (357149030 == L.id) {
                J = L;
                break;
              }
            }
            if (!J)
              throw new O(2, 3, 3010);
            J = new dp(J.g);
            L = 1e6;
            for (I = null; J.ha(); ) {
              var R = ep(J);
              if (2807729 == R.id)
                L = ip(R);
              else if (17545 == R.id)
                if (4 == R.g.byteLength)
                  I = R.g.getFloat32(0);
                else if (8 == R.g.byteLength)
                  I = R.g.getFloat64(0);
                else
                  throw new O(2, 3, 3003);
            }
            if (null == I)
              throw new O(2, 3, 3011);
            J = L / 1e9;
            I *= J;
            L = ep(new dp(w));
            if (475249515 != L.id)
              throw new O(2, 3, 3007);
            H = jp(L, H, J, I, d, c, z, B, E);
          }
          C = H;
          h.Ib(C);
          t = new Jj(C);
          k2 && t.Wa(B, E, true);
          return F.return(t);
        });
      }
      function op(a) {
        return a.wc;
      }
      function qp(a) {
        var b = Zo(a, op, "RepresentationIndex");
        a = Yo(a, op, "indexRange");
        a = Xf(a || "");
        b && (a = Uf(b, "range", Xf, a));
        return a;
      }
      function pp(a, b) {
        sp(a, b);
        if (!qp(a))
          throw new O(2, 4, 4002);
      }
      function sp(a, b) {
        var c = a.I.mimeType.split("/")[1];
        if (a.I.contentType != jc && "mp4" != c && "webm" != c)
          throw new O(2, 4, 4006);
        if ("webm" == c && !b)
          throw new O(2, 4, 4005);
      }
      function mp(a) {
        var b = a.I;
        return { bandwidth: a.bandwidth, audioSamplingRate: b.audioSamplingRate, codecs: b.codecs, contentType: b.contentType, frameRate: b.frameRate || null, height: b.height || null, mimeType: b.mimeType, channelsCount: b.ad, pixelAspectRatio: b.pixelAspectRatio || null, width: b.width || null };
      }
      function tp(a, b) {
        var c = lp(a, up2), d = vp(a);
        if (!d.ia && !d.timeline && 1 < d.Gb.length)
          throw new O(2, 4, 4002);
        if (!d.ia && !a.T.duration && !d.timeline && 1 == d.Gb.length)
          throw new O(2, 4, 4002);
        if (d.timeline && 0 == d.timeline.length)
          throw new O(2, 4, 4002);
        var e = null, f = null;
        a.$.id && a.I.id && (f = b[a.$.id + "," + a.I.id]) && (e = f.segmentIndex);
        var g = wp(a.T.start, a.T.duration, a.I.wa, d, c);
        b = !e;
        e ? e.Hb(g, a.presentationTimeline.Pa()) : e = new Jj(g);
        a.presentationTimeline.Ib(g);
        a.Ma && a.T.Gd || e.Wa(a.T.start, a.T.duration ? a.T.start + a.T.duration : Infinity, b);
        f && (f.segmentIndex = e);
        return { Bb: function() {
          e && 0 != e.g.length || e.pc(g);
          return Promise.resolve(e);
        } };
      }
      function up2(a) {
        return a.ab;
      }
      function vp(a) {
        var b = xp(a);
        a = Xo(a, up2);
        var c = a.Lb;
        0 == c && (c = 1);
        var d = 0;
        a.ia ? d = a.ia * (c - 1) : a.timeline && 0 < a.timeline.length && (d = a.timeline[0].start);
        return { ia: a.ia, startTime: d, Lb: c, Sa: a.Sa, timeline: a.timeline, Gb: b };
      }
      function wp(a, b, c, d, e) {
        var f = d.Gb.length;
        d.timeline && d.timeline.length != d.Gb.length && (f = Math.min(d.timeline.length, d.Gb.length));
        for (var g = a - d.Sa, h = b ? a + b : Infinity, k2 = [], l = d.startTime, m = {}, n = 0; n < f; m = { od: m.od }, n++) {
          var p = d.Gb[n];
          m.od = ec(c, [p.dg]);
          var t = void 0;
          t = null != d.ia ? l + d.ia : d.timeline ? d.timeline[n].end : l + b;
          k2.push(new qi(a + l, a + t, function(v) {
            return function() {
              return v.od;
            };
          }(m), p.start, p.end, e, g, a, h));
          l = t;
        }
        return k2;
      }
      function xp(a) {
        return [a.I.ab, a.fa.ab, a.$.ab].filter(dc).map(function(b) {
          return Mf(b, "SegmentURL");
        }).reduce(function(b, c) {
          return 0 < b.length ? b : c;
        }).map(function(b) {
          b.getAttribute("indexRange") && !a.Ke && (a.Ke = true);
          var c = b.getAttribute("media");
          b = Uf(b, "mediaRange", Xf, { start: 0, end: null });
          return { dg: c, start: b.start, end: b.end };
        });
      }
      function yp(a, b, c, d, e, f) {
        var g = zp(a), h = Ap(a);
        Bp(h);
        var k2 = We(a);
        if (h.oc)
          return sp(a, g), { Bb: function() {
            var t = Wo(h.oc, k2.I.id, null, k2.bandwidth || null, null);
            t = ec(k2.I.wa, [t]);
            return rp(k2, b, g, t, 0, null, h.Sa);
          } };
        if (h.ia)
          return d || "image" === a.fa.contentType || (a.presentationTimeline.Sd(h.ia), a.presentationTimeline.Td(a.T.start)), { Bb: function() {
            return Cp(k2, h, e, g, f);
          } };
        var l = null;
        d = d = null;
        a.$.id && a.I.id && (d = a.$.id + "," + a.I.id, d = c[d]) && (l = d.segmentIndex);
        var m = Dp(k2, h, g);
        c = a.T.start;
        var n = a.T.duration ? a.T.start + a.T.duration : Infinity, p = !(a.Ma && a.T.Gd);
        l ? (p && new Jj(m).Wa(c, n, true), l.Hb(m, a.presentationTimeline.Pa())) : l = new Jj(m);
        a.presentationTimeline.Ib(m);
        p && l.Wa(c, n);
        d && a.Ma && (d.segmentIndex = l);
        return { Bb: function() {
          l && 0 != l.g.length || l.pc(m);
          return Promise.resolve(l);
        } };
      }
      function Ep(a) {
        return a.xc;
      }
      function Ap(a) {
        var b = Xo(a, Ep), c = Yo(a, Ep, "media");
        a = Yo(a, Ep, "index");
        return { ia: b.ia, timescale: b.timescale, Lb: b.Lb, Sa: b.Sa, se: b.se, timeline: b.timeline, Pd: c, oc: a };
      }
      function Bp(a) {
        var b = a.oc ? 1 : 0;
        b += a.timeline ? 1 : 0;
        b += a.ia ? 1 : 0;
        if (0 == b)
          throw new O(2, 4, 4002);
        1 != b && (a.oc && (a.timeline = null), a.ia = null);
        if (!a.oc && !a.Pd)
          throw new O(2, 4, 4002);
      }
      function Cp(a, b, c, d, e) {
        function f(J) {
          var L = (J - t) * p, R = L + b.Sa, Q = L + l;
          L = Q + p;
          var U = Math.min(L, h());
          Q = new qi(Q, U, function() {
            var N = Wo(y, x, J, w, R * v);
            return ec(C, [N]);
          }, 0, null, d, z, l, h());
          Q.j = L;
          return Q;
        }
        function g() {
          var J = [Math.max(k2.Pa(), l), Math.min(k2.gb(), h())].map(function(L) {
            return L - l;
          });
          return [Math.ceil(J[0] / p), Math.ceil(J[1] / p) - 1].map(function(L) {
            return L + t;
          });
        }
        function h() {
          var J = null != m && e[m] || n;
          return J ? l + J : Infinity;
        }
        var k2 = a.presentationTimeline, l = a.T.start, m = a.$.id, n = a.T.duration, p = b.ia, t = b.Lb, v = b.timescale, y = b.Pd, w = a.bandwidth || null, x = a.I.id, C = a.I.wa, z = l - b.Sa, B = g();
        a = a.Ma ? Math.max(B[0], B[1] - c + 1) : B[0];
        B = B[1];
        c = [];
        for (var E = a; E <= B; ++E) {
          var F = f(E);
          c.push(F);
        }
        var H = new Jj(c);
        c = k2.gb() < h();
        E = k2.U();
        if (c || E) {
          var I = Math.max(a, B + 1);
          H.fd(p, function() {
            var J = k2.Pa();
            H.eb(J);
            var L = r(g());
            L.next();
            L = L.next().value;
            for (var R = []; I <= L; ) {
              var Q = f(I);
              R.push(Q);
              I++;
            }
            return J > h() && !R.length ? null : R;
          });
        }
        return Promise.resolve(H);
      }
      function Dp(a, b, c) {
        var d = a.T.start, e = a.T.duration, f = d - b.Sa;
        e = e ? d + e : Infinity;
        for (var g = [], h = {}, k2 = 0; k2 < b.timeline.length; h = { nd: h.nd, rd: h.rd, ud: h.ud, kd: h.kd, wd: h.wd, ld: h.ld }, k2++) {
          var l = b.timeline[k2], m = l.start, n = l.Dg;
          l = l.end;
          h.ud = k2 + b.Lb;
          h.wd = n + b.se;
          h.rd = a.I.id;
          h.kd = a.bandwidth || null;
          h.nd = b.Pd;
          h.ld = a.I.wa;
          g.push(new qi(d + m, d + l, function(p) {
            return function() {
              var t = Wo(p.nd, p.rd, p.ud, p.kd || null, p.wd);
              return ec(p.ld, [t]).map(function(v) {
                return v.toString();
              });
            };
          }(h), 0, null, c, f, d, e));
        }
        return g;
      }
      function zp(a) {
        var b = Yo(a, Ep, "initialization");
        if (!b)
          return null;
        var c = a.I.id, d = a.bandwidth || null, e = a.I.wa;
        return new oi(function() {
          var f = Wo(b, c, null, d, null);
          return ec(e, [f]);
        }, 0, null, mp(a));
      }
      function Fp() {
        this.l = [];
        this.g = [];
        this.h = [];
        this.j = [];
        this.i = [];
        this.m = /* @__PURE__ */ new Set();
      }
      Fp.prototype.release = function() {
        for (var a = r(this.g.concat(this.h, this.j, this.i)), b = a.next(); !b.done; b = a.next())
          b = b.value, b.segmentIndex && b.segmentIndex.release();
        this.g = [];
        this.h = [];
        this.j = [];
        this.i = [];
        this.l = [];
      };
      function Gp(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N, wa, va;
        return G(function(Ma) {
          switch (Ma.g) {
            case 1:
              d = kc;
              Hp(b);
              Ip(b);
              Jp(b);
              Kp(b);
              if (!c && 1 == b.length) {
                e = b[0];
                a.g = e.Kc;
                a.h = e.gd;
                a.j = e.textStreams;
                a.i = e.imageStreams;
                Ma.A(2);
                break;
              }
              f = -1;
              for (g = 0; g < b.length; g++)
                h = b[g], a.m.has(h.id) || (a.m.add(h.id), -1 == f && (f = g));
              if (-1 == f)
                return Ma.return();
              k2 = b.map(function(Sa) {
                return Sa.Kc;
              });
              l = b.map(function(Sa) {
                return Sa.gd;
              });
              m = b.map(function(Sa) {
                return Sa.textStreams;
              });
              n = b.map(function(Sa) {
                return Sa.imageStreams;
              });
              p = r(m);
              for (t = p.next(); !t.done; t = p.next())
                v = t.value, v.push(Lp(d.X));
              y = r(n);
              for (w = y.next(); !w.done; w = y.next())
                x = w.value, x.push(Lp(d.Wb));
              return u(Ma, Mp(a.g, k2, f, Np, Op), 3);
            case 3:
              return u(Ma, Mp(a.h, l, f, Np, Op), 4);
            case 4:
              return u(Ma, Mp(a.j, m, f, Np, Op), 5);
            case 5:
              return u(Ma, Mp(a.i, n, f, Np, Op), 2);
            case 2:
              C = 0;
              z = [];
              if (a.h.length && a.g.length)
                for (J = r(a.g), L = J.next(); !L.done; L = J.next())
                  for (R = L.value, Q = r(a.h), U = Q.next(); !U.done; U = Q.next())
                    N = U.value, wa = Pg(R.drmInfos, N.drmInfos), R.drmInfos.length && N.drmInfos.length && !wa.length || (va = C++, z.push({ id: va, language: R.language, primary: R.primary, audio: R, video: N, bandwidth: (R.bandwidth || 0) + (N.bandwidth || 0), drmInfos: wa, allowedByApplication: true, allowedByKeySystem: true, decodingInfos: [] }));
              else
                for (B = a.h.concat(a.g), E = r(B), F = E.next(); !F.done; F = E.next())
                  H = F.value, I = C++, z.push({ id: I, language: H.language, primary: H.primary, audio: H.type == d.Hc ? H : null, video: H.type == d.va ? H : null, bandwidth: H.bandwidth || 0, drmInfos: H.drmInfos, allowedByApplication: true, allowedByKeySystem: true, decodingInfos: [] });
              a.l = z;
              A(Ma);
          }
        });
      }
      function Hp(a) {
        a = r(a);
        for (var b = a.next(); !b.done; b = a.next()) {
          b = b.value;
          for (var c = [], d = r(b.Kc), e = d.next(); !e.done; e = d.next()) {
            e = e.value;
            for (var f = false, g = r(c), h = g.next(); !h.done; h = g.next())
              h = h.value, e.id != h.id && e.channelsCount == h.channelsCount && e.language == h.language && e.bandwidth == h.bandwidth && e.label == h.label && e.codecs == h.codecs && e.mimeType == h.mimeType && ib(e.roles, h.roles) && e.audioSamplingRate == h.audioSamplingRate && e.primary == h.primary && (f = true);
            f || c.push(e);
          }
          b.Kc = c;
        }
      }
      function Jp(a) {
        a = r(a);
        for (var b = a.next(); !b.done; b = a.next()) {
          b = b.value;
          for (var c = [], d = r(b.textStreams), e = d.next(); !e.done; e = d.next()) {
            e = e.value;
            for (var f = false, g = r(c), h = g.next(); !h.done; h = g.next())
              h = h.value, e.id != h.id && e.language == h.language && e.label == h.label && e.codecs == h.codecs && e.mimeType == h.mimeType && e.bandwidth == h.bandwidth && ib(e.roles, h.roles) && (f = true);
            f || c.push(e);
          }
          b.textStreams = c;
        }
      }
      function Ip(a) {
        a = r(a);
        for (var b = a.next(); !b.done; b = a.next()) {
          b = b.value;
          for (var c = [], d = r(b.gd), e = d.next(); !e.done; e = d.next()) {
            e = e.value;
            for (var f = false, g = r(c), h = g.next(); !h.done; h = g.next())
              h = h.value, e.id != h.id && e.width == h.width && e.frameRate == h.frameRate && e.codecs == h.codecs && e.mimeType == h.mimeType && e.label == h.label && ib(e.roles, h.roles) && vf(e.closedCaptions, h.closedCaptions) && e.bandwidth == h.bandwidth && (f = true);
            f || c.push(e);
          }
          b.gd = c;
        }
      }
      function Kp(a) {
        a = r(a);
        for (var b = a.next(); !b.done; b = a.next()) {
          b = b.value;
          for (var c = [], d = r(b.imageStreams), e = d.next(); !e.done; e = d.next()) {
            e = e.value;
            for (var f = false, g = r(c), h = g.next(); !h.done; h = g.next())
              h = h.value, e.id != h.id && e.width == h.width && e.codecs == h.codecs && e.mimeType == h.mimeType && (f = true);
            f || c.push(e);
          }
          b.imageStreams = c;
        }
      }
      function Pp(a) {
        var b, c, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R;
        return G(function(Q) {
          switch (Q.g) {
            case 1:
              b = kc;
              if (1 == a.length)
                return Q.return(a[0]);
              c = a.map(function(U) {
                return U.filter(function(N) {
                  return N.type == b.Hc;
                });
              });
              d = a.map(function(U) {
                return U.filter(function(N) {
                  return N.type == b.va;
                });
              });
              e = a.map(function(U) {
                return U.filter(function(N) {
                  return N.type == b.X;
                });
              });
              f = a.map(function(U) {
                return U.filter(function(N) {
                  return N.type == b.Wb;
                });
              });
              g = r(e);
              for (h = g.next(); !h.done; h = g.next())
                k2 = h.value, k2.push(Qp(b.X));
              l = r(f);
              for (m = l.next(); !m.done; m = l.next())
                n = m.value, n.push(Qp(b.Wb));
              return u(Q, Mp([], c, 0, Rp, Sp), 2);
            case 2:
              return p = Q.h, u(Q, Mp([], d, 0, Rp, Sp), 3);
            case 3:
              return t = Q.h, u(Q, Mp([], e, 0, Rp, Sp), 4);
            case 4:
              return v = Q.h, u(Q, Mp([], f, 0, Rp, Sp), 5);
            case 5:
              y = Q.h;
              w = 0;
              if (t.length && p.length)
                for (E = r(p), F = E.next(); !F.done; F = E.next())
                  for (H = F.value, I = r(t), J = I.next(); !J.done; J = I.next())
                    L = J.value, R = w++, L.variantIds.push(R), H.variantIds.push(R);
              else
                for (x = t.concat(p), C = r(x), z = C.next(); !z.done; z = C.next())
                  B = z.value, B.variantIds = [w++];
              return Q.return(t.concat(p).concat(v).concat(y));
          }
        });
      }
      function Mp(a, b, c, d, e) {
        var f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I;
        return G(function(L) {
          switch (L.g) {
            case 1:
              f = kc;
              g = [];
              for (h = 0; h < b.length; h++)
                h >= c ? g.push(new Set(b[h])) : g.push(/* @__PURE__ */ new Set());
              k2 = r(a);
              l = k2.next();
            case 2:
              if (l.done) {
                L.A(4);
                break;
              }
              m = l.value;
              return u(L, Tp(m, b, c, e, g), 5);
            case 5:
              n = L.h;
              if (!n)
                throw new O(2, 4, 4037);
              l = k2.next();
              L.A(2);
              break;
            case 4:
              p = r(g);
              for (t = p.next(); !t.done; t = p.next())
                for (v = t.value, y = r(v), w = y.next(); !w.done; w = y.next())
                  x = w.value, (C = Up(x, b, d, e, g)) && a.push(C);
              z = r(g);
              for (t = z.next(); !t.done; t = z.next())
                for (B = t.value, E = {}, F = r(B), w = F.next(); !w.done; E = { Va: E.Va }, w = F.next())
                  if (E.Va = w.value, H = E.Va.type == f.X && !E.Va.language, I = E.Va.type == f.Wb && !E.Va.tilesLayout, !H && !I && a.some(function(R) {
                    return function(Q) {
                      return Q.mimeType == R.Va.mimeType && ad(Q.codecs) == ad(R.Va.codecs);
                    };
                  }(E)))
                    throw new O(2, 4, 4037);
              return L.return(a);
          }
        });
      }
      function Tp(a, b, c, d, e) {
        return G(function(f) {
          if (1 == f.g)
            return Vp(b, a), a.matchedStreams ? a.segmentIndex ? u(f, Wp(a, c), 2) : f.A(2) : f.return(false);
          Xp(a, c, d, e);
          return f.return(true);
        });
      }
      function Wp(a, b) {
        var c, d, e, f, g, h, k2;
        return G(function(l) {
          if (1 == l.g) {
            c = [];
            d = a.matchedStreams;
            e = r(d);
            for (f = e.next(); !f.done; f = e.next())
              g = f.value, c.push(g.createSegmentIndex()), g.trickModeVideo && !g.trickModeVideo.segmentIndex && c.push(g.trickModeVideo.createSegmentIndex());
            return u(l, Promise.all(c), 2);
          }
          if (a.segmentIndex instanceof Nj)
            for (h = 0; h < d.length; h++)
              k2 = d[h], k2.segmentIndex && h >= b && a.segmentIndex.l.push(k2.segmentIndex);
          A(l);
        });
      }
      function Up(a, b, c, d, e) {
        var f = c(a);
        Vp(b, f);
        f.createSegmentIndex && (f.createSegmentIndex = function() {
          return G(function(g) {
            if (f.segmentIndex)
              return g.A(0);
            f.segmentIndex = new Nj();
            return u(g, Wp(f, 0), 0);
          });
        });
        if (!f.matchedStreams)
          return null;
        Xp(f, 0, d, e);
        return f;
      }
      function Xp(a, b, c, d) {
        for (var e = a.matchedStreams, f = 0; f < e.length; f++)
          if (f >= b) {
            var g = e[f];
            c(a, g);
            var h = true;
            "audio" == a.type && 0 == sd(a.language, g.language) && (h = false);
            h && d[f].delete(g);
          }
      }
      function Np(a) {
        var b = Object.assign({}, a);
        b.originalId = null;
        b.createSegmentIndex = function() {
          return Promise.resolve();
        };
        b.closeSegmentIndex = function() {
          b.segmentIndex && (b.segmentIndex.release(), b.segmentIndex = null);
          if (b.matchedStreams)
            for (var c = r(b.matchedStreams), d = c.next(); !d.done; d = c.next())
              d = d.value, d.segmentIndex && (d.segmentIndex.release(), d.segmentIndex = null);
        };
        b.segmentIndex = null;
        b.emsgSchemeIdUris = [];
        b.keyIds = /* @__PURE__ */ new Set();
        b.closedCaptions = null;
        b.trickModeVideo = null;
        return b;
      }
      function Rp(a) {
        a = Object.assign({}, a);
        a.keyIds = /* @__PURE__ */ new Set();
        a.segments = [];
        a.variantIds = [];
        a.closedCaptions = null;
        return a;
      }
      function Op(a, b) {
        a.roles = Array.from(new Set(a.roles.concat(b.roles)));
        b.emsgSchemeIdUris && (a.emsgSchemeIdUris = Array.from(new Set(a.emsgSchemeIdUris.concat(b.emsgSchemeIdUris))));
        a.keyIds = function(f, g) {
          return new Set([].concat(ha(f), ha(g)));
        }(a.keyIds, b.keyIds);
        null == a.originalId ? a.originalId = b.originalId : a.originalId += "," + (b.originalId || "");
        var c = Pg(a.drmInfos, b.drmInfos);
        if (b.drmInfos.length && a.drmInfos.length && !c.length)
          throw new O(2, 4, 4038);
        a.drmInfos = c;
        a.encrypted = a.encrypted || b.encrypted;
        if (b.closedCaptions) {
          a.closedCaptions || (a.closedCaptions = /* @__PURE__ */ new Map());
          c = r(b.closedCaptions);
          for (var d = c.next(); !d.done; d = c.next()) {
            var e = r(d.value);
            d = e.next().value;
            e = e.next().value;
            a.closedCaptions.set(d, e);
          }
        }
        b.trickModeVideo ? (a.trickModeVideo || (a.trickModeVideo = Np(b.trickModeVideo), a.trickModeVideo.createSegmentIndex = function() {
          a.trickModeVideo.segmentIndex = a.segmentIndex.clone();
          return Promise.resolve();
        }), Op(a.trickModeVideo, b.trickModeVideo)) : a.trickModeVideo && Op(a.trickModeVideo, b);
      }
      function Sp(a, b) {
        a.roles = Array.from(new Set(a.roles.concat(b.roles)));
        var c = b.keyIds;
        c = new Set([].concat(ha(a.keyIds), ha(c)));
        a.keyIds = c;
        a.encrypted = a.encrypted && b.encrypted;
        a.segments.push.apply(a.segments, ha(b.segments));
        if (b.closedCaptions)
          for (a.closedCaptions || (a.closedCaptions = /* @__PURE__ */ new Map()), b = r(b.closedCaptions), c = b.next(); !c.done; c = b.next()) {
            var d = r(c.value);
            c = d.next().value;
            d = d.next().value;
            a.closedCaptions.set(c, d);
          }
      }
      function Vp(a, b) {
        var c = [];
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next()) {
          var e = b, f = { audio: Yp, video: Yp, text: Zp, image: $p }[e.type], g = { audio: aq, video: bq, text: cq, image: dq }[e.type], h = null;
          d = r(d.value);
          for (var k2 = d.next(); !k2.done; k2 = d.next())
            k2 = k2.value, !f(e, k2) || h && !g(e, h, k2) || (h = k2);
          e = h;
          if (!e)
            return;
          c.push(e);
        }
        b.matchedStreams = c;
      }
      function Yp(a, b) {
        var c;
        !(c = b.mimeType != a.mimeType || ad(b.codecs) != ad(a.codecs)) && (c = a.drmInfos) && (a = a.drmInfos, b = b.drmInfos, c = !(a.length && b.length ? 0 < Pg(a, b).length : 1));
        return c ? false : true;
      }
      function Zp(a, b) {
        return a.language ? b.language ? 0 == sd(a.language, b.language) || b.kind != a.kind ? false : true : true : false;
      }
      function $p(a) {
        return a.tilesLayout ? true : false;
      }
      function aq(a, b, c) {
        if (a.id == c.id)
          return true;
        var d = sd(a.language, b.language), e = sd(a.language, c.language);
        if (e > d)
          return true;
        if (e < d)
          return false;
        if (a.roles.length)
          return d = b.roles.filter(function(f) {
            return a.roles.includes(f);
          }), e = c.roles.filter(function(f) {
            return a.roles.includes(f);
          }), e.length > d.length ? true : e.length < d.length ? false : c.roles.length < b.roles.length;
        if (!c.roles.length && b.roles.length)
          return true;
        if (c.roles.length && !b.roles.length)
          return false;
        if (!b.primary && c.primary)
          return true;
        if (b.primary && !c.primary)
          return false;
        d = eq(a.channelsCount, b.channelsCount, c.channelsCount);
        if (d == fq)
          return true;
        if (d == gq)
          return false;
        d = eq(a.audioSamplingRate, b.audioSamplingRate, c.audioSamplingRate);
        return d == fq ? true : d == gq ? false : a.bandwidth && hq(a.bandwidth, b.bandwidth, c.bandwidth) == fq ? true : false;
      }
      function bq(a, b, c) {
        if (a.id == c.id)
          return true;
        var d = eq(a.width * a.height, b.width * b.height, c.width * c.height);
        if (d == fq)
          return true;
        if (d == gq)
          return false;
        if (a.frameRate) {
          d = eq(a.frameRate, b.frameRate, c.frameRate);
          if (d == fq)
            return true;
          if (d == gq)
            return false;
        }
        return a.bandwidth && hq(a.bandwidth, b.bandwidth, c.bandwidth) == fq ? true : false;
      }
      function cq(a, b, c) {
        if (a.id == c.id)
          return true;
        var d = sd(a.language, b.language), e = sd(a.language, c.language);
        if (e > d)
          return true;
        if (e < d)
          return false;
        if (!b.primary && c.primary)
          return true;
        if (b.primary && !c.primary)
          return false;
        if (a.roles.length) {
          d = b.roles.filter(function(f) {
            return a.roles.includes(f);
          });
          e = c.roles.filter(function(f) {
            return a.roles.includes(f);
          });
          if (e.length > d.length)
            return true;
          if (e.length < d.length)
            return false;
        } else {
          if (!c.roles.length && b.roles.length)
            return true;
          if (c.roles.length && !b.roles.length)
            return false;
        }
        return c.mimeType != a.mimeType || c.codecs != a.codecs || b.mimeType == a.mimeType && b.codecs == a.codecs ? false : true;
      }
      function dq(a, b, c) {
        return a.id == c.id ? true : eq(a.width * a.height, b.width * b.height, c.width * c.height) == fq ? true : false;
      }
      function Qp(a) {
        return { id: 0, originalId: "", primary: false, type: a, mimeType: "", codecs: "", language: "", label: null, width: null, height: null, encrypted: false, keyIds: /* @__PURE__ */ new Set(), segments: [], variantIds: [], roles: [], forced: false, channelsCount: null, audioSamplingRate: null, spatialAudio: false, closedCaptions: null };
      }
      function Lp(a) {
        return { id: 0, originalId: "", createSegmentIndex: function() {
          return Promise.resolve();
        }, segmentIndex: new Jj([]), mimeType: "", codecs: "", encrypted: false, drmInfos: [], keyIds: /* @__PURE__ */ new Set(), language: "", label: null, type: a, primary: false, trickModeVideo: null, emsgSchemeIdUris: null, roles: [], forced: false, channelsCount: null, audioSamplingRate: null, spatialAudio: false, closedCaptions: null };
      }
      function eq(a, b, c) {
        if (b == a && a != c)
          return gq;
        if (c == a && a != b)
          return fq;
        if (b > a) {
          if (c <= a || c - a < b - a)
            return fq;
          if (c - a > b - a)
            return gq;
        } else {
          if (c > a)
            return gq;
          if (a - c < a - b)
            return fq;
          if (a - c > a - b)
            return gq;
        }
        return iq;
      }
      function hq(a, b, c) {
        b = Math.abs(a - b);
        a = Math.abs(a - c);
        return a < b ? fq : b < a ? gq : iq;
      }
      var fq = 1, iq = 0, gq = -1;
      function jq() {
        var a = this;
        this.h = this.g = null;
        this.m = [];
        this.i = null;
        this.G = 1;
        this.l = {};
        this.L = {};
        this.j = new Fp();
        this.F = 0;
        this.H = new Pa(5);
        this.D = new P(function() {
          kq(a);
        });
        this.o = new Xe();
        this.s = null;
        this.J = [];
        this.u = Infinity;
        this.B = false;
      }
      q = jq.prototype;
      q.configure = function(a) {
        this.g = a;
      };
      q.start = function(a, b) {
        var c = this, d;
        return G(function(e) {
          if (1 == e.g)
            return c.B = b.isLowLatencyMode(), c.m = [a], c.h = b, u(e, lq(c), 2);
          d = e.h;
          c.h && mq(c, d);
          if (!c.h)
            throw new O(2, 7, 7001);
          return e.return(c.i);
        });
      };
      q.stop = function() {
        for (var a = r(Object.values(this.l)), b = a.next(); !b.done; b = a.next())
          b = b.value, b.segmentIndex && b.segmentIndex.release();
        this.j && this.j.release();
        this.g = this.h = null;
        this.m = [];
        this.i = null;
        this.l = {};
        this.j = null;
        null != this.D && (this.D.stop(), this.D = null);
        return this.o.destroy();
      };
      q.update = function() {
        var a = this, b;
        return G(function(c) {
          if (1 == c.g)
            return D(c, 2), u(c, lq(a), 4);
          if (2 != c.g)
            return ta(c, 0);
          b = ua(c);
          if (!a.h || !b)
            return c.return();
          a.h.onError(b);
          A(c);
        });
      };
      q.onExpirationUpdated = function() {
      };
      function lq(a) {
        var b, c, d, e, f, g, h;
        return G(function(k2) {
          if (1 == k2.g)
            return b = cf(a.m, a.g.retryParameters), c = a.h.networkingEngine, a.h.modifyManifestRequest(b, { format: "d" }), d = Date.now(), e = c.request(0, b), Ye(a.o, e), u(k2, e.promise, 2);
          if (3 != k2.g) {
            f = k2.h;
            if (!a.h)
              return k2.return(0);
            f.uri && !a.m.includes(f.uri) && a.m.unshift(f.uri);
            return u(k2, nq(a, f.data, f.uri), 3);
          }
          g = Date.now();
          h = (g - d) / 1e3;
          a.H.sample(1, h);
          return k2.return(h);
        });
      }
      function nq(a, b, c) {
        var d, f, g, h;
        return G(function(k2) {
          if (1 == k2.g) {
            d = eg(b, "MPD");
            if (!d)
              throw new O(2, 4, 4001, c);
            if (a.g.dash.disableXlinkProcessing)
              return k2.return(oq(a, d, c));
            f = a.g.dash.xlinkFailGracefully;
            g = ap(d, a.g.retryParameters, f, c, a.h.networkingEngine);
            Ye(a.o, g);
            return u(k2, g.promise, 2);
          }
          h = k2.h;
          return k2.return(oq(a, h, c));
        });
      }
      function oq(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, R, Q, U, N, wa, Ma, Sa;
        return G(function(Ga) {
          switch (Ga.g) {
            case 1:
              (d = a.g.dash.manifestPreprocessor) && d(b);
              e = [c];
              f = Mf(b, "Location").map(Sf).filter(dc);
              0 < f.length && (g = ec(e, f), e = a.m = g);
              h = Mf(b, "BaseURL");
              k2 = h.map(Sf);
              l = ec(e, k2);
              m = 0;
              h && h.length && (m = Uf(h[0], "availabilityTimeOffset", ag) || 0);
              n = a.g.dash.ignoreMinBufferTime;
              p = 0;
              n || (p = Uf(b, "minBufferTime", Wf) || 0);
              a.F = Uf(b, "minimumUpdatePeriod", Wf, -1);
              t = Uf(b, "availabilityStartTime", Vf);
              v = Uf(
                b,
                "timeShiftBufferDepth",
                Wf
              );
              y = a.g.dash.ignoreSuggestedPresentationDelay;
              w = null;
              y || (w = Uf(b, "suggestedPresentationDelay", Wf));
              x = a.g.dash.ignoreMaxSegmentDuration;
              C = null;
              x || (C = Uf(b, "maxSegmentDuration", Wf));
              z = b.getAttribute("type") || "static";
              if (a.i)
                for (B = a.i.presentationTimeline, E = r(Object.values(a.l)), F = E.next(); !F.done; F = E.next())
                  H = F.value, H.segmentIndex && H.segmentIndex.eb(B.Pa());
              else
                I = a.g.defaultPresentationDelay || 1.5 * p, J = null != w ? w : I, B = new T(t, J, a.g.dash.autoCorrectDrift);
              B.yc("static" == z);
              B.U() && !isNaN(a.g.availabilityWindowOverride) && (v = a.g.availabilityWindowOverride);
              null == v && (v = Infinity);
              B.me(v);
              R = b.getAttribute("profiles") || "";
              Q = { Ma: "static" != z, presentationTimeline: B, $: null, T: null, fa: null, I: null, bandwidth: 0, Ke: false, zb: m, profiles: R.split(",") };
              U = pq(a, Q, l, b);
              N = U.duration;
              wa = U.periods;
              "static" != z && U.De || B.Aa(N || Infinity);
              a.u && !a.B && a.h.isAutoLowLatencyMode() && (a.h.enableLowLatencyMode(), a.B = a.h.isLowLatencyMode());
              a.B ? B.Ue(a.u) : a.u && Wa("Low-latency DASH live stream detected, but low-latency streaming mode is not enabled in Shaka Player. Set streaming.lowLatencyMode configuration to true, and see https://bit.ly/3clctcj for details.");
              B.Sd(C || 1);
              return u(Ga, Gp(a.j, wa, Q.Ma), 2);
            case 2:
              if (a.i) {
                a.i.variants = a.j.l;
                a.i.textStreams = a.j.j.slice();
                a.i.imageStreams = a.j.i;
                a.h.filter(a.i);
                Ga.A(3);
                break;
              }
              a.i = { presentationTimeline: B, variants: a.j.l, textStreams: a.j.j.slice(), imageStreams: a.j.i, offlineSessionIds: [], minBufferTime: p || 0, sequenceMode: a.g.dash.sequenceMode };
              if (!B.df()) {
                Ga.A(4);
                break;
              }
              Ma = Mf(b, "UTCTiming");
              return u(Ga, qq(a, l, Ma), 5);
            case 5:
              Sa = Ga.h;
              if (!a.h)
                return Ga.return();
              B.Ve(Sa);
            case 4:
              B.Md();
            case 3:
              a.h.makeTextStreamsForClosedCaptions(a.i), A(Ga);
          }
        });
      }
      function pq(a, b, c, d) {
        var e = Uf(d, "mediaPresentationDuration", Wf), f = [], g = 0;
        d = Mf(d, "Period");
        for (var h = 0; h < d.length; h++) {
          var k2 = d[h], l = d[h + 1], m = Uf(k2, "start", Wf, g), n = k2.id, p = Uf(k2, "duration", Wf), t = null;
          if (l) {
            var v = Uf(l, "start", Wf);
            null != v && (t = v - m);
          } else
            null != e && (t = e - m);
          null == t && (t = p);
          if (!(null !== a.s && null !== n && null !== m && m < a.s) || a.J.includes(n) || h + 1 == d.length) {
            null !== m && (null === a.s || m > a.s) && (a.s = m);
            g = rq(a, b, c, { start: m, duration: t, node: k2, Gd: null == t || !l });
            f.push(g);
            b.$.id && t && (a.L[b.$.id] = t);
            if (null == t) {
              g = null;
              break;
            }
            g = m + t;
          }
        }
        a.J = f.map(function(y) {
          return y.id;
        });
        return null != e ? { periods: f, duration: e, De: false } : { periods: f, duration: g, De: true };
      }
      function rq(a, b, c, d) {
        b.$ = sq(d.node, null, c);
        b.T = d;
        b.$.zb = b.zb;
        b.$.id || (b.$.id = "__shaka_period_" + d.start);
        var e = Mf(d.node, "EventStream");
        c = b.presentationTimeline.Pa();
        e = r(e);
        for (var f = e.next(); !f.done; f = e.next())
          tq(a, d.start, d.duration, f.value, c);
        c = Mf(d.node, "AdaptationSet").map(function(m) {
          return uq(a, b, m);
        }).filter(dc);
        if (b.Ma) {
          d = [];
          e = r(c);
          for (f = e.next(); !f.done; f = e.next()) {
            f = r(f.value.qg);
            for (var g = f.next(); !g.done; g = f.next())
              d.push(g.value);
          }
          if (d.length != new Set(d).size)
            throw new O(2, 4, 4018);
        }
        d = c.filter(function(m) {
          return !m.qe;
        });
        c = c.filter(function(m) {
          return m.qe;
        });
        c = r(c);
        for (e = c.next(); !e.done; e = c.next()) {
          e = e.value;
          f = e.qe.split(" ");
          g = r(d);
          for (var h = g.next(); !h.done; h = g.next()) {
            var k2 = h.value;
            if (f.includes(k2.id)) {
              h = {};
              k2 = r(k2.streams);
              for (var l = k2.next(); !l.done; h = { Gc: h.Gc }, l = k2.next())
                h.Gc = l.value, h.Gc.trickModeVideo = e.streams.find(function(m) {
                  return function(n) {
                    return ad(m.Gc.codecs) == ad(n.codecs);
                  };
                }(h));
            }
          }
        }
        e = a.g.disableAudio ? [] : vq(d, "audio");
        g = a.g.disableVideo ? [] : vq(d, "video");
        f = a.g.disableText ? [] : vq(d, jc);
        c = a.g.disableThumbnails ? [] : vq(d, "image");
        if (!g.length && !e.length)
          throw new O(2, 4, 4004);
        d = [];
        e = r(e);
        for (h = e.next(); !h.done; h = e.next())
          d.push.apply(d, ha(h.value.streams));
        e = [];
        g = r(g);
        for (h = g.next(); !h.done; h = g.next())
          e.push.apply(e, ha(h.value.streams));
        g = [];
        f = r(f);
        for (h = f.next(); !h.done; h = f.next())
          g.push.apply(g, ha(h.value.streams));
        f = [];
        c = r(c);
        for (h = c.next(); !h.done; h = c.next())
          f.push.apply(f, ha(h.value.streams));
        return { id: b.$.id, Kc: d, gd: e, textStreams: g, imageStreams: f };
      }
      function vq(a, b) {
        return a.filter(function(c) {
          return c.contentType == b;
        });
      }
      function uq(a, b, c) {
        function d(F) {
          switch (F) {
            case 1:
            case 6:
            case 13:
            case 14:
            case 15:
              return "SDR";
            case 16:
              return "PQ";
            case 18:
              return "HLG";
          }
        }
        b.fa = sq(c, b.$, null);
        var e = false, f = Mf(c, "Role"), g = f.map(function(F) {
          return F.getAttribute("value");
        }).filter(dc), h = void 0, k2 = b.fa.contentType == jc;
        k2 && (h = "subtitle");
        f = r(f);
        for (var l = f.next(); !l.done; l = f.next()) {
          l = l.value;
          var m = l.getAttribute("schemeIdUri");
          if (null == m || "urn:mpeg:dash:role:2011" == m)
            switch (l = l.getAttribute("value"), l) {
              case "main":
                e = true;
                break;
              case "caption":
              case "subtitle":
                h = l;
            }
        }
        var n;
        m = Mf(c, "EssentialProperty");
        f = null;
        l = false;
        m = r(m);
        for (var p = m.next(); !p.done; p = m.next()) {
          p = p.value;
          var t = p.getAttribute("schemeIdUri");
          "http://dashif.org/guidelines/trickmode" == t ? f = p.getAttribute("value") : "urn:mpeg:mpegB:cicp:TransferCharacteristics" == t ? n = d(parseInt(p.getAttribute("value"), 10)) : l = true;
        }
        m = Mf(c, "SupplementalProperty");
        m = r(m);
        for (p = m.next(); !p.done; p = m.next())
          p = p.value, "urn:mpeg:mpegB:cicp:TransferCharacteristics" == p.getAttribute("schemeIdUri") && (n = d(parseInt(
            p.getAttribute("value"),
            10
          )));
        m = Mf(c, "Accessibility");
        var v = /* @__PURE__ */ new Map();
        m = r(m);
        for (p = m.next(); !p.done; p = m.next())
          if (t = p.value, p = t.getAttribute("schemeIdUri"), t = t.getAttribute("value"), "urn:scte:dash:cc:cea-608:2015" == p)
            if (p = 1, null != t) {
              t = t.split(";");
              for (var y = r(t), w = y.next(); !w.done; w = y.next()) {
                var x = w.value, C = w = void 0;
                x.includes("=") ? (x = x.split("="), w = x[0].startsWith("CC") ? x[0] : "CC" + x[0], C = x[1] || "und") : (w = "CC" + p, 2 == t.length ? p += 2 : p++, C = x);
                v.set(w, od(C));
              }
            } else
              v.set("CC1", "und");
          else if ("urn:scte:dash:cc:cea-708:2015" == p)
            if (p = 1, null != t)
              for (t = r(t.split(";")), w = t.next(); !w.done; w = t.next())
                w = w.value, x = y = void 0, w.includes("=") ? (w = w.split("="), y = "svc" + w[0], x = w[1].split(",")[0].split(":").pop()) : (y = "svc" + p, p++, x = w), v.set(y, od(x));
            else
              v.set("svc1", "und");
          else
            "urn:mpeg:dash:role:2011" == p && null != t && (g.push(t), "captions" == t && (h = "caption"));
        if (l)
          return null;
        l = Mf(c, "ContentProtection");
        var z = Mo(l, a.g.dash.ignoreDrmInfo, a.g.dash.keySystemsByURI), B = od(c.getAttribute("lang") || "und"), E = c.getAttribute("label");
        (l = Mf(c, "Label")) && l.length && (l = l[0], l.textContent && (E = l.textContent));
        l = Mf(c, "Representation");
        c = l.map(function(F) {
          if (F = wq(a, b, z, h, B, E, e, g, v, F))
            F.hdr = F.hdr || n;
          return F;
        }).filter(function(F) {
          return !!F;
        });
        if (0 == c.length) {
          f = "image" == b.fa.contentType;
          if (a.g.dash.ignoreEmptyAdaptationSet || k2 || f)
            return null;
          throw new O(2, 4, 4003);
        }
        if (!b.fa.contentType || "application" == b.fa.contentType)
          for (b.fa.contentType = xq(c[0].mimeType, c[0].codecs), k2 = r(c), m = k2.next(); !m.done; m = k2.next())
            m.value.type = b.fa.contentType;
        k2 = r(c);
        for (m = k2.next(); !m.done; m = k2.next())
          for (m = m.value, p = r(z.drmInfos), t = p.next(); !t.done; t = p.next())
            t = t.value, t.keyIds = t.keyIds && m.keyIds ? new Set([].concat(ha(t.keyIds), ha(m.keyIds))) : t.keyIds || m.keyIds;
        k2 = l.map(function(F) {
          return F.getAttribute("id");
        }).filter(dc);
        return { id: b.fa.id || "__fake__" + a.G++, contentType: b.fa.contentType, language: B, th: e, streams: c, drmInfos: z.drmInfos, qe: f, qg: k2 };
      }
      function wq(a, b, c, d, e, f, g, h, k2, l) {
        b.I = sq(l, b.fa, null);
        a.u = Math.min(a.u, b.I.zb);
        if (!yq(b.I))
          return null;
        var m = b.T.start;
        b.bandwidth = Uf(l, "bandwidth", Zf) || 0;
        var n = b.I.contentType, p = n == jc || "application" == n;
        n = "image" == n;
        try {
          var t = function(H, I, J) {
            return zq(a, H, I, J);
          };
          if (b.I.wc)
            var v = np(b, t);
          else if (b.I.ab)
            v = tp(b, a.l);
          else if (b.I.xc)
            v = yp(b, t, a.l, !!a.i, a.g.dash.initialSegmentLimit, a.L);
          else {
            var y = b.I.wa, w = b.T.duration || 0;
            v = { Bb: function() {
              return Promise.resolve(Mj(m, w, y));
            } };
          }
        } catch (H) {
          if ((p || n) && 4002 == H.code)
            return null;
          throw H;
        }
        t = Mf(l, "ContentProtection");
        t = Po(t, c, a.g.dash.ignoreDrmInfo, a.g.dash.keySystemsByURI);
        t = new Set(t ? [t] : []);
        var x = false;
        Mf(l, "SupplementalProperty").some(function(H) {
          return "tag:dolby.com,2018:dash:EC3_ExtensionType:2018" == H.getAttribute("schemeIdUri") && "JOC" == H.getAttribute("value");
        }) && (x = true);
        var C = false;
        p && (C = h.includes("forced_subtitle") || h.includes("forced-subtitle"));
        var z;
        if (n && ((l = Mf(l, "EssentialProperty").find(function(H) {
          return ["http://dashif.org/thumbnail_tile", "http://dashif.org/guidelines/thumbnail_tile"].includes(H.getAttribute("schemeIdUri"));
        })) && (z = l.getAttribute("value")), !z))
          return null;
        var B;
        l = b.I.codecs;
        b.profiles.includes("http://dashif.org/guidelines/dash-if-uhd#hevc-hdr-pq10") && (l.includes("hvc1.2.4.L153.B0") || l.includes("hev1.2.4.L153.B0")) && (B = "PQ");
        var E = b.I.id ? b.$.id + "," + b.I.id : "", F = {
          id: a.G++,
          originalId: b.I.id,
          createSegmentIndex: function() {
            var I, J;
            return G(function(L) {
              if (1 == L.g) {
                I = E && b.Ma && a.l[E] ? a.l[E] : F;
                if (I.segmentIndex)
                  return L.A(0);
                J = I;
                return u(L, v.Bb(), 3);
              }
              J.segmentIndex = L.h;
              A(L);
            });
          },
          closeSegmentIndex: function() {
            F.segmentIndex && (F.segmentIndex.release(), F.segmentIndex = null);
          },
          segmentIndex: null,
          mimeType: b.I.mimeType,
          codecs: b.I.codecs,
          frameRate: b.I.frameRate,
          pixelAspectRatio: b.I.pixelAspectRatio,
          bandwidth: b.bandwidth,
          width: b.I.width,
          height: b.I.height,
          kind: d,
          encrypted: 0 < c.drmInfos.length,
          drmInfos: c.drmInfos,
          keyIds: t,
          language: e,
          label: f,
          type: b.fa.contentType,
          primary: g,
          trickModeVideo: null,
          emsgSchemeIdUris: b.I.emsgSchemeIdUris,
          roles: h,
          forced: C,
          channelsCount: b.I.ad,
          audioSamplingRate: b.I.audioSamplingRate,
          spatialAudio: x,
          closedCaptions: k2,
          hdr: B,
          tilesLayout: z,
          matchedStreams: []
        };
        E && b.Ma && !a.l[E] && (a.l[E] = F);
        return F;
      }
      function kq(a) {
        var b, c;
        G(function(d) {
          switch (d.g) {
            case 1:
              return b = 0, D(d, 2), u(d, lq(a), 4);
            case 4:
              b = d.h;
              ta(d, 3);
              break;
            case 2:
              c = ua(d), a.h && (c.severity = 1, a.h.onError(c));
            case 3:
              if (!a.h)
                return d.return();
              mq(a, b);
              A(d);
          }
        });
      }
      function mq(a, b) {
        0 > a.F || a.D.N(Math.max(3, a.F - b, Qa(a.H)));
      }
      function sq(a, b, c) {
        b = b || { contentType: "", mimeType: "", codecs: "", emsgSchemeIdUris: [], frameRate: void 0, pixelAspectRatio: void 0, ad: null, audioSamplingRate: null, zb: 0 };
        c = c || b.wa;
        var d = Mf(a, "BaseURL"), e = d.map(Sf), f = a.getAttribute("contentType") || b.contentType, g = a.getAttribute("mimeType") || b.mimeType, h = a.getAttribute("codecs") || b.codecs, k2 = Uf(a, "frameRate", bg) || b.frameRate, l = a.getAttribute("sar") || b.pixelAspectRatio, m = Mf(a, "InbandEventStream"), n = b.emsgSchemeIdUris.slice();
        m = r(m);
        for (var p = m.next(); !p.done; p = m.next())
          p = p.value.getAttribute("schemeIdUri"), n.includes(p) || n.push(p);
        m = Mf(a, "AudioChannelConfiguration");
        m = Aq(m) || b.ad;
        p = Uf(a, "audioSamplingRate", $f) || b.audioSamplingRate;
        f || (f = xq(g, h));
        var t = Lf(a, "SegmentBase"), v = Lf(a, "SegmentTemplate"), y = t ? Uf(t, "availabilityTimeOffset", ag) || 0 : 0, w = v ? Uf(v, "availabilityTimeOffset", ag) || 0 : 0;
        d = d && d.length ? Uf(d[0], "availabilityTimeOffset", ag) || 0 : 0;
        d = b.zb + d + y + w;
        return { wa: ec(c, e), wc: t || b.wc, ab: Lf(a, "SegmentList") || b.ab, xc: v || b.xc, width: Uf(a, "width", $f) || b.width, height: Uf(
          a,
          "height",
          $f
        ) || b.height, contentType: f, mimeType: g, codecs: h, frameRate: k2, pixelAspectRatio: l, emsgSchemeIdUris: n, id: a.getAttribute("id"), ad: m, audioSamplingRate: p, zb: d };
      }
      function Aq(a) {
        a = r(a);
        for (var b = a.next(); !b.done; b = a.next()) {
          var c = b.value;
          if (b = c.getAttribute("schemeIdUri")) {
            if (c = c.getAttribute("value"))
              switch (b) {
                case "urn:mpeg:dash:outputChannelPositionList:2012":
                  return c.trim().split(/ +/).length;
                case "urn:mpeg:dash:23003:3:audio_channel_configuration:2011":
                case "urn:dts:dash:audio_channel_configuration:2012":
                  b = parseInt(c, 10);
                  if (!b)
                    continue;
                  return b;
                case "tag:dolby.com,2014:dash:audio_channel_configuration:2011":
                case "urn:dolby:dash:audio_channel_configuration:2011":
                  b = parseInt(c, 16);
                  if (!b)
                    continue;
                  for (a = 0; b; )
                    b & 1 && ++a, b >>= 1;
                  return a;
                case "urn:mpeg:mpegB:cicp:ChannelConfiguration":
                  if (b = [0, 1, 2, 3, 4, 5, 6, 8, 2, 3, 4, 7, 8, 24, 8, 12, 10, 12, 14, 12, 14], (c = parseInt(c, 10)) && 0 < c && c < b.length)
                    return b[c];
              }
          }
        }
        return null;
      }
      function yq(a) {
        var b = a.wc ? 1 : 0;
        b += a.ab ? 1 : 0;
        b += a.xc ? 1 : 0;
        if (0 == b)
          return a.contentType == jc || "application" == a.contentType ? true : false;
        1 != b && (a.wc && (a.ab = null), a.xc = null);
        return true;
      }
      function Bq(a, b, c, d) {
        var e, f, g, h, k2, l;
        return G(function(m) {
          if (1 == m.g)
            return e = ec(b, [c]), f = cf(e, a.g.retryParameters), f.method = d, g = a.h.networkingEngine.request(4, f), Ye(a.o, g), u(m, g.promise, 2);
          h = m.h;
          if ("HEAD" == d) {
            if (!h.headers || !h.headers.date)
              return m.return(0);
            k2 = h.headers.date;
          } else
            k2 = Cc(h.data);
          l = Date.parse(k2);
          return isNaN(l) ? m.return(0) : m.return(l - Date.now());
        });
      }
      function qq(a, b, c) {
        var d, e, f, g, h, k2, l, m;
        return G(function(n) {
          switch (n.g) {
            case 1:
              d = c.map(function(p) {
                return { scheme: p.getAttribute("schemeIdUri"), value: p.getAttribute("value") };
              }), e = a.g.dash.clockSyncUri, !d.length && e && d.push({ scheme: "urn:mpeg:dash:utc:http-head:2014", value: e }), f = r(d), g = f.next();
            case 2:
              if (g.done) {
                n.A(4);
                break;
              }
              h = g.value;
              D(n, 5);
              k2 = h.scheme;
              l = h.value;
              switch (k2) {
                case "urn:mpeg:dash:utc:http-head:2014":
                case "urn:mpeg:dash:utc:http-head:2012":
                  return n.A(7);
                case "urn:mpeg:dash:utc:http-xsdate:2014":
                case "urn:mpeg:dash:utc:http-iso:2014":
                case "urn:mpeg:dash:utc:http-xsdate:2012":
                case "urn:mpeg:dash:utc:http-iso:2012":
                  return n.A(8);
                case "urn:mpeg:dash:utc:direct:2014":
                case "urn:mpeg:dash:utc:direct:2012":
                  return m = Date.parse(l), n.return(isNaN(m) ? 0 : m - Date.now());
                case "urn:mpeg:dash:utc:http-ntp:2014":
                case "urn:mpeg:dash:utc:ntp:2014":
                case "urn:mpeg:dash:utc:sntp:2014":
                  Wa("NTP UTCTiming scheme is not supported");
                  break;
                default:
                  Wa("Unrecognized scheme in UTCTiming element", k2);
              }
              n.A(9);
              break;
            case 7:
              return u(n, Bq(a, b, l, "HEAD"), 10);
            case 10:
              return n.return(n.h);
            case 8:
              return u(n, Bq(a, b, l, "GET"), 11);
            case 11:
              return n.return(n.h);
            case 9:
              ta(
                n,
                3
              );
              break;
            case 5:
              ua(n);
            case 3:
              g = f.next();
              n.A(2);
              break;
            case 4:
              return Wa("A UTCTiming element should always be given in live manifests! This content may not play on clients with bad clocks!"), n.return(0);
          }
        });
      }
      function tq(a, b, c, d, e) {
        var f = d.getAttribute("schemeIdUri") || "", g = d.getAttribute("value") || "", h = Uf(d, "timescale", $f) || 1;
        d = r(Mf(d, "Event"));
        for (var k2 = d.next(); !k2.done; k2 = d.next()) {
          k2 = k2.value;
          var l = Uf(k2, "presentationTime", $f) || 0, m = Uf(k2, "duration", $f) || 0;
          l = l / h + b;
          m = l + m / h;
          null != c && (l = Math.min(l, b + c), m = Math.min(m, b + c));
          m < e || (k2 = { schemeIdUri: f, value: g, startTime: l, endTime: m, id: k2.getAttribute("id") || "", eventElement: k2 }, a.h.onTimelineRegionAdded(k2));
        }
      }
      function zq(a, b, c, d) {
        var e, f, g, h, k2;
        return G(function(l) {
          if (1 == l.g)
            return e = jf, f = ck(b, c, d, a.g.retryParameters), g = a.h.networkingEngine, h = g.request(e, f), Ye(a.o, h), u(l, h.promise, 2);
          k2 = l.h;
          return l.return(k2.data);
        });
      }
      function xq(a, b) {
        return ed(Zc(a, b)) ? jc : a.split("/")[0];
      }
      K("shaka.dash.DashParser", jq);
      Vg.mpd = function() {
        return new jq();
      };
      Tg["application/dash+xml"] = function() {
        return new jq();
      };
      Tg["video/vnd.mpeg.dash.mpd"] = function() {
        return new jq();
      };
      function Cq(a, b, c, d) {
        this.h = a;
        this.type = b;
        this.g = c;
        this.segments = d || null;
      }
      function Dq(a, b, c, d) {
        this.id = a;
        this.name = b;
        this.g = c;
        this.value = void 0 === d ? null : d;
      }
      Dq.prototype.toString = function() {
        function a(d) {
          return d.name + "=" + (isNaN(Number(d.value)) ? '"' + d.value + '"' : d.value);
        }
        var b = "#" + this.name, c = this.g ? this.g.map(a) : [];
        this.value && c.unshift(this.value);
        0 < c.length && (b += ":" + c.join(","));
        return b;
      };
      Dq.prototype.getAttribute = function(a) {
        var b = this.g.filter(function(c) {
          return c.name == a;
        });
        return b.length ? b[0] : null;
      };
      function Z(a, b, c) {
        return (a = a.getAttribute(b)) ? a.value : c || null;
      }
      function Eq(a, b) {
        a = a.getAttribute(b);
        if (!a)
          throw new O(2, 4, 4023, b);
        return a.value;
      }
      function Fq(a, b, c) {
        c = void 0 === c ? [] : c;
        this.g = b;
        this.i = a;
        this.h = c;
      }
      function Gq(a, b) {
        this.name = a;
        this.value = b;
      }
      function Hq(a, b) {
        return a.filter(function(c) {
          return c.name == b;
        });
      }
      function Iq(a, b) {
        return a.filter(function(c) {
          return Eq(c, "TYPE") == b;
        });
      }
      function Jq(a, b) {
        a = Hq(a, b);
        return a.length ? a[0] : null;
      }
      function Kq(a, b) {
        var c = 0;
        c = void 0 === c ? 0 : c;
        return (a = Jq(a, b)) ? Number(a.value) : c;
      }
      function Lq(a, b) {
        return ec([a], [b])[0];
      }
      function Mq(a) {
        this.h = a;
        this.g = 0;
      }
      function Nq(a) {
        Oq(a, /[ \t]+/gm);
      }
      function Oq(a, b) {
        b.lastIndex = a.g;
        b = b.exec(a.h);
        b = null == b ? null : { position: b.index, length: b[0].length, results: b };
        if (a.g == a.h.length || null == b || b.position != a.g)
          return null;
        a.g += b.length;
        return b.results;
      }
      function Pq(a) {
        return a.g == a.h.length ? null : (a = Oq(a, /[^ \t\n]*/gm)) ? a[0] : null;
      }
      function Qq() {
        this.g = 0;
      }
      function Rq(a, b, c) {
        b = Cc(b);
        b = b.replace(/\r\n|\r(?=[^\n]|$)/gm, "\n").trim();
        var d = b.split(/\n+/m);
        if (!/^#EXTM3U($|[ \t\n])/m.test(d[0]))
          throw new O(2, 4, 4015);
        b = 0;
        for (var e = true, f = r(d), g = f.next(); !g.done; g = f.next())
          if (g = g.value, /^#(?!EXT)/m.test(g) || e)
            e = false;
          else if (g = Sq(a, g), --a.g, Tq.includes(g.name)) {
            b = 1;
            break;
          } else
            "EXT-X-STREAM-INF" == g.name && (e = true);
        f = [];
        e = true;
        for (g = 0; g < d.length; g++) {
          var h = d[g], k2 = d[g + 1];
          if (/^#(?!EXT)/m.test(h) || e)
            e = false;
          else {
            h = Sq(a, h);
            if (Uq.includes(h.name)) {
              if (1 != b)
                throw new O(2, 4, 4017);
              var l = d.splice(g, d.length - g);
              d = c;
              e = [];
              g = [];
              k2 = [];
              h = null;
              l = r(l);
              for (var m = l.next(); !m.done; m = l.next())
                m = m.value, /^(#EXT)/.test(m) ? (m = Sq(a, m), Tq.includes(m.name) ? f.push(m) : "EXT-X-MAP" == m.name ? h = m : "EXT-X-PART" == m.name ? k2.push(m) : "EXT-X-PRELOAD-HINT" == m.name ? "PART" == Z(m, "TYPE") ? k2.push(m) : "MAP" == Z(m, "TYPE") && (m.name = "EXT-X-MAP", h = m) : g.push(m)) : /^#(?!EXT)/m.test(m) || (m = Lq(d, m.trim()), h && g.push(h), e.push(new Fq(m, g, k2)), g = [], k2 = []);
              k2.length && (h && g.push(h), e.push(new Fq("", g, k2)));
              return new Cq(c, b, f, e);
            }
            f.push(h);
            "EXT-X-STREAM-INF" == h.name && (h.g.push(new Gq("URI", k2)), e = true);
          }
        }
        return new Cq(c, b, f);
      }
      function Sq(a, b) {
        a = a.g++;
        var c = b.match(/^#(EXT[^:]*)(?::(.*))?$/);
        if (!c)
          throw new O(2, 4, 4016, b);
        b = c[1];
        var d = c[2];
        c = [];
        var e;
        if (d) {
          d = new Mq(d);
          var f;
          (f = Oq(d, /^([^,=]+)(?:,|$)/g)) && (e = f[1]);
          for (var g = /([^=]+)=(?:"([^"]*)"|([^",]*))(?:,|$)/g; f = Oq(d, g); )
            c.push(new Gq(f[1], f[2] || f[3])), Nq(d);
        }
        return new Dq(a, b, c, e);
      }
      var Tq = "EXT-X-TARGETDURATION EXT-X-MEDIA-SEQUENCE EXT-X-DISCONTINUITY-SEQUENCE EXT-X-PLAYLIST-TYPE EXT-X-I-FRAMES-ONLY EXT-X-ENDLIST EXT-X-SERVER-CONTROL EXT-X-SKIP".split(" "), Uq = "EXTINF EXT-X-BYTERANGE EXT-X-DISCONTINUITY EXT-X-PROGRAM-DATE-TIME EXT-X-KEY EXT-X-DATERANGE EXT-X-MAP".split(" ");
      function Vq() {
      }
      function Wq(a) {
        try {
          var b = Xq(a);
          return Oe({ uri: a, Oe: a, data: b.data, headers: { "content-type": b.contentType } });
        } catch (c) {
          return Me(c);
        }
      }
      function Xq(a) {
        var b = a.split(":");
        if (2 > b.length || "data" != b[0])
          throw new O(2, 1, 1004, a);
        b = b.slice(1).join(":").split(",");
        if (2 > b.length)
          throw new O(2, 1, 1004, a);
        var c = b[0];
        a = window2.decodeURIComponent(b.slice(1).join(","));
        b = c.split(";");
        c = b[0];
        var d = false;
        1 < b.length && "base64" == b[b.length - 1] && (d = true, b.pop());
        var e;
        d ? e = Lc(a) : e = Gc(a);
        return { data: e, contentType: c };
      }
      K("shaka.net.DataUriPlugin", Vq);
      Vq.parse = Wq;
      $e("data", Wq);
      function Yq() {
        var a = this;
        this.g = this.i = null;
        this.Fa = 1;
        this.o = /* @__PURE__ */ new Map();
        this.u = /* @__PURE__ */ new Map();
        this.F = /* @__PURE__ */ new Map();
        this.F.set("video", /* @__PURE__ */ new Map());
        this.F.set("audio", /* @__PURE__ */ new Map());
        this.F.set(jc, /* @__PURE__ */ new Map());
        this.F.set("image", /* @__PURE__ */ new Map());
        this.ua = /* @__PURE__ */ new Set();
        this.h = /* @__PURE__ */ new Map();
        this.j = null;
        this.M = "";
        this.W = new Qq();
        this.O = 0;
        this.B = -1;
        this.H = Infinity;
        this.Ga = false;
        this.m = new P(function() {
          Zq(a);
        });
        this.ea = $q;
        this.D = null;
        this.ca = 0;
        this.J = Infinity;
        this.V = this.da = 0;
        this.G = new Xe();
        this.L = /* @__PURE__ */ new Map();
        this.s = /* @__PURE__ */ new Map();
        this.ba = /* @__PURE__ */ new Map();
        this.l = false;
      }
      q = Yq.prototype;
      q.configure = function(a) {
        this.g = a;
      };
      q.start = function(a, b) {
        var c = this, d;
        return G(function(e) {
          return 1 == e.g ? (c.i = b, c.l = b.isLowLatencyMode(), u(e, ar(c, a), 2)) : 3 != e.g ? (d = e.h, c.M = d.uri, u(e, br(c, d.data, a), 3)) : e.return(c.D);
        });
      };
      q.stop = function() {
        this.m && (this.m.stop(), this.m = null);
        var a = [];
        this.G && (a.push(this.G.destroy()), this.G = null);
        this.g = this.i = null;
        this.ua.clear();
        this.D = null;
        this.h.clear();
        this.u.clear();
        this.s.clear();
        this.o.clear();
        return Promise.all(a);
      };
      q.update = function() {
        var a = this, b, c, d, e, f, g, h, k2, l;
        return G(function(m) {
          if (1 == m.g) {
            if (!cr(a))
              return m.return();
            b = [];
            c = Array.from(a.h.values());
            d = c.filter(function(n) {
              return n.stream.segmentIndex;
            });
            e = r(d);
            for (f = e.next(); !f.done; f = e.next())
              g = f.value, b.push(dr(a, g));
            return u(m, Promise.all(b), 2);
          }
          er(a, d.map(function(n) {
            return n.stream;
          }));
          h = d.some(function(n) {
            return 0 == n.mc;
          });
          d.length && !h && (k2 = fr, gr(a, k2.ff), l = d.map(function(n) {
            return n.Ya;
          }), a.j.Aa(Math.min.apply(Math, ha(l))), a.i.updateDuration());
          A(m);
        });
      };
      function hr(a, b) {
        return cr(a) ? a.F.get(b.type) : b.$c;
      }
      function dr(a, b) {
        var c, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x;
        return G(function(z) {
          if (1 == z.g)
            return c = b.Jc, d = new Nb(c), a.l && b.Mc && Qb(d, new Sb("_HLS_skip=YES")), u(z, ar(a, d.toString()), 2);
          e = z.h;
          if (!b.stream.segmentIndex)
            return z.return();
          f = Rq(a.W, e.data, e.uri);
          if (1 != f.type)
            throw new O(2, 4, 4017);
          g = Hq(f.g, "EXT-X-DEFINE");
          h = ir(a, g);
          k2 = b.stream;
          l = hr(a, b);
          m = jr(f, k2.mimeType);
          n = m.keyIds;
          p = m.drmInfos;
          t = function(B, E) {
            return B.size === E.size && [].concat(ha(B)).every(function(F) {
              return E.has(F);
            });
          };
          t(k2.keyIds, n) || (k2.keyIds = n, k2.drmInfos = p, a.i.newDrmInfo(k2));
          v = kr(a, f, k2.type, l, h);
          k2.segmentIndex.Hb(v, a.j.Pa());
          v.length && (y = Kq(f.g, "EXT-X-MEDIA-SEQUENCE"), w = l.get(y), k2.segmentIndex.eb(w));
          x = v[v.length - 1];
          if (Jq(f.g, "EXT-X-ENDLIST"))
            b.mc = true, b.Ya = x.endTime;
          A(z);
        });
      }
      q.onExpirationUpdated = function() {
      };
      function lr(a, b) {
        for (var c = -1 == a.B, d = r(b), e = d.next(); !e.done; e = d.next()) {
          e = e.value;
          var f = e.stream.segmentIndex, g = hr(a, e);
          if (f = f.g[0] || null) {
            g = r(g);
            for (var h = g.next(); !h.done; h = g.next()) {
              h = r(h.value);
              var k2 = h.next().value;
              if (h.next().value == f.startTime) {
                c && (a.B = Math.max(a.B, k2));
                e.Cd = k2;
                break;
              }
            }
          }
        }
        if (!(0 > a.B)) {
          for (b = r(b), e = b.next(); !e.done; e = b.next())
            if (c = e.value, d = c.stream.segmentIndex) {
              if (d.g.splice(0, a.B - c.Cd), d = d.g[0] || null)
                d = -d.startTime, c.stream.segmentIndex.offset(d), mr(a, c, d);
            }
        }
      }
      function nr(a, b) {
        if (Infinity == a.H) {
          b = r(b);
          for (var c = b.next(); !c.done; c = b.next()) {
            var d = c.value.stream.segmentIndex.g[0] || null;
            null != d && null != d.g && (a.H = Math.min(a.H, d.g));
          }
        }
        b = a.H;
        if (Infinity != b)
          for (d = r(a.h.values()), c = d.next(); !c.done; c = d.next()) {
            c = c.value;
            var e = c.stream.segmentIndex;
            if (null != e) {
              var f = e.g[0] || null;
              if (null == f.g)
                Va("Missing EXT-X-PROGRAM-DATE-TIME for stream", c.Ac, "Expect AV sync issues!");
              else
                for (mr(a, c, f.g - b - f.startTime), c = r(e), e = c.next(); !e.done; e = c.next())
                  e.value.oe(b);
            }
          }
      }
      function mr(a, b, c) {
        b.Ya += c;
        a = hr(a, b);
        b = r(a);
        for (var d = b.next(); !d.done; d = b.next()) {
          var e = r(d.value);
          d = e.next().value;
          e = e.next().value;
          a.set(d, e + c);
        }
      }
      function br(a, b, c) {
        var d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N, wa, va, Ma, Sa;
        return G(function(Ga) {
          switch (Ga.g) {
            case 1:
              d = Rq(a.W, b, a.M);
              e = Hq(d.g, "EXT-X-DEFINE");
              for (var Kb = r(e), Ja = Kb.next(); !Ja.done; Ja = Kb.next()) {
                var Ua = Ja.value;
                Ja = Z(Ua, "NAME");
                Ua = Z(Ua, "VALUE");
                Ja && Ua && (a.o.has(Ja) || a.o.set(Ja, Ua));
              }
              f = [];
              g = [];
              h = [];
              if (1 == d.type)
                return F = a.g.hls.mediaPlaylistFullMimeType, d.segments.length && (H = new Nb(d.segments[0].i), I = H.qa.split(".").pop(), (J = or[I]) ? F = J : "ts" !== I && "mp4" !== I && (pr[I] ? (J = pr[I], L = a.g.hls.defaultAudioCodec, F = J + '; codecs="' + L + '"') : qr[I] && (J = qr[I], R = a.g.hls.defaultVideoCodec, F = J + '; codecs="' + R + '"'))), Q = F.split(";")[0], U = Q.split("/")[0], N = cd(F), wa = /* @__PURE__ */ new Map(), u(Ga, rr(a, d, c, c, N, U, "", true, "Media Playlist", null, wa, null, false, false, Q), 5);
              k2 = Hq(d.g, "EXT-X-MEDIA");
              l = Hq(d.g, "EXT-X-STREAM-INF");
              m = Hq(d.g, "EXT-X-IMAGE-STREAM-INF");
              n = Hq(d.g, "EXT-X-SESSION-KEY");
              Kb = r(l);
              for (Ja = Kb.next(); !Ja.done; Ja = Kb.next()) {
                var Zb = Ja.value;
                Ua = Z(Zb, "AUDIO");
                Ja = Z(Zb, "VIDEO");
                var pb = Z(Zb, "SUBTITLES");
                Zb = sr(a, Zb);
                if (pb) {
                  var Wn = hc(jc, Zb);
                  a.s.set(pb, Wn);
                  hb(Zb, Wn);
                }
                Ua && (pb = hc("audio", Zb), pb || (pb = a.g.hls.defaultAudioCodec), a.s.set(Ua, pb));
                Ja && (Ua = hc("video", Zb), Ua || (Ua = a.g.hls.defaultVideoCodec), a.s.set(Ja, Ua));
              }
              p = Hq(d.g, "EXT-X-SESSION-DATA");
              t = r(p);
              for (v = t.next(); !v.done; v = t.next())
                if (y = v.value, w = Z(y, "DATA-ID"), x = Z(y, "URI"), C = Z(y, "LANGUAGE"), z = Z(y, "VALUE"), B = (/* @__PURE__ */ new Map()).set("id", w), x && B.set("uri", Lq(a.M, x)), C && B.set("language", C), z && B.set("value", z), E = new S("sessiondata", B), a.i)
                  a.i.onEvent(E);
              tr(a, k2);
              Kb = Iq(k2, "CLOSED-CAPTIONS");
              Kb = r(Kb);
              for (Ja = Kb.next(); !Ja.done; Ja = Kb.next())
                pb = Ja.value, Ja = ur(pb), Ua = Eq(pb, "GROUP-ID"), pb = Eq(pb, "INSTREAM-ID"), a.L.get(Ua) || a.L.set(Ua, /* @__PURE__ */ new Map()), a.L.get(Ua).set(pb, Ja);
              f = vr(a, l, n);
              g = wr(a, k2);
              return u(Ga, xr(a, m), 4);
            case 4:
              h = Ga.h;
              Ga.A(3);
              break;
            case 5:
              va = Ga.h, a.h.set(c, va), f.push({ id: 0, language: "und", disabledUntilTime: 0, primary: true, audio: "audio" == U ? va.stream : null, video: "video" == U ? va.stream : null, bandwidth: 0, allowedByApplication: true, allowedByKeySystem: true, decodingInfos: [] });
            case 3:
              if (!a.i)
                throw new O(
                  2,
                  7,
                  7001
                );
              a.j = new T(null, 0);
              a.j.yc(true);
              1 == d.type && (cr(a) && (yr(a), Ma = a.O, a.m.N(Ma)), Sa = Array.from(a.h.values()), zr(a, Sa), Ar(a));
              a.D = { presentationTimeline: a.j, variants: f, textStreams: g, imageStreams: h, offlineSessionIds: [], minBufferTime: 0, sequenceMode: true };
              a.i.makeTextStreamsForClosedCaptions(a.D);
              A(Ga);
          }
        });
      }
      function Ar(a) {
        if (cr(a)) {
          if (a.O = a.J, a.ea == Br) {
            var b = Cr(a);
            a.g.hls.useSafariBehaviorForLive && (b = a.j.m);
            isNaN(a.g.availabilityWindowOverride) || (b = a.g.availabilityWindowOverride);
            a.j.me(b);
          }
        } else
          a.j.Aa(Cr(a));
        a.j.Md();
      }
      function ir(a, b) {
        var c = /* @__PURE__ */ new Map();
        b = r(b);
        for (var d = b.next(); !d.done; d = b.next()) {
          var e = d.value;
          d = Z(e, "NAME");
          var f = Z(e, "VALUE");
          e = Z(e, "IMPORT");
          d && f && c.set(d, f);
          e && (d = a.o.get(e)) && c.set(e, d);
        }
        return c;
      }
      function wr(a, b) {
        var c = Iq(b, "SUBTITLES");
        b = c.map(function(g) {
          if (a.g.disableText)
            return null;
          try {
            return Dr(a, g).stream;
          } catch (h) {
            if (a.g.hls.ignoreTextStreamFailures)
              return null;
            throw h;
          }
        });
        c = r(c);
        for (var d = c.next(); !d.done; d = c.next()) {
          var e = Eq(d.value, "GROUP-ID");
          if (d = a.s.get(e)) {
            if (e = a.u.get(e)) {
              e = r(e);
              for (var f = e.next(); !f.done; f = e.next())
                f = f.value, f.stream.codecs = d, f.stream.mimeType = Er(jc, d) || Fr(jc);
            }
          }
        }
        return b.filter(function(g) {
          return g;
        });
      }
      function xr(a, b) {
        var c, d;
        return G(function(e) {
          if (1 == e.g)
            return c = b.map(function(f) {
              var h, k2;
              return G(function(l) {
                if (1 == l.g) {
                  if (a.g.disableThumbnails)
                    return l.return(null);
                  D(l, 2);
                  return u(l, Gr(a, f), 4);
                }
                if (2 != l.g)
                  return h = l.h, l.return(h.stream);
                k2 = ua(l);
                if (a.g.hls.ignoreImageStreamFailures)
                  return l.return(null);
                throw k2;
              });
            }), u(e, Promise.all(c), 2);
          d = e.h;
          return e.return(d.filter(function(f) {
            return f;
          }));
        });
      }
      function tr(a, b) {
        b = b.filter(function(d) {
          var e = Z(d, "URI") || "";
          return "SUBTITLES" != Z(d, "TYPE") && "" != e;
        });
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next())
          Dr(a, c.value);
      }
      function vr(a, b, c) {
        var d = [], e = /* @__PURE__ */ new Set();
        if (0 < c.length) {
          c = r(c);
          for (var f = c.next(); !f.done; f = c.next()) {
            f = f.value;
            var g = Eq(f, "METHOD");
            if ("NONE" != g && "AES-128" != g && (g = Z(f, "KEYFORMAT") || "identity", f = (g = Hr[g]) ? g(f, "") : null)) {
              if (f.keyIds) {
                g = r(f.keyIds);
                for (var h = g.next(); !h.done; h = g.next())
                  e.add(h.value);
              }
              d.push(f);
            }
          }
        }
        b = b.map(function(k2) {
          var l = Z(k2, "FRAME-RATE"), m = Number(Z(k2, "AVERAGE-BANDWIDTH")) || Number(Eq(k2, "BANDWIDTH")), n = Z(k2, "RESOLUTION");
          n = r(n ? n.split("x") : [null, null]);
          var p = n.next().value, t = n.next().value, v = Z(k2, "VIDEO-RANGE");
          k2 = Ir(a, k2);
          n = k2.audio;
          k2 = k2.video;
          for (var y = r(k2), w = y.next(); !w.done; w = y.next())
            if (w = w.value.stream)
              w.width = Number(p) || void 0, w.height = Number(t) || void 0, w.frameRate = Number(l) || void 0, w.hdr = v || void 0;
          l = a.g.disableAudio;
          if (!n.length || l)
            n = [null];
          l = a.g.disableVideo;
          if (!k2.length || l)
            k2 = [null];
          l = [];
          n = r(n);
          for (p = n.next(); !p.done; p = n.next())
            for (p = p.value, t = r(k2), v = t.next(); !v.done; v = t.next()) {
              var x = v.value;
              if (v = p ? p.stream : null)
                v.drmInfos = d, v.keyIds = e;
              if (y = x ? x.stream : null)
                y.drmInfos = d, y.keyIds = e;
              w = p ? p.stream.drmInfos : null;
              var C = x ? x.stream.drmInfos : null;
              x = (x ? x.Ac : "") + " - " + (p ? p.Ac : "");
              v && y && w.length && C.length && !(0 < Pg(w, C).length) || a.ua.has(x) || (v = { id: a.Fa++, language: v ? v.language : "und", primary: !!v && v.primary || !!y && y.primary, audio: v, video: y, bandwidth: m, allowedByApplication: true, allowedByKeySystem: true, decodingInfos: [] }, l.push(v), a.ua.add(x));
            }
          return l;
        }).reduce(bc, []);
        return b = b.filter(function(k2) {
          return null != k2;
        });
      }
      function Ir(a, b) {
        var c = sr(a, b), d = Z(b, "AUDIO"), e = Z(b, "VIDEO"), f = d || e;
        f = f && a.u.has(f) ? a.u.get(f) : [];
        d = { audio: d ? f : [], video: e ? f : [] };
        e = false;
        var g = Eq(b, "URI"), h = d.audio.find(function(m) {
          return m && m.Ac == g;
        }), k2 = hc("video", c), l = hc("audio", c);
        l && !k2 ? f = "audio" : !f.length && l && k2 ? (f = "video", c = [[k2, l].join()]) : d.audio.length && h ? (f = "audio", e = true) : f = d.video.length && !d.audio.length ? "audio" : "video";
        e || (a = Jr(a, b, c, f), d[a.stream.type] = [a]);
        return d;
      }
      function sr(a, b) {
        var c = [];
        a.g.disableVideo || c.push(a.g.hls.defaultVideoCodec);
        a.g.disableAudio || c.push(a.g.hls.defaultAudioCodec);
        c = Z(b, "CODECS", c.join(",")).split(/\s*,\s*/);
        a = /* @__PURE__ */ new Set();
        b = [];
        c = r(c);
        for (var d = c.next(); !d.done; d = c.next()) {
          d = d.value;
          var e = bd(d)[0];
          a.has(e) || (b.push(d), a.add(e));
        }
        return b;
      }
      function ur(a) {
        a = Z(a, "LANGUAGE") || "und";
        return od(a);
      }
      function Dr(a, b) {
        var c = Eq(b, "GROUP-ID"), d = "", e = Eq(b, "TYPE").toLowerCase();
        "subtitles" == e && (e = jc);
        var f = e;
        f != jc && c && a.s.has(c) && (d = a.s.get(c));
        e = Kr(Eq(b, "URI"), a.o);
        if (a.h.has(e))
          return a.h.get(e);
        var g = ur(b), h = Z(b, "NAME"), k2 = "YES" == Z(b, "DEFAULT");
        var l = "audio" == f ? (l = Z(b, "CHANNELS")) ? parseInt(l.split("/")[0], 10) : null : null;
        var m = "audio" == f ? (m = Z(b, "CHANNELS")) ? m.includes("/JOC") : false : false;
        var n = Z(b, "CHARACTERISTICS");
        b = "YES" == Z(b, "FORCED");
        d = Lr(a, e, d, f, g, k2, h, l, null, n, b, m);
        a.u.has(c) ? a.u.get(c).push(d) : a.u.set(
          c,
          [d]
        );
        if (a.h.has(e))
          return a.h.get(e);
        a.h.set(e, d);
        return d;
      }
      function Gr(a, b) {
        var c, d, e, f, g, h, k2, l, m, n;
        return G(function(p) {
          if (1 == p.g) {
            c = Kr(Eq(b, "URI"), a.o);
            d = Z(b, "CODECS", "jpeg") || "";
            if (a.h.has(c))
              return p.return(a.h.get(c));
            e = ur(b);
            f = Z(b, "NAME");
            g = Z(b, "CHARACTERISTICS");
            h = Lr(a, c, d, "image", e, false, f, null, null, g, false, false);
            return a.h.has(c) ? p.return(a.h.get(c)) : (k2 = Z(b, "RESOLUTION")) ? u(p, h.stream.createSegmentIndex(), 3) : p.A(2);
          }
          2 != p.g && (l = h.stream.segmentIndex.get(0), m = l.tilesLayout) && (h.stream.width = Number(k2.split("x")[0]) * Number(m.split("x")[0]), h.stream.height = Number(k2.split("x")[1]) * Number(m.split("x")[1]));
          if (n = Z(b, "BANDWIDTH"))
            h.stream.bandwidth = Number(n);
          a.h.set(c, h);
          return p.return(h);
        });
      }
      function Jr(a, b, c, d) {
        var e = Kr(Eq(b, "URI"), a.o);
        if (a.h.has(e))
          return a.h.get(e);
        b = Z(b, "CLOSED-CAPTIONS");
        b = "video" == d && b && "NONE" != b ? a.L.get(b) : null;
        c = gc(d, c);
        d = Lr(a, e, c, d, "und", false, null, null, b, null, false, false);
        if (a.h.has(e))
          return a.h.get(e);
        a.h.set(e, d);
        return d;
      }
      function Lr(a, b, c, d, e, f, g, h, k2, l, m, n) {
        function p(C) {
          var z, B, E, F, H, I, J, L, R, Q, U, N, wa;
          return G(function(va) {
            if (1 == va.g)
              return u(va, ar(a, y.Jc), 2);
            if (3 != va.g) {
              z = va.h;
              if (C.aborted)
                return va.return();
              B = z.uri;
              E = Rq(a.W, z.data, B);
              F = cr(a);
              return u(va, rr(a, E, b, B, c, d, e, f, g, h, k2, l, m, n), 3);
            }
            H = va.h;
            if (C.aborted)
              return va.return();
            I = H.stream;
            cr(a) && !F && yr(a);
            y.Jc = B;
            y.Ya = H.Ya;
            y.Mc = H.Mc;
            y.mc = H.mc;
            y.$c = H.$c;
            y.Ld = true;
            v.segmentIndex = I.segmentIndex;
            v.encrypted = I.encrypted;
            v.drmInfos = I.drmInfos;
            v.keyIds = I.keyIds;
            v.mimeType = I.mimeType;
            Yi.includes(v.mimeType) && (v.codecs = "");
            v.drmInfos.length && a.i.newDrmInfo(v);
            J = kc;
            if (d == J.va || d == J.Hc)
              for (L = r(a.h.values()), R = L.next(); !R.done; R = L.next())
                Q = R.value, Q.Ld || Q.type != d || (Q.stream.mimeType = I.mimeType, Yi.includes(Q.stream.mimeType) && (Q.stream.codecs = ""));
            Mr(a) && (a.Ga ? zr(a, [y]) : (a.Ga = true, U = Array.from(a.h.values()), N = U.filter(function(Ma) {
              return Ma.stream.segmentIndex;
            }), zr(a, N), Ar(a), wa = a.O, 0 < wa && a.m.N(wa)));
            A(va);
          });
        }
        var t = Lq(a.M, b), v = Nr(a, c, d, e, f, g, h, k2, l, m, n);
        Yi.includes(v.mimeType) && (v.codecs = "");
        var y = { stream: v, type: d, Ac: b, Jc: t, Ya: 0, $c: /* @__PURE__ */ new Map(), Mc: false, mc: false, Cd: -1, Ld: false }, w = null, x = new AbortController();
        v.createSegmentIndex = function() {
          if (w)
            return w;
          x = new AbortController();
          return w = new Promise(function(C) {
            C(p(x.signal));
          });
        };
        v.closeSegmentIndex = function() {
          w && !v.segmentIndex && x.abort();
          v.segmentIndex && (v.segmentIndex.release(), v.segmentIndex = null);
          w = null;
        };
        return y;
      }
      function Cr(a) {
        var b = Infinity;
        a = r(a.h.values());
        for (var c = a.next(); !c.done; c = a.next())
          c = c.value, c.stream.segmentIndex && "text" != c.stream.type && (b = Math.min(b, c.Ya));
        return b;
      }
      function er(a, b) {
        var c = [];
        b = r(b);
        for (var d = b.next(); !d.done; d = b.next())
          d = d.value, d.segmentIndex && Kj(d.segmentIndex, function(e) {
            c.push(e);
          });
        a.j.Ib(c);
      }
      function zr(a, b) {
        if (!cr(a))
          for (var c = Cr(a), d = r(b), e = d.next(); !e.done; e = d.next())
            e.value.stream.segmentIndex.Wa(0, c);
        c = r(b);
        for (e = c.next(); !e.done; e = c.next())
          e = e.value.stream, Yi.includes(e.mimeType) && (e.codecs = "");
        er(a, b.map(function(f) {
          return f.stream;
        }));
        a.g.hls.ignoreManifestProgramDateTime ? lr(a, b) : nr(a, b);
      }
      function Mr(a) {
        if (!a.D)
          return false;
        var b = [], c = [];
        a = r(a.D.variants);
        for (var d = a.next(); !d.done; d = a.next())
          d = d.value, d.video && b.push(d.video), d.audio && c.push(d.audio);
        return 0 < b.length && !b.some(function(e) {
          return e.segmentIndex;
        }) || 0 < c.length && !c.some(function(e) {
          return e.segmentIndex;
        }) ? false : true;
      }
      function rr(a, b, c, d, e, f, g, h, k2, l, m, n, p, t, v) {
        var y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U;
        return G(function(N) {
          if (1 == N.g) {
            if (1 != b.type)
              throw new O(2, 4, 4017);
            y = Hq(b.g, "EXT-X-DEFINE");
            w = ir(a, y);
            Or(a, b);
            return v ? N.A(2) : u(N, Pr(a, f, e, b, w), 3);
          }
          2 != N.g && (v = N.h);
          x = jr(b, v);
          C = x.drmInfos;
          z = x.keyIds;
          B = x.encrypted;
          E = x.kf;
          if (B && !C.length && !E)
            throw new O(2, 4, 4026);
          F = cr(a) ? a.F.get(f) : /* @__PURE__ */ new Map();
          H = a.l;
          I = kr(a, b, f, F, w);
          H != a.l && Or(a, b);
          J = I[I.length - 1].endTime;
          L = new Jj(I);
          Q = (R = Jq(b.g, "EXT-X-SERVER-CONTROL")) ? null != R.getAttribute("CAN-SKIP-UNTIL") : false;
          U = Nr(a, e, f, g, h, k2, l, m, n, p, t);
          U.segmentIndex = L;
          U.encrypted = B;
          U.drmInfos = C;
          U.keyIds = z;
          U.mimeType = v;
          return N.return({ stream: U, type: f, Ac: c, Jc: d, Ya: J, Mc: Q, mc: false, Cd: -1, $c: F, Ld: false });
        });
      }
      function Nr(a, b, c, d, e, f, g, h, k2, l, m) {
        var n = Er(c, b) || Fr(c);
        return {
          id: a.Fa++,
          originalId: f,
          createSegmentIndex: function() {
            return Promise.resolve();
          },
          segmentIndex: null,
          mimeType: n,
          codecs: b,
          kind: c == jc ? "subtitle" : void 0,
          encrypted: false,
          drmInfos: [],
          keyIds: /* @__PURE__ */ new Set(),
          language: d,
          label: f,
          type: c,
          primary: e,
          trickModeVideo: null,
          emsgSchemeIdUris: null,
          frameRate: void 0,
          pixelAspectRatio: void 0,
          width: void 0,
          height: void 0,
          bandwidth: void 0,
          roles: k2 ? k2.split(",") : [],
          forced: l,
          channelsCount: g,
          audioSamplingRate: null,
          spatialAudio: m,
          closedCaptions: h,
          hdr: void 0,
          tilesLayout: void 0
        };
      }
      function jr(a, b) {
        var c = [];
        if (a.segments) {
          a = r(a.segments);
          for (var d = a.next(); !d.done; d = a.next())
            d = Hq(d.value.g, "EXT-X-KEY"), c.push.apply(c, ha(d));
        }
        d = a = false;
        var e = [], f = /* @__PURE__ */ new Set();
        c = r(c);
        for (var g = c.next(); !g.done; g = c.next()) {
          g = g.value;
          var h = Eq(g, "METHOD");
          if ("NONE" != h) {
            if (a = true, "AES-128" == h)
              d = true;
            else if (h = Z(g, "KEYFORMAT") || "identity", g = (h = Hr[h]) ? h(g, b) : null) {
              if (g.keyIds) {
                h = r(g.keyIds);
                for (var k2 = h.next(); !k2.done; k2 = h.next())
                  f.add(k2.value);
              }
              e.push(g);
            }
          }
        }
        return { drmInfos: e, keyIds: f, encrypted: a, kf: d };
      }
      function Qr(a, b, c) {
        if (!window2.crypto || !window2.crypto.subtle)
          throw Wa("Web Crypto API is not available to decrypt AES-128. (Web Crypto only exists in secure origins like https)"), new O(2, 4, 4042);
        var d = 0, e = Z(b, "IV", "");
        if (e) {
          var f = Mc(e.substr(2));
          if (16 != f.byteLength)
            throw new O(2, 4, 4043);
        } else
          d = Kq(c.g, "EXT-X-MEDIA-SEQUENCE");
        b = Lq(c.h, Eq(b, "URI"));
        var g = cf([b], a.g.retryParameters), h = { method: "AES-128", iv: f, firstMediaSequenceNumber: d, fetchKey: function() {
          var k2, l, m;
          return G(function(n) {
            if (1 == n.g)
              return u(
                n,
                Rr(a, g, 6),
                2
              );
            if (3 != n.g) {
              k2 = n.h;
              if (!k2.data || 16 != k2.data.byteLength)
                throw new O(2, 4, 4044);
              l = { name: "AES-CBC" };
              m = h;
              return u(n, window2.crypto.subtle.importKey("raw", k2.data, l, true, ["decrypt"]), 3);
            }
            m.cryptoKey = n.h;
            h.fetchKey = void 0;
            A(n);
          });
        } };
        return h;
      }
      function Or(a, b) {
        var c = Jq(b.g, "EXT-X-PLAYLIST-TYPE"), d = Jq(b.g, "EXT-X-ENDLIST");
        d = c && "VOD" == c.value || d;
        c = c && "EVENT" == c.value && !d;
        c = !d && !c;
        if (d)
          gr(a, $q);
        else {
          c ? gr(a, Br) : gr(a, Sr);
          d = Jq(b.g, "EXT-X-TARGETDURATION");
          if (!d)
            throw new O(2, 4, 4024, "EXT-X-TARGETDURATION");
          d = Number(d.value);
          c = Jq(b.g, "EXT-X-PART-INF");
          a.l && c ? (a.da = Number(Eq(c, "PART-TARGET")), a.J = Math.min(a.da, a.J), b = Jq(b.g, "EXT-X-SERVER-CONTROL"), a.V = b ? Number(Eq(b, "PART-HOLD-BACK")) : 0) : a.J = Math.min(d, a.J);
          a.ca = Math.max(d, a.ca);
        }
      }
      function yr(a) {
        var b = a.g.defaultPresentationDelay ? a.g.defaultPresentationDelay : a.V ? a.V : a.ca * a.g.hls.liveSegmentsDelay;
        a.j.Xe(0);
        a.j.We(b);
        a.j.yc(false);
      }
      function Tr(a, b, c, d) {
        c = Jq(c, "EXT-X-MAP");
        if (!c)
          return null;
        var e = Eq(c, "URI");
        d = Kr(Lq(b, e), d);
        b = [d, Z(c, "BYTERANGE", "")].join("-");
        a.ba.has(b) || (c = Ur(d, c), a.ba.set(b, c));
        return a.ba.get(b);
      }
      function Ur(a, b) {
        var c = 0, d = null;
        if (b = Z(b, "BYTERANGE"))
          c = b.split("@"), d = Number(c[0]), c = Number(c[1]), d = c + d - 1;
        return new oi(function() {
          return [a];
        }, c, d);
      }
      function Vr(a, b, c, d, e, f, g, h, k2) {
        var l = d.g, m = Kr(d.i, f), n = Jq(l, "EXTINF"), p = f = 0, t = null;
        d.h.length && !a.l && Wa("Low-latency HLS live stream detected, but low-latency streaming mode is not enabled in Shaka Player. Set streaming.lowLatencyMode configuration to true, and see https://bit.ly/3clctcj for details.");
        var v = null;
        if (!a.g.hls.ignoreManifestProgramDateTime) {
          var y = Jq(l, "EXT-X-PROGRAM-DATE-TIME");
          y && y.value && (v = Vf(y.value));
        }
        y = ri;
        Jq(l, "EXT-X-GAP") && (y = 2);
        if (!n) {
          if (0 == d.h.length)
            throw new O(2, 4, 4024, "EXTINF");
          if (!a.l)
            return null;
        }
        var w = [];
        if (a.l)
          for (var x = {}, C = 0; C < d.h.length; x = { pd: x.pd }, C++) {
            var z = d.h[C], B = 0 == C ? c : w[w.length - 1], E = 0 == C ? e : B.endTime, F = Number(Z(z, "DURATION")) || a.da;
            if (F) {
              F = E + F;
              var H = 0, I = null;
              "EXT-X-PRELOAD-HINT" == z.name ? H = (H = Z(z, "BYTERANGE-START")) ? Number(H) : 0 : (H = Z(z, "BYTERANGE"), I = r(Wr(B, H)), H = I.next().value, I = I.next().value);
              if (B = Z(z, "URI"))
                x.pd = Lq(g, B), B = ri, "YES" == Z(z, "GAP") && (B = 2), w.push(new qi(E, F, function(J) {
                  return function() {
                    return [J.pd];
                  };
                }(x), H, I, b, 0, 0, Infinity, [], "", null, null, B));
            }
          }
        n ? f = e + Number(n.value.split(",")[0]) : f = w[w.length - 1].endTime;
        (a = Jq(l, "EXT-X-BYTERANGE")) ? (t = r(Wr(c, a.value)), p = t.next().value, t = t.next().value) : w.length && (p = w[0].Ba, t = w[w.length - 1].ka);
        c = "";
        a = null;
        "image" == h && (c = "1x1", h = Jq(l, "EXT-X-TILES")) && (c = Eq(h, "LAYOUT"), (h = Z(h, "DURATION")) && (a = Number(h)));
        return new qi(e, f, function() {
          return m.length ? [m] : [];
        }, p, t, b, 0, 0, Infinity, w, c, a, v, y, k2);
      }
      function Wr(a, b) {
        var c = 0, d = null;
        b && (c = b.split("@"), b = Number(c[0]), c = c[1] ? Number(c[1]) : a.ka + 1, d = c + b - 1);
        return [c, d];
      }
      function kr(a, b, c, d, e) {
        var f = b.segments, g = void 0, h = Kq(b.g, "EXT-X-DISCONTINUITY-SEQUENCE"), k2 = Kq(b.g, "EXT-X-MEDIA-SEQUENCE"), l = Jq(b.g, "EXT-X-SKIP");
        l = l ? Number(Z(l, "SKIPPED-SEGMENTS")) : 0;
        var m = k2 + l, n = 0;
        cr(a) && d.has(m) && (n = d.get(m));
        for (var p = [], t = null, v = 0; v < f.length; v++) {
          var y = f[v], w = 0 == v ? n : t.endTime;
          m = k2 + l + v;
          Jq(y.g, "EXT-X-DISCONTINUITY") && h++;
          var x = r(y.g);
          for (var C = x.next(); !C.done; C = x.next())
            C = C.value, "EXT-X-KEY" == C.name && ("AES-128" == Eq(C, "METHOD") ? g = Qr(a, C, b) : g = void 0);
          d.set(m, w);
          x = Tr(a, b.h, y.g, e);
          !a.l && a.i.isAutoLowLatencyMode() && (a.i.enableLowLatencyMode(), a.l = a.i.isLowLatencyMode());
          if (t = y = Vr(a, x, t, y, w, e, b.h, c, g))
            y.m = h, a.g.hls.ignoreManifestProgramDateTime && null != a.B && m < a.B || p.push(y);
        }
        if (b = p.some(function(z) {
          return null != z.g;
        })) {
          for (c = {}, d = 0; d < p.length; c = { Qb: c.Qb, Pb: c.Pb, Bc: c.Bc, Ta: c.Ta, Ob: c.Ob }, d++)
            if (c.Ta = p[d], null == c.Ta.g)
              for (c.Pb = 0, c.Qb = d, e = function(z) {
                return function() {
                  var B = p[z.Qb];
                  if (B) {
                    if (null != B.g)
                      return B.g + z.Pb;
                    z.Pb -= B.endTime - B.startTime;
                    z.Qb += 1;
                  }
                  return null;
                };
              }(c), c.Ob = 0, c.Bc = d, f = function(z) {
                return function() {
                  var B = p[z.Bc];
                  if (B) {
                    B != z.Ta && (z.Ob += B.endTime - B.startTime);
                    if (null != B.g)
                      return B.g + z.Ob;
                    --z.Bc;
                  }
                  return null;
                };
              }(c); null == c.Ta.g; )
                c.Ta.g = f(), null == c.Ta.g && (c.Ta.g = e());
        }
        if (b)
          for (c = r(p), d = c.next(); !d.done; d = c.next())
            for (e = d.value, d = e.g, e = r(e.i), f = e.next(); !f.done; f = e.next())
              f = f.value, f.g = d, d += f.endTime - f.startTime;
        a = a.H;
        if (b && Infinity != a)
          for (b = r(p), d = b.next(); !d.done; d = b.next())
            d.value.oe(a);
        return p;
      }
      function Kr(a, b) {
        a = String(a).replace(/%7B/g, "{").replace(/%7D/g, "}");
        var c = a.match(/{\$\w*}/g);
        if (c) {
          c = r(c);
          for (var d = c.next(); !d.done; d = c.next()) {
            d = d.value;
            var e = d.slice(2, d.length - 1), f = b.get(e);
            if (f)
              a = a.replace(d, f);
            else
              throw new O(2, 4, 4039, e);
          }
        }
        return a;
      }
      function Er(a, b) {
        if (a == jc) {
          if ("vtt" == b || "wvtt" == b)
            return "text/vtt";
          if (b && "" !== b)
            return "application/mp4";
        }
        return "image" != a || b && "jpeg" != b ? "audio" == a && "mp4a.40.34" == b ? "audio/mpeg" : null : "image/jpeg";
      }
      function Fr(a) {
        return a == jc ? "text/vtt" : Xr[a].mp4;
      }
      function Pr(a, b, c, d, e) {
        var f, g, h, k2, l, m, n, p, t, v;
        return G(function(y) {
          if (1 == y.g) {
            f = jf;
            g = Math.trunc((d.segments.length - 1) / 2);
            h = Kr(d.segments[g].i, e);
            k2 = new Nb(h);
            l = k2.qa.split(".").pop();
            m = Xr[b];
            if ((n = m[l]) || (n = or[l]) || (n = Er(b, c)))
              return y.return(n);
            p = cf([h], a.g.retryParameters);
            p.method = "HEAD";
            return u(y, Rr(a, p, f), 2);
          }
          t = y.h;
          return (v = t.headers["content-type"]) ? y.return(v.split(";")[0]) : y.return(Fr(b));
        });
      }
      function ar(a, b) {
        b = cf([b], a.g.retryParameters);
        a.i.modifyManifestRequest(b, { format: "h" });
        return Rr(a, b, 0);
      }
      function Zq(a) {
        var b, c;
        G(function(d) {
          if (1 == d.g) {
            if (!a.i)
              return d.return();
            D(d, 2);
            return u(d, a.update(), 4);
          }
          if (2 != d.g)
            return cr(a) && (b = a.O, a.m.N(b)), ta(d, 0);
          c = ua(d);
          if (!a.i)
            return d.return();
          c.severity = 1;
          a.i.onError(c);
          a.m.N(0.1);
          A(d);
        });
      }
      function cr(a) {
        return a.ea != $q;
      }
      function gr(a, b) {
        a.ea = b;
        a.j && a.j.yc(!cr(a));
        cr(a) || a.m.stop();
      }
      function Rr(a, b, c) {
        if (!a.G)
          throw new O(2, 7, 7001);
        b = a.i.networkingEngine.request(c, b);
        Ye(a.G, b);
        return b.promise;
      }
      K("shaka.hls.HlsParser", Yq);
      var or = { aac: "audio/aac", ac3: "audio/ac3", ec3: "audio/ec3", mp3: "audio/mpeg" }, pr = { mp4: "audio/mp4", mp4a: "audio/mp4", m4s: "audio/mp4", m4i: "audio/mp4", m4a: "audio/mp4", m4f: "audio/mp4", cmfa: "audio/mp4", ts: "video/mp2t", tsa: "video/mp2t" }, qr = { mp4: "video/mp4", mp4v: "video/mp4", m4s: "video/mp4", m4i: "video/mp4", m4v: "video/mp4", m4f: "video/mp4", cmfv: "video/mp4", ts: "video/mp2t", tsv: "video/mp2t" }, Xr = { audio: pr, video: qr, text: {
        mp4: "application/mp4",
        m4s: "application/mp4",
        m4i: "application/mp4",
        m4f: "application/mp4",
        cmft: "application/mp4",
        vtt: "text/vtt",
        webvtt: "text/vtt",
        ttml: "application/ttml+xml"
      }, image: { jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", webp: "image/webp", avif: "image/avif" } }, Hr = { "com.apple.streamingkeydelivery": function(a, b) {
        if ("video/mp2t" == b)
          throw new O(2, 4, 4040);
        if (window2.shakaMediaKeysPolyfill)
          throw new O(2, 4, 4041);
        return fc("com.apple.fps", [{ initDataType: "sinf", initData: new Uint8Array(0), keyId: null }]);
      }, "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": function(a) {
        var b = Eq(a, "METHOD");
        if (!["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(b))
          return null;
        b = Eq(a, "URI");
        b = Xq(b);
        b = M(b.data);
        b = fc("com.widevine.alpha", [{ initDataType: "cenc", initData: b }]);
        if (a = Z(a, "KEYID"))
          b.keyIds = /* @__PURE__ */ new Set([a.toLowerCase().substr(2)]);
        return b;
      }, "com.microsoft.playready": function(a) {
        var b = Eq(a, "METHOD");
        if (!["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(b))
          return null;
        a = Eq(a, "URI");
        a = Xq(a);
        a = M(a.data);
        b = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
        a = Kf(a, b, /* @__PURE__ */ new Set(), 0);
        return fc("com.microsoft.playready", [{ initDataType: "cenc", initData: a }]);
      }, identity: function(a) {
        a = Eq(a, "METHOD");
        return ["SAMPLE-AES", "SAMPLE-AES-CTR"].includes(a) ? fc("org.w3.clearkey", null) : null;
      } }, $q = "VOD", Sr = "EVENT", Br = "LIVE", fr = { ff: $q, Og: Sr, Sg: Br };
      tc("Tizen 3") || tc("Tizen 2") || vc() || (Vg.m3u8 = function() {
        return new Yq();
      }, Tg["application/x-mpegurl"] = function() {
        return new Yq();
      }, Tg["application/vnd.apple.mpegurl"] = function() {
        return new Yq();
      });
      function Yr(a, b, c, d, e, f) {
        if (200 <= c && 299 >= c && 202 != c)
          return { uri: e || d, Oe: d, data: b, status: c, headers: a, fromCache: !!a["x-shaka-from-cache"] };
        e = null;
        try {
          e = Fc(b);
        } catch (g) {
        }
        throw new O(401 == c || 403 == c ? 2 : 1, 1, 1001, d, c, e, a, f);
      }
      function Zr() {
      }
      function $r(a, b, c, d, e) {
        var f = new as();
        tf(b.headers).forEach(function(l, m) {
          f.append(m, l);
        });
        var g = new bs(), h = { ye: false, bf: false };
        a = cs(a, c, { body: b.body || void 0, headers: f, method: b.method, signal: g.signal, credentials: b.allowCrossSiteCredentials ? "include" : void 0 }, h, d, e, b.streamDataCallback);
        a = new Le(a, function() {
          h.ye = true;
          g.abort();
          return Promise.resolve();
        });
        if (b = b.retryParameters.timeout) {
          var k2 = new P(function() {
            h.bf = true;
            g.abort();
          });
          k2.N(b / 1e3);
          a.finally(function() {
            k2.stop();
          });
        }
        return a;
      }
      function cs(a, b, c, d, e, f, g) {
        var h, k2, l, m, n, p, t, v, y, w, x, C, z;
        return G(function(B) {
          switch (B.g) {
            case 1:
              return h = ds, k2 = es, p = n = 0, t = Date.now(), D(B, 2), u(B, h(a, c), 4);
            case 4:
              return l = B.h, f(fs(l.headers)), v = l.clone().body.getReader(), w = (y = l.headers.get("Content-Length")) ? parseInt(y, 10) : 0, x = function(E) {
                function F() {
                  var H, I;
                  return G(function(J) {
                    switch (J.g) {
                      case 1:
                        return D(J, 2), u(J, v.read(), 4);
                      case 4:
                        H = J.h;
                        ta(J, 3);
                        break;
                      case 2:
                        return ua(J), J.return();
                      case 3:
                        if (H.done) {
                          J.A(5);
                          break;
                        }
                        n += H.value.byteLength;
                        if (!g) {
                          J.A(5);
                          break;
                        }
                        return u(J, g(H.value), 5);
                      case 5:
                        I = Date.now();
                        if (100 < I - t || H.done)
                          e(I - t, n - p, w - n), p = n, t = I;
                        H.done ? E.close() : (E.enqueue(H.value), F());
                        A(J);
                    }
                  });
                }
                F();
              }, new k2({ start: x }), u(B, l.arrayBuffer(), 5);
            case 5:
              m = B.h;
              ta(B, 3);
              break;
            case 2:
              C = ua(B);
              if (d.ye)
                throw new O(1, 1, 7001, a, b);
              if (d.bf)
                throw new O(1, 1, 1003, a, b);
              throw new O(1, 1, 1002, a, C, b);
            case 3:
              return z = fs(l.headers), B.return(Yr(z, m, l.status, a, l.url, b));
          }
        });
      }
      function fs(a) {
        var b = {};
        a.forEach(function(c, d) {
          b[d.trim()] = c;
        });
        return b;
      }
      function gs() {
        if (window2.ReadableStream)
          try {
            new ReadableStream({});
          } catch (a) {
            return false;
          }
        else
          return false;
        return !(!window2.fetch || !window2.AbortController);
      }
      K("shaka.net.HttpFetchPlugin", Zr);
      Zr.isSupported = gs;
      Zr.parse = $r;
      var ds = window2.fetch, bs = window2.AbortController, es = window2.ReadableStream, as = window2.Headers;
      gs() && ($e("http", $r, 2, true), $e("https", $r, 2, true), $e("blob", $r, 2, true));
      function hs() {
      }
      function is(a, b, c, d, e) {
        var f = new js(), g = Date.now(), h = 0, k2 = new Promise(function(l, m) {
          f.open(b.method, a, true);
          f.responseType = "arraybuffer";
          f.timeout = b.retryParameters.timeout;
          f.withCredentials = b.allowCrossSiteCredentials;
          f.onabort = function() {
            m(new O(1, 1, 7001, a, c));
          };
          var n = false;
          f.onreadystatechange = function() {
            if (2 == f.readyState && !n) {
              var t = ks(f);
              e(t);
              n = true;
            }
          };
          f.onload = function() {
            var t = ks(f), v = f.response;
            try {
              var y = Yr(t, v, f.status, a, f.responseURL, c);
              l(y);
            } catch (w) {
              m(w);
            }
          };
          f.onerror = function(t) {
            m(new O(
              1,
              1,
              1002,
              a,
              t,
              c
            ));
          };
          f.ontimeout = function() {
            m(new O(1, 1, 1003, a, c));
          };
          f.onprogress = function(t) {
            var v = Date.now();
            if (100 < v - g || t.lengthComputable && t.loaded == t.total)
              d(v - g, t.loaded - h, t.total - t.loaded), h = t.loaded, g = v;
          };
          for (var p in b.headers)
            f.setRequestHeader(p.toLowerCase(), b.headers[p]);
          f.send(b.body);
        });
        return new Le(k2, function() {
          f.abort();
          return Promise.resolve();
        });
      }
      function ks(a) {
        var b = a.getAllResponseHeaders().trim().split("\r\n");
        a = {};
        b = r(b);
        for (var c = b.next(); !c.done; c = b.next())
          c = c.value.split(": "), a[c[0].toLowerCase()] = c.slice(1).join(": ");
        return a;
      }
      K("shaka.net.HttpXHRPlugin", hs);
      hs.parse = is;
      var js = window2.XMLHttpRequest;
      $e("http", is, 1, true);
      $e("https", is, 1, true);
      $e("blob", is, 1, true);
      function ls(a, b, c, d) {
        this.g = a;
        this.i = b;
        this.groupId = c;
        this.h = d;
      }
      function ms(a) {
        return a.ya().map(function(b) {
          return "{" + encodeURI(b) + "}";
        }).join("") + ":" + a.Ba + ":" + a.ka;
      }
      function ns(a, b) {
        return ck(a.g.ya(), a.g.Ba, a.g.ka, b.streaming.retryParameters);
      }
      function os() {
        this.h = this.j = this.i = 0;
        this.g = /* @__PURE__ */ new Map();
        this.l = 0;
      }
      function ps(a, b) {
        a.i += b;
        var c = a.l;
        a.l++;
        a.g.set(c, b);
        return c;
      }
      os.prototype.close = function(a, b) {
        if (this.g.has(a)) {
          var c = this.g.get(a);
          this.g.delete(a);
          this.j += c;
          this.h += b;
        }
      };
      function qs(a) {
        var b = this;
        this.o = a;
        this.j = /* @__PURE__ */ new Map();
        this.i = new kf(function() {
          return rs(b).catch(function() {
          });
        });
        this.h = [];
        this.m = function() {
        };
        this.l = function() {
        };
        this.g = new os();
      }
      qs.prototype.destroy = function() {
        return this.i.destroy();
      };
      function ss(a, b, c) {
        a.m = b;
        a.l = c;
      }
      function rs(a) {
        var b = a.h.map(function(c) {
          return c();
        });
        a.h = [];
        return Promise.all(b);
      }
      function ts(a, b, c, d, e, f) {
        lf(a.i);
        var g = (a.j.get(b) || Promise.resolve()).then(function() {
          var h, k2, l, m, n, p, t;
          return G(function(v) {
            if (1 == v.g)
              return u(v, us(a, c), 2);
            h = v.h;
            if (a.i.g)
              throw new O(2, 9, 7001);
            if (e)
              for (m in k2 = M(h), l = new Jf(k2), l.data)
                n = Number(m), p = l.data[n], t = l.g[n], a.l(p, t);
            a.g.close(d, h.byteLength);
            var y = a.g;
            a.m(0 == y.i ? 0 : y.j / y.i, a.g.h);
            return v.return(f(h));
          });
        });
        a.j.set(b, g);
      }
      function vs(a) {
        return G(function(b) {
          return 1 == b.g ? u(b, Promise.all(a.j.values()), 2) : b.return(a.g.h);
        });
      }
      function us(a, b) {
        var c, d, e, f;
        return G(function(g) {
          if (1 == g.g)
            return c = jf, d = a.o.request(c, b), e = function() {
              return d.abort();
            }, a.h.push(e), u(g, d.promise, 2);
          f = g.h;
          hb(a.h, e);
          return g.return(f.data);
        });
      }
      function ws(a, b) {
        var c = this;
        this.i = a;
        this.h = a.objectStore(b);
        this.g = new lc2();
        a.onabort = function(d) {
          d.preventDefault();
          c.g.reject();
        };
        a.onerror = function(d) {
          d.preventDefault();
          c.g.reject();
        };
        a.oncomplete = function() {
          c.g.resolve();
        };
      }
      ws.prototype.abort = function() {
        var a = this;
        return G(function(b) {
          if (1 == b.g) {
            try {
              a.i.abort();
            } catch (c) {
            }
            D(b, 2);
            return u(b, a.g, 4);
          }
          if (2 != b.g)
            return ta(b, 0);
          ua(b);
          A(b);
        });
      };
      function xs(a, b) {
        return new Promise(function(c, d) {
          var e = a.h.openCursor();
          e.onerror = d;
          e.onsuccess = function() {
            var f;
            return G(function(g) {
              if (1 == g.g) {
                if (null == e.result)
                  return c(), g.return();
                f = e.result;
                return u(g, b(f.key, f.value, f), 2);
              }
              f.continue();
              A(g);
            });
          };
        });
      }
      ws.prototype.store = function() {
        return this.h;
      };
      ws.prototype.promise = function() {
        return this.g;
      };
      function ys(a) {
        this.h = a;
        this.g = [];
      }
      ys.prototype.destroy = function() {
        return Promise.all(this.g.map(function(a) {
          return a.abort();
        }));
      };
      function zs(a, b) {
        return As(a, b, "readwrite");
      }
      function As(a, b, c) {
        c = a.h.transaction([b], c);
        var d = new ws(c, b);
        a.g.push(d);
        d.promise().then(function() {
          hb(a.g, d);
        }, function() {
          hb(a.g, d);
        });
        return d;
      }
      function Bs(a, b, c) {
        this.h = new ys(a);
        this.i = b;
        this.g = c;
      }
      q = Bs.prototype;
      q.destroy = function() {
        return this.h.destroy();
      };
      q.hasFixedKeySpace = function() {
        return true;
      };
      q.addSegments = function() {
        return Cs(this.i);
      };
      q.removeSegments = function(a, b) {
        return Ds(this, this.i, a, b);
      };
      q.getSegments = function(a) {
        var b = this, c;
        return G(function(d) {
          if (1 == d.g)
            return u(d, Es(b, b.i, a), 2);
          c = d.h;
          return d.return(c.map(function(e) {
            return b.ze(e);
          }));
        });
      };
      q.addManifests = function() {
        return Cs(this.g);
      };
      q.updateManifest = function() {
        return Promise.reject(new O(2, 9, 9016, "Cannot modify values in " + this.g));
      };
      function Fs(a, b, c) {
        a = zs(a.h, a.g);
        var d = a.store();
        d.get(b).onsuccess = function() {
          d.put(c, b);
        };
        return a.promise();
      }
      q.updateManifestExpiration = function(a, b) {
        var c = zs(this.h, this.g), d = c.store();
        d.get(a).onsuccess = function(e) {
          if (e = e.target.result)
            e.expiration = b, d.put(e, a);
        };
        return c.promise();
      };
      q.removeManifests = function(a, b) {
        return Ds(this, this.g, a, b);
      };
      q.getManifests = function(a) {
        var b = this, c;
        return G(function(d) {
          if (1 == d.g)
            return u(d, Es(b, b.g, a), 2);
          c = d.h;
          return d.return(Promise.all(c.map(function(e) {
            return b.bc(e);
          })));
        });
      };
      q.getAllManifests = function() {
        var a = this, b, c;
        return G(function(d) {
          return 1 == d.g ? (b = As(a.h, a.g, "readonly"), c = /* @__PURE__ */ new Map(), u(d, xs(b, function(e, f) {
            var g;
            return G(function(h) {
              if (1 == h.g)
                return u(h, a.bc(f), 2);
              g = h.h;
              c.set(e, g);
              A(h);
            });
          }), 2)) : 3 != d.g ? u(d, b.promise(), 3) : d.return(c);
        });
      };
      q.ze = function(a) {
        return a;
      };
      q.bc = function(a) {
        return Promise.resolve(a);
      };
      function Cs(a) {
        return Promise.reject(new O(2, 9, 9011, "Cannot add new value to " + a));
      }
      q.add = function(a, b) {
        var c = this, d, e, f, g, h, k2, l;
        return G(function(m) {
          if (1 == m.g) {
            d = zs(c.h, a);
            e = d.store();
            f = [];
            g = {};
            h = r(b);
            for (k2 = h.next(); !k2.done; g = { Fc: g.Fc }, k2 = h.next())
              l = k2.value, g.Fc = e.add(l), g.Fc.onsuccess = function(n) {
                return function() {
                  f.push(n.Fc.result);
                };
              }(g);
            return u(m, d.promise(), 2);
          }
          return m.return(f);
        });
      };
      function Ds(a, b, c, d) {
        a = zs(a.h, b);
        b = a.store();
        var e = {};
        c = r(c);
        for (var f = c.next(); !f.done; e = { Ec: e.Ec }, f = c.next())
          e.Ec = f.value, b.delete(e.Ec).onsuccess = function(g) {
            return function() {
              return d(g.Ec);
            };
          }(e);
        return a.promise();
      }
      function Es(a, b, c) {
        var d, e, f, g, h, k2, l;
        return G(function(m) {
          if (1 == m.g) {
            d = As(a.h, b, "readonly");
            e = d.store();
            f = {};
            g = [];
            h = {};
            k2 = r(c);
            for (l = k2.next(); !l.done; h = { Vb: h.Vb, Tb: h.Tb }, l = k2.next())
              h.Tb = l.value, h.Vb = e.get(h.Tb), h.Vb.onsuccess = function(n) {
                return function() {
                  void 0 == n.Vb.result && g.push(n.Tb);
                  f[n.Tb] = n.Vb.result;
                };
              }(h);
            return u(m, d.promise(), 2);
          }
          if (g.length)
            throw new O(2, 9, 9012, "Could not find values for " + g);
          return m.return(c.map(function(n) {
            return f[n];
          }));
        });
      }
      function Gs(a) {
        this.g = new ys(a);
      }
      Gs.prototype.destroy = function() {
        return this.g.destroy();
      };
      Gs.prototype.getAll = function() {
        var a = this, b, c;
        return G(function(d) {
          return 1 == d.g ? (b = As(a.g, "session-ids", "readonly"), c = [], u(d, xs(b, function(e, f) {
            c.push(f);
          }), 2)) : 3 != d.g ? u(d, b.promise(), 3) : d.return(c);
        });
      };
      Gs.prototype.add = function(a) {
        var b = zs(this.g, "session-ids"), c = b.store();
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next())
          c.add(d.value);
        return b.promise();
      };
      Gs.prototype.remove = function(a) {
        var b = this, c;
        return G(function(d) {
          return 1 == d.g ? (c = zs(b.g, "session-ids"), u(d, xs(c, function(e, f, g) {
            a.includes(f.sessionId) && g.delete();
          }), 2)) : u(d, c.promise(), 0);
        });
      };
      function Hs() {
        this.g = /* @__PURE__ */ new Map();
      }
      Hs.prototype.destroy = function() {
        for (var a = [], b = r(this.g.values()), c = b.next(); !c.done; c = b.next())
          a.push(c.value.destroy());
        this.g.clear();
        return Promise.all(a);
      };
      Hs.prototype.init = function() {
        var a = this;
        Is.forEach(function(e, f) {
          (e = e()) && a.g.set(f, e);
        });
        for (var b = [], c = r(this.g.values()), d = c.next(); !d.done; d = c.next())
          b.push(d.value.init());
        return Promise.all(b);
      };
      function Js(a) {
        var b = null;
        a.g.forEach(function(c, d) {
          c.getCells().forEach(function(e, f) {
            e.hasFixedKeySpace() || b || (b = { path: { za: d, ja: f }, ja: e });
          });
        });
        if (b)
          return b;
        throw new O(2, 9, 9013, "Could not find a cell that supports add-operations");
      }
      function Ks(a, b) {
        a.g.forEach(function(c, d) {
          c.getCells().forEach(function(e, f) {
            b({ za: d, ja: f }, e);
          });
        });
      }
      function Ls(a, b, c) {
        a = a.g.get(b);
        if (!a)
          throw new O(2, 9, 9013, "Could not find mechanism with name " + b);
        b = a.getCells().get(c);
        if (!b)
          throw new O(2, 9, 9013, "Could not find cell with name " + c);
        return b;
      }
      function Ms(a, b) {
        a.g.forEach(function(c) {
          b(c.getEmeSessionCell());
        });
      }
      function Ns(a) {
        var b = Array.from(a.g.keys());
        if (!b.length)
          throw new O(2, 9, 9e3, "No supported storage mechanisms found");
        return a.g.get(b[0]).getEmeSessionCell();
      }
      function Os(a) {
        var b, c, d;
        return G(function(e) {
          return 1 == e.g ? (b = Array.from(a.g.values()), c = 0 < b.length, c || (d = Is, d.forEach(function(f) {
            (f = f()) && b.push(f);
          })), u(e, Promise.all(b.map(function(f) {
            return f.erase();
          })), 2)) : c ? e.A(0) : u(e, Promise.all(b.map(function(f) {
            return f.destroy();
          })), 0);
        });
      }
      function Ps(a, b) {
        Is.set(a, b);
      }
      K("shaka.offline.StorageMuxer", Hs);
      Hs.unregister = function(a) {
        Is.delete(a);
      };
      Hs.register = Ps;
      Hs.prototype.destroy = Hs.prototype.destroy;
      var Is = /* @__PURE__ */ new Map();
      function Qs() {
        Bs.apply(this, arguments);
      }
      oa(Qs, Bs);
      Qs.prototype.updateManifestExpiration = function(a, b) {
        var c = this, d, e, f;
        return G(function(g) {
          d = zs(c.h, c.g);
          e = d.store();
          f = new lc2();
          e.get(a).onsuccess = function(h) {
            (h = h.target.result) ? (h.expiration = b, e.put(h), f.resolve()) : f.reject(new O(2, 9, 9012, "Could not find values for " + a));
          };
          return u(g, Promise.all([d.promise(), f]), 0);
        });
      };
      Qs.prototype.bc = function(a) {
        var b, c, d, e, f, g;
        return G(function(h) {
          if (1 == h.g) {
            b = [];
            for (c = 0; c < a.periods.length; ++c)
              d = c == a.periods.length - 1 ? a.duration : a.periods[c + 1].startTime, e = d - a.periods[c].startTime, f = Rs(a.periods[c], e), b.push(f);
            return u(h, Pp(b), 2);
          }
          g = h.h;
          return h.return({ creationTime: 0, originalManifestUri: a.originalManifestUri, duration: a.duration, size: a.size, expiration: null == a.expiration ? Infinity : a.expiration, streams: g, sessionIds: a.sessionIds, drmInfo: a.drmInfo, appMetadata: a.appMetadata, sequenceMode: false });
        });
      };
      function Rs(a, b) {
        Ss(a);
        for (var c = r(a.streams), d = c.next(); !d.done; d = c.next())
          ;
        return a.streams.map(function(e) {
          return Ts(e, a.startTime, b);
        });
      }
      function Ts(a, b, c) {
        var d = a.initSegmentUri ? Us(a.initSegmentUri) : null, e = b + a.presentationTimeOffset, f = b + c;
        return { id: a.id, originalId: null, primary: a.primary, type: a.contentType, mimeType: a.mimeType, codecs: a.codecs, frameRate: a.frameRate, pixelAspectRatio: void 0, hdr: void 0, kind: a.kind, language: a.language, label: a.label, width: a.width, height: a.height, initSegmentKey: d, encrypted: a.encrypted, keyIds: /* @__PURE__ */ new Set([a.keyId]), segments: a.segments.map(function(g) {
          var h = Us(g.uri);
          return {
            startTime: b + g.startTime,
            endTime: b + g.endTime,
            dataKey: h,
            initSegmentKey: d,
            appendWindowStart: b,
            appendWindowEnd: f,
            timestampOffset: e,
            tilesLayout: ""
          };
        }), variantIds: a.variantIds, roles: [], forced: false, audioSamplingRate: null, channelsCount: null, spatialAudio: false, closedCaptions: null, tilesLayout: void 0 };
      }
      Qs.prototype.ze = function(a) {
        return { data: a.data };
      };
      function Us(a) {
        var b;
        if ((b = /^offline:[0-9]+\/[0-9]+\/([0-9]+)$/.exec(a)) || (b = /^offline:segment\/([0-9]+)$/.exec(a)))
          return Number(b[1]);
        throw new O(2, 9, 9004, "Could not parse uri " + a);
      }
      function Ss(a) {
        var b = a.streams.filter(function(h) {
          return "audio" == h.contentType;
        });
        a = a.streams.filter(function(h) {
          return "video" == h.contentType;
        });
        if (!b.every(function(h) {
          return h.variantIds;
        }) || !a.every(function(h) {
          return h.variantIds;
        })) {
          for (var c = r(b), d = c.next(); !d.done; d = c.next())
            d.value.variantIds = [];
          c = r(a);
          for (d = c.next(); !d.done; d = c.next())
            d.value.variantIds = [];
          c = 0;
          if (a.length && !b.length) {
            var e = c++, f = r(a);
            for (d = f.next(); !d.done; d = f.next())
              d.value.variantIds.push(e);
          }
          if (!a.length && b.length)
            for (e = c++, f = r(b), d = f.next(); !d.done; d = f.next())
              d.value.variantIds.push(e);
          if (a.length && b.length)
            for (b = r(b), d = b.next(); !d.done; d = b.next())
              for (d = d.value, e = r(a), f = e.next(); !f.done; f = e.next()) {
                f = f.value;
                var g = c++;
                d.variantIds.push(g);
                f.variantIds.push(g);
              }
        }
      }
      function Vs() {
        Bs.apply(this, arguments);
      }
      oa(Vs, Bs);
      Vs.prototype.bc = function(a) {
        var b, c, d, e, f, g;
        return G(function(h) {
          if (1 == h.g) {
            b = [];
            for (c = 0; c < a.periods.length; ++c) {
              d = c == a.periods.length - 1 ? a.duration : a.periods[c + 1].startTime;
              e = d - a.periods[c].startTime;
              for (var k2 = a.periods[c], l = [], m = r(k2.streams), n = m.next(); !n.done; n = m.next())
                n = n.value, 0 != n.variantIds.length && l.push(Ws(n, k2.startTime, k2.startTime + e));
              f = l;
              b.push(f);
            }
            return u(h, Pp(b), 2);
          }
          g = h.h;
          return h.return({ appMetadata: a.appMetadata, creationTime: 0, drmInfo: a.drmInfo, duration: a.duration, expiration: null == a.expiration ? Infinity : a.expiration, originalManifestUri: a.originalManifestUri, sessionIds: a.sessionIds, size: a.size, streams: g, sequenceMode: false });
        });
      };
      function Ws(a, b, c) {
        return { id: a.id, originalId: a.originalId, primary: a.primary, type: a.contentType, mimeType: a.mimeType, codecs: a.codecs, frameRate: a.frameRate, pixelAspectRatio: a.pixelAspectRatio, hdr: void 0, kind: a.kind, language: a.language, label: a.label, width: a.width, height: a.height, encrypted: a.encrypted, keyIds: /* @__PURE__ */ new Set([a.keyId]), segments: a.segments.map(function(d) {
          return {
            startTime: b + d.startTime,
            endTime: b + d.endTime,
            initSegmentKey: a.initSegmentKey,
            appendWindowStart: b,
            appendWindowEnd: c,
            timestampOffset: b - a.presentationTimeOffset,
            dataKey: d.dataKey,
            tilesLayout: ""
          };
        }), variantIds: a.variantIds, roles: [], forced: false, audioSamplingRate: null, channelsCount: null, spatialAudio: false, closedCaptions: null, tilesLayout: void 0 };
      }
      function Xs() {
        Bs.apply(this, arguments);
      }
      oa(Xs, Bs);
      q = Xs.prototype;
      q.hasFixedKeySpace = function() {
        return false;
      };
      q.addSegments = function(a) {
        return this.add(this.i, a);
      };
      q.addManifests = function(a) {
        return this.add(this.g, a);
      };
      q.updateManifest = function(a, b) {
        return Fs(this, a, b);
      };
      q.bc = function(a) {
        null == a.expiration && (a.expiration = Infinity);
        return Promise.resolve(a);
      };
      function Ys() {
        this.m = this.j = this.i = this.h = this.g = this.l = null;
      }
      q = Ys.prototype;
      q.init = function() {
        var a = this, b = new lc2(), c = false, d = new P(function() {
          c = true;
          b.reject(new O(2, 9, 9017));
        });
        d.N(5);
        var e = window2.indexedDB.open("shaka_offline_db", 5);
        e.onsuccess = function() {
          if (!c) {
            var f = e.result;
            a.l = f;
            var g = f.objectStoreNames;
            g = g.contains("manifest") && g.contains("segment") ? new Qs(f, "segment", "manifest") : null;
            a.g = g;
            g = f.objectStoreNames;
            g = g.contains("manifest-v2") && g.contains("segment-v2") ? new Vs(f, "segment-v2", "manifest-v2") : null;
            a.h = g;
            g = f.objectStoreNames;
            g = g.contains("manifest-v3") && g.contains("segment-v3") ? new Vs(f, "segment-v3", "manifest-v3") : null;
            a.i = g;
            g = f.objectStoreNames;
            g = g.contains("manifest-v5") && g.contains("segment-v5") ? new Xs(f, "segment-v5", "manifest-v5") : null;
            a.j = g;
            f = f.objectStoreNames.contains("session-ids") ? new Gs(f) : null;
            a.m = f;
            d.stop();
            b.resolve();
          }
        };
        e.onupgradeneeded = function() {
          for (var f = e.result, g = r(["segment-v5", "manifest-v5", "session-ids"]), h = g.next(); !h.done; h = g.next())
            h = h.value, f.objectStoreNames.contains(h) || f.createObjectStore(h, { autoIncrement: true });
        };
        e.onerror = function(f) {
          c || (b.reject(new O(
            2,
            9,
            9001,
            e.error
          )), d.stop(), f.preventDefault());
        };
        return b;
      };
      q.destroy = function() {
        var a = this;
        return G(function(b) {
          switch (b.g) {
            case 1:
              if (!a.g) {
                b.A(2);
                break;
              }
              return u(b, a.g.destroy(), 2);
            case 2:
              if (!a.h) {
                b.A(4);
                break;
              }
              return u(b, a.h.destroy(), 4);
            case 4:
              if (!a.i) {
                b.A(6);
                break;
              }
              return u(b, a.i.destroy(), 6);
            case 6:
              if (!a.j) {
                b.A(8);
                break;
              }
              return u(b, a.j.destroy(), 8);
            case 8:
              if (!a.m) {
                b.A(10);
                break;
              }
              return u(b, a.m.destroy(), 10);
            case 10:
              a.l && a.l.close(), A(b);
          }
        });
      };
      q.getCells = function() {
        var a = /* @__PURE__ */ new Map();
        this.g && a.set("v1", this.g);
        this.h && a.set("v2", this.h);
        this.i && a.set("v3", this.i);
        this.j && a.set("v5", this.j);
        return a;
      };
      q.getEmeSessionCell = function() {
        return this.m;
      };
      q.erase = function() {
        var a = this;
        return G(function(b) {
          switch (b.g) {
            case 1:
              if (!a.g) {
                b.A(2);
                break;
              }
              return u(b, a.g.destroy(), 2);
            case 2:
              if (!a.h) {
                b.A(4);
                break;
              }
              return u(b, a.h.destroy(), 4);
            case 4:
              if (!a.i) {
                b.A(6);
                break;
              }
              return u(b, a.i.destroy(), 6);
            case 6:
              if (!a.j) {
                b.A(8);
                break;
              }
              return u(b, a.j.destroy(), 8);
            case 8:
              return a.l && a.l.close(), u(b, Zs(), 10);
            case 10:
              return a.l = null, a.g = null, a.h = null, a.i = null, a.j = null, u(b, a.init(), 0);
          }
        });
      };
      function Zs() {
        var a = new lc2(), b = window2.indexedDB.deleteDatabase("shaka_offline_db");
        b.onblocked = function() {
        };
        b.onsuccess = function() {
          a.resolve();
        };
        b.onerror = function(c) {
          a.reject(new O(2, 9, 9001, b.error));
          c.preventDefault();
        };
        return a;
      }
      Ps("idb", function() {
        return tc("CrKey") || sc() || !window2.indexedDB ? null : new Ys();
      });
      function $s(a, b, c, d) {
        this.g = a;
        this.i = b;
        this.h = c;
        this.l = d;
        this.j = ["offline:", a, "/", b, "/", c, "/", d].join("");
      }
      $s.prototype.za = function() {
        return this.i;
      };
      $s.prototype.ja = function() {
        return this.h;
      };
      $s.prototype.key = function() {
        return this.l;
      };
      $s.prototype.toString = function() {
        return this.j;
      };
      function at(a) {
        a = /^offline:([a-z]+)\/([^/]+)\/([^/]+)\/([0-9]+)$/.exec(a);
        if (null == a)
          return null;
        var b = a[1];
        if ("manifest" != b && "segment" != b)
          return null;
        var c = a[2];
        if (!c)
          return null;
        var d = a[3];
        return d && null != b ? new $s(b, c, d, Number(a[4])) : null;
      }
      function bt(a, b) {
        this.h = a;
        this.g = b;
      }
      function ct(a, b) {
        var c = new T(null, 0);
        c.Aa(b.duration);
        var d = b.streams.filter(function(l) {
          return "audio" == l.type;
        }), e = b.streams.filter(function(l) {
          return "video" == l.type;
        });
        d = dt(a, d, e, c);
        e = b.streams.filter(function(l) {
          return l.type == jc;
        }).map(function(l) {
          return et(a, l, c);
        });
        var f = b.streams.filter(function(l) {
          return "image" == l.type;
        }).map(function(l) {
          return et(a, l, c);
        }), g = b.drmInfo ? [b.drmInfo] : [];
        if (b.drmInfo)
          for (var h = r(d.values()), k2 = h.next(); !k2.done; k2 = h.next())
            k2 = k2.value, k2.audio && k2.audio.encrypted && (k2.audio.drmInfos = g), k2.video && k2.video.encrypted && (k2.video.drmInfos = g);
        return { presentationTimeline: c, minBufferTime: 2, offlineSessionIds: b.sessionIds, variants: Array.from(d.values()), textStreams: e, imageStreams: f, sequenceMode: b.sequenceMode || false };
      }
      function dt(a, b, c, d) {
        for (var e = /* @__PURE__ */ new Set(), f = r(b), g = f.next(); !g.done; g = f.next()) {
          var h = r(g.value.variantIds);
          for (g = h.next(); !g.done; g = h.next())
            e.add(g.value);
        }
        f = r(c);
        for (g = f.next(); !g.done; g = f.next())
          for (h = r(g.value.variantIds), g = h.next(); !g.done; g = h.next())
            e.add(g.value);
        f = /* @__PURE__ */ new Map();
        e = r(e);
        for (g = e.next(); !g.done; g = e.next())
          g = g.value, f.set(g, { id: g, language: "", disabledUntilTime: 0, primary: false, audio: null, video: null, bandwidth: 0, allowedByApplication: true, allowedByKeySystem: true, decodingInfos: [] });
        b = r(b);
        for (e = b.next(); !e.done; e = b.next())
          for (e = e.value, g = et(a, e, d), h = r(e.variantIds), e = h.next(); !e.done; e = h.next())
            e = f.get(e.value), e.language = g.language, e.primary = e.primary || g.primary, e.audio = g;
        c = r(c);
        for (b = c.next(); !b.done; b = c.next())
          for (e = b.value, b = et(a, e, d), g = r(e.variantIds), e = g.next(); !e.done; e = g.next())
            e = f.get(e.value), e.primary = e.primary || b.primary, e.video = b;
        return f;
      }
      function et(a, b, c) {
        var d = b.segments.map(function(e) {
          return ft(a, e);
        });
        c.Ib(d);
        return {
          id: b.id,
          originalId: b.originalId,
          createSegmentIndex: function() {
            return Promise.resolve();
          },
          segmentIndex: new Jj(d),
          mimeType: b.mimeType,
          codecs: b.codecs,
          width: b.width || void 0,
          height: b.height || void 0,
          frameRate: b.frameRate,
          pixelAspectRatio: b.pixelAspectRatio,
          hdr: b.hdr,
          kind: b.kind,
          encrypted: b.encrypted,
          drmInfos: [],
          keyIds: b.keyIds,
          language: b.language,
          label: b.label,
          type: b.type,
          primary: b.primary,
          trickModeVideo: null,
          emsgSchemeIdUris: null,
          roles: b.roles,
          forced: b.forced,
          channelsCount: b.channelsCount,
          audioSamplingRate: b.audioSamplingRate,
          spatialAudio: b.spatialAudio,
          closedCaptions: b.closedCaptions,
          tilesLayout: b.tilesLayout
        };
      }
      function ft(a, b) {
        var c = new $s("segment", a.h, a.g, b.dataKey);
        return new qi(b.startTime, b.endTime, function() {
          return [c.toString()];
        }, 0, null, null != b.initSegmentKey ? gt(a, b.initSegmentKey) : null, b.timestampOffset, b.appendWindowStart, b.appendWindowEnd, [], b.tilesLayout || "");
      }
      function gt(a, b) {
        var c = new $s("segment", a.h, a.g, b);
        return new oi(function() {
          return [c.toString()];
        }, 0, null);
      }
      function ht() {
        this.g = null;
      }
      q = ht.prototype;
      q.configure = function() {
      };
      q.start = function(a, b) {
        var c = this, d, e, f, g, h, k2, l;
        return G(function(m) {
          switch (m.g) {
            case 1:
              d = at(a);
              c.g = d;
              if (null == d || "manifest" != d.g)
                throw new O(2, 1, 9004, a);
              e = new Hs();
              sa(m);
              return u(m, e.init(), 4);
            case 4:
              return u(m, Ls(e, d.za(), d.ja()), 5);
            case 5:
              return f = m.h, u(m, f.getManifests([d.key()]), 6);
            case 6:
              return g = m.h, h = g[0], k2 = new bt(d.za(), d.ja()), l = ct(k2, h), b.makeTextStreamsForClosedCaptions(l), m.return(l);
            case 2:
              return xa(m), u(m, e.destroy(), 7);
            case 7:
              ya(m, 0);
          }
        });
      };
      q.stop = function() {
        return Promise.resolve();
      };
      q.update = function() {
      };
      q.onExpirationUpdated = function(a, b) {
        var c = this, d, e, f, g, h, k2, l;
        return G(function(m) {
          switch (m.g) {
            case 1:
              return d = c.g, e = new Hs(), D(m, 2, 3), u(m, e.init(), 5);
            case 5:
              return u(m, Ls(e, d.za(), d.ja()), 6);
            case 6:
              return f = m.h, u(m, f.getManifests([d.key()]), 7);
            case 7:
              g = m.h;
              h = g[0];
              k2 = h.sessionIds.includes(a);
              l = void 0 == h.expiration || h.expiration > b;
              if (!k2 || !l) {
                m.A(3);
                break;
              }
              return u(m, f.updateManifestExpiration(d.key(), b), 3);
            case 3:
              return xa(m), u(m, e.destroy(), 10);
            case 10:
              ya(m, 0);
              break;
            case 2:
              ua(m), m.A(3);
          }
        });
      };
      Tg["application/x-offline-manifest"] = function() {
        return new ht();
      };
      function it() {
      }
      function jt(a) {
        var b = at(a);
        b && "manifest" == b.g ? (a = { uri: a, Oe: a, data: new ArrayBuffer(0), headers: { "content-type": "application/x-offline-manifest" } }, a = Oe(a)) : a = b && "segment" == b.g ? kt(b.key(), b) : Me(new O(2, 1, 9004, a));
        return a;
      }
      function kt(a, b) {
        var c = new Hs();
        return Oe(void 0).Y(function() {
          return c.init();
        }).Y(function() {
          return Ls(c, b.za(), b.ja());
        }).Y(function(d) {
          return d.getSegments([b.key()]);
        }).Y(function(d) {
          return { uri: b, data: d[0].data, headers: {} };
        }).finally(function() {
          return c.destroy();
        });
      }
      K("shaka.offline.OfflineScheme", it);
      it.plugin = jt;
      $e("offline", jt);
      function lt(a, b, c) {
        var d, e, f, g, h, k2;
        return G(function(l) {
          switch (l.g) {
            case 1:
              d = [];
              for (var m = [], n = r(c), p = n.next(); !p.done; p = n.next()) {
                p = p.value;
                for (var t = false, v = r(m), y = v.next(); !y.done; y = v.next())
                  if (y = y.value, mt(y.info, p)) {
                    y.sessionIds.push(p.sessionId);
                    t = true;
                    break;
                  }
                t || m.push({ info: p, sessionIds: [p.sessionId] });
              }
              e = r(m);
              f = e.next();
            case 2:
              if (f.done) {
                l.A(4);
                break;
              }
              g = f.value;
              h = nt(a, b, g);
              return u(l, h, 5);
            case 5:
              k2 = l.h;
              d = d.concat(k2);
              f = e.next();
              l.A(2);
              break;
            case 4:
              return l.return(d);
          }
        });
      }
      function nt(a, b, c) {
        var d, e;
        return G(function(f) {
          switch (f.g) {
            case 1:
              return d = new fg({ kb: b, onError: function() {
              }, cd: function() {
              }, onExpirationUpdated: function() {
              }, onEvent: function() {
              } }), D(f, 2), d.configure(a), u(f, ng(d, c.info.keySystem, c.info.licenseUri, c.info.serverCertificate, c.info.audioCapabilities, c.info.videoCapabilities), 4);
            case 4:
              ta(f, 3);
              break;
            case 2:
              return ua(f), u(f, d.destroy(), 5);
            case 5:
              return f.return([]);
            case 3:
              return D(f, 6), u(f, yg(d), 8);
            case 8:
              ta(f, 7);
              break;
            case 6:
              return ua(f), u(
                f,
                d.destroy(),
                9
              );
            case 9:
              return f.return([]);
            case 7:
              return e = [], u(f, Promise.all(c.sessionIds.map(function(g) {
                return G(function(h) {
                  if (1 == h.g)
                    return D(h, 2), u(h, zg(d, g), 4);
                  if (2 != h.g)
                    return e.push(g), ta(h, 0);
                  ua(h);
                  A(h);
                });
              })), 10);
            case 10:
              return u(f, d.destroy(), 11);
            case 11:
              return f.return(e);
          }
        });
      }
      function mt(a, b) {
        function c(d, e) {
          return d.robustness == e.robustness && d.contentType == e.contentType;
        }
        return a.keySystem == b.keySystem && a.licenseUri == b.licenseUri && ib(a.audioCapabilities, b.audioCapabilities, c) && ib(a.videoCapabilities, b.videoCapabilities, c);
      }
      function ot(a, b, c) {
        var d = b.presentationTimeline.getDuration();
        b = pt(b);
        return { offlineUri: null, originalManifestUri: a, duration: d, size: 0, expiration: Infinity, tracks: b, appMetadata: c, isIncomplete: false };
      }
      function qt(a, b) {
        var c = ct(new bt(a.za(), a.ja()), b), d = b.appMetadata || {};
        c = pt(c);
        return { offlineUri: a.toString(), originalManifestUri: b.originalManifestUri, duration: b.duration, size: b.size, expiration: b.expiration, tracks: c, appMetadata: d, isIncomplete: b.isIncomplete || false };
      }
      function pt(a) {
        var b = [], c = ie(a.variants);
        c = r(c);
        for (var d = c.next(); !d.done; d = c.next())
          b.push($d(d.value));
        a = r(a.textStreams);
        for (c = a.next(); !c.done; c = a.next())
          b.push(ae(c.value));
        return b;
      }
      function rt() {
        this.g = {};
      }
      function st(a, b) {
        var c = b.audio, d = b.video;
        c && !d && (a.g[c.id] = c.bandwidth || b.bandwidth);
        !c && d && (a.g[d.id] = d.bandwidth || b.bandwidth);
        if (c && d) {
          var e = c.bandwidth || 393216, f = d.bandwidth || b.bandwidth - e;
          0 >= f && (f = b.bandwidth);
          a.g[c.id] = e;
          a.g[d.id] = f;
        }
      }
      function tt(a, b) {
        a.g[b.id] = b.bandwidth || 2048;
      }
      function ut(a, b) {
        a = a.g[b];
        null == a && (a = 0);
        return a;
      }
      function vt(a) {
        var b = this;
        if (a && a.constructor != V)
          throw new O(2, 9, 9008);
        this.g = this.h = null;
        a ? (this.h = a.h, this.g = a.jc()) : (this.h = El(), this.g = new Ze());
        this.i = [];
        this.j = [];
        var c = !a;
        this.l = new kf(function() {
          var d, e, f, g, h;
          return G(function(k2) {
            switch (k2.g) {
              case 1:
                return u(k2, Promise.all(b.j.map(function(l) {
                  return rs(l);
                })), 2);
              case 2:
                d = function() {
                };
                e = [];
                f = r(b.i);
                for (g = f.next(); !g.done; g = f.next())
                  h = g.value, e.push(h.then(d, d));
                return u(k2, Promise.all(e), 3);
              case 3:
                if (!c) {
                  k2.A(4);
                  break;
                }
                return u(k2, b.g.destroy(), 4);
              case 4:
                b.h = null, b.g = null, A(k2);
            }
          });
        });
      }
      function wt() {
        if (oc())
          a: {
            var a = r(Is.values());
            for (var b = a.next(); !b.done; b = a.next())
              if (b = b.value, b = b()) {
                b.destroy();
                a = true;
                break a;
              }
            a = false;
          }
        else
          a = false;
        return a;
      }
      q = vt.prototype;
      q.destroy = function() {
        return this.l.destroy();
      };
      q.configure = function(a, b) {
        2 == arguments.length && "string" == typeof a && (a = yl(a, b));
        return Gl(this.h, a);
      };
      q.getConfiguration = function() {
        var a = El();
        Gl(a, this.h, El());
        return a;
      };
      q.jc = function() {
        return this.g;
      };
      q.store = function(a, b, c) {
        var d = this, e = this.getConfiguration(), f = new qs(this.g);
        this.j.push(f);
        b = xt(this, a, b || {}, function() {
          var g;
          return G(function(h) {
            if (1 == h.g)
              return u(h, Sg(a, d.g, e.manifest.retryParameters, c || null), 2);
            g = h.h;
            return h.return(g());
          });
        }, e, f);
        b = new Le(b, function() {
          return rs(f);
        });
        b.finally(function() {
          hb(d.j, f);
        });
        return yt(this, b);
      };
      function xt(a, b, c, d, e, f) {
        var g, h, k2, l, m, n, p, t, v, y, w, x, C, z;
        return G(function(B) {
          switch (B.g) {
            case 1:
              return zt(), h = g = null, k2 = new Hs(), n = m = l = null, D(B, 2, 3), u(B, d(), 5);
            case 5:
              return g = B.h, u(B, At(a, b, g, e), 6);
            case 6:
              p = B.h;
              Bt(a);
              t = !p.presentationTimeline.U() && !p.presentationTimeline.jb();
              if (!t)
                throw new O(2, 9, 9005, b);
              return u(B, Ct(a, p, function(E) {
                n = n || E;
              }, e), 7);
            case 7:
              h = B.h;
              Bt(a);
              if (n)
                throw n;
              return u(B, Dt(p, e), 8);
            case 8:
              return u(B, k2.init(), 9);
            case 9:
              return Bt(a), u(B, Js(k2), 10);
            case 10:
              return l = B.h, Bt(a), v = Et(
                h,
                p,
                b,
                c,
                e,
                f
              ), y = v.ag, w = v.pe, u(B, l.ja.addManifests([y]), 11);
            case 11:
              x = B.h;
              Bt(a);
              m = x[0];
              Bt(a);
              if (n)
                throw n;
              return u(B, Ft(a, w, m, y, f, e, l.ja, p, h), 12);
            case 12:
              return Bt(a), C = new $s("manifest", l.path.za, l.path.ja, m), B.return(qt(C, y));
            case 3:
              return xa(B), u(B, k2.destroy(), 13);
            case 13:
              if (!g) {
                B.A(14);
                break;
              }
              return u(B, g.stop(), 14);
            case 14:
              if (!h) {
                B.A(16);
                break;
              }
              return u(B, h.destroy(), 16);
            case 16:
              ya(B, 0);
              break;
            case 2:
              z = ua(B);
              if (null == m) {
                B.A(18);
                break;
              }
              return u(B, Gt(m), 18);
            case 18:
              throw n || z;
          }
        });
      }
      function Ft(a, b, c, d, e, f, g, h, k2) {
        var l, m, n, p, t, v, y, w, x, C;
        return G(function(z) {
          switch (z.g) {
            case 1:
              l = {};
              m = 0;
              n = function(B, E) {
                var F, H, I, J, L, R, Q;
                return G(function(U) {
                  if (1 == U.g) {
                    F = {};
                    H = r(B);
                    for (I = H.next(); !I.done; F = { cb: F.cb }, I = H.next())
                      F.cb = I.value, J = ns(F.cb, f), L = F.cb.i, R = F.cb.h, Q = function(N) {
                        return function(wa) {
                          var va, Ma, Sa;
                          return G(function(Ga) {
                            if (1 == Ga.g)
                              return u(Ga, g.addSegments([{ data: wa }]), 2);
                            va = Ga.h;
                            Bt(a);
                            Ma = N.cb.g;
                            Sa = ms(Ma);
                            l[Sa] = va[0];
                            m += wa.byteLength;
                            A(Ga);
                          });
                        };
                      }(F), ts(e, F.cb.groupId, J, L, R, Q);
                    return u(
                      U,
                      vs(e),
                      2
                    );
                  }
                  if (!E)
                    return U.A(0);
                  Bt(a);
                  Ht(h, d, k2, f);
                  return u(U, g.updateManifest(c, d), 0);
                });
              };
              p = false;
              D(z, 2);
              if (!It(h) || !p || Jt(h)) {
                z.A(4);
                break;
              }
              return u(z, n(b.filter(function(B) {
                return B.h;
              }), true), 5);
            case 5:
              return Bt(a), b = b.filter(function(B) {
                return !B.h;
              }), t = l, v = m, l = {}, m = 0, u(z, Kt(g, c, d, t, v, function() {
                return Bt(a);
              }), 6);
            case 6:
              Bt(a);
            case 4:
              if (p) {
                z.A(7);
                break;
              }
              return u(z, n(b, false), 8);
            case 8:
              return Bt(a), y = l, w = m, l = {}, m = 0, u(z, Kt(g, c, d, y, w, function() {
                return Bt(a);
              }), 9);
            case 9:
              Bt(a);
            case 7:
              ta(z, 0);
              break;
            case 2:
              return x = ua(z), C = Object.values(l), u(z, g.removeSegments(C, function() {
              }), 10);
            case 10:
              throw x;
          }
        });
      }
      function Gt(a) {
        var b, c, d, e;
        return G(function(f) {
          switch (f.g) {
            case 1:
              return b = new Hs(), u(f, b.init(), 2);
            case 2:
              return u(f, Js(b), 3);
            case 3:
              return c = f.h, d = new $s("manifest", c.path.za, c.path.ja, a), u(f, b.destroy(), 4);
            case 4:
              return e = new vt(), u(f, e.remove(d.toString()), 0);
          }
        });
      }
      function Kt(a, b, c, d, e, f) {
        var g, h, k2, l, m, n, p, t, v, y, w;
        return G(function(x) {
          switch (x.g) {
            case 1:
              g = false;
              D(x, 2);
              h = true;
              k2 = r(c.streams);
              for (l = k2.next(); !l.done; l = k2.next())
                for (m = l.value, n = r(m.segments), p = n.next(); !p.done; p = n.next())
                  t = p.value, v = t.pendingSegmentRefId ? d[t.pendingSegmentRefId] : null, null != v && (t.dataKey = v, t.pendingSegmentRefId = void 0), v = t.pendingInitSegmentRefId ? d[t.pendingInitSegmentRefId] : null, null != v && (t.initSegmentKey = v, t.pendingInitSegmentRefId = void 0), t.pendingSegmentRefId && (h = false), t.pendingInitSegmentRefId && (h = false);
              c.size += e;
              h && (c.isIncomplete = false);
              return u(x, a.updateManifest(b, c), 4);
            case 4:
              g = true;
              f();
              ta(x, 0);
              break;
            case 2:
              return y = ua(x), u(x, Gt(b), 5);
            case 5:
              if (g) {
                x.A(6);
                break;
              }
              w = Object.values(d);
              return u(x, a.removeSegments(w, function() {
              }), 6);
            case 6:
              throw y;
          }
        });
      }
      function Dt(a, b) {
        var c, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x, C, z, B, E, F, H, I, J, L, R, Q, U, N;
        return G(function(wa) {
          switch (wa.g) {
            case 1:
              return c = { width: Infinity, height: Infinity }, Jd(a, b.restrictions, c), u(wa, Nd(a, b.offline.usePersistentLicense), 2);
            case 2:
              d = [];
              e = b.preferredAudioChannelCount;
              f = b.preferredDecodingAttributes;
              g = b.preferredVideoCodecs;
              h = b.preferredAudioCodecs;
              xd(a, g, h, e, f);
              k2 = r(a.variants);
              for (l = k2.next(); !l.done; l = k2.next())
                m = l.value, d.push($d(m));
              n = r(a.textStreams);
              for (p = n.next(); !p.done; p = n.next())
                t = p.value, d.push(ae(t));
              v = r(a.imageStreams);
              for (y = v.next(); !y.done; y = v.next())
                w = y.value, d.push(be(w));
              return u(wa, b.offline.trackSelectionCallback(d), 3);
            case 3:
              x = wa.h;
              C = a.presentationTimeline.getDuration();
              z = 0;
              B = r(x);
              for (E = B.next(); !E.done; E = B.next())
                F = E.value, H = F.bandwidth * C / 8, z += H;
              D(wa, 4);
              return u(wa, b.offline.downloadSizeCallback(z), 6);
            case 6:
              I = wa.h;
              if (!I)
                throw new O(2, 9, 9014);
              ta(wa, 5);
              break;
            case 4:
              J = ua(wa);
              if (J instanceof O)
                throw J;
              throw new O(2, 9, 9015);
            case 5:
              L = /* @__PURE__ */ new Set();
              R = /* @__PURE__ */ new Set();
              Q = /* @__PURE__ */ new Set();
              U = r(x);
              for (E = U.next(); !E.done; E = U.next())
                N = E.value, "variant" == N.type && L.add(N.id), "text" == N.type && R.add(N.id), "image" == N.type && Q.add(N.id);
              a.variants = a.variants.filter(function(va) {
                return L.has(va.id);
              });
              a.textStreams = a.textStreams.filter(function(va) {
                return R.has(va.id);
              });
              a.imageStreams = a.imageStreams.filter(function(va) {
                return Q.has(va.id);
              });
              Lt(a);
              A(wa);
          }
        });
      }
      function Et(a, b, c, d, e, f) {
        var g = ot(c, b, d), h = e.offline.progressCallback;
        ss(f, function(t, v) {
          g.size = v;
          h(g, t);
        }, function(t, v) {
          k2 && e.offline.usePersistentLicense && l == v && vg(a, "cenc", t);
        });
        var k2 = It(b) && !Jt(b), l = null;
        k2 && (l = Mt.get(a.g.keySystem));
        for (var m = new rt(), n = r(b.textStreams), p = n.next(); !p.done; p = n.next())
          m.g[p.value.id] = 52;
        n = r(b.imageStreams);
        for (p = n.next(); !p.done; p = n.next())
          tt(m, p.value);
        p = r(b.variants);
        for (n = p.next(); !n.done; n = p.next())
          st(m, n.value);
        m = Nt(f, m, b, e);
        f = m.streams;
        m = m.pe;
        p = a.g;
        n = e.offline.usePersistentLicense;
        p && n && (p.initData = []);
        return { ag: { creationTime: Date.now(), originalManifestUri: c, duration: b.presentationTimeline.getDuration(), size: 0, expiration: a.ic(), streams: f, sessionIds: n ? Eg(a) : [], drmInfo: p, appMetadata: d, isIncomplete: true, sequenceMode: b.sequenceMode }, pe: m };
      }
      function It(a) {
        return a.variants.some(function(b) {
          var c = b.audio && b.audio.encrypted;
          return b.video && b.video.encrypted || c;
        });
      }
      function Jt(a) {
        return a.variants.some(function(b) {
          return (b.video ? b.video.drmInfos : []).concat(b.audio ? b.audio.drmInfos : []).some(function(c) {
            return c.initData && c.initData.length;
          });
        });
      }
      function Ht(a, b, c, d) {
        b.expiration = c.ic();
        c = Eg(c);
        b.sessionIds = d.offline.usePersistentLicense ? c : [];
        if (It(a) && d.offline.usePersistentLicense && !c.length)
          throw new O(2, 9, 9007);
      }
      q.remove = function(a) {
        return Ot(this, Pt(this, a));
      };
      function Pt(a, b) {
        var c, d, e, f, g, h;
        return G(function(k2) {
          switch (k2.g) {
            case 1:
              zt();
              c = at(b);
              if (null == c || "manifest" != c.g)
                throw new O(2, 9, 9004, b);
              d = c;
              e = new Hs();
              sa(k2);
              return u(k2, e.init(), 4);
            case 4:
              return u(k2, Ls(e, d.za(), d.ja()), 5);
            case 5:
              return f = k2.h, u(k2, f.getManifests([d.key()]), 6);
            case 6:
              return g = k2.h, h = g[0], u(k2, Promise.all([Qt(a, h, e), Rt(f, d, h)]), 2);
            case 2:
              return xa(k2), u(k2, e.destroy(), 8);
            case 8:
              ya(k2, 0);
          }
        });
      }
      function St(a, b) {
        for (var c = [], d = r(a.streams), e = d.next(); !e.done; e = d.next())
          e = e.value, b && "video" == e.type ? c.push({ contentType: Zc(e.mimeType, e.codecs), robustness: a.drmInfo.videoRobustness }) : b || "audio" != e.type || c.push({ contentType: Zc(e.mimeType, e.codecs), robustness: a.drmInfo.audioRobustness });
        return c;
      }
      function Qt(a, b, c) {
        return G(function(d) {
          return u(d, Tt(a.g, a.h.drm, c, b), 0);
        });
      }
      function Rt(a, b, c) {
        function d() {
        }
        var e = Ut(c);
        qt(b, c);
        return Promise.all([a.removeSegments(e, d), a.removeManifests([b.key()], d)]);
      }
      q.pg = function() {
        return Ot(this, Vt(this));
      };
      function Vt(a) {
        var b, c, d, e, f, g, h, k2, l, m;
        return G(function(n) {
          switch (n.g) {
            case 1:
              return zt(), b = a.g, c = a.h.drm, d = new Hs(), e = false, sa(n), u(n, d.init(), 4);
            case 4:
              f = [], Ms(d, function(p) {
                return f.push(p);
              }), g = r(f), h = g.next();
            case 5:
              if (h.done) {
                n.A(2);
                break;
              }
              k2 = h.value;
              return u(n, k2.getAll(), 8);
            case 8:
              return l = n.h, u(n, lt(c, b, l), 9);
            case 9:
              return m = n.h, u(n, k2.remove(m), 10);
            case 10:
              m.length != l.length && (e = true);
              h = g.next();
              n.A(5);
              break;
            case 2:
              return xa(n), u(n, d.destroy(), 11);
            case 11:
              ya(n, 3);
              break;
            case 3:
              return n.return(!e);
          }
        });
      }
      q.list = function() {
        return Ot(this, Wt());
      };
      function Wt() {
        var a, b, c;
        return G(function(d) {
          switch (d.g) {
            case 1:
              return zt(), a = [], b = new Hs(), sa(d), u(d, b.init(), 4);
            case 4:
              return c = Promise.resolve(), Ks(b, function(e, f) {
                c = c.then(function() {
                  var g;
                  return G(function(h) {
                    if (1 == h.g)
                      return u(h, f.getAllManifests(), 2);
                    g = h.h;
                    g.forEach(function(k2, l) {
                      k2 = qt(new $s("manifest", e.za, e.ja, l), k2);
                      a.push(k2);
                    });
                    A(h);
                  });
                });
              }), u(d, c, 2);
            case 2:
              return xa(d), u(d, b.destroy(), 6);
            case 6:
              ya(d, 3);
              break;
            case 3:
              return d.return(a);
          }
        });
      }
      function At(a, b, c, d) {
        var e, f, g, h, k2;
        return G(function(l) {
          if (1 == l.g)
            return e = null, f = a.g, g = { networkingEngine: f, modifyManifestRequest: function() {
            }, modifySegmentRequest: function() {
            }, filter: function() {
              return Promise.resolve();
            }, makeTextStreamsForClosedCaptions: function() {
            }, onTimelineRegionAdded: function() {
            }, onEvent: function() {
            }, onError: function(m) {
              e = m;
            }, isLowLatencyMode: function() {
              return false;
            }, isAutoLowLatencyMode: function() {
              return false;
            }, enableLowLatencyMode: function() {
            }, updateDuration: function() {
            }, newDrmInfo: function() {
            } }, c.configure(d.manifest), Bt(a), u(l, c.start(b, g), 2);
          if (3 != l.g)
            return h = l.h, Bt(a), k2 = Xt(h), u(l, Promise.all(rf(k2, function(m) {
              return m.createSegmentIndex();
            })), 3);
          Bt(a);
          if (e)
            throw e;
          return l.return(h);
        });
      }
      function Ct(a, b, c, d) {
        var e;
        return G(function(f) {
          switch (f.g) {
            case 1:
              return e = new fg({ kb: a.g, onError: c, cd: function() {
              }, onExpirationUpdated: function() {
              }, onEvent: function() {
              } }), e.configure(d.drm), u(f, kg(e, b.variants, d.offline.usePersistentLicense), 2);
            case 2:
              return u(f, yg(e), 3);
            case 3:
              return u(f, xg(e), 4);
            case 4:
              return f.return(e);
          }
        });
      }
      function Nt(a, b, c, d) {
        var e = /* @__PURE__ */ new Map(), f = Xt(c), g = /* @__PURE__ */ new Map();
        f = r(f);
        for (var h = f.next(); !h.done; h = f.next()) {
          h = h.value;
          var k2 = Yt(a, b, c, h, d, e);
          g.set(h.id, k2);
        }
        a = r(c.variants);
        for (b = a.next(); !b.done; b = a.next())
          b = b.value, b.audio && g.get(b.audio.id).variantIds.push(b.id), b.video && g.get(b.video.id).variantIds.push(b.id);
        return { streams: Array.from(g.values()), pe: Array.from(e.values()) };
      }
      function Yt(a, b, c, d, e, f) {
        var g = {
          id: d.id,
          originalId: d.originalId,
          primary: d.primary,
          type: d.type,
          mimeType: d.mimeType,
          codecs: d.codecs,
          frameRate: d.frameRate,
          pixelAspectRatio: d.pixelAspectRatio,
          hdr: d.hdr,
          kind: d.kind,
          language: d.language,
          label: d.label,
          width: d.width || null,
          height: d.height || null,
          encrypted: d.encrypted,
          keyIds: d.keyIds,
          segments: [],
          variantIds: [],
          roles: d.roles,
          forced: d.forced,
          channelsCount: d.channelsCount,
          audioSamplingRate: d.audioSamplingRate,
          spatialAudio: d.spatialAudio,
          closedCaptions: d.closedCaptions,
          tilesLayout: d.tilesLayout
        }, h = e.offline.numberOfParallelDownloads, k2 = 0;
        Zt(d, c.presentationTimeline.Pa(), function(l) {
          var m = ms(l), n = void 0;
          if (!f.has(m)) {
            var p = l.endTime - l.startTime;
            p = ut(b, d.id) * p;
            p = ps(a.g, p);
            f.set(m, new ls(l, p, k2, false));
          }
          l.h && (n = ms(l.h), f.has(n) || (p = 0.5 * ut(b, d.id), p = ps(a.g, p), f.set(n, new ls(l.h, p, k2, true))));
          g.segments.push({
            pendingInitSegmentRefId: n,
            initSegmentKey: n ? 0 : null,
            startTime: l.startTime,
            endTime: l.endTime,
            appendWindowStart: l.appendWindowStart,
            appendWindowEnd: l.appendWindowEnd,
            timestampOffset: l.timestampOffset,
            tilesLayout: l.tilesLayout,
            pendingSegmentRefId: m,
            dataKey: 0
          });
          k2 = (k2 + 1) % h;
        });
        return g;
      }
      function Zt(a, b, c) {
        b = a.segmentIndex.find(b);
        if (null != b)
          for (var d = a.segmentIndex.get(b); d; )
            c(d), d = a.segmentIndex.get(++b);
      }
      function Bt(a) {
        if (a.l.g)
          throw new O(2, 9, 7001);
      }
      function zt() {
        if (!wt())
          throw new O(2, 9, 9e3);
      }
      function Ot(a, b) {
        return G(function(c) {
          if (1 == c.g)
            return a.i.push(b), sa(c), u(c, b, 4);
          if (2 != c.g)
            return c.return(c.h);
          xa(c);
          hb(a.i, b);
          return ya(c, 0);
        });
      }
      function yt(a, b) {
        var c = b.promise;
        a.i.push(c);
        return b.finally(function() {
          hb(a.i, c);
        });
      }
      function Ut(a) {
        var b = /* @__PURE__ */ new Set();
        a = r(a.streams);
        for (var c = a.next(); !c.done; c = a.next()) {
          c = r(c.value.segments);
          for (var d = c.next(); !d.done; d = c.next())
            d = d.value, null != d.initSegmentKey && b.add(d.initSegmentKey), b.add(d.dataKey);
        }
        return Array.from(b);
      }
      function Tt(a, b, c, d) {
        var e, f, g;
        return G(function(h) {
          if (1 == h.g) {
            if (!d.drmInfo)
              return h.return();
            e = Ns(c);
            f = d.sessionIds.map(function(k2) {
              return { sessionId: k2, keySystem: d.drmInfo.keySystem, licenseUri: d.drmInfo.licenseServerUri, serverCertificate: d.drmInfo.serverCertificate, audioCapabilities: St(d, false), videoCapabilities: St(d, true) };
            });
            return u(h, lt(b, a, f), 2);
          }
          return 3 != h.g ? (g = h.h, u(h, e.remove(g), 3)) : u(h, e.add(f.filter(function(k2) {
            return !g.includes(k2.sessionId);
          })), 0);
        });
      }
      function Xt(a) {
        for (var b = /* @__PURE__ */ new Set(), c = r(a.textStreams), d = c.next(); !d.done; d = c.next())
          b.add(d.value);
        c = r(a.imageStreams);
        for (d = c.next(); !d.done; d = c.next())
          b.add(d.value);
        a = r(a.variants);
        for (c = a.next(); !c.done; c = a.next())
          c = c.value, c.audio && b.add(c.audio), c.video && b.add(c.video);
        return b;
      }
      function Lt(a) {
        a.variants.map(function(f) {
          return f.video;
        });
        var b = new Set(a.variants.map(function(f) {
          return f.audio;
        }));
        a = a.textStreams;
        for (var c = r(b), d = c.next(); !d.done; d = c.next()) {
          d = r(b);
          for (var e = d.next(); !e.done; e = d.next())
            ;
        }
        b = r(a);
        for (c = b.next(); !c.done; c = b.next())
          for (c = r(a), d = c.next(); !d.done; d = c.next())
            ;
      }
      K("shaka.offline.Storage", vt);
      vt.deleteAll = function() {
        var a;
        return G(function(b) {
          return 1 == b.g ? (a = new Hs(), sa(b), u(b, Os(a), 2)) : 5 != b.g ? (xa(b), u(b, a.destroy(), 5)) : ya(b, 0);
        });
      };
      vt.prototype.list = vt.prototype.list;
      vt.prototype.removeEmeSessions = vt.prototype.pg;
      vt.prototype.remove = vt.prototype.remove;
      vt.prototype.store = vt.prototype.store;
      vt.prototype.getNetworkingEngine = vt.prototype.jc;
      vt.prototype.getConfiguration = vt.prototype.getConfiguration;
      vt.prototype.configure = vt.prototype.configure;
      vt.prototype.destroy = vt.prototype.destroy;
      vt.support = wt;
      var Mt = (/* @__PURE__ */ new Map()).set("org.w3.clearkey", "1077efecc0b24d02ace33c1e52e2fb4b").set("com.widevine.alpha", "edef8ba979d64acea3c827dcd51d21ed").set("com.microsoft.playready", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.recommendation", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.software", "9a04f07998404286ab92e65be0885f95").set("com.microsoft.playready.hardware", "9a04f07998404286ab92e65be0885f95").set("com.adobe.primetime", "f239e769efa348509c16a903c6932efb");
      rn.offline = wt;
      function $t() {
      }
      function au(a, b) {
        a = { priority: b || 0, mf: a };
        for (b = 0; b < bu.length; b++)
          if (bu[b].priority < a.priority) {
            bu.splice(b, 0, a);
            return;
          }
        bu.push(a);
      }
      K("shaka.polyfill", $t);
      $t.register = au;
      $t.installAll = function() {
        for (var a = r(bu), b = a.next(); !b.done; b = a.next()) {
          b = b.value;
          try {
            b.mf();
          } catch (c) {
            Wa("Error installing polyfill!", c);
          }
        }
      };
      var bu = [];
      function cu() {
        this.g = new du();
      }
      function eu() {
        window2.AbortController || (window2.AbortController = cu, window2.AbortSignal = du);
      }
      cu.prototype.abort = function(a) {
        var b = this.g;
        if (!b.h) {
          b.h = true;
          b.g = a;
          void 0 === b.g && (b.g = new DOMException("signal is aborted without reason", "AbortError"));
          a = new S("abort");
          if (b.onabort)
            b.onabort(a);
          b.dispatchEvent(a);
        }
      };
      da.Object.defineProperties(cu.prototype, { signal: { configurable: true, enumerable: true, get: function() {
        return this.g;
      } } });
      $t.AbortController = cu;
      cu.install = eu;
      function du() {
        Ue.call(this);
        this.h = false;
        this.g = void 0;
        this.onabort = null;
      }
      oa(du, Ue);
      da.Object.defineProperties(du.prototype, { aborted: { configurable: true, enumerable: true, get: function() {
        return this.h;
      } }, reason: { configurable: true, enumerable: true, get: function() {
        return this.g;
      } } });
      au(eu);
      function fu() {
      }
      function gu() {
        if (!Object.getOwnPropertyDescriptor(Element.prototype, "ariaHidden"))
          for (var a = r(["ariaHidden", "ariaLabel", "ariaPressed", "ariaSelected"]), b = a.next(); !b.done; b = a.next())
            hu(b.value);
      }
      function hu(a) {
        var b = "aria-" + a.toLowerCase().replace(/^aria/, "");
        Object.defineProperty(Element.prototype, a, { get: function() {
          return this.getAttribute(b);
        }, set: function(c) {
          null == c || void 0 == c ? this.removeAttribute(b) : this.setAttribute(b, c);
        } });
      }
      $t.Aria = fu;
      fu.install = gu;
      au(gu);
      function iu() {
      }
      function ju() {
        ku();
      }
      $t.EncryptionScheme = iu;
      iu.install = ju;
      au(ju, -2);
      function lu() {
      }
      function mu() {
        if (window2.Document) {
          var a = Element.prototype;
          a.requestFullscreen = a.requestFullscreen || a.mozRequestFullScreen || a.msRequestFullscreen || a.webkitRequestFullscreen;
          a = Document.prototype;
          a.exitFullscreen = a.exitFullscreen || a.mozCancelFullScreen || a.msExitFullscreen || a.webkitCancelFullScreen;
          "fullscreenElement" in document || (Object.defineProperty(document, "fullscreenElement", { get: function() {
            return document.mozFullScreenElement || document.msFullscreenElement || document.webkitCurrentFullScreenElement || document.webkitFullscreenElement;
          } }), Object.defineProperty(document, "fullscreenEnabled", { get: function() {
            return document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled;
          } }));
          document.addEventListener("webkitfullscreenchange", nu);
          document.addEventListener("webkitfullscreenerror", nu);
          document.addEventListener("mozfullscreenchange", nu);
          document.addEventListener("mozfullscreenerror", nu);
          document.addEventListener("MSFullscreenChange", nu);
          document.addEventListener("MSFullscreenError", nu);
        }
      }
      function nu(a) {
        var b = a.type.replace(/^(webkit|moz|MS)/, "").toLowerCase(), c = document.createEvent("Event");
        c.initEvent(b, a.bubbles, a.cancelable);
        a.target.dispatchEvent(c);
      }
      $t.Fullscreen = lu;
      lu.install = mu;
      au(mu);
      function ou() {
      }
      function pu() {
        var a = true;
        if (wc() || tc("PlayStation 5") || xc() || tc("Web0S") || uc() || tc("CrKey") || tc("PC=EOS") || tc("Hisense") || tc("VIDAA"))
          a = false;
        a && navigator.mediaCapabilities || (navigator.mediaCapabilities || (navigator.mediaCapabilities = {}), qu = navigator.mediaCapabilities, navigator.mediaCapabilities.decodingInfo = ru);
      }
      function ru(a) {
        var b, c, d, e, f, g, h, k2, l, m, n, p, t, v, y, w, x;
        return G(function(C) {
          switch (C.g) {
            case 1:
              b = { supported: false, powerEfficient: true, smooth: true, keySystemAccess: null, configuration: a };
              if (!a)
                return C.return(b);
              c = a.video;
              d = a.audio;
              if ("media-source" == a.type) {
                if (!oc())
                  return C.return(b);
                if (c) {
                  if (tc("CrKey"))
                    if (window2.cast && cast.__platform__ && cast.__platform__.canDisplayType) {
                      var z = c.contentType;
                      c.width && c.height && (z += "; width=" + c.width + "; height=" + c.height);
                      c.framerate && (z += "; framerate=" + c.framerate);
                      "pq" === c.transferFunction && (z += "; eotf=smpte2084");
                      z = cast.__platform__.canDisplayType(z);
                    } else
                      z = eb(c.contentType);
                  else
                    z = eb(c.contentType);
                  e = z;
                  if (!e)
                    return C.return(b);
                }
                if (d && (f = d.contentType, g = eb(f), !g))
                  return C.return(b);
              } else if ("file" == a.type) {
                if (c && (h = c.contentType, k2 = pc(h), !k2) || d && (l = d.contentType, m = pc(l), !m))
                  return C.return(b);
              } else
                return C.return(b);
              if (!a.keySystemConfiguration)
                return b.supported = true, C.return(Promise.resolve(b));
              n = a.keySystemConfiguration;
              p = [];
              t = [];
              n.audio && (v = { robustness: n.audio.robustness || "", contentType: a.audio.contentType }, p.push(v));
              n.video && (y = { robustness: n.video.robustness || "", contentType: a.video.contentType }, t.push(y));
              w = { initDataTypes: [n.initDataType], distinctiveIdentifier: n.distinctiveIdentifier, persistentState: n.persistentState, sessionTypes: n.sessionTypes };
              p.length && (w.audioCapabilities = p);
              t.length && (w.videoCapabilities = t);
              D(C, 3);
              return u(C, navigator.requestMediaKeySystemAccess(n.keySystem, [w]), 5);
            case 5:
              x = C.h;
              ta(C, 4);
              break;
            case 3:
              ua(C);
            case 4:
              x && (b.supported = true, b.keySystemAccess = x);
            case 2:
              return C.return(b);
          }
        });
      }
      $t.MediaCapabilities = ou;
      ou.install = pu;
      var qu = null;
      ou.originalMcap = qu;
      au(pu, -1);
      function su() {
      }
      function tu() {
        var a = yc();
        window2.MediaSource && (window2.cast && cast.__platform__ && cast.__platform__.canDisplayType ? uu() : a ? 12 >= a ? (vu(), wu()) : 15 >= a && vu() : rc() ? xu() : (tc("Tizen 2") || tc("Tizen 3") || tc("Tizen 4")) && yu());
        window2.MediaSource && MediaSource.isTypeSupported('video/webm; codecs="vp9"') && !MediaSource.isTypeSupported('video/webm; codecs="vp09.00.10.08"') && zu();
      }
      function vu() {
        var a = MediaSource.prototype.addSourceBuffer;
        MediaSource.prototype.addSourceBuffer = function() {
          var b = a.apply(this, Fa.apply(0, arguments));
          b.abort = function() {
          };
          return b;
        };
      }
      function wu() {
        var a = SourceBuffer.prototype.remove;
        SourceBuffer.prototype.remove = function(b, c) {
          return a.call(this, b, c - 1e-3);
        };
      }
      function xu() {
        var a = MediaSource.isTypeSupported;
        MediaSource.isTypeSupported = function(b) {
          return "mp2t" != b.split(";")[0].split("/")[1] && a(b);
        };
      }
      function yu() {
        var a = MediaSource.isTypeSupported;
        MediaSource.isTypeSupported = function(b) {
          return "opus" != bd(b)[0] && a(b);
        };
      }
      function uu() {
        var a = MediaSource.isTypeSupported;
        MediaSource.isTypeSupported = function(b) {
          var c = b.split(/ *; */);
          c.shift();
          return c.some(function(d) {
            return d.startsWith("codecs=");
          }) ? cast.__platform__.canDisplayType(b) : a(b);
        };
      }
      function zu() {
        var a = MediaSource.isTypeSupported;
        tc("Web0S") || (MediaSource.isTypeSupported = function(b) {
          var c = b.split(/ *; */), d = c.findIndex(function(g) {
            return g.startsWith("codecs=");
          });
          if (0 > d)
            return a(b);
          var e = c[d].replace("codecs=", "").replace(/"/g, "").split(/\s*,\s*/), f = e.findIndex(function(g) {
            return g.startsWith("vp09");
          });
          0 <= f && (e[f] = "vp9", c[d] = 'codecs="' + e.join(",") + '"', b = c.join("; "));
          return a(b);
        });
      }
      $t.MediaSource = su;
      su.install = tu;
      au(tu);
      function Au() {
      }
      function Bu() {
        screen.orientation || void 0 != window2.orientation && Cu();
      }
      function Cu() {
        function a() {
          switch (window2.orientation) {
            case -90:
              b.type = "landscape-secondary";
              b.angle = 270;
              break;
            case 0:
              b.type = "portrait-primary";
              b.angle = 0;
              break;
            case 90:
              b.type = "landscape-primary";
              b.angle = 90;
              break;
            case 180:
              b.type = "portrait-secondary", b.angle = 180;
          }
        }
        var b = new Du();
        screen.orientation = b;
        a();
        window2.addEventListener("orientationchange", function() {
          a();
          var c = new S("change");
          b.dispatchEvent(c);
        });
      }
      $t.Orientation = Au;
      Au.install = Bu;
      function Du() {
        Ue.call(this);
        this.type = "";
        this.angle = 0;
      }
      oa(Du, Ue);
      Du.prototype.lock = function(a) {
        function b(d) {
          return screen.lockOrientation ? screen.lockOrientation(d) : screen.mozLockOrientation ? screen.mozLockOrientation(d) : screen.msLockOrientation ? screen.msLockOrientation(d) : false;
        }
        var c = false;
        switch (a) {
          case "natural":
            c = b("default");
            break;
          case "any":
            c = true;
            this.unlock();
            break;
          default:
            c = b(a);
        }
        if (c)
          return Promise.resolve();
        a = Error("screen.orientation.lock() is not available on this device");
        a.name = "NotSupportedError";
        a.code = DOMException.NOT_SUPPORTED_ERR;
        return Promise.reject(a);
      };
      Du.prototype.unlock = function() {
        screen.unlockOrientation ? screen.unlockOrientation() : screen.mozUnlockOrientation ? screen.mozUnlockOrientation() : screen.msUnlockOrientation && screen.msUnlockOrientation();
      };
      au(Bu);
      function Eu() {
      }
      var Fu, Gu, Hu, Iu, Ju, Ku;
      function Lu(a, b) {
        try {
          var c = new Mu(a, b);
          return Promise.resolve(c);
        } catch (d) {
          return Promise.reject(d);
        }
      }
      function Nu(a) {
        var b = this.mediaKeys;
        b && b != a && Ou(b, null);
        delete this.mediaKeys;
        return (this.mediaKeys = a) ? Ou(a, this) : Promise.resolve();
      }
      function Pu(a) {
        a = M(a.initData);
        if (Lb(a).getUint32(0, true) + 4 != a.byteLength)
          throw new RangeError("Malformed FairPlay init data");
        a = Dc(a.subarray(4), true);
        a = Gc(a);
        var b = new Event("encrypted");
        b.initDataType = "skd";
        b.initData = Ib(a);
        this.dispatchEvent(b);
      }
      $t.PatchedMediaKeysApple = Eu;
      Eu.uninstall = function() {
        Fu && (Fu = false, Object.defineProperty(HTMLMediaElement.prototype, "mediaKeys", Gu), HTMLMediaElement.prototype.setMediaKeys = Hu, window2.MediaKeys = Iu, window2.MediaKeySystemAccess = Ju, navigator.requestMediaKeySystemAccess = Ku, Gu = Ku = Hu = Ju = Iu = null, window2.shakaMediaKeysPolyfill = false);
      };
      Eu.install = function(a) {
        if (window2.HTMLVideoElement && window2.WebKitMediaKeys) {
          if (void 0 === a ? 0 : a)
            Fu = true, Gu = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, "mediaKeys"), Hu = HTMLMediaElement.prototype.setMediaKeys, Iu = window2.MediaKeys, Ju = window2.MediaKeySystemAccess, Ku = navigator.requestMediaKeySystemAccess;
          delete HTMLMediaElement.prototype.mediaKeys;
          HTMLMediaElement.prototype.mediaKeys = null;
          HTMLMediaElement.prototype.setMediaKeys = Nu;
          window2.MediaKeys = Qu;
          window2.MediaKeySystemAccess = Mu;
          navigator.requestMediaKeySystemAccess = Lu;
          window2.shakaMediaKeysPolyfill = true;
        }
      };
      function Mu(a, b) {
        this.keySystem = a;
        if (a.startsWith("com.apple.fps"))
          for (a = r(b), b = a.next(); !b.done; b = a.next()) {
            var c = b.value;
            if ("required" == c.persistentState)
              b = null;
            else {
              b = { audioCapabilities: [], videoCapabilities: [], persistentState: "optional", distinctiveIdentifier: "optional", initDataTypes: c.initDataTypes, sessionTypes: ["temporary"], label: c.label };
              var d = false, e = false;
              if (c.audioCapabilities)
                for (var f = r(c.audioCapabilities), g = f.next(); !g.done; g = f.next())
                  g = g.value, g.contentType && (d = true, WebKitMediaKeys.isTypeSupported(
                    this.keySystem,
                    g.contentType.split(";")[0]
                  ) && (b.audioCapabilities.push(g), e = true));
              if (c.videoCapabilities)
                for (c = r(c.videoCapabilities), g = c.next(); !g.done; g = c.next())
                  f = g.value, f.contentType && (d = true, WebKitMediaKeys.isTypeSupported(this.keySystem, f.contentType.split(";")[0]) && (b.videoCapabilities.push(f), e = true));
              d || (e = WebKitMediaKeys.isTypeSupported(this.keySystem, "video/mp4"));
              b = e ? b : null;
            }
            if (b) {
              this.g = b;
              return;
            }
          }
        a = Error("Unsupported keySystem");
        a.name = "NotSupportedError";
        a.code = DOMException.NOT_SUPPORTED_ERR;
        throw a;
      }
      Mu.prototype.createMediaKeys = function() {
        var a = new Qu(this.keySystem);
        return Promise.resolve(a);
      };
      Mu.prototype.getConfiguration = function() {
        return this.g;
      };
      function Qu(a) {
        this.h = new WebKitMediaKeys(a);
        this.g = new mf();
      }
      Qu.prototype.createSession = function(a) {
        a = a || "temporary";
        if ("temporary" != a)
          throw new TypeError("Session type " + a + " is unsupported on this platform.");
        return new Ru(this.h);
      };
      Qu.prototype.setServerCertificate = function() {
        return Promise.resolve(false);
      };
      function Ou(a, b) {
        a.g.nb();
        if (!b)
          return Promise.resolve();
        a.g.C(b, "webkitneedkey", Pu);
        try {
          return tj(b, HTMLMediaElement.HAVE_METADATA, a.g, function() {
            b.webkitSetMediaKeys(a.h);
          }), Promise.resolve();
        } catch (c) {
          return Promise.reject(c);
        }
      }
      function Ru(a) {
        Ue.call(this);
        this.i = null;
        this.l = a;
        this.g = this.h = null;
        this.j = new mf();
        this.sessionId = "";
        this.expiration = NaN;
        this.closed = new lc2();
        this.keyStatuses = new Su();
      }
      oa(Ru, Ue);
      q = Ru.prototype;
      q.generateRequest = function(a, b) {
        var c = this;
        this.h = new lc2();
        try {
          var d = this.l.createSession("video/mp4", M(b));
          this.i = d;
          this.sessionId = d.sessionId || "";
          this.j.C(this.i, "webkitkeymessage", function(e) {
            c.h && (c.h.resolve(), c.h = null);
            e = (/* @__PURE__ */ new Map()).set("messageType", void 0 == c.keyStatuses.Eb() ? "license-request" : "license-renewal").set("message", Ib(e.message));
            e = new S("message", e);
            c.dispatchEvent(e);
          });
          this.j.C(d, "webkitkeyadded", function() {
            c.g && (Tu(c, "usable"), c.g.resolve(), c.g = null);
          });
          this.j.C(
            d,
            "webkitkeyerror",
            function() {
              var e = Error("EME PatchedMediaKeysApple key error");
              e.errorCode = c.i.error;
              if (null != c.h)
                c.h.reject(e), c.h = null;
              else if (null != c.g)
                c.g.reject(e), c.g = null;
              else
                switch (c.i.error.code) {
                  case WebKitMediaKeyError.MEDIA_KEYERR_OUTPUT:
                  case WebKitMediaKeyError.MEDIA_KEYERR_HARDWARECHANGE:
                    Tu(c, "output-not-allowed");
                    break;
                  default:
                    Tu(c, "internal-error");
                }
            }
          );
          Tu(this, "status-pending");
        } catch (e) {
          this.h.reject(e);
        }
        return this.h;
      };
      q.load = function() {
        return Promise.reject(Error("MediaKeySession.load not yet supported"));
      };
      q.update = function(a) {
        this.g = new lc2();
        try {
          this.i.update(M(a));
        } catch (b) {
          this.g.reject(b);
        }
        return this.g;
      };
      q.close = function() {
        try {
          this.i.close(), this.closed.resolve(), this.j.nb();
        } catch (a) {
          this.closed.reject(a);
        }
        return this.closed;
      };
      q.remove = function() {
        return Promise.reject(Error("MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform"));
      };
      function Tu(a, b) {
        var c = a.keyStatuses;
        c.size = void 0 == b ? 0 : 1;
        c.g = b;
        b = new S("keystatuseschange");
        a.dispatchEvent(b);
      }
      function Su() {
        this.size = 0;
        this.g = void 0;
      }
      q = Su.prototype;
      q.Eb = function() {
        return this.g;
      };
      q.forEach = function(a) {
        this.g && a(this.g, Qg.value());
      };
      q.get = function(a) {
        if (this.has(a))
          return this.g;
      };
      q.has = function(a) {
        var b = Qg.value();
        return this.g && Gb(a, b) ? true : false;
      };
      q.entries = function() {
      };
      q.keys = function() {
      };
      q.values = function() {
      };
      function Uu() {
      }
      function Vu() {
        !window2.HTMLVideoElement || navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration || (navigator.requestMediaKeySystemAccess = Wu, delete HTMLMediaElement.prototype.mediaKeys, HTMLMediaElement.prototype.mediaKeys = null, HTMLMediaElement.prototype.setMediaKeys = Xu, window2.MediaKeys = Yu, window2.MediaKeySystemAccess = Zu, window2.shakaMediaKeysPolyfill = true);
      }
      function Wu() {
        return Promise.reject(Error("The key system specified is not supported."));
      }
      function Xu(a) {
        return null == a ? Promise.resolve() : Promise.reject(Error("MediaKeys not supported."));
      }
      $t.PatchedMediaKeysNop = Uu;
      Uu.install = Vu;
      function Yu() {
        throw new TypeError("Illegal constructor.");
      }
      Yu.prototype.createSession = function() {
      };
      Yu.prototype.setServerCertificate = function() {
      };
      function Zu() {
        this.keySystem = "";
        throw new TypeError("Illegal constructor.");
      }
      Zu.prototype.getConfiguration = function() {
      };
      Zu.prototype.createMediaKeys = function() {
      };
      au(Vu, -10);
      function $u() {
      }
      function av() {
        if (!(!window2.HTMLVideoElement || navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration)) {
          if (HTMLMediaElement.prototype.webkitGenerateKeyRequest)
            bv = "webkit";
          else if (!HTMLMediaElement.prototype.generateKeyRequest)
            return;
          navigator.requestMediaKeySystemAccess = cv;
          delete HTMLMediaElement.prototype.mediaKeys;
          HTMLMediaElement.prototype.mediaKeys = null;
          HTMLMediaElement.prototype.setMediaKeys = dv;
          window2.MediaKeys = ev;
          window2.MediaKeySystemAccess = fv;
          window2.shakaMediaKeysPolyfill = true;
        }
      }
      function gv(a) {
        var b = bv;
        return b ? b + a.charAt(0).toUpperCase() + a.slice(1) : a;
      }
      function cv(a, b) {
        try {
          var c = new fv(a, b);
          return Promise.resolve(c);
        } catch (d) {
          return Promise.reject(d);
        }
      }
      function dv(a) {
        var b = this.mediaKeys;
        b && b != a && hv(b, null);
        delete this.mediaKeys;
        (this.mediaKeys = a) && hv(a, this);
        return Promise.resolve();
      }
      $t.PatchedMediaKeysWebkit = $u;
      $u.install = av;
      function fv(a, b) {
        this.g = this.keySystem = a;
        var c = false;
        "org.w3.clearkey" == a && (this.g = "webkit-org.w3.clearkey", c = false);
        var d = false;
        var e = document.getElementsByTagName("video");
        e = e.length ? e[0] : document.createElement("video");
        b = r(b);
        for (var f = b.next(); !f.done; f = b.next()) {
          f = f.value;
          var g = { audioCapabilities: [], videoCapabilities: [], persistentState: "optional", distinctiveIdentifier: "optional", initDataTypes: f.initDataTypes, sessionTypes: ["temporary"], label: f.label }, h = false;
          if (f.audioCapabilities)
            for (var k2 = r(f.audioCapabilities), l = k2.next(); !l.done; l = k2.next())
              l = l.value, l.contentType && (h = true, e.canPlayType(l.contentType.split(";")[0], this.g) && (g.audioCapabilities.push(l), d = true));
          if (f.videoCapabilities)
            for (k2 = r(f.videoCapabilities), l = k2.next(); !l.done; l = k2.next())
              l = l.value, l.contentType && (h = true, e.canPlayType(l.contentType, this.g) && (g.videoCapabilities.push(l), d = true));
          h || (d = e.canPlayType("video/mp4", this.g) || e.canPlayType("video/webm", this.g));
          "required" == f.persistentState && (c ? (g.persistentState = "required", g.sessionTypes = ["persistent-license"]) : d = false);
          if (d) {
            this.h = g;
            return;
          }
        }
        c = "Unsupported keySystem";
        if ("org.w3.clearkey" == a || "com.widevine.alpha" == a)
          c = "None of the requested configurations were supported.";
        a = Error(c);
        a.name = "NotSupportedError";
        a.code = DOMException.NOT_SUPPORTED_ERR;
        throw a;
      }
      fv.prototype.createMediaKeys = function() {
        var a = new ev(this.g);
        return Promise.resolve(a);
      };
      fv.prototype.getConfiguration = function() {
        return this.h;
      };
      function ev(a) {
        this.l = a;
        this.h = null;
        this.g = new mf();
        this.i = [];
        this.j = /* @__PURE__ */ new Map();
      }
      function hv(a, b) {
        a.h = b;
        a.g.nb();
        var c = bv;
        b && (a.g.C(b, c + "needkey", function(d) {
          var e = new CustomEvent("encrypted");
          e.initDataType = "cenc";
          e.initData = Ib(d.initData);
          a.h.dispatchEvent(e);
        }), a.g.C(b, c + "keymessage", function(d) {
          var e = iv(a, d.sessionId);
          e && (d = (/* @__PURE__ */ new Map()).set("messageType", void 0 == e.keyStatuses.Eb() ? "licenserequest" : "licenserenewal").set("message", d.message), d = new S("message", d), e.h && (e.h.resolve(), e.h = null), e.dispatchEvent(d));
        }), a.g.C(b, c + "keyadded", function(d) {
          if (d = iv(a, d.sessionId))
            jv(d, "usable"), d.g && d.g.resolve(), d.g = null;
        }), a.g.C(b, c + "keyerror", function(d) {
          var e = iv(a, d.sessionId);
          e && e.handleError(d);
        }));
      }
      ev.prototype.createSession = function(a) {
        a = a || "temporary";
        if ("temporary" != a && "persistent-license" != a)
          throw new TypeError("Session type " + a + " is unsupported on this platform.");
        var b = this.h || document.createElement("video");
        b.src || (b.src = "about:blank");
        a = new kv(b, this.l, a);
        this.i.push(a);
        return a;
      };
      ev.prototype.setServerCertificate = function() {
        return Promise.resolve(false);
      };
      function iv(a, b) {
        var c = a.j.get(b);
        return c ? c : (c = a.i.shift()) ? (c.sessionId = b, a.j.set(b, c), c) : null;
      }
      function kv(a, b, c) {
        Ue.call(this);
        this.j = a;
        this.m = false;
        this.g = this.h = null;
        this.i = b;
        this.l = c;
        this.sessionId = "";
        this.expiration = NaN;
        this.closed = new lc2();
        this.keyStatuses = new lv();
      }
      oa(kv, Ue);
      q = kv.prototype;
      q.handleError = function(a) {
        var b = Error("EME v0.1b key error"), c = a.errorCode;
        c.systemCode = a.systemCode;
        b.errorCode = c;
        !a.sessionId && this.h ? (45 == a.systemCode && (b.message = "Unsupported session type."), this.h.reject(b), this.h = null) : a.sessionId && this.g ? (this.g.reject(b), this.g = null) : (b = a.systemCode, a.errorCode.code == MediaKeyError.MEDIA_KEYERR_OUTPUT ? jv(this, "output-restricted") : 1 == b ? jv(this, "expired") : jv(this, "internal-error"));
      };
      function mv(a, b, c) {
        if (a.m)
          return Promise.reject(Error("The session is already initialized."));
        a.m = true;
        try {
          if ("persistent-license" == a.l)
            if (c)
              var d = M(Gc("LOAD_SESSION|" + c));
            else {
              var e = Gc("PERSISTENT|");
              d = Oc(e, b);
            }
          else
            d = M(b);
        } catch (g) {
          return Promise.reject(g);
        }
        a.h = new lc2();
        var f = gv("generateKeyRequest");
        try {
          a.j[f](a.i, d);
        } catch (g) {
          if ("InvalidStateError" != g.name)
            return a.h = null, Promise.reject(g);
          new P(function() {
            try {
              a.j[f](a.i, d);
            } catch (h) {
              a.h.reject(h), a.h = null;
            }
          }).N(0.01);
        }
        return a.h;
      }
      function nv(a, b, c) {
        if (a.g)
          a.g.then(function() {
            return nv(a, b, c);
          }).catch(function() {
            return nv(a, b, c);
          });
        else {
          a.g = b;
          if ("webkit-org.w3.clearkey" == a.i) {
            var d = Cc(c);
            var e = JSON.parse(d);
            "oct" != e.keys[0].kty && (a.g.reject(Error("Response is not a valid JSON Web Key Set.")), a.g = null);
            d = Lc(e.keys[0].k);
            e = Lc(e.keys[0].kid);
          } else
            d = M(c), e = null;
          var f = gv("addKey");
          try {
            a.j[f](a.i, d, e, a.sessionId);
          } catch (g) {
            a.g.reject(g), a.g = null;
          }
        }
      }
      function jv(a, b) {
        var c = a.keyStatuses;
        c.size = void 0 == b ? 0 : 1;
        c.g = b;
        b = new S("keystatuseschange");
        a.dispatchEvent(b);
      }
      q.generateRequest = function(a, b) {
        return mv(this, b, null);
      };
      q.load = function(a) {
        return "persistent-license" == this.l ? mv(this, null, a) : Promise.reject(Error("Not a persistent session."));
      };
      q.update = function(a) {
        var b = new lc2();
        nv(this, b, a);
        return b;
      };
      q.close = function() {
        if ("persistent-license" != this.l) {
          if (!this.sessionId)
            return this.closed.reject(Error("The session is not callable.")), this.closed;
          var a = gv("cancelKeyRequest");
          try {
            this.j[a](this.i, this.sessionId);
          } catch (b) {
          }
        }
        this.closed.resolve();
        return this.closed;
      };
      q.remove = function() {
        return "persistent-license" != this.l ? Promise.reject(Error("Not a persistent session.")) : this.close();
      };
      function lv() {
        this.size = 0;
        this.g = void 0;
      }
      q = lv.prototype;
      q.Eb = function() {
        return this.g;
      };
      q.forEach = function(a) {
        this.g && a(this.g, Qg.value());
      };
      q.get = function(a) {
        if (this.has(a))
          return this.g;
      };
      q.has = function(a) {
        var b = Qg.value();
        return this.g && Gb(a, b) ? true : false;
      };
      q.entries = function() {
      };
      q.keys = function() {
      };
      q.values = function() {
      };
      var bv = "";
      au(av);
      function ov() {
      }
      function pv() {
        if (window2.HTMLVideoElement) {
          var a = HTMLVideoElement.prototype;
          a.requestPictureInPicture && document.exitPictureInPicture || !a.webkitSupportsPresentationMode || (document.pictureInPictureEnabled = true, document.pictureInPictureElement = null, a.requestPictureInPicture = qv, Object.defineProperty(a, "disablePictureInPicture", { get: rv, set: sv, enumerable: true, configurable: true }), document.exitPictureInPicture = tv, document.addEventListener("webkitpresentationmodechanged", uv, true));
        }
      }
      function uv(a) {
        a = a.target;
        if ("picture-in-picture" == a.webkitPresentationMode) {
          document.pictureInPictureElement = a;
          var b = new Event("enterpictureinpicture");
          a.dispatchEvent(b);
        } else
          document.pictureInPictureElement == a && (document.pictureInPictureElement = null), b = new Event("leavepictureinpicture"), a.dispatchEvent(b);
      }
      function qv() {
        return this.webkitSupportsPresentationMode("picture-in-picture") ? (this.webkitSetPresentationMode("picture-in-picture"), document.pictureInPictureElement = this, Promise.resolve()) : Promise.reject(Error("PiP not allowed by video element"));
      }
      function tv() {
        var a = document.pictureInPictureElement;
        return a ? (a.webkitSetPresentationMode("inline"), document.pictureInPictureElement = null, Promise.resolve()) : Promise.reject(Error("No picture in picture element found"));
      }
      function rv() {
        return this.hasAttribute("disablePictureInPicture") ? true : !this.webkitSupportsPresentationMode("picture-in-picture");
      }
      function sv(a) {
        a ? this.setAttribute("disablePictureInPicture", "") : this.removeAttribute("disablePictureInPicture");
      }
      $t.PiPWebkit = ov;
      ov.install = pv;
      au(pv);
      function vv() {
      }
      function wv() {
        window2.crypto && ("randomUUID" in window2.crypto || (window2.crypto.randomUUID = xv));
      }
      function xv() {
        var a = URL.createObjectURL(new Blob()), b = a.toString();
        URL.revokeObjectURL(a);
        return b.substr(b.lastIndexOf("/") + 1);
      }
      $t.RandomUUID = vv;
      vv.install = wv;
      au(wv);
      function yv() {
      }
      function zv() {
        navigator.storage && navigator.storage.estimate || !navigator.webkitTemporaryStorage || !navigator.webkitTemporaryStorage.queryUsageAndQuota || ("storage" in navigator || (navigator.storage = {}), navigator.storage.estimate = Av);
      }
      function Av() {
        return new Promise(function(a, b) {
          navigator.webkitTemporaryStorage.queryUsageAndQuota(function(c, d) {
            a({ usage: c, quota: d });
          }, b);
        });
      }
      $t.StorageEstimate = yv;
      yv.install = zv;
      au(zv);
      function Bv() {
      }
      function Cv() {
        var a = Symbol.prototype;
        "description" in a || Object.defineProperty(a, "description", { get: Dv });
      }
      function Dv() {
        var a = /\((.*)\)/.exec(this.toString());
        return a ? a[1] : void 0;
      }
      $t.Symbol = Bv;
      Bv.install = Cv;
      au(Cv);
      function Ev() {
      }
      function Fv() {
        if (window2.HTMLMediaElement) {
          var a = HTMLMediaElement.prototype.play;
          HTMLMediaElement.prototype.play = function() {
            var b = a.apply(this);
            b && b.catch(function() {
            });
            return b;
          };
        }
      }
      $t.VideoPlayPromise = Ev;
      Ev.install = Fv;
      au(Fv);
      function Gv() {
      }
      function Hv() {
        if (window2.HTMLVideoElement) {
          var a = HTMLVideoElement.prototype;
          !a.getVideoPlaybackQuality && ("webkitDroppedFrameCount" in a || vc()) && (a.getVideoPlaybackQuality = Iv);
        }
      }
      function Iv() {
        return { droppedVideoFrames: this.webkitDroppedFrameCount, totalVideoFrames: this.webkitDecodedFrameCount, corruptedVideoFrames: 0, creationTime: NaN, totalFrameDelay: 0 };
      }
      $t.VideoPlaybackQuality = Gv;
      Gv.install = Hv;
      au(Hv);
      function Jv() {
      }
      function Kv() {
        if (!window2.VTTCue && window2.TextTrackCue) {
          var a = null, b = TextTrackCue.length;
          if (3 == b)
            a = Lv;
          else if (6 == b)
            a = Mv;
          else {
            try {
              var c = !!Lv(1, 2, "");
            } catch (d) {
              c = false;
            }
            c && (a = Lv);
          }
          a && (window2.VTTCue = function(d, e, f) {
            return a(d, e, f);
          });
        }
      }
      function Lv(a, b, c) {
        return new window2.TextTrackCue(a, b, c);
      }
      function Mv(a, b, c) {
        return new window2.TextTrackCue(a + "-" + b + "-" + c, a, b, c);
      }
      $t.VTTCue = Jv;
      Jv.install = Kv;
      au(Kv);
      function Nv() {
      }
      Nv.prototype.parseInit = function() {
      };
      Nv.prototype.setSequenceMode = function() {
      };
      Nv.prototype.parseMedia = function(a, b) {
        var c = null, d = [];
        a = Cc(a).split(/\r?\n/);
        a = r(a);
        for (var e = a.next(); !e.done; e = a.next())
          if ((e = e.value) && !/^\s+$/.test(e) && (e = Ov.exec(e))) {
            var f = Pv.exec(e[1]);
            f = 60 * parseInt(f[1], 10) + parseFloat(f[2].replace(",", "."));
            e = new kb(f, b.segmentEnd ? b.segmentEnd : f + 2, e[2]);
            c && (c.endTime = f, d.push(c));
            c = e;
          }
        c && d.push(c);
        return d;
      };
      K("shaka.text.LrcTextParser", Nv);
      Nv.prototype.parseMedia = Nv.prototype.parseMedia;
      Nv.prototype.setSequenceMode = Nv.prototype.setSequenceMode;
      Nv.prototype.parseInit = Nv.prototype.parseInit;
      var Ov = /^\[(\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\](.*)/, Pv = /^(\d+):(\d{1,2}(?:[.,]\d{1,3})?)$/;
      fd["application/x-subtitle-lrc"] = function() {
        return new Nv();
      };
      function Qv() {
      }
      Qv.prototype.parseInit = function() {
      };
      Qv.prototype.setSequenceMode = function() {
      };
      Qv.prototype.parseMedia = function(a, b) {
        var c = Cc(a);
        a = [];
        if ("" == c)
          return a;
        var d = cg(c, "tt");
        if (!d)
          throw new O(2, 2, 2005, "Failed to parse TTML.");
        c = d.getElementsByTagName("body")[0];
        if (!c)
          return [];
        var e = Rf(d, Rv, "frameRate"), f = Rf(d, Rv, "subFrameRate"), g = Rf(d, Rv, "frameRateMultiplier"), h = Rf(d, Rv, "tickRate"), k2 = Rf(d, Rv, "cellResolution"), l = d.getAttribute("xml:space") || "default", m = Rf(d, Sv, "extent");
        if ("default" != l && "preserve" != l)
          throw new O(2, 2, 2005, "Invalid xml:space value: " + l);
        l = "default" == l;
        e = new Tv(
          e,
          f,
          g,
          h
        );
        k2 = k2 ? (k2 = /^(\d+) (\d+)$/.exec(k2)) ? { columns: parseInt(k2[1], 10), rows: parseInt(k2[2], 10) } : null : null;
        f = (f = d.getElementsByTagName("metadata")[0]) ? Pf(f) : [];
        g = Array.from(d.getElementsByTagName("style"));
        d = Array.from(d.getElementsByTagName("region"));
        h = [];
        for (var n = r(d), p = n.next(); !p.done; p = n.next()) {
          var t = p.value;
          p = new mb();
          var v = t.getAttribute("xml:id");
          if (v) {
            p.id = v;
            var y = null;
            m && (y = Uv.exec(m) || Vv.exec(m));
            v = y ? Number(y[1]) : null;
            y = y ? Number(y[2]) : null;
            var w, x;
            if (w = Wv(t, g, "extent"))
              w = (x = Uv.exec(w)) || Vv.exec(w), null != w && (p.width = Number(w[1]), p.height = Number(w[2]), x || (null != v && (p.width = 100 * p.width / v), null != y && (p.height = 100 * p.height / y)), p.widthUnits = x || null != v ? Db : 0, p.heightUnits = x || null != y ? Db : 0);
            if (t = Wv(t, g, "origin"))
              w = (x = Uv.exec(t)) || Vv.exec(t), null != w && (p.viewportAnchorX = Number(w[1]), p.viewportAnchorY = Number(w[2]), x || (null != y && (p.viewportAnchorY = 100 * p.viewportAnchorY / y), null != v && (p.viewportAnchorX = 100 * p.viewportAnchorX / v)), p.viewportAnchorUnits = x || null != v ? Db : 0);
          } else
            p = null;
          p && h.push(p);
        }
        if (Mf(c, "p").length)
          throw new O(
            2,
            2,
            2001,
            "<p> can only be inside <div> in TTML"
          );
        m = r(Mf(c, "div"));
        for (n = m.next(); !n.done; n = m.next())
          if (Mf(n.value, "span").length)
            throw new O(2, 2, 2001, "<span> can only be inside <p> in TTML");
        if (b = Xv(c, b, e, f, g, d, h, l, k2, null, false))
          b.backgroundColor || (b.backgroundColor = "transparent"), a.push(b);
        return a;
      };
      function Xv(a, b, c, d, e, f, g, h, k2, l, m) {
        var n = a.parentNode;
        if (a.nodeType == Node.COMMENT_NODE)
          return null;
        if (a.nodeType == Node.TEXT_NODE) {
          if (!m)
            return null;
          var p = document.createElement("span");
          p.textContent = a.textContent;
        } else
          p = a;
        for (var t = null, v = r(Yv), y = v.next(); !y.done && !(t = Zv(p, "backgroundImage", d, "#", y.value)[0]); y = v.next())
          ;
        v = m;
        if ("p" == a.nodeName || t)
          m = true;
        h = "default" == (p.getAttribute("xml:space") || (h ? "default" : "preserve"));
        y = Array.from(p.childNodes).every(function(B) {
          return B.nodeType == Node.TEXT_NODE;
        });
        a = [];
        if (!y)
          for (var w = r(p.childNodes), x = w.next(); !x.done; x = w.next())
            (x = Xv(x.value, b, c, d, e, f, g, h, k2, p, m)) && a.push(x);
        d = null != l;
        w = /\S/.test(p.textContent);
        var C = p.hasAttribute("begin") || p.hasAttribute("end") || p.hasAttribute("dur");
        if (!(C || w || "br" == p.tagName || 0 != a.length || d && !h))
          return null;
        x = $v(p, c);
        w = x.start;
        for (x = x.end; n && n.nodeType == Node.ELEMENT_NODE && "tt" != n.tagName; )
          x = aw(n, c, w, x), w = x.start, x = x.end, n = n.parentNode;
        null == w && (w = 0);
        w += b.periodStart;
        x = null == x ? Infinity : x + b.periodStart;
        w = Math.max(w, b.segmentStart);
        x = Math.min(x, b.segmentEnd);
        if (!C && 0 < a.length)
          for (w = Infinity, x = 0, b = r(a), c = b.next(); !c.done; c = b.next())
            c = c.value, w = Math.min(w, c.startTime), x = Math.max(x, c.endTime);
        if ("br" == p.tagName)
          return e = new kb(w, x, ""), e.lineBreak = true, e;
        b = "";
        y && (b = p.textContent, h && (b = b.trim(), b = b.replace(/\s+/g, " ")));
        b = new kb(w, x, b);
        b.nestedCues = a;
        m || (b.isContainer = true);
        k2 && (b.cellResolution = k2);
        k2 = Zv(p, "region", f, "")[0];
        if (p.hasAttribute("region") && k2 && k2.getAttribute("xml:id")) {
          var z = k2.getAttribute("xml:id");
          b.region = g.filter(function(B) {
            return B.id == z;
          })[0];
        }
        g = k2;
        l && d && !p.getAttribute("region") && !p.getAttribute("style") && (g = Zv(l, "region", f, "")[0]);
        bw(b, p, g, t, e, v, 0 == a.length);
        return b;
      }
      function bw(a, b, c, d, e, f, g) {
        f = f || g;
        "rtl" == cw(b, c, e, "direction", f) && (a.direction = "rtl");
        g = cw(b, c, e, "writingMode", f);
        "tb" == g || "tblr" == g ? a.writingMode = "vertical-lr" : "tbrl" == g ? a.writingMode = "vertical-rl" : "rltb" == g || "rl" == g ? a.direction = "rtl" : g && (a.direction = lb);
        (g = cw(b, c, e, "textAlign", true)) ? (a.positionAlign = dw[g], a.lineAlign = ew[g], a.textAlign = xb[g.toUpperCase()]) : a.textAlign = ob;
        if (g = cw(b, c, e, "displayAlign", true))
          a.displayAlign = yb[g.toUpperCase()];
        if (g = cw(b, c, e, "color", f))
          a.color = g;
        if (g = cw(
          b,
          c,
          e,
          "backgroundColor",
          f
        ))
          a.backgroundColor = g;
        if (g = cw(b, c, e, "border", f))
          a.border = g;
        if (g = cw(b, c, e, "fontFamily", f))
          switch (g) {
            case "monospaceSerif":
              a.fontFamily = "Courier New,Liberation Mono,Courier,monospace";
              break;
            case "proportionalSansSerif":
              a.fontFamily = "Arial,Helvetica,Liberation Sans,sans-serif";
              break;
            case "sansSerif":
              a.fontFamily = "sans-serif";
              break;
            case "monospaceSansSerif":
              a.fontFamily = "Consolas,monospace";
              break;
            case "proportionalSerif":
              a.fontFamily = "serif";
              break;
            default:
              a.fontFamily = g;
          }
        (g = cw(b, c, e, "fontWeight", f)) && "bold" == g && (a.fontWeight = 700);
        g = cw(b, c, e, "wrapOption", f);
        a.wrapLine = g && "noWrap" == g ? false : true;
        (g = cw(b, c, e, "lineHeight", f)) && g.match(fw) && (a.lineHeight = g);
        (g = cw(b, c, e, "fontSize", f)) && (g.match(fw) || g.match(gw)) && (a.fontSize = g);
        if (g = cw(b, c, e, "fontStyle", f))
          a.fontStyle = Cb[g.toUpperCase()];
        if (d) {
          g = d.getAttribute("imageType") || d.getAttribute("imagetype");
          var h = d.getAttribute("encoding");
          d = d.textContent.trim();
          "PNG" == g && "Base64" == h && d && (a.backgroundImage = "data:image/png;base64," + d);
        }
        if (d = cw(
          b,
          c,
          e,
          "textOutline",
          f
        ))
          d = d.split(" "), d[0].match(fw) ? a.textStrokeColor = a.color : (a.textStrokeColor = d[0], d.shift()), d[0] && d[0].match(fw) ? a.textStrokeWidth = d[0] : a.textStrokeColor = "";
        (d = cw(b, c, e, "letterSpacing", f)) && d.match(fw) && (a.letterSpacing = d);
        (d = cw(b, c, e, "linePadding", f)) && d.match(fw) && (a.linePadding = d);
        if (f = cw(b, c, e, "opacity", f))
          a.opacity = parseFloat(f);
        (c = Wv(c, e, "textDecoration")) && hw(a, c);
        (b = iw(b, e, "textDecoration")) && hw(a, b);
      }
      function hw(a, b) {
        b = r(b.split(" "));
        for (var c = b.next(); !c.done; c = b.next())
          switch (c.value) {
            case "underline":
              a.textDecoration.includes("underline") || a.textDecoration.push("underline");
              break;
            case "noUnderline":
              a.textDecoration.includes("underline") && hb(a.textDecoration, "underline");
              break;
            case "lineThrough":
              a.textDecoration.includes("lineThrough") || a.textDecoration.push("lineThrough");
              break;
            case "noLineThrough":
              a.textDecoration.includes("lineThrough") && hb(a.textDecoration, "lineThrough");
              break;
            case "overline":
              a.textDecoration.includes("overline") || a.textDecoration.push("overline");
              break;
            case "noOverline":
              a.textDecoration.includes("overline") && hb(a.textDecoration, "overline");
          }
      }
      function cw(a, b, c, d, e) {
        e = void 0 === e ? true : e;
        return (a = iw(a, c, d)) ? a : e ? Wv(b, c, d) : null;
      }
      function Wv(a, b, c) {
        if (!a)
          return null;
        var d = Rf(a, Sv, c);
        return d ? d : jw(a, b, c);
      }
      function iw(a, b, c) {
        var d = Rf(a, Sv, c);
        return d ? d : jw(a, b, c);
      }
      function jw(a, b, c) {
        a = Zv(a, "style", b, "");
        for (var d = null, e = 0; e < a.length; e++) {
          var f = Qf(a[e], "urn:ebu:tt:style", c);
          f || (f = Rf(a[e], Sv, c));
          f || (f = iw(a[e], b, c));
          f && (d = f);
        }
        return d;
      }
      function Zv(a, b, c, d, e) {
        var f = [];
        if (!a || 1 > c.length)
          return f;
        var g = a;
        for (a = null; g && !(a = e ? Qf(g, e, b) : g.getAttribute(b)) && (g = g.parentNode, g instanceof Element); )
          ;
        if (b = a) {
          for (b = r(b.split(" ")), e = b.next(); !e.done; e = b.next())
            for (e = e.value, a = r(c), g = a.next(); !g.done; g = a.next())
              if (g = g.value, d + g.getAttribute("xml:id") == e) {
                f.push(g);
                break;
              }
        }
        return f;
      }
      function aw(a, b, c, d) {
        a = $v(a, b);
        null == c ? c = a.start : null != a.start && (c += a.start);
        null == d ? d = a.end : null != a.start && (d += a.start);
        return { start: c, end: d };
      }
      function $v(a, b) {
        var c = kw(a.getAttribute("begin"), b), d = kw(a.getAttribute("end"), b);
        a = kw(a.getAttribute("dur"), b);
        null == d && null != a && (d = c + a);
        return { start: c, end: d };
      }
      function kw(a, b) {
        var c = null;
        if (lw.test(a)) {
          a = lw.exec(a);
          c = Number(a[1]);
          var d = Number(a[2]), e = Number(a[3]), f = Number(a[4]);
          f += (Number(a[5]) || 0) / b.h;
          e += f / b.frameRate;
          c = e + 60 * d + 3600 * c;
        } else if (mw.test(a))
          c = nw(mw, a);
        else if (ow.test(a))
          c = nw(ow, a);
        else if (pw.test(a))
          a = pw.exec(a), c = Number(a[1]) / b.frameRate;
        else if (qw.test(a))
          a = qw.exec(a), c = Number(a[1]) / b.g;
        else if (rw.test(a))
          c = nw(rw, a);
        else if (a)
          throw new O(2, 2, 2001, "Could not parse cue time range in TTML");
        return c;
      }
      function nw(a, b) {
        a = a.exec(b);
        return null == a || "" == a[0] ? null : (Number(a[4]) || 0) / 1e3 + (Number(a[3]) || 0) + 60 * (Number(a[2]) || 0) + 3600 * (Number(a[1]) || 0);
      }
      K("shaka.text.TtmlTextParser", Qv);
      Qv.prototype.parseMedia = Qv.prototype.parseMedia;
      Qv.prototype.setSequenceMode = Qv.prototype.setSequenceMode;
      Qv.prototype.parseInit = Qv.prototype.parseInit;
      function Tv(a, b, c, d) {
        this.frameRate = Number(a) || 30;
        this.h = Number(b) || 1;
        this.g = Number(d);
        0 == this.g && (this.g = a ? this.frameRate * this.h : 1);
        c && (a = /^(\d+) (\d+)$/g.exec(c)) && (this.frameRate *= Number(a[1]) / Number(a[2]));
      }
      var Uv = /^(\d{1,2}(?:\.\d+)?|100(?:\.0+)?)% (\d{1,2}(?:\.\d+)?|100(?:\.0+)?)%$/, gw = /^(\d{1,2}(?:\.\d+)?|100)%$/, fw = /^(\d+px|\d+em|\d*\.?\d+c)$/, Vv = /^(\d+)px (\d+)px$/, lw = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, mw = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/, ow = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/, pw = /^(\d*(?:\.\d*)?)f$/, qw = /^(\d*(?:\.\d*)?)t$/, rw = RegExp("^(?:(\\d*(?:\\.\\d*)?)h)?(?:(\\d*(?:\\.\\d*)?)m)?(?:(\\d*(?:\\.\\d*)?)s)?(?:(\\d*(?:\\.\\d*)?)ms)?$"), ew = {
        left: sb,
        center: "center",
        right: "end",
        start: sb,
        end: "end"
      }, dw = { left: "line-left", center: "center", right: "line-right" }, Rv = ["http://www.w3.org/ns/ttml#parameter", "http://www.w3.org/2006/10/ttaf1#parameter"], Sv = ["http://www.w3.org/ns/ttml#styling", "http://www.w3.org/2006/10/ttaf1#styling"], Yv = ["http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt", "http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt"];
      fd["application/ttml+xml"] = function() {
        return new Qv();
      };
      function sw() {
        this.g = new Qv();
      }
      sw.prototype.parseInit = function(a) {
        var b = false;
        new zf().box("moov", Ef).box("trak", Ef).box("mdia", Ef).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("stpp", function(c) {
          b = true;
          c.parser.stop();
        }).parse(a);
        if (!b)
          throw new O(2, 2, 2007);
      };
      sw.prototype.setSequenceMode = function() {
      };
      sw.prototype.parseMedia = function(a, b) {
        var c = this, d = false, e = [];
        new zf().box("mdat", If(function(f) {
          d = true;
          e = e.concat(c.g.parseMedia(f, b));
        })).parse(a, false);
        if (!d)
          throw new O(2, 2, 2007);
        return e;
      };
      K("shaka.text.Mp4TtmlParser", sw);
      sw.prototype.parseMedia = sw.prototype.parseMedia;
      sw.prototype.setSequenceMode = sw.prototype.setSequenceMode;
      sw.prototype.parseInit = sw.prototype.parseInit;
      fd['application/mp4; codecs="stpp"'] = function() {
        return new sw();
      };
      fd['application/mp4; codecs="stpp.ttml"'] = function() {
        return new sw();
      };
      fd['application/mp4; codecs="stpp.ttml.im1t"'] = function() {
        return new sw();
      };
      fd['application/mp4; codecs="stpp.TTML.im1t"'] = function() {
        return new sw();
      };
      function tw() {
        this.g = false;
      }
      tw.prototype.parseInit = function() {
      };
      tw.prototype.setSequenceMode = function(a) {
        this.g = a;
      };
      tw.prototype.parseMedia = function(a, b) {
        a = Cc(a);
        a = a.replace(/\r\n|\r(?=[^\n]|$)/gm, "\n");
        var c = a.split(/\n{2,}/m);
        if (!/^WEBVTT($|[ \t\n])/m.test(c[0]))
          throw new O(2, 2, 2e3);
        a = b.vttOffset;
        if (c[0].includes("X-TIMESTAMP-MAP") && this.g) {
          var d = c[0].match(/LOCAL:((?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{3}))/m), e = c[0].match(/MPEGTS:(\d+)/m);
          if (d && e) {
            a = uw(new Mq(d[1]));
            if (null == a)
              throw new O(2, 2, 2e3);
            e = Number(e[1]);
            for (d = b.segmentStart - b.periodStart; 95443.7176888889 <= d; )
              d -= 95443.7176888889, e += 8589934592;
            a = b.periodStart + e / 9e4 - a;
          }
        }
        b = [];
        e = r(c[0].split("\n"));
        for (d = e.next(); !d.done; d = e.next())
          if (d = d.value, /^Region:/.test(d)) {
            d = new Mq(d);
            var f = new mb();
            Pq(d);
            Nq(d);
            for (var g = Pq(d); g; ) {
              var h = f, k2 = g;
              (g = /^id=(.*)$/.exec(k2)) ? h.id = g[1] : (g = /^width=(\d{1,2}|100)%$/.exec(k2)) ? h.width = Number(g[1]) : (g = /^lines=(\d+)$/.exec(k2)) ? (h.height = Number(g[1]), h.heightUnits = 2) : (g = /^regionanchor=(\d{1,2}|100)%,(\d{1,2}|100)%$/.exec(k2)) ? (h.regionAnchorX = Number(g[1]), h.regionAnchorY = Number(g[2])) : (g = /^viewportanchor=(\d{1,2}|100)%,(\d{1,2}|100)%$/.exec(k2)) ? (h.viewportAnchorX = Number(g[1]), h.viewportAnchorY = Number(g[2])) : /^scroll=up$/.exec(k2) && (h.scroll = "up");
              Nq(d);
              g = Pq(d);
            }
            b.push(f);
          }
        e = /* @__PURE__ */ new Map();
        vw(e);
        d = [];
        c = r(c.slice(1));
        for (f = c.next(); !f.done; f = c.next()) {
          f = f.value.split("\n");
          if ((1 != f.length || f[0]) && !/^NOTE($|[ \t])/.test(f[0]) && "STYLE" == f[0]) {
            h = [];
            g = -1;
            for (k2 = 1; k2 < f.length; k2++)
              f[k2].includes("::cue") && (h.push([]), g = h.length - 1), -1 != g && (h[g].push(f[k2]), f[k2].includes("}") && (g = -1));
            h = r(h);
            for (g = h.next(); !g.done; g = h.next()) {
              var l = g.value;
              g = "global";
              (k2 = l[0].match(/\((.*)\)/)) && (g = k2.pop());
              k2 = l.slice(1, -1);
              l[0].includes("}") && (l = /\{(.*?)\}/.exec(l[0])) && (k2 = l[1].split(";"));
              (l = e.get(g)) || (l = new kb(0, 0, ""));
              for (var m = false, n = 0; n < k2.length; n++) {
                var p = /^\s*([^:]+):\s*(.*)/.exec(k2[n]);
                if (p) {
                  var t = p[2].trim().replace(";", "");
                  switch (p[1].trim()) {
                    case "background-color":
                    case "background":
                      m = true;
                      l.backgroundColor = t;
                      break;
                    case "color":
                      m = true;
                      l.color = t;
                      break;
                    case "font-family":
                      m = true;
                      l.fontFamily = t;
                      break;
                    case "font-size":
                      m = true;
                      l.fontSize = t;
                      break;
                    case "font-weight":
                      if (700 <= parseInt(t, 10) || "bold" == t)
                        m = true, l.fontWeight = 700;
                      break;
                    case "font-style":
                      switch (t) {
                        case "normal":
                          m = true;
                          l.fontStyle = vb;
                          break;
                        case "italic":
                          m = true;
                          l.fontStyle = "italic";
                          break;
                        case "oblique":
                          m = true, l.fontStyle = "oblique";
                      }
                      break;
                    case "opacity":
                      m = true;
                      l.opacity = parseFloat(t);
                      break;
                    case "text-shadow":
                      m = true;
                      l.textShadow = t;
                      break;
                    case "white-space":
                      m = true, l.wrapLine = "noWrap" != t;
                  }
                }
              }
              m && e.set(g, l);
            }
          }
          m = a;
          if (1 == f.length && !f[0] || /^NOTE($|[ \t])/.test(f[0]) || "STYLE" == f[0] || "REGION" == f[0])
            f = null;
          else {
            h = null;
            f[0].includes("-->") || (h = f[0], f.splice(0, 1));
            g = new Mq(f[0]);
            k2 = uw(g);
            n = Oq(g, /[ \t]+--\x3e[ \t]+/g);
            l = uw(g);
            if (null == k2 || null == n || null == l)
              throw new O(2, 2, 2001, "Could not parse cue time range in WebVTT");
            k2 += m;
            l += m;
            m = f.slice(1).join("\n").trim();
            e.has("global") ? (f = e.get("global").clone(), f.startTime = k2, f.endTime = l, f.payload = "") : f = new kb(k2, l, "");
            ww(m, f, e);
            Nq(g);
            for (k2 = Pq(g); k2; )
              xw(f, k2, b), Nq(g), k2 = Pq(g);
            null != h && (f.id = h);
          }
          f && d.push(f);
        }
        return d;
      };
      function vw(a) {
        for (var b = r(Object.entries(Ab)), c = b.next(); !c.done; c = b.next()) {
          var d = r(c.value);
          c = d.next().value;
          d = d.next().value;
          var e = new kb(0, 0, "");
          e.color = d;
          a.set("." + c, e);
        }
        b = r(Object.entries(Bb));
        for (c = b.next(); !c.done; c = b.next())
          d = r(c.value), c = d.next().value, d = d.next().value, e = new kb(0, 0, ""), e.backgroundColor = d, a.set("." + c, e);
      }
      function ww(a, b, c) {
        0 === c.size && vw(c);
        a: {
          var d = a;
          a = [];
          for (var e = -1, f = "", g = 0; g < d.length; g++)
            if ("/" === d[g] && 0 < g && "<" === d[g - 1]) {
              var h = d.indexOf(">", g);
              if (h <= g) {
                a = d;
                break a;
              }
              if ((h = d.substring(g + 1, h)) && "c" === h) {
                var k2 = a.pop();
                k2 ? k2 === h ? (f += "/" + h + ">", g += h.length + 1) : k2.startsWith("c.") ? (g += h.length + 1, f += "/" + k2 + ">") : f += d[g] : f += d[g];
              } else
                f += d[g];
            } else
              "<" === d[g] ? (e = g + 1, "c" != d[e] && (e = -1)) : ">" === d[g] && 0 < e && (a.push(d.substr(e, g - e)), e = -1), f += d[g];
          a = f;
        }
        d = [];
        f = -1;
        for (e = 0; e < a.length; e++)
          "<" === a[e] ? f = e + 1 : ">" === a[e] && 0 < f && (f = a.substr(f, e - f), f.match(yw) && d.push(f), f = -1);
        d = r(d);
        for (e = d.next(); !e.done; e = d.next())
          e = e.value, a = a.replace("<" + e + ">", '<div time="' + e + '">'), a += "</div>";
        a: {
          e = a;
          f = [];
          g = -1;
          d = "";
          a = false;
          for (h = 0; h < e.length; h++)
            if ("/" === e[h]) {
              k2 = e.indexOf(">", h);
              if (-1 === k2) {
                a = e;
                break a;
              }
              if ((k2 = e.substring(h + 1, k2)) && "v" == k2) {
                a = true;
                var l = null;
                f.length && (l = f[f.length - 1]);
                if (l) {
                  if (l === k2)
                    d += "/" + k2 + ">";
                  else {
                    if (!l.startsWith("v")) {
                      d += e[h];
                      continue;
                    }
                    d += "/" + l + ">";
                  }
                  h += k2.length + 1;
                } else
                  d += e[h];
              } else
                d += e[h];
            } else
              "<" === e[h] ? (g = h + 1, "v" != e[g] && (g = -1)) : ">" === e[h] && 0 < g && (f.push(e.substr(g, h - g)), g = -1), d += e[h];
          e = r(f);
          for (f = e.next(); !f.done; f = e.next())
            f = f.value, g = f.replace(" ", ".voice-"), d = d.replace("<" + f + ">", "<" + g + ">"), d = d.replace("</" + f + ">", "</" + g + ">"), a || (d += "</" + g + ">");
          a = d;
        }
        if (e = cg("<span>" + a + "</span>", "span")) {
          d = [];
          e = e.childNodes;
          if (1 == e.length && (f = e[0], f.nodeType == Node.TEXT_NODE || f.nodeType == Node.CDATA_SECTION_NODE)) {
            b.payload = zw(a);
            return;
          }
          a = r(e);
          for (e = a.next(); !e.done; e = a.next())
            Aw(e.value, b, d, c);
          b.nestedCues = d;
        } else
          b.payload = zw(a);
      }
      function Bw(a, b) {
        return a && 0 < a.length ? a : b;
      }
      function Aw(a, b, c, d) {
        var e = b.clone();
        if (a.nodeType === Node.ELEMENT_NODE && a.nodeName)
          for (var f = r(a.nodeName.split(/(?=[ .])+/g)), g = f.next(); !g.done; g = f.next()) {
            var h = g = g.value;
            if (h.startsWith(".voice-")) {
              var k2 = h.split("-").pop();
              h = 'v[voice="' + k2 + '"]';
              d.has(h) || (h = "v[voice=" + k2 + "]");
            }
            d.has(h) && (h = d.get(h)) && (e.backgroundColor = Bw(h.backgroundColor, e.backgroundColor), e.color = Bw(h.color, e.color), e.fontFamily = Bw(h.fontFamily, e.fontFamily), e.fontSize = Bw(h.fontSize, e.fontSize), e.fontWeight = h.fontWeight, e.fontStyle = h.fontStyle, e.opacity = h.opacity, e.wrapLine = h.wrapLine);
            switch (g) {
              case "br":
                g = b.clone();
                g.lineBreak = true;
                c.push(g);
                break;
              case "b":
                e.fontWeight = 700;
                break;
              case "i":
                e.fontStyle = "italic";
                break;
              case "u":
                e.textDecoration.push("underline");
                break;
              case "div":
                if (g = a.getAttribute("time")) {
                  if (g = uw(new Mq(g)))
                    e.startTime = g;
                }
            }
          }
        if (Tf(a))
          for (f = true, d = r(a.textContent.split("\n")), a = d.next(); !a.done; a = d.next())
            a = a.value, f || (f = b.clone(), f.lineBreak = true, c.push(f)), 0 < a.length && (f = e.clone(), f.payload = zw(a), c.push(f)), f = false;
        else
          for (b = r(a.childNodes), a = b.next(); !a.done; a = b.next())
            Aw(a.value, e, c, d);
      }
      function xw(a, b, c) {
        var d;
        if (d = /^align:(start|middle|center|end|left|right)$/.exec(b))
          b = d[1], "middle" == b ? a.textAlign = ob : a.textAlign = xb[b.toUpperCase()];
        else if (d = /^vertical:(lr|rl)$/.exec(b))
          a.writingMode = "lr" == d[1] ? "vertical-lr" : "vertical-rl";
        else if (d = /^size:([\d.]+)%$/.exec(b))
          a.size = Number(d[1]);
        else if (d = /^position:([\d.]+)%(?:,(line-left|line-right|center|start|end))?$/.exec(b))
          a.position = Number(d[1]), d[2] && (b = d[2], a.positionAlign = "line-left" == b || "start" == b ? "line-left" : "line-right" == b || "end" == b ? "line-right" : "center");
        else if (d = /^region:(.*)$/.exec(b)) {
          if (b = Cw(c, d[1]))
            a.region = b;
        } else if (c = /^line:([\d.]+)%(?:,(start|end|center))?$/.exec(b))
          a.lineInterpretation = 1, a.line = Number(c[1]), c[2] && (a.lineAlign = zb[c[2].toUpperCase()]);
        else if (c = /^line:(-?\d+)(?:,(start|end|center))?$/.exec(b))
          a.lineInterpretation = rb, a.line = Number(c[1]), c[2] && (a.lineAlign = zb[c[2].toUpperCase()]);
      }
      function Cw(a, b) {
        a = a.filter(function(c) {
          return c.id == b;
        });
        return a.length ? a[0] : null;
      }
      function uw(a) {
        a = Oq(a, yw);
        if (null == a)
          return null;
        var b = Number(a[2]), c = Number(a[3]);
        return 59 < b || 59 < c ? null : Number(a[4]) / 1e3 + c + 60 * b + 3600 * (Number(a[1]) || 0);
      }
      function zw(a) {
        var b = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'", "&nbsp;": " ", "&lrm;": "‎", "&rlm;": "‏" }, c = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g, d = RegExp(c.source);
        return a && d.test(a) ? a.replace(c, function(e) {
          return b[e] || "'";
        }) : a || "";
      }
      K("shaka.text.VttTextParser", tw);
      tw.prototype.parseMedia = tw.prototype.parseMedia;
      tw.prototype.setSequenceMode = tw.prototype.setSequenceMode;
      tw.prototype.parseInit = tw.prototype.parseInit;
      var yw = /(?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{2,3})/g;
      fd["text/vtt"] = function() {
        return new tw();
      };
      fd['text/vtt; codecs="vtt"'] = function() {
        return new tw();
      };
      fd['text/vtt; codecs="wvtt"'] = function() {
        return new tw();
      };
      function Dw() {
        this.g = null;
      }
      Dw.prototype.parseInit = function(a) {
        var b = this, c = false;
        new zf().box("moov", Ef).box("trak", Ef).box("mdia", Ef).P("mdhd", function(d) {
          d = fi(d.reader, d.version);
          b.g = d.timescale;
        }).box("minf", Ef).box("stbl", Ef).P("stsd", Gf).box("wvtt", function() {
          c = true;
        }).parse(a);
        if (!this.g)
          throw new O(2, 2, 2008);
        if (!c)
          throw new O(2, 2, 2008);
      };
      Dw.prototype.setSequenceMode = function() {
      };
      Dw.prototype.parseMedia = function(a, b) {
        if (!this.g)
          throw new O(2, 2, 2008);
        var c = 0, d = [], e, f = [], g = false, h = false, k2 = false, l = null;
        new zf().box("moof", Ef).box("traf", Ef).P("tfdt", function(z) {
          g = true;
          c = ei(z.reader, z.version).we;
        }).P("tfhd", function(z) {
          l = di(z.reader, z.flags).Ce;
        }).P("trun", function(z) {
          h = true;
          d = gi(z.reader, z.version, z.flags).Re;
        }).box("mdat", If(function(z) {
          k2 = true;
          e = z;
        })).parse(a, false);
        if (!k2 && !g && !h)
          throw new O(2, 2, 2008);
        a = c;
        for (var m = new wf(e, 0), n = r(d), p = n.next(); !p.done; p = n.next()) {
          p = p.value;
          var t = p.ee || l, v = p.ed ? c + p.ed : a;
          a = v + (t || 0);
          var y = 0;
          do {
            var w = m.K();
            y += w;
            var x = m.K(), C = null;
            "vttc" == Df(x) ? 8 < w && (C = m.Za(w - 8)) : m.skip(w - 8);
            t && C && (w = Ew(C, b.periodStart + v / this.g, b.periodStart + a / this.g), f.push(w));
          } while (p.sampleSize && y < p.sampleSize);
        }
        return f.filter(dc);
      };
      function Ew(a, b, c) {
        var d, e, f;
        new zf().box("payl", If(function(g) {
          d = Cc(g);
        })).box("iden", If(function(g) {
          e = Cc(g);
        })).box("sttg", If(function(g) {
          f = Cc(g);
        })).parse(a);
        return d ? Fw(d, e, f, b, c) : null;
      }
      function Fw(a, b, c, d, e) {
        d = new kb(d, e, "");
        ww(a, d, /* @__PURE__ */ new Map());
        b && (d.id = b);
        if (c)
          for (a = new Mq(c), b = Pq(a); b; )
            xw(d, b, []), Nq(a), b = Pq(a);
        return d;
      }
      K("shaka.text.Mp4VttParser", Dw);
      Dw.prototype.parseMedia = Dw.prototype.parseMedia;
      Dw.prototype.setSequenceMode = Dw.prototype.setSequenceMode;
      Dw.prototype.parseInit = Dw.prototype.parseInit;
      fd['application/mp4; codecs="wvtt"'] = function() {
        return new Dw();
      };
      function Gw() {
      }
      Gw.prototype.parseInit = function() {
      };
      Gw.prototype.setSequenceMode = function() {
      };
      Gw.prototype.parseMedia = function(a) {
        var b = Cc(a).replace(/\r+/g, "");
        b = b.trim();
        a = [];
        if ("" == b)
          return a;
        b = r(b.split("\n\n"));
        for (var c = b.next(); !c.done; c = b.next()) {
          c = c.value.split("\n");
          var d = new Mq(c[0]), e = Hw(d), f = Oq(d, /,/g);
          d = Hw(d);
          if (null == e || null == f || null == d)
            throw new O(2, 2, 2001, "Could not parse cue time range in SubViewer");
          a.push(new kb(e, d, c.slice(1).join("\n").trim()));
        }
        return a;
      };
      function Hw(a) {
        a = Oq(a, /(?:(\d{1,}):)?(\d{2}):(\d{2})\.(\d{2,3})/g);
        if (null == a)
          return null;
        var b = Number(a[2]), c = Number(a[3]);
        return 59 < b || 59 < c ? null : Number(a[4]) / 1e3 + c + 60 * b + 3600 * (Number(a[1]) || 0);
      }
      K("shaka.text.SbvTextParser", Gw);
      Gw.prototype.parseMedia = Gw.prototype.parseMedia;
      Gw.prototype.setSequenceMode = Gw.prototype.setSequenceMode;
      Gw.prototype.parseInit = Gw.prototype.parseInit;
      fd["text/x-subviewer"] = function() {
        return new Gw();
      };
      function Iw() {
        this.g = new tw();
      }
      Iw.prototype.parseInit = function() {
      };
      Iw.prototype.setSequenceMode = function() {
      };
      Iw.prototype.parseMedia = function(a, b) {
        a = Cc(a);
        a = Jw(a);
        a = M(Gc(a));
        return this.g.parseMedia(a, b);
      };
      function Jw(a) {
        var b = "WEBVTT\n\n";
        if ("" == a)
          return b;
        a = a.replace(/\r+/g, "");
        a = a.trim();
        a = r(a.split("\n\n"));
        for (var c = a.next(); !c.done; c = a.next())
          c = c.value.split(/\n/), c[0].match(/\d+/) && c.shift(), c[0] = c[0].replace(/,/g, "."), b += c.join("\n") + "\n\n";
        return b;
      }
      K("shaka.text.SrtTextParser", Iw);
      Iw.srt2webvtt = Jw;
      Iw.prototype.parseMedia = Iw.prototype.parseMedia;
      Iw.prototype.setSequenceMode = Iw.prototype.setSequenceMode;
      Iw.prototype.parseInit = Iw.prototype.parseInit;
      fd["text/srt"] = function() {
        return new Iw();
      };
      function Kw() {
      }
      Kw.prototype.parseInit = function() {
      };
      Kw.prototype.setSequenceMode = function() {
      };
      Kw.prototype.parseMedia = function(a) {
        var b = "", c = "";
        a = Cc(a).split(/\r?\n\s*\r?\n/);
        a = r(a);
        for (var d = a.next(); !d.done; d = a.next()) {
          var e = Lw.exec(d.value);
          e && (d = e[1], e = e[2], "V4 Styles" == d || "V4+ Styles" == d ? b = e : "Events" == d && (c = e));
        }
        a = [];
        d = null;
        b = r(b.split(/\r?\n/));
        for (var f = b.next(); !f.done; f = b.next())
          if (e = f.value, !/^\s*;/.test(e) && (f = Mw.exec(e))) {
            if (e = f[1].trim(), f = f[2].trim(), "Format" == e)
              d = f.split(Nw);
            else if ("Style" == e) {
              e = f.split(Nw);
              f = {};
              for (var g = 0; g < d.length && g < e.length; g++)
                f[d[g]] = e[g];
              a.push(f);
            }
          }
        d = [];
        b = null;
        e = {};
        c = r(c.split(/\r?\n/));
        for (f = c.next(); !f.done; e = { vd: e.vd }, f = c.next())
          if (f = f.value, !/^\s*;/.test(f) && (g = Mw.exec(f))) {
            if (f = g[1].trim(), g = g[2].trim(), "Format" == f)
              b = g.split(Nw);
            else if ("Dialogue" == f) {
              g = g.split(Nw);
              f = {};
              for (var h = 0; h < b.length && h < g.length; h++)
                f[b[h]] = g[h];
              h = Ow(f.Start);
              var k2 = Ow(f.End);
              g = new kb(h, k2, g.slice(b.length - 1).join(",").replace(/\\N/g, "\n").replace(/\{[^}]+\}/g, ""));
              e.vd = f.Style;
              (f = a.find(function(l) {
                return function(m) {
                  return m.Name == l.vd;
                };
              }(e))) && Pw(g, f);
              d.push(g);
            }
          }
        return d;
      };
      function Pw(a, b) {
        var c = b.Fontname;
        c && (a.fontFamily = c);
        if (c = b.Fontsize)
          a.fontSize = c + "px";
        if (c = b.PrimaryColour) {
          if (c = Qw(c))
            a.color = c;
        }
        if (c = b.BackColour) {
          if (c = Qw(c))
            a.backgroundColor = c;
        }
        b.Bold && (a.fontWeight = 700);
        b.Italic && (a.fontStyle = "italic");
        b.Underline && a.textDecoration.push("underline");
        if (c = b.Spacing)
          a.letterSpacing = c + "px";
        if (c = b.Alignment)
          switch (parseInt(c, 10)) {
            case 1:
              a.displayAlign = tb;
              a.textAlign = "start";
              break;
            case 2:
              a.displayAlign = tb;
              a.textAlign = ob;
              break;
            case 3:
              a.displayAlign = tb;
              a.textAlign = "end";
              break;
            case 5:
              a.displayAlign = "before";
              a.textAlign = "start";
              break;
            case 6:
              a.displayAlign = "before";
              a.textAlign = ob;
              break;
            case 7:
              a.displayAlign = "before";
              a.textAlign = "end";
              break;
            case 9:
              a.displayAlign = "center";
              a.textAlign = "start";
              break;
            case 10:
              a.displayAlign = "center";
              a.textAlign = ob;
              break;
            case 11:
              a.displayAlign = "center", a.textAlign = "end";
          }
        if (b = b.AlphaLevel)
          a.opacity = parseFloat(b);
      }
      function Qw(a) {
        a = parseInt(a.replace("&H", ""), 16);
        return 0 <= a ? "rgba(" + (a & 255) + "," + (a >> 8 & 255) + "," + (a >> 16 & 255) + "," + (a >> 24 & 255 ^ 255) / 255 + ")" : null;
      }
      function Ow(a) {
        a = Rw.exec(a);
        return 3600 * (a[1] ? parseInt(a[1].replace(":", ""), 10) : 0) + 60 * parseInt(a[2], 10) + parseFloat(a[3]);
      }
      K("shaka.text.SsaTextParser", Kw);
      Kw.prototype.parseMedia = Kw.prototype.parseMedia;
      Kw.prototype.setSequenceMode = Kw.prototype.setSequenceMode;
      Kw.prototype.parseInit = Kw.prototype.parseInit;
      var Lw = /^\s*\[([^\]]+)\]\r?\n([\s\S]*)/, Mw = /^\s*([^:]+):\s*(.*)/, Nw = /\s*,\s*/, Rw = /^(\d+:)?(\d{1,2}):(\d{1,2}(?:[.]\d{1,3})?)?$/;
      fd["text/x-ssa"] = function() {
        return new Kw();
      };
      /*
       @license
       EME Encryption Scheme Polyfill
       Copyright 2019 Google LLC
       SPDX-License-Identifier: Apache-2.0
      */
      function Sw() {
      }
      var Tw;
      function Uw() {
        Tw ? console.debug("EmeEncryptionSchemePolyfill: Already installed.") : navigator.requestMediaKeySystemAccess && MediaKeySystemAccess.prototype.getConfiguration ? (Tw = navigator.requestMediaKeySystemAccess, console.debug("EmeEncryptionSchemePolyfill: Waiting to detect encryptionScheme support."), navigator.requestMediaKeySystemAccess = Vw) : console.debug("EmeEncryptionSchemePolyfill: EME not found");
      }
      function Vw(a, b) {
        var c = this, d;
        return G(function(e) {
          if (1 == e.g)
            return console.assert(c == navigator, 'bad "this" for requestMediaKeySystemAccess'), u(e, Tw.call(c, a, b), 2);
          d = e.h;
          if (Ww(d))
            return console.debug("EmeEncryptionSchemePolyfill: Native encryptionScheme support found."), navigator.requestMediaKeySystemAccess = Tw, e.return(d);
          console.debug("EmeEncryptionSchemePolyfill: No native encryptionScheme support found. Patching encryptionScheme support.");
          navigator.requestMediaKeySystemAccess = Xw;
          return e.return(Xw.call(
            c,
            a,
            b
          ));
        });
      }
      function Xw(a, b) {
        var c = this, d, e, f, g, h, k2, l, m, n, p;
        return G(function(t) {
          if (1 == t.g) {
            console.assert(c == navigator, 'bad "this" for requestMediaKeySystemAccess');
            d = Yw(a);
            e = [];
            f = r(b);
            for (g = f.next(); !g.done; g = f.next())
              h = g.value, k2 = Zw(h.videoCapabilities, d), l = Zw(h.audioCapabilities, d), h.videoCapabilities && h.videoCapabilities.length && !k2.length || h.audioCapabilities && h.audioCapabilities.length && !l.length || (m = Object.assign({}, h), m.videoCapabilities = k2, m.audioCapabilities = l, e.push(m));
            if (!e.length)
              throw n = Error("Unsupported keySystem or supportedConfigurations."), n.name = "NotSupportedError", n.code = DOMException.NOT_SUPPORTED_ERR, n;
            return u(t, Tw.call(c, a, e), 2);
          }
          p = t.h;
          return t.return(new $w(p, d));
        });
      }
      function Zw(a, b) {
        return a ? a.filter(function(c) {
          return !c.encryptionScheme || c.encryptionScheme == b;
        }) : a;
      }
      K("EmeEncryptionSchemePolyfill", Sw);
      Sw.install = Uw;
      function ax() {
      }
      var bx;
      function cx() {
        bx ? console.debug("McEncryptionSchemePolyfill: Already installed.") : navigator.mediaCapabilities ? (bx = navigator.mediaCapabilities.decodingInfo, console.debug("McEncryptionSchemePolyfill: Waiting to detect encryptionScheme support."), navigator.mediaCapabilities.decodingInfo = dx) : console.debug("McEncryptionSchemePolyfill: MediaCapabilities not found");
      }
      function dx(a) {
        var b = this, c, d, e;
        return G(function(f) {
          switch (f.g) {
            case 1:
              return console.assert(b == navigator.mediaCapabilities, 'bad "this" for decodingInfo'), u(f, bx.call(b, a), 2);
            case 2:
              c = f.h;
              if (!a.keySystemConfiguration)
                return f.return(c);
              if ((d = c.keySystemAccess) && Ww(d))
                return console.debug("McEncryptionSchemePolyfill: Native encryptionScheme support found."), navigator.mediaCapabilities.decodingInfo = bx, f.return(c);
              console.debug("McEncryptionSchemePolyfill: No native encryptionScheme support found. Patching encryptionScheme support.");
              navigator.mediaCapabilities.decodingInfo = ex;
              if (d) {
                f.A(3);
                break;
              }
              e = c;
              return u(f, fx(a), 4);
            case 4:
              return e.keySystemAccess = f.h, f.return(c);
            case 3:
              return f.return(ex.call(b, a));
          }
        });
      }
      function ex(a) {
        var b = this, c, d, e, f, g, h, k2, l;
        return G(function(m) {
          switch (m.g) {
            case 1:
              return console.assert(b == navigator.mediaCapabilities, 'bad "this" for decodingInfo'), c = null, a.keySystemConfiguration && (d = a.keySystemConfiguration, e = d.keySystem, f = d.audio && d.audio.encryptionScheme, g = d.video && d.video.encryptionScheme, c = Yw(e), h = { powerEfficient: false, smooth: false, supported: false, keySystemAccess: null, configuration: a }, f && f != c || g && g != c) ? m.return(h) : u(m, bx.call(b, a), 2);
            case 2:
              k2 = m.h;
              if (k2.keySystemAccess) {
                k2.keySystemAccess = new $w(k2.keySystemAccess, c);
                m.A(3);
                break;
              }
              if (!a.keySystemConfiguration) {
                m.A(3);
                break;
              }
              l = k2;
              return u(m, fx(a), 5);
            case 5:
              l.keySystemAccess = m.h;
            case 3:
              return m.return(k2);
          }
        });
      }
      function fx(a) {
        var b, c;
        return G(function(d) {
          if (1 == d.g) {
            var e = a.keySystemConfiguration, f = [], g = [];
            e.audio && f.push({ robustness: e.audio.robustness || "", contentType: a.audio.contentType });
            e.video && g.push({ robustness: e.video.robustness || "", contentType: a.video.contentType });
            e = { initDataTypes: e.initDataType ? [e.initDataType] : [], distinctiveIdentifier: e.distinctiveIdentifier, persistentState: e.persistentState, sessionTypes: e.sessionTypes };
            f.length && (e.audioCapabilities = f);
            g.length && (e.videoCapabilities = g);
            b = e;
            return u(
              d,
              navigator.requestMediaKeySystemAccess(a.keySystemConfiguration.keySystem, [b]),
              2
            );
          }
          c = d.h;
          return d.return(c);
        });
      }
      K("McEncryptionSchemePolyfill", ax);
      ax.install = cx;
      function $w(a, b) {
        this.h = a;
        this.g = b;
        this.keySystem = a.keySystem;
      }
      $w.prototype.getConfiguration = function() {
        var a = this.h.getConfiguration();
        if (a.videoCapabilities)
          for (var b = r(a.videoCapabilities), c = b.next(); !c.done; c = b.next())
            c.value.encryptionScheme = this.g;
        if (a.audioCapabilities)
          for (b = r(a.audioCapabilities), c = b.next(); !c.done; c = b.next())
            c.value.encryptionScheme = this.g;
        return a;
      };
      $w.prototype.createMediaKeys = function() {
        return this.h.createMediaKeys();
      };
      function Yw(a) {
        if (a.startsWith("com.widevine") || a.startsWith("com.microsoft") || a.startsWith("com.chromecast") || a.startsWith("com.adobe") || a.startsWith("org.w3"))
          return "cenc";
        if (a.startsWith("com.apple"))
          return "cbcs-1-9";
        console.warn("EmeEncryptionSchemePolyfill: Unknown key system:", a, "Please contribute!");
        return null;
      }
      function Ww(a) {
        a = a.getConfiguration();
        var b = a.audioCapabilities && a.audioCapabilities[0];
        return (a = a.videoCapabilities && a.videoCapabilities[0] || b) && void 0 !== a.encryptionScheme ? true : false;
      }
      function gx() {
      }
      function ku() {
        Uw();
        cx();
      }
      K("EncryptionSchemePolyfills", gx);
      gx.install = ku;
      "undefined" !== typeof module && module.exports && (module.exports = gx);
    }).call(exportTo, innerGlobal, innerGlobal, void 0);
    for (var k in exportTo.shaka)
      exports[k] = exportTo.shaka[k];
  })();
})(shakaPlayer_compiled);
const shaka = /* @__PURE__ */ getDefaultExportFromCjs(shakaPlayer_compiled);
class POCVideoPlayer extends lightning.Component {
  constructor() {
    super(...arguments);
    this.videoUrl = "http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4";
    this.index = 1;
    this.contentId = "";
    this._isPlaying = true;
    this._loadPlayback = async (url, videoEl2) => {
      this._setupShakaPlayer(videoEl2);
      await this._player.load(url);
    };
    this._unloadPlayback = async () => {
      await this._player.unload();
    };
  }
  /**
   * This function is responsible for the creation and return of the UI template. This function 
   * takes  no parameters and returns the template.
   * 
   * @returns Template for the Application
   * 
   */
  static _template() {
    return {
      Wrapper: {
        alpha: 1,
        BackButton: {
          x: 40,
          y: 40,
          zIndex: 99,
          type: BackButton
        },
        PlayPause: {
          type: PlayPauseButton
        }
      }
    };
  }
  set params(args) {
    const { id } = args;
    this.contentId = id;
  }
  // when the playe is shown in the screen and active for the first time 
  _firstActive() {
    VideoPlayer.consumer(this);
    VideoPlayer.loader(this._loadPlayback);
    VideoPlayer.unloader(this._unloadPlayback);
  }
  // initializing the component
  _init() {
  }
  _active() {
    VideoPlayer.open(this.videoUrl);
  }
  _inactive() {
    VideoPlayer.close();
  }
  // handling up button click
  _handleUp() {
    if (this.index > 0) {
      this.index -= 1;
    }
  }
  // handling down button click
  _handleDown() {
    if (this.index < 1) {
      this.index += 1;
    }
  }
  // handling okay button click
  _handleEnter() {
    if (this.index === 0) {
      Router.navigate(`content/railItem/${this.contentId}`);
    } else if (this.index === 1) {
      const button = this.tag("PlayPause");
      button.isPlaying = !button.isPlaying;
      button.isPlaying ? VideoPlayer.play() : VideoPlayer.pause();
    }
  }
  _getFocused() {
    return this.tag("Wrapper").children[this.index];
  }
  // shaka player
  _setupShakaPlayer(videoEl2) {
    videoEl2.autoplay = true;
    this._player = new shaka.Player(videoEl2);
    console.log(this._player);
  }
}
class GridItem extends lightning.Component {
  constructor() {
    super(...arguments);
    this.data = {};
  }
  /**
   * This function is responsible for the creation and return of the UI template. This
   * function takes  no parameters and returns the template of the Rail Item component.
   *
   * @returns Template for the Rail Item Component.
   *
   */
  static _template() {
    return {
      rect: true,
      color: theme.colors.primary,
      shader: { type: lightning.shaders.RoundedRectangle, radius: 20 },
      Image: {
        shader: {
          type: lightning.shaders.RoundedRectangle,
          radius: 20
        }
      },
      Label: {
        x: 10,
        y: 435,
        w: (w) => w,
        color: theme.colors.accentGrey.light,
        text: { fontSize: 30 }
      }
    };
  }
  /**
   * Setter for setting the values for the item property.
   *
   * @Param The value that needs to be setted to the item property.
   *
   */
  set item(obj) {
    const { label, src, data } = obj;
    this.data = data;
    this.patch({
      Image: {
        src
      },
      Label: { text: label == null ? void 0 : label.toString() }
    });
  }
  /**
  * This function overrides the default behaviour of keypress 'Enter'.
  * This functions checks the index to see the focused element and decides
  * the route to navigate.
  */
  _handleEnter() {
    Router.navigate(`content/gridItem/${this.data.uid}`, { contentData: this.data, from: "Grid" });
  }
  /**
   * This function overrides the default behavior of the component when come in focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it comes to the focus.
   *
   */
  _focus() {
    this.patch({
      smooth: { color: theme.colors.secondary, scale: 1.1 },
      Label: {
        smooth: { color: theme.colors.white }
      },
      Rectangle: { color: theme.colors.yellow, x: 10, y: (y) => y + 72, w: (w) => w - 20, h: 5, rect: true }
    });
  }
  /**
   * This function overrides the default behavior of the component when goes out of focus.
   * We can add all the changes / updates that needs to be made to the component when
   * it goes out of the focus.
   *
   */
  _unfocus() {
    this.patch({
      smooth: { color: theme.colors.primary, scale: 1 },
      Label: {
        smooth: { color: theme.colors.accentGrey.light }
      },
      Rectangle: void 0
    });
  }
}
class GridLayout extends lightning.Component {
  constructor() {
    super(...arguments);
    this.index = 1;
    this.data = [];
    this.dataLength = 0;
    this.intervalSub = 0;
    this.isLoading = true;
  }
  static _template() {
    return {
      w: 1920,
      h: 1080,
      color: theme.colors.primaryLight,
      rect: true,
      shader: { x: 100, y: -100, pivot: 0.5, type: lightning.shaders.RadialGradient, outerColor: theme.colors.primaryLight, innerColor: theme.colors.dark, radius: 800 },
      BackButton: { x: 40, y: 40, shader: null, type: BackButton },
      Content: {
        Grid: { x: 110, y: 200, columns: 5, spacing: 160, crossSpacing: 50, itemType: GridItem, type: Grid }
      }
    };
  }
  _init() {
    this.setLongRail();
  }
  async setLongRail() {
    var _a, _b, _c;
    this.isLoading = true;
    this.data = await Storage.get("longData");
    this.dataLength = this.data.length;
    const rail = [];
    for (let i = 0; i < this.dataLength; i++) {
      let label = (_a = this.data[i]) == null ? void 0 : _a.title;
      let img_src = (_c = (_b = this.data[i]) == null ? void 0 : _b.images.find((img) => img.width === 288)) == null ? void 0 : _c.url;
      rail.push({
        w: 288,
        h: 432,
        item: { label, src: img_src || "https://pmd205470tn-a.akamaihd.net/D2C_-_Content/191/249/oyPcsfGWL5Se6RGW1JCVgpHlASH_288x432_13635141800.jpg", data: this.data[i] }
      });
    }
    this.tag("Grid").add(rail.map((gridItem) => {
      return gridItem;
    }));
    this.isLoading = false;
  }
  /**
   * 
   * Network intensive Testing
   * 
   */
  // override _active() {
  //     let axiosRequester: AxiosRequester = new AxiosRequester();
  //     this.intervalSub = setInterval(() => {
  //         for (let i = 0; i < 100; i++) {
  //             for (let index = 0; index < 10; index++) {
  //                 const timestamp = new Date().getTime();
  //                 axiosRequester.fetch(endpoint[index]! + `timestamp=${timestamp}`).then((response) => { });
  //             }
  //         }
  //     }, 1000);
  // }
  // override _inactive() {
  //     clearInterval(this.intervalSub);
  // }
  _getFocused() {
    if (this.index === 0) {
      return this.tag("BackButton");
    }
    return this.tag("Grid");
  }
  _handleUp() {
    if (this.index > 0) {
      this.index -= 1;
    }
  }
  _handleDown() {
    if (this.index < 1) {
      this.index += 1;
    }
  }
  _handleEnter() {
    if (this.index === 0) {
      Router.navigate("home");
    }
  }
}
const routes = {
  root: "home",
  routes: [
    {
      path: "home",
      component: Home
    },
    {
      path: "search",
      component: Search
    },
    {
      path: "grid",
      component: GridLayout
    },
    {
      path: "settings",
      component: Home
    },
    {
      path: "content/:from/:id",
      component: ContentDetails,
      options: {
        reuseInstance: false
      }
    },
    {
      path: "player/:id",
      component: POCVideoPlayer
    }
  ]
};
class App extends Router.App {
  // setting up the router for the application
  _setup() {
    Router.startRouter(routes, this);
  }
}
const app = Launch(App, {
  stage: {
    pauseRafLoopOnIdle: true,
    fontSharp: true
  },
  debug: true,
  enablePointer: true,
  keys: {
    38: "Up",
    40: "Down",
    37: "Left",
    39: "Right",
    13: "Enter",
    8: "Back",
    27: "Exit"
  }
}, {
  /* Platform settings */
});
const canvas = app.stage.getCanvas();
document.body.appendChild(canvas);
export {
  __vite_legacy_guard
};
//# sourceMappingURL=index-0c2d5c71.js.map
